<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>完美解决git报错fatal unable to access ‘https://github.com/.../.git‘:Recv failure Connection was reset</title>
    <url>/2023/08/04/giterr/</url>
    <content><![CDATA[<p>在使用git时，经常会碰到这个错误：<code>fatal: unable to access &#39;https://github.com/.../.git&#39;:Recv failure Connection was reset</code>。</p>
<p>结合我个人最近的使用经验，提供两个方法，亲测有效。</p>
<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p>该方法也是最常见的方法，那就是在终端执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy </span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>本人之前在使用git时，有些时候使用方法一就能解决问题，有些时候还是会报错，下面这个方法，能够完美地解决报错。</p>
<p>系统设置搜索代理，然后点击编辑按钮：<br><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/a2cad54ac3ea4705a01709eca9930978.png"></p>
<p>打开代理服务器，端口设置为<code>7890</code>，这个对你正常上网没有影响，可以放心设置。然后点击保存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/0f403beb730149d680f1f4d4ab0b2472.png"></p>
<p>然后在终端输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<p>这样就大功告成了。可以在终端输入<code>git config --global -l</code>加以检验是否设置成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/8fd73100caf64012a736f16b25a9aed9.png"></p>
<p>设置完后你就能愉快的使用git啦~</p>
]]></content>
      <tags>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装部署Gitlab详细教程</title>
    <url>/2023/08/01/gitlab/</url>
    <content><![CDATA[<h1 id="Ubuntu安装配置Gitlab详细步骤"><a href="#Ubuntu安装配置Gitlab详细步骤" class="headerlink" title="Ubuntu安装配置Gitlab详细步骤"></a>Ubuntu安装配置Gitlab详细步骤</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>打开终端，运行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line">sudo apt-get install curl openssh-server ca-certificates postfix</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/0e99dc761cea445da730990723b78fbe.png"></p>
<p>接下来会遇到如下界面，Tab切换到“确定”按钮，然后回车。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/aa949d0683d7470bbaa00a488f2d957f.png"></p>
<p>还是照样Tab切换到“确定”按钮，然后回车。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/fd2d07b2ca214c2aa878c5dabcda95a9.png"></p>
<h2 id="安装Gitlab"><a href="#安装Gitlab" class="headerlink" title="安装Gitlab"></a>安装Gitlab</h2><p>先执行命令<code>curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash</code>（我这里不小心执行了两次，一次即可）</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/2315de59a5024e648396450af6c26169.png"></p>
<p>前往Gitlab官网：<a href="https://packages.gitlab.com/gitlab/gitlab-ce">https://packages.gitlab.com/gitlab/gitlab-ce</a>，找到最新版本的<code>gitlab-ce</code>安装包，注意版本是<code>ubuntu/focal</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/21e4f8f4268e4a298858d5c0fd166927.png"></p>
<p>通过<code>wget</code>方式在线安装gitlab，复制<code>wsgt</code>下载命令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/34679b89cbe9497aab5f13b0f661c8e7.png"></p>
<p>安装命令：<br><code>wget --content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/ubuntu/focal/gitlab-ce_16.2.1-ce.0_amd64.deb/download.deb</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/8464cabea24c40cd9b4e84ccf7f17b7d.png"></p>
<p>然后再解压：<code>sudo dpkg -i gitlab-ce_16.2.1-ce.0_amd64.deb</code></p>
<p>如果运行<code>dpkg</code>报openssh-server相关的错误，请先执行下面三个命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt --fix-broken install</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<p>运行完<code>sudo dpkg</code>后如果出现下面的界面就表示gitlab安装成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/2beb0c31044649728f1c2d2b5f248bbc.png"></p>
<h2 id="配置Gitlab"><a href="#配置Gitlab" class="headerlink" title="配置Gitlab"></a>配置Gitlab</h2><p>运行<code>sudo vim /etc/gitlab/gitlab.rb</code>来查看当前gitlab网页ip和端口号。</p>
<p>如果出现vim识别不了的报错，运行下面两行命令即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /var/lib/dpkg/lock*</span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install vim</span><br></pre></td></tr></table></figure>
<p>如果运行上述命令出现权限问题，运行下列命令即可：<code>chmod -R 755 /var/log/gitlab</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/4d4358c7677841f998585cf27deef4d8.png"></p>
<p>然后再运行<code>sudo vim /etc/gitlab/gitlab.rb</code>进入gitlab的配置文件修改界面，输入i进入编辑模式，然后找到<code>external_url</code>字段（在第32行），改成自己需要设置的IP和端口号，IP我设置为本机的ipv4地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/ae4574778db24b68a96b944cf003f9c0.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/b04287b584ab4edf989260db5326131f.png"></p>
<p>修改完毕以后按<code>esc键</code>退出编辑模式，然后输入<code>:wq</code>保存即可。接下来通过下列命令重启服务。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止gitlab服务 </span></span><br><span class="line">sudo gitlab-ctl stop </span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动gitlab服务 </span></span><br><span class="line">sudo gitlab-ctl reconfigure </span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启所有gitlab组件 </span></span><br><span class="line">sudo gitlab-ctl restart </span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动所有gitlab组件 </span></span><br><span class="line">sudo gitlab-ctl start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用开机自启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> gitlab-runsvdir.service</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/2ebae6acbff34db0944f673544013e24.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/8ee2075112ef4d0fb39f62b064d9a1eb.png"></p>
<h2 id="初始化root的密码"><a href="#初始化root的密码" class="headerlink" title="初始化root的密码"></a>初始化root的密码</h2><p>按照如下命令初始化管理员账户的密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#切换路径</span></span><br><span class="line"><span class="built_in">cd</span> /opt/gitlab/bin/ </span><br><span class="line"></span><br><span class="line"><span class="comment">#打开控制台</span></span><br><span class="line">sudo gitlab-rails console -e production </span><br><span class="line"> </span><br><span class="line"><span class="comment">#查询用户账号信息并赋值给u</span></span><br><span class="line">u=User.<span class="built_in">where</span>(<span class="built_in">id</span>:1).first</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置root的密码</span></span><br><span class="line">u.password=<span class="string">&#x27;wxy123456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#确认密码</span></span><br><span class="line">u.password_confirmation=<span class="string">&#x27;wxy123456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存信息(注意有个感叹号）</span></span><br><span class="line">u.save!</span><br><span class="line"></span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/b1ac4589ab4f4de6942fe6918318455e.png"></p>
<h2 id="登录gitlab"><a href="#登录gitlab" class="headerlink" title="登录gitlab"></a>登录gitlab</h2><p>接下来就可以通过<code>http://192.168.17.128:8077</code>来登录gitlab了。登录的地址是你之前设置<code>external_url</code>字段的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/4958b5e3322b4248a236bce92ebafcb1.png"></p>
<p>登录进去大概长这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/c8a98f168ec6422d870273430886b66d.png"></p>
<p>按下面的步骤将gitlab语言设置为中文：<br>注意点击<code>Preferences</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/7e2b34bb0e144840af5298e012c55a0e.png"></p>
<p>点击<code>Save changes</code>，刷新即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/22c92a1876474e3f9a08f5f2283aecfd.png"></p>
<h2 id="Gitlab注册新用户"><a href="#Gitlab注册新用户" class="headerlink" title="Gitlab注册新用户"></a>Gitlab注册新用户</h2><p>通过以下步骤来注册新用户：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/6aafdc1bced54725a2cdf50dbc04dce4.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/1c9c05af1c3049cfacb7fa00cd14b98c.png"></p>
<p>注册之后会显示需要管理员批准，这样才算真正注册成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/d07ce2d7d13c40a28f9d9564c25d5911.png"></p>
<p>再次登录<code>root</code>账户，点击配置Gitlab：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/f178bd5c1ddd4441b19d448582a752a3.png"></p>
<p>查看最新的用户：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/6550043ecae34e33b7eeffd4d263a499.png"></p>
<p>点击等待批准，然后批准该用户进入群组。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/05f066b300694acf8479c33fb91482b9.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/6e3f7320a45447d488439c295145bf1b.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/60472816550246fab5b66f2309c03558.png"></p>
<p>至此gitlab安装配置完成。</p>
]]></content>
      <tags>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>方法与接口</title>
    <url>/2023/06/06/Go/10/</url>
    <content><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="什么是方法"><a href="#什么是方法" class="headerlink" title="什么是方法"></a>什么是方法</h2><p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。</p>
<p>方法只是一个函数，它带有一个特殊的接收器类型，它是在func关键字和方法名之间编写的。接收器可以是struct类型或非struct类型。接收方可以在方法内部访问。</p>
<h2 id="方法的语法"><a href="#方法的语法" class="headerlink" title="方法的语法"></a>方法的语法</h2><p>定义方法的语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Type)</span></span> methodName(parameter list)(<span class="keyword">return</span> list) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(parameter list)</span></span>(<span class="keyword">return</span> list)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name     <span class="type">string</span></span><br><span class="line">    salary   <span class="type">int</span></span><br><span class="line">    currency <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> displaySalary() method has Employee as the receiver type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> displaySalary() &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;Salary of %s is %s%d&quot;</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp1 := Employee &#123;</span><br><span class="line">        name:     <span class="string">&quot;Sam Adolf&quot;</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">&quot;$&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    emp1.displaySalary() <span class="comment">//Calling displaySalary() method of Employee type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以定义相同的方法名</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">	r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">	c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">	c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, r1.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, r2.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of c1 is: &quot;</span>, c1.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of c2 is: &quot;</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Area of r1 is:  24</span><br><span class="line">Area of r2 is:  36</span><br><span class="line">Area of c1 is:  314.1592653589793</span><br><span class="line">Area of c2 is:  1963.4954084936207</span><br></pre></td></tr></table></figure>

<ul>
<li>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</li>
<li>method里面可以访问接收者的字段</li>
<li>调用method通过.访问，就像struct里面访问字段一样</li>
</ul>
<h2 id="方法和函数"><a href="#方法和函数" class="headerlink" title="方法和函数"></a>方法和函数</h2><p>既然我们已经有了函数，为什么还要使用方法？</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name     <span class="type">string</span></span><br><span class="line">    salary   <span class="type">int</span></span><br><span class="line">    currency <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> displaySalary() method converted to function with Employee as parameter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">displaySalary</span><span class="params">(e Employee)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;Salary of %s is %s%d&quot;</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp1 := Employee&#123;</span><br><span class="line">        name:     <span class="string">&quot;Sam Adolf&quot;</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">&quot;$&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    displaySalary(emp1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的程序中，displaySalary方法被转换为一个函数，而Employee struct作为参数传递给它。这个程序也产生了相同的输出：Salary of Sam Adolf is $5000.。</p>
</blockquote>
<p>为什么我们可以用函数来写相同的程序呢?有以下几个原因</p>
<ol>
<li>Go不是一种纯粹面向对象的编程语言，它不支持类。因此，类型的方法是一种实现类似于类的行为的方法。</li>
<li>相同名称的方法可以在不同的类型上定义，而具有相同名称的函数是不允许的。假设我们有一个正方形和圆形的结构。可以在正方形和圆形上定义一个名为Area的方法。</li>
</ol>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p>
<p>Go 语言中变量可以在三个地方声明：</p>
<ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<p><strong>局部变量</strong></p>
<p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。</p>
<p><strong>全局变量</strong></p>
<p>在函数体外声明的变量称之为全局变量，首字母大写全局变量可以在整个包甚至外部包（被导出后）使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> g <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化参数 */</span></span><br><span class="line">   a = <span class="number">10</span></span><br><span class="line">   b = <span class="number">20</span></span><br><span class="line">   g = a + b</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;结果： a = %d, b = %d and g = %d\n&quot;</span>, a, b, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结果： a = 10, b = 20 and g = 30</span><br></pre></td></tr></table></figure>

<p><strong>形式参数</strong></p>
<p>形式参数会作为函数的局部变量来使用</p>
<p><strong>指针作为接收者</strong></p>
<p>若不是以指针作为接收者，实际只是获取了一个copy，而不能真正改变接收者的中的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> SetColor(c Color) &#123;</span><br><span class="line">	b.color = c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> setVal() &#123;</span><br><span class="line">	r.height = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := Rectangle&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s := p</span><br><span class="line">	p.setVal()</span><br><span class="line">	fmt.Println(p.height, s.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 2</span><br></pre></td></tr></table></figure>

<p>如果没有那个*，则值就是<code>2 2</code></p>
<h2 id="method继承"><a href="#method继承" class="headerlink" title="method继承"></a>method继承</h2><p>method是可以继承的，如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">	age   <span class="type">int</span></span><br><span class="line">	phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Hi, I am Mark you can call me on <span class="number">222</span><span class="number">-222</span>-YYYY</span><br><span class="line">Hi, I am Sam you can call me on <span class="number">111</span><span class="number">-888</span>-XXXX</span><br></pre></td></tr></table></figure>

<h2 id="method重写"><a href="#method重写" class="headerlink" title="method重写"></a>method重写</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">	age   <span class="type">int</span></span><br><span class="line">	phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">		e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi, I am Mark you can call me on 222-222-YYYY</span><br><span class="line">Hi, I am Sam, I work at Golang Inc. Call me on 111-888-XXXX</span><br></pre></td></tr></table></figure>

<ul>
<li>方法是可以继承和重写的</li>
<li>存在继承关系时，按照就近原则，进行调用</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p>面向对象世界中的接口的一般定义是“接口定义对象的行为”。它表示让指定对象应该做什么。实现这种行为的方法(实现细节)是针对对象的。</p>
<p>在Go中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。它与OOP非常相似。接口指定了类型应该具有的方法，类型决定了如何实现这些方法。</p>
<blockquote>
<p> 它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口</p>
<p> 接口定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了该接口。</p>
</blockquote>
<h2 id="接口的定义语法"><a href="#接口的定义语法" class="headerlink" title="接口的定义语法"></a>接口的定义语法</h2><p>定义接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span></span> method_name1() [return_type] &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span></span> method_namen() [return_type] &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>NokiaPhone</code>结构体实现了<code>Phone</code>接口中的方法，因此可以将其赋值给<code>phone</code>。</p>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">I am Nokia, I can call you!</span><br><span class="line">I am iPhone, I can call you!</span><br></pre></td></tr></table></figure>

<ul>
<li>interface可以被任意的对象实现</li>
<li>一个对象可以实现任意多个interface</li>
<li>任意的类型都实现了空interface(我们这样定义：interface{})，也就是包含0个method的interface</li>
</ul>
<h2 id="interface值"><a href="#interface值" class="headerlink" title="interface值"></a>interface值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">	age   <span class="type">int</span></span><br><span class="line">	phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="type">string</span></span><br><span class="line">	loan   <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="type">string</span></span><br><span class="line">	money   <span class="type">float32</span></span><br><span class="line">&#125; <span class="comment">//Human实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> SayHi() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125; <span class="comment">//Human实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;La la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125; <span class="comment">//Employee重写Human的SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> SayHi() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">		e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface Men被Human,Student和Employee实现</span></span><br><span class="line"><span class="comment">// 因为这三个类型都实现了这两个方法</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">	SayHi()</span><br><span class="line">	Sing(lyrics <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mike := Student&#123;Human&#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-XXX&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>, <span class="number">0.00</span>&#125;</span><br><span class="line">	paul := Student&#123;Human&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">26</span>, <span class="string">&quot;111-222-XXX&quot;</span>&#125;, <span class="string">&quot;Harvard&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">36</span>, <span class="string">&quot;444-222-XXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc.&quot;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">	Tom := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">36</span>, <span class="string">&quot;444-222-XXX&quot;</span>&#125;, <span class="string">&quot;Things Ltd.&quot;</span>, <span class="number">5000</span>&#125;</span><br><span class="line">	<span class="comment">//定义Men类型的变量i</span></span><br><span class="line">	<span class="keyword">var</span> i Men</span><br><span class="line">	<span class="comment">//i能存储Student</span></span><br><span class="line">	i = mike</span><br><span class="line">	fmt.Println(<span class="string">&quot;This is Mike, a Student:&quot;</span>)</span><br><span class="line">	i.SayHi()</span><br><span class="line">	i.Sing(<span class="string">&quot;November rain&quot;</span>)</span><br><span class="line">	<span class="comment">//i也能存储Employee</span></span><br><span class="line">	i = Tom</span><br><span class="line">	fmt.Println(<span class="string">&quot;This is Tom, an Employee:&quot;</span>)</span><br><span class="line">	i.SayHi()</span><br><span class="line">	i.Sing(<span class="string">&quot;Born to be wild&quot;</span>)</span><br><span class="line">	<span class="comment">//定义了slice Men</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Let&#x27;s use a slice of Men and see what happens&quot;</span>)</span><br><span class="line">	x := <span class="built_in">make</span>([]Men, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">//T这三个都是不同类型的元素，但是他们实现了interface同一个接口</span></span><br><span class="line">	x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = paul, sam, mike</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> x &#123;</span><br><span class="line">		value.SayHi()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is Mike, a Student:</span><br><span class="line">Hi, I am Mike you can call me on 222-222-XXX</span><br><span class="line">La la la la... November rain</span><br><span class="line">This is Tom, an Employee:</span><br><span class="line">Hi, I am Sam, I work at Things Ltd.. Call me on 444-222-XXX</span><br><span class="line">La la la la... Born to be wild</span><br><span class="line">Let&#x27;s use a slice of Men and see what happens</span><br><span class="line">Hi, I am Paul you can call me on 111-222-XXX</span><br><span class="line">Hi, I am Sam, I work at Golang Inc.. Call me on 444-222-XXX</span><br><span class="line">Hi, I am Mike you can call me on 222-222-XXX</span><br></pre></td></tr></table></figure>

<p>那么interface里面到底能存什么值呢？如果我们定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，我们定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值</p>
<blockquote>
<p>当然，使用指针的方式，也是可以的</p>
<p>但是，接口对象不能调用实现对象的属性</p>
</blockquote>
<p><strong>interface函数参数</strong></p>
<p>interface的变量可以持有任意实现该interface类型的对象，这给我们编写函数(包括method)提供了一些额外的思考，我们是不是可以通过定义interface参数，让函数接受各种类型的参数</p>
<p><strong>嵌入interface</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">interface</span> &#123;</span><br><span class="line">	Len()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">interface</span> &#123;</span><br><span class="line">	Human</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Test)</span></span> Len() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s Student</span><br><span class="line">	s = <span class="built_in">new</span>(Test)</span><br><span class="line">	s.Len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了一个<code>Student</code>接口，它通过嵌套<code>Human</code>接口，继承了<code>Human</code>接口中的方法。在<code>Test</code>结构体上定义了一个指针接收者的<code>Len</code>方法。该方法实现了<code>Human</code>接口中的<code>Len</code>方法。通过<code>s.Len()</code>调用了<code>Test</code>结构体中实现的<code>Len</code>方法，并输出”成功”。这样，通过接口的嵌套，我们可以在一个接口中组合多个其他接口，并且实现了嵌套接口的方法的结构体也被认为是实现了嵌套接口。这样可以实现接口的扩展和复用。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	M <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Something <span class="keyword">interface</span> &#123;</span><br><span class="line">	Get()</span><br><span class="line">	Post()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> Get() &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> Post() &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;test&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	test.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Get() &#123;</span><br><span class="line">	<span class="comment">//new(test.Controller).Get()</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Post() &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> something test.Something</span><br><span class="line">	something = <span class="built_in">new</span>(T)</span><br><span class="line">	<span class="keyword">var</span> t T</span><br><span class="line">	t.M = <span class="number">1</span></span><br><span class="line">	<span class="comment">//	t.Controller.M = 1</span></span><br><span class="line">	something.Get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller实现了所有的Something接口方法，当结构体T中调用Controller结构体的时候，T就相当于Java中的继承，T继承了Controller，因此，T可以不用重写所有的Something接口中的方法，因为父构造器已经实现了接口。</p>
<p>如果Controller没有实现Something接口方法，则T要调用Something中方法，就要实现其所有方法。</p>
<p>如果<code>something = new(test.Controller)</code>则调用的是Controller中的Get方法，T可以使用Controller结构体中定义的变量</p>
<p>总之，接口对象不能调用接口实现对象的属性</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>学习go的准备工作</title>
    <url>/2023/06/01/Go/1/</url>
    <content><![CDATA[<h2 id="一-golang环境配置"><a href="#一-golang环境配置" class="headerlink" title="一.golang环境配置"></a>一.golang环境配置</h2><ol>
<li><p><strong>下载SDK</strong></p>
<p>由于我用的是goland专业版，可以直接在上面下载Go SDK，很方便也不需要解压</p>
<p>也可以去官网安装，<strong><a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></strong></p>
<p><em><strong>🤡其实sdk和下文Gopath路径简洁一点更加方便~</strong></em></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f0639cd12d544b5a19868c934ad34b4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512213759389.png"></p>
</li>
<li><p><strong>将go的bin路径添加至Path环境变量中</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5390cc87df4744d9950fa570b1b99604~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512214558987.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e1571d984c048b9bdbcadf2ac0cd68d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512214829533.png"></p>
</li>
<li><p><strong>新建工作目录go_workspace，测试环境</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2001ee1accac4628b96c8515a23edd46~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512215418478.png"></p>
<p>​	在该目录里创建test.txt文件，代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8a01a5064104a60b490755a1b2f0fd2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512215631547"></p>
<p>​	将文件后缀名改为go</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0031456c4f894df5b7e1810e74d56e09~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512215705515"></p>
<p>​	打开命令行，进入go_workspace的目录</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0af7b34cb1224a6dab550296b0f3ae83~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512220156250.png"></p>
<p>​	输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run test.go</span></span><br></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0af7b34cb1224a6dab550296b0f3ae83~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512220740795"></p>
<p>​	输出Hello world!，证明环境配置成功</p>
<ol start="4">
<li><p><strong>设置模块代理</strong></p>
<p>如果访问 github 速度比较慢，建议配置 go mod proxy，下载第三方依赖包的速度可以大大加快</p>
</li>
</ol>
<blockquote>
<ol>
<li>打开“开始”并搜索“env” </li>
<li>选择“编辑系统环境变量” </li>
<li>点击“环境变量…”按钮 </li>
<li>在“&lt;**你的用户名**&gt; 的用户变量”章节下（上半部分）</li>
<li>点击“新建…”按钮</li>
<li>选择“变量名”输入框并输入“GO111MODULE” </li>
<li>选择“变量值”输入框并输入“on” </li>
<li>点击“确定”按钮 </li>
<li>点击“新建…”按钮 </li>
<li>选择“变量名”输入框并输入“GOPROXY” </li>
<li>选择“变量值”输入框并输入“<a href="https://goproxy.cn”/">https://goproxy.cn”</a> </li>
<li>点击“确定”按钮</li>
</ol>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2906b6d25e1743d08166f72c5fb8abdc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230513094942468"></p>
<p>或者打开终端并执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">env</span> -w GO111MODULE=on</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span></span><br></pre></td></tr></table></figure>

<p>如果不放心配置是否准确，当然也可以命令行输入go env检验</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7da62670712f41b487dfefbaa7be4a70~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230513100243945"></p>
<p><em><strong>当然还可以设置自托管go模块代理</strong></em>，参照<a href="https://goproxy.cn/">https://goproxy.cn/</a></p>
<p>​	以下列出自托管go模块代理的一些好处：</p>
<ul>
<li>在没有网络连接的情况下使用代码，因为代码和依赖项都在本地存储。</li>
<li>更好地控制你的代码和依赖项，因为它们都在本地存储。</li>
<li>更好地保护你的代码和依赖项，因为它们不会被外部访问。</li>
<li>更快地构建和测试代码，因为它们不需要从远程服务器下载依赖项。</li>
</ul>
</li>
</ol>
<h2 id="二-goland配置"><a href="#二-goland配置" class="headerlink" title="二.goland配置"></a>二.goland配置</h2><p><strong>系统变量</strong>中新建GOROOT和GOPATH，GOROOT为go的安装路径（Go语言安装目录），GOPATH为go_workspace的路径</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/922f246f49bc482f805f451d9fcd1120~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512223852340.png"></p>
<p>并将<strong>用户变量</strong>中的GOPATH改为go_workspace的路径</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3ba81f6e9403eadd02764531eb944~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512224220984.png"></p>
<p>命令行输入go env，配置成功</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3da83af8fa14d5e95df99a62efabccf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512224355670.png"></p>
<p>新建go工程，GOROOT为go语言安装目录</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/309a90dc08704cb096f68bd1ba1003fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230513082400448.png"></p>
<p>新建main目录，创建test.go文件，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右键并单击运行</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e97edf2697f44c9ac6989f149b432a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230513084354777.png"></p>
<p>输出Hello world！配置成功</p>
<h2 id="三-goland常用快捷键"><a href="#三-goland常用快捷键" class="headerlink" title="三.goland常用快捷键"></a>三.goland常用快捷键</h2><p>文件相关快捷键：</p>
<blockquote>
<p>CTRL+E，打开最近浏览过的文件。<br>CTRL+SHIFT+E，打开最近更改的文件。<br>CTRL+N，可以快速打开struct结构体。<br>CTRL+SHIFT+N，可以快速打开文件。</p>
</blockquote>
<p>代码格式化：</p>
<blockquote>
<p>CTRL+ALT+T，可以把代码包在一个块内，例如if{…}else{…}。<br>CTRL+ALT+L，格式化代码。<br>CTRL+空格，代码提示。<br>CTRL+&#x2F;，单行注释。CTRL+SHIFT+&#x2F;，进行多行注释。<br>CTRL+B，快速打开光标处的结构体或方法（跳转到定义处）。<br>CTRL+“+&#x2F;-”，可以将当前方法进行展开或折叠。</p>
</blockquote>
<p>查找和定位:</p>
<blockquote>
<p>CTRL+R，替换文本。<br>CTRL+F，查找文本。<br>CTRL+SHIFT+F，进行全局查找。<br>CTRL+G，快速定位到某行。</p>
</blockquote>
<p>代码编辑:</p>
<blockquote>
<p>ALT+Q，可以看到当前方法的声明。<br>CTRL+Backspace，按单词进行删除。<br>SHIFT+ENTER，可以向下插入新行，即使光标在当前行的中间。<br>CTRL+X，删除当前光标所在行。<br>CTRL+D，复制当前光标所在行。<br>ALT+SHIFT+UP&#x2F;DOWN，可以将光标所在行的代码上下移动。<br>CTRL+SHIFT+U，可以将选中内容进行大小写转化。</p>
</blockquote>
<p>原文链接：<a href="https://juejin.cn/post/7232459954580947000">Windows系统下golang和goland详细配置|青训营笔记 - 掘金 (juejin.cn)</a></p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>补充函数与字符串</title>
    <url>/2023/06/08/Go/11/</url>
    <content><![CDATA[<p>补充关于闭包，递归，匿名函数，回调函数，strings包、strconv包的使用。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>go语言支持函数式编程：<br>支持将一个函数作为另一个函数的参数，也支持将一个函数作为另一个函数的返回值。</p>
<p>闭包(closure)：<br> 一个外层函数中，有内层函数，该内层函数中，会操作外层函数的局部变量(外层函数中的参数，或者外层函数中直接定义的变量)，并且该外层函数的返回值就是这个内层函数。这个内层函数和外层函数的局部变量，统称为闭包结构。</p>
<p>局部变量的生命周期会发生改变，正常的局部变量随着函数调用而创建，随着函数的结束而销毁。<br>但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁，因为内层函数还要继续使用。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    res1 := increment()      <span class="comment">//res1 = fun</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, res1) <span class="comment">//func() int</span></span><br><span class="line">    fmt.Println(res1)</span><br><span class="line">    v1 := res1()</span><br><span class="line">    fmt.Println(v1) <span class="comment">//1</span></span><br><span class="line">    v2 := res1()</span><br><span class="line">    fmt.Println(v2) <span class="comment">//2</span></span><br><span class="line">    fmt.Println(res1())</span><br><span class="line">    fmt.Println(res1())</span><br><span class="line">    fmt.Println(res1())</span><br><span class="line">    fmt.Println(res1())</span><br><span class="line"></span><br><span class="line">    res2 := increment()</span><br><span class="line">    fmt.Println(res2)</span><br><span class="line">    v3 := res2()</span><br><span class="line">    fmt.Println(v3) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(res2())</span><br><span class="line"></span><br><span class="line">    fmt.Println(res1())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="comment">//外层函数</span></span><br><span class="line">    <span class="comment">//1.定义了一个局部变量</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">//2.定义了一个匿名函数，给变量自增并返回</span></span><br><span class="line">    fun := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="comment">//内层函数</span></span><br><span class="line">       i++</span><br><span class="line">       <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.返回该匿名函数</span></span><br><span class="line">    <span class="keyword">return</span> fun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func() int</span><br><span class="line">0xdbfd60</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">0xdbfd40</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归函数(recursion)：一个函数自己调用自己，就叫做递归函数。<br>一个函数自己调用自己，就叫做递归调用，一个递归函数一定要有出口，否则会陷入死循环。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	sum := getSum(<span class="number">5</span>)</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line"></span><br><span class="line">	res := getFibonacci(<span class="number">12</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFibonacci</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getFibonacci(n<span class="number">-1</span>) + getFibonacci(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;**********&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getSum(n<span class="number">-1</span>) + n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**********</span><br><span class="line">**********</span><br><span class="line">**********</span><br><span class="line">**********</span><br><span class="line">**********</span><br><span class="line">15</span><br><span class="line">144</span><br></pre></td></tr></table></figure>

<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>匿名：没有名字<br>匿名函数：没有名字的函数。</p>
<p>定义一个匿名函数，直接进行调用。通常只能使用一次。也可以使用匿名函数赋值给某个函数变量，那么就可以调用多次了。</p>
<p>匿名函数：<br>Go语言是支持函数式编程：</p>
<p>将匿名函数作为另一个函数的参数，回调函数<br>将匿名函数作为另一个函数的返回值，可以形成闭包结构。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fun1()</span><br><span class="line">	fun1()</span><br><span class="line">	fun2 := fun1</span><br><span class="line">	fun2()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名函数</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;我是一个匿名函数。。&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	fun3 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;我也是一个匿名函数。。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fun3()</span><br><span class="line">	fun3()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义带参数的匿名函数</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(a, b)</span><br><span class="line">	&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义带返回值的匿名函数</span></span><br><span class="line">	res1 := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b</span><br><span class="line">	&#125;(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">//匿名函数调用了，将执行结果给res1</span></span><br><span class="line">	fmt.Println(res1)</span><br><span class="line"></span><br><span class="line">	res2 := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b</span><br><span class="line">	&#125; <span class="comment">//将匿名函数的值，赋值给res2</span></span><br><span class="line">	fmt.Println(res2)</span><br><span class="line"></span><br><span class="line">	fmt.Println(res2(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是fun1()函数。。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是fun1()函数。。</span><br><span class="line">我是fun1()函数。。</span><br><span class="line">我是fun1()函数。。</span><br><span class="line">我是一个匿名函数。。</span><br><span class="line">我也是一个匿名函数。。</span><br><span class="line">我也是一个匿名函数。。</span><br><span class="line">1 2</span><br><span class="line">30</span><br><span class="line">0x63e160</span><br><span class="line">300</span><br></pre></td></tr></table></figure>

<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>高阶函数：<br>根据go语言的数据类型的特点，可以将一个函数作为另一个函数的参数。</p>
<p>fun1(),fun2()<br>将fun1函数作为了fun2这个函数的参数。</p>
<p>fun2函数：就叫高阶函数<br>接收了一个函数作为参数的函数，高阶函数</p>
<p>fun1函数：回调函数<br>作为另一个函数的参数的函数，叫做回调函数。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//设计一个函数，用于求两个整数的加减乘除运算</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, add)  <span class="comment">//func(int, int) int</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, oper) <span class="comment">//func(int, int, func(int, int) int) int</span></span><br><span class="line"></span><br><span class="line">	res1 := add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(res1)</span><br><span class="line"></span><br><span class="line">	res2 := oper(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">	fmt.Println(res2)</span><br><span class="line"></span><br><span class="line">	res3 := oper(<span class="number">5</span>, <span class="number">2</span>, sub)</span><br><span class="line">	fmt.Println(res3)</span><br><span class="line"></span><br><span class="line">	fun1 := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a * b</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res4 := oper(<span class="number">10</span>, <span class="number">4</span>, fun1)</span><br><span class="line">	fmt.Println(res4)</span><br><span class="line"></span><br><span class="line">	res5 := oper(<span class="number">100</span>, <span class="number">8</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;除数不能为零&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a / b</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(res5)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oper</span><span class="params">(a, b <span class="type">int</span>, fun <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Println(a, b, fun) <span class="comment">//打印3个参数</span></span><br><span class="line">	res := fun(a, b)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func(int, int) int</span><br><span class="line">func(int, int, func(int, int) int) int</span><br><span class="line">3</span><br><span class="line">10 20 0xb8fc20</span><br><span class="line">30</span><br><span class="line">5 2 0xb8fc40</span><br><span class="line">3</span><br><span class="line">10 4 0xb8fc60</span><br><span class="line">40</span><br><span class="line">100 8 0xb8fc80</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Go中的字符串是一个字节的切片。<br>可以通过将其内容封装在“”中来创建字符串。Go中的字符串是Unicode兼容的，并且是UTF-8编码的。</p>
<p>字符串是一些字节的集合。理解为一个字符的序列。<br>每个字符都有固定的位置(索引，下标，index：从0开始，到长度减1)<br>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.定义字符串</span></span><br><span class="line">	s1 := <span class="string">&quot;hello中国&quot;</span></span><br><span class="line">	s2 := <span class="string">`hello world`</span></span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.字符串的长度：返回的是字节的个数</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s1))</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s2))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.获取某个字节</span></span><br><span class="line">	fmt.Println(s2[<span class="number">0</span>]) <span class="comment">//获取字符串中的第一个字节</span></span><br><span class="line">	a := <span class="string">&#x27;h&#x27;</span></span><br><span class="line">	b := <span class="number">104</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%c,%c,%c\n&quot;</span>, s2[<span class="number">0</span>], a, b)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.字符串的遍历</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s2); i++ &#123;</span><br><span class="line">		<span class="comment">//fmt.Println(s2[i])</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%c\t&quot;</span>, s2[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//for range</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">		<span class="comment">//fmt.Println(i,v)</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%c&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.字符串是字节的集合</span></span><br><span class="line">	slice1 := []<span class="type">byte</span>&#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>&#125;</span><br><span class="line">	s3 := <span class="type">string</span>(slice1) <span class="comment">//根据一个字节切片，构建字符串</span></span><br><span class="line">	fmt.Println(s3)</span><br><span class="line"></span><br><span class="line">	s4 := <span class="string">&quot;abcdef&quot;</span></span><br><span class="line">	slice2 := []<span class="type">byte</span>(s4) <span class="comment">//根据字符串，获取对应的字节切片</span></span><br><span class="line">	fmt.Println(slice2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6.字符串不能修改</span></span><br><span class="line">	fmt.Println(s4)</span><br><span class="line">	<span class="comment">//s4[2] = &#x27;B&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello中国</span><br><span class="line">hello world</span><br><span class="line">11</span><br><span class="line">11</span><br><span class="line">104</span><br><span class="line">h,h,h</span><br><span class="line">h       e       l       l       o               w       o       r       l      d</span><br><span class="line">hello world</span><br><span class="line">ABCDE</span><br><span class="line">[97 98 99 100 101 102]</span><br><span class="line">abcdef</span><br></pre></td></tr></table></figure>

<h2 id="strings包"><a href="#strings包" class="headerlink" title="strings包"></a>strings包</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="string">&quot;helloworld&quot;</span></span><br><span class="line">	<span class="comment">//1.是否包含指定的内容--&gt;bool</span></span><br><span class="line">	fmt.Println(strings.Contains(s1, <span class="string">&quot;abc&quot;</span>))</span><br><span class="line">	<span class="comment">//2.是否包含chars中任意的一个字符即可</span></span><br><span class="line">	fmt.Println(strings.ContainsAny(s1, <span class="string">&quot;abcd&quot;</span>))</span><br><span class="line">	<span class="comment">//3.统计substr在s中出现的次数</span></span><br><span class="line">	fmt.Println(strings.Count(s1, <span class="string">&quot;lloo&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.以xxx前缀开头，以xxx后缀结尾</span></span><br><span class="line">	s2 := <span class="string">&quot;20230525课堂笔记.txt&quot;</span></span><br><span class="line">	<span class="keyword">if</span> strings.HasPrefix(s2, <span class="string">&quot;202305&quot;</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;23年5月的文件。。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> strings.HasSuffix(s2, <span class="string">&quot;.txt&quot;</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文本文档。。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//索引</span></span><br><span class="line">	<span class="comment">//helloworld</span></span><br><span class="line">	fmt.Println(strings.Index(s1, <span class="string">&quot;lloo&quot;</span>))     <span class="comment">//查找substr在s中的位置，如果不存在就返回-1</span></span><br><span class="line">	fmt.Println(strings.IndexAny(s1, <span class="string">&quot;abcdh&quot;</span>)) <span class="comment">//查找chars中任意的一个字符，出现在s中的位置</span></span><br><span class="line">	fmt.Println(strings.LastIndex(s1, <span class="string">&quot;l&quot;</span>))    <span class="comment">//查找substr在s中最后一次出现的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串的拼接</span></span><br><span class="line">	ss1 := []<span class="type">string</span>&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;ruby&quot;</span>&#125;</span><br><span class="line">	s3 := strings.Join(ss1, <span class="string">&quot;-&quot;</span>)</span><br><span class="line">	fmt.Println(s3)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//切割</span></span><br><span class="line">	s4 := <span class="string">&quot;123,4563,aaa,49595,45&quot;</span></span><br><span class="line">	ss2 := strings.Split(s4, <span class="string">&quot;,&quot;</span>)	<span class="comment">//数组</span></span><br><span class="line">	<span class="comment">//fmt.Println(ss2)</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ss2); i++ &#123;</span><br><span class="line">		fmt.Println(ss2[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重复，自己拼接自己count次</span></span><br><span class="line">	s5 := strings.Repeat(<span class="string">&quot;hello&quot;</span>, <span class="number">5</span>)</span><br><span class="line">	fmt.Println(s5)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line">	<span class="comment">//helloworld</span></span><br><span class="line">	s6 := strings.Replace(s1, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">	fmt.Println(s6)</span><br><span class="line">	<span class="comment">//fmt.Println(strings.Repeat(&quot;hello&quot;,5))</span></span><br><span class="line"></span><br><span class="line">	s7 := <span class="string">&quot;heLLo WOrlD**123..&quot;</span></span><br><span class="line">	fmt.Println(strings.ToLower(s7))</span><br><span class="line">	fmt.Println(strings.ToUpper(s7))</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		截取子串：</span></span><br><span class="line"><span class="comment">		substring(start,end)--&gt;substr</span></span><br><span class="line"><span class="comment">		str[start:end]--&gt;substr</span></span><br><span class="line"><span class="comment">			包含start，不包含end下标</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	s8 := s1[:<span class="number">5</span>]</span><br><span class="line">	fmt.Println(s8)</span><br><span class="line">	fmt.Println(s1[<span class="number">5</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">0</span><br><span class="line">23年5月的文件。。</span><br><span class="line">文本文档。。</span><br><span class="line">-1</span><br><span class="line">0</span><br><span class="line">8</span><br><span class="line">abc-world-hello-ruby</span><br><span class="line">123</span><br><span class="line">4563</span><br><span class="line">aaa</span><br><span class="line">49595</span><br><span class="line">45</span><br><span class="line">hellohellohellohellohello</span><br><span class="line">he**owor*d</span><br><span class="line">hello world**123..</span><br><span class="line">HELLO WORLD**123..</span><br><span class="line">helloworld</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<h2 id="strconv包"><a href="#strconv包" class="headerlink" title="strconv包"></a>strconv包</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.bool类型</span></span><br><span class="line">	s1 := <span class="string">&quot;true&quot;</span></span><br><span class="line">	b1, err := strconv.ParseBool(s1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%t\n&quot;</span>, b1, b1)	<span class="comment">//%t是bool类型</span></span><br><span class="line"></span><br><span class="line">	ss1 := strconv.FormatBool(b1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%s\n&quot;</span>, ss1, ss1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.整数</span></span><br><span class="line">	s2 := <span class="string">&quot;100&quot;</span></span><br><span class="line">	i2, err := strconv.ParseInt(s2, <span class="number">2</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%d\n&quot;</span>, i2, i2)</span><br><span class="line"></span><br><span class="line">	ss2 := strconv.FormatInt(i2, <span class="number">10</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%s\n&quot;</span>, ss2, ss2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//itoa(),atoi()</span></span><br><span class="line">	i3, err := strconv.Atoi(<span class="string">&quot;-42&quot;</span>) <span class="comment">//转为int类型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%d\n&quot;</span>, i3, i3)</span><br><span class="line">	ss3 := strconv.Itoa(<span class="number">-42</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%s\n&quot;</span>, ss3, ss3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool,true</span><br><span class="line">string,true</span><br><span class="line">int64,4</span><br><span class="line">string,4</span><br><span class="line">int,-42</span><br><span class="line">string,-42</span><br></pre></td></tr></table></figure>

<p>“strconv”用于进行字符串和基本类型之间的转换。在main函数中，首先演示了布尔类型的转换。使用strconv.ParseBool函数将s1转换为bool类型的变量b1。如果转换过程中出现错误，则会打印错误信息并返回。否则，使用fmt.Printf函数输出b1的类型和值。接下来，使用strconv.FormatBool函数将b1转换为字符串类型的变量ss1，演示了整数类型的转换，使用strconv.ParseInt函数将s2按照二进制解析为int64类型的变量i2。使用strconv.FormatInt函数将i2按照十进制转换为字符串类型的变量ss2，使用strconv.Atoi函数将字符串”-42”转换为int类型的变量i3，使用strconv.Itoa函数将整数-42转换为字符串类型的变量ss3。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>包的使用和time包</title>
    <url>/2023/06/10/Go/13/</url>
    <content><![CDATA[<h1 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h1><p>Go语言使用包（package）这种语法元素来组织源码，所有语法可见性均定义在package这个级别，与Java 、python等语言相比，这算不上什么创新，但与C传统的include相比，则是显得“先进”了许多。</p>
<p>Go 语言的源码复用建立在包（package）基础之上。包通过 package, import, GOPATH 操作完成。</p>
<h2 id="main包"><a href="#main包" class="headerlink" title="main包"></a>main包</h2><p>Go 语言的入口 main() 函数所在的包（package）叫 main，main 包想要引用别的代码，需要import导入！</p>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>src 目录是以代码包的形式组织并保存 Go 源码文件的。每个代码包都和 src 目录下的文件夹一一对应。每个子目录都是一个代码包。</p>
<blockquote>
<p>代码包包名和文件目录名，不要求一致。比如文件目录叫 hello，但是代码包包名可以声明为 “main”，但是同一个目录下的源码文件第一行声明的所属包，必须一致！</p>
</blockquote>
<p>同一个目录下的所有.go文件的第一行添加 包定义，以标记该文件归属的包，演示语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure>

<p>包需要满足：</p>
<ul>
<li>一个目录下的同级文件归属一个包。也就是说，在同一个包下面的所有文件的package名，都是一样的。</li>
<li>在同一个包下面的文件<code>package</code>名都建议设为是该目录名，但也可以不是。也就是说，包名可以与其目录不同名。</li>
<li>包名为 main 的包为应用程序的入口包，其他包不能使用。</li>
</ul>
<blockquote>
<p>在同一个包下面的文件属于同一个工程文件，不用<code>import</code>包，可以直接使用</p>
</blockquote>
<p>包可以嵌套定义，对应的就是嵌套目录，但包名应该与所在的目录一致。</p>
<p>包中，通过标识符首字母是否大写，来确定是否可以被导出。首字母大写才可以被导出，视为 public 公共的资源。</p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>要引用其他包，可以使用 import 关键字，可以单个导入或者批量导入，语法演示：</p>
<p>A：通常导入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package&quot;</span></span><br><span class="line"><span class="comment">// 批量导入</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;package1&quot;</span></span><br><span class="line">  <span class="string">&quot;package2&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>B：点操作<br>我们有时候会看到如下的方式导入包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	. <span class="string">&quot;fmt&quot;</span></span><br><span class="line">) </span><br></pre></td></tr></table></figure>

<p>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	. <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span></span> p(n <span class="type">int</span>) S &#123;</span><br><span class="line">	Print(n)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">defer</span> s.p(<span class="number">1</span>).p(<span class="number">2</span>)</span><br><span class="line">	Print(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C：起别名</p>
<p>别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字。导入时，可以为包定义别名，语法演示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  p1 <span class="string">&quot;package1&quot;</span></span><br><span class="line">  p2 <span class="string">&quot;package2&quot;</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment">// 使用时：别名操作，调用包函数时前缀变成了我们的前缀</span></span><br><span class="line">p1.Method()</span><br></pre></td></tr></table></figure>

<p>D：_操作<br>如果仅仅需要导入包时执行初始化操作，并不需要使用包内的其他函数，常量等资源。则可以在导入包时，匿名导入。</p>
<p>这个操作经常是让很多人费解的一个操作符，请看下面这个import：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:@tcp(127.0.0.1:3306)/flask_meeting?charset=utf8mb4&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;错误信息&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;连接成功&quot;</span>, db)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。也就是说，使用下划线作为包的别名，会仅仅执行init()。</p>
<blockquote>
<p>导入的包的路径名，可以是相对路径也可以是绝对路径，推荐使用绝对路径（起始于工程根目录）。</p>
</blockquote>
<h2 id="GOPATH环境变量"><a href="#GOPATH环境变量" class="headerlink" title="GOPATH环境变量"></a>GOPATH环境变量</h2><p>import导入时，会从GO的安装目录（也就是GOROOT环境变量设置的目录）和GOPATH环境变量设置的目录中，检索 src&#x2F;package 来导入包。如果不存在，则导入失败。<br>GOROOT，就是GO内置的包所在的位置。<br>GOPATH，就是我们自己定义的包的位置。</p>
<p>通常我们在开发Go项目时，调试或者编译构建时，需要设置GOPATH指向我们的项目目录，目录中的src目录中的包就可以被导入了。</p>
<h2 id="init-包初始化"><a href="#init-包初始化" class="headerlink" title="init() 包初始化"></a>init() 包初始化</h2><p>下面我们详细的来介绍一下这两个函数：init()、main() 是 go 语言中的保留函数。我们可以在源码中，定义 init() 函数。此函数会在包被导入时执行，例如如果是在 main 中导入包，包中存在 init()，那么 init() 中的代码会在 main() 函数执行前执行，用于初始化包所需要的特定资料。例如：<br>包源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/userPackage/tool.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> userPackage</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;tool init&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;userPackage&quot;</span></span><br><span class="line">  )</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;main run&quot;</span>)</span><br><span class="line">  <span class="comment">// 使用userPackage</span></span><br><span class="line">  userPackage.SomeFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行时，会先输出 “tool init”，再输出 “main run”。</p>
<p>下面我们详细的来介绍一下init()、main() 这两个函数。在 go 语言中的区别如下：<br>相同点：</p>
<p>两个函数在定义时不能有任何的参数和返回值。<br>该函数只能由 go 程序自动调用，不可以被引用。</p>
<p>不同点：</p>
<p>init 可以应用于任意包中，且可以重复定义多个。<br>main 函数只能用于 main 包中，且只能定义一个。</p>
<p>两个函数的执行顺序：</p>
<p>在 main 包中的 go 文件默认总是会被执行。</p>
<ul>
<li><p>对同一个 go 文件的 init( ) 调用顺序是从上到下的。</p>
</li>
<li><p>对同一个 package 中的不同文件，将文件名按字符串进行“从小到大”排序，之后顺序调用各文件中的init()函数。</p>
</li>
<li><p>对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数。</p>
</li>
<li><p>如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main，一次执行对应的 init 方法。main 包总是被最后一个初始化，因为它总是依赖别的包</p>
</li>
</ul>
<p>避免出现循环 import，例如：A –&gt; B –&gt; C –&gt; A。</p>
<p>一个包被其它多个包 import，但只能被初始化一次</p>
<h2 id="管理外部包"><a href="#管理外部包" class="headerlink" title="管理外部包"></a>管理外部包</h2><p>go允许import不同代码库的代码。对于import要导入的外部的包，可以使用 go get 命令取下来放到GOPATH对应的目录中去。</p>
<p>举个例子，比如说我们想通过go语言连接mysql数据库，那么需要先下载mysql的数据包，打开终端并输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go get github.com/go-sql-driver/mysql</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>也就是说，对于go语言来讲，其实并不关心你的代码是内部还是外部的，总之都在GOPATH里，任何import包的路径都是从GOPATH开始的；唯一的区别，就是内部依赖的包是开发者自己写的，外部依赖的包是go get下来的。</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们可以通过go install 来编译包文件。</p>
<p>我们知道一个非main包在编译后会生成一个.a文件（在临时目录下生成，除非使用go install安装到$GOROOT或$GOPATH下，否则你看不到.a），用于后续可执行程序链接使用。</p>
<p>比如Go标准库中的包对应的源码部分路径在：$GOROOT&#x2F;src，而标准库中包编译后的.a文件路径在$GOROOT&#x2F;pkg&#x2F;darwin_amd64下。</p>
<ul>
<li>pkg 目录是用来存放通过 go install 命令安装后的代码包的归档文件(.a 文件)。归档文件的名字就是代码包的名字。所有归档文件都会被存放到该目录下的平台相关目录中，即在 <code>$GOPATH/pkg/$GOOS_$GOARCH</code> 中，同样以代码包为组织形式。</li>
</ul>
<h1 id="time包"><a href="#time包" class="headerlink" title="time包"></a>time包</h1><p>time包：<br>       1年&#x3D;365天，day<br>       1天&#x3D;24小时，hour<br>       1小时&#x3D;60分钟，minute<br>       1分钟&#x3D;60秒，second<br>       1秒钟&#x3D;1000毫秒，millisecond<br>       1毫秒&#x3D;1000微秒，microsecond–&gt;μs<br>       1微秒&#x3D;1000纳秒，nanosecond–&gt;ns<br>       1纳秒&#x3D;1000皮秒，picosecond–&gt;ps</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.获取当前的时间</span></span><br><span class="line">	t1 := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, t1) <span class="comment">//time.Time</span></span><br><span class="line">	fmt.Println(t1)        <span class="comment">//2023-06-10 11:16:15.340273 +0800 CST m=+0.003384001</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.获取指定的时间</span></span><br><span class="line">	t2 := time.Date(<span class="number">2008</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">28</span>, <span class="number">0</span>, time.Local)</span><br><span class="line">	fmt.Println(t2) <span class="comment">//2008-07-15 16:30:28 +0800 CST</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.time--&gt;string之间的转换</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 t1.Format(&quot;格式模板&quot;)--&gt;string</span></span><br><span class="line"><span class="comment">		模板的日期必须是固定：06-1-2-3-4-5</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s1 := t1.Format(<span class="string">&quot;2006-1-2 15:04:05&quot;</span>)</span><br><span class="line">	fmt.Println(s1) <span class="comment">//2023-6-10 11:16:15</span></span><br><span class="line"></span><br><span class="line">	s2 := t1.Format(<span class="string">&quot;2006/01/02&quot;</span>)</span><br><span class="line">	fmt.Println(s2) <span class="comment">//2023/06/10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//string--&gt;time</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 time.Parse(&quot;模板&quot;,str)--&gt;time,err</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s3 := <span class="string">&quot;1999年10月10日&quot;</span> <span class="comment">//string</span></span><br><span class="line">	t3, err := time.Parse(<span class="string">&quot;2006年01月02日&quot;</span>, s3)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(t3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, t3)</span><br><span class="line"></span><br><span class="line">	fmt.Println(t1.String())</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.根据当前时间，获取指定的内容</span></span><br><span class="line">	year, month, day := t1.Date() <span class="comment">//年，月，日</span></span><br><span class="line">	fmt.Println(year, month, day) <span class="comment">//2023 June 10</span></span><br><span class="line"></span><br><span class="line">	hour, min, sec := t1.Clock()</span><br><span class="line">	fmt.Println(hour, min, sec) <span class="comment">//时，分，秒</span></span><br><span class="line"></span><br><span class="line">	year2 := t1.Year()</span><br><span class="line">	fmt.Println(<span class="string">&quot;年：&quot;</span>, year2)</span><br><span class="line">	fmt.Println(t1.YearDay())</span><br><span class="line"></span><br><span class="line">	month2 := t1.Month()</span><br><span class="line">	fmt.Println(<span class="string">&quot;月：&quot;</span>, month2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;日：&quot;</span>, t1.Day())</span><br><span class="line">	fmt.Println(<span class="string">&quot;时：&quot;</span>, t1.Hour())</span><br><span class="line">	fmt.Println(<span class="string">&quot;分钟：&quot;</span>, t1.Minute())</span><br><span class="line">	fmt.Println(<span class="string">&quot;秒：&quot;</span>, t1.Second())</span><br><span class="line">	fmt.Println(<span class="string">&quot;纳秒：&quot;</span>, t1.Nanosecond())</span><br><span class="line"></span><br><span class="line">	fmt.Println(t1.Weekday()) <span class="comment">//Wednesday</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.时间戳：指定的日期，距离1970年1月1日0点0时0分0秒的时间差值：秒，纳秒</span></span><br><span class="line"></span><br><span class="line">	t4 := time.Date(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">	timeStamp1 := t4.Unix() <span class="comment">//秒的差值</span></span><br><span class="line">	fmt.Println(timeStamp1)</span><br><span class="line">	timeStamp2 := t1.Unix()</span><br><span class="line">	fmt.Println(timeStamp2)</span><br><span class="line"></span><br><span class="line">	timeStamp3 := t4.UnixNano()</span><br><span class="line">	fmt.Println(timeStamp3) <span class="comment">//3600 000 000 000</span></span><br><span class="line">	timeStamp4 := t1.UnixNano()</span><br><span class="line">	fmt.Println(timeStamp4)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6.时间间隔</span></span><br><span class="line">	t5 := t1.Add(time.Minute)</span><br><span class="line">	fmt.Println(t1)</span><br><span class="line">	fmt.Println(t5)</span><br><span class="line">	fmt.Println(t1.Add(<span class="number">24</span> * time.Hour))</span><br><span class="line"></span><br><span class="line">	t6 := t1.AddDate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	fmt.Println(t6)</span><br><span class="line"></span><br><span class="line">	d1 := t5.Sub(t1)</span><br><span class="line">	fmt.Println(d1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//7.睡眠</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second) <span class="comment">//让当前的程序进入睡眠状态</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main。。。over。。。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//睡眠[1-10]的随机秒数</span></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	randNum := rand.Intn(<span class="number">10</span>) + <span class="number">1</span> <span class="comment">//int</span></span><br><span class="line">	fmt.Println(randNum)</span><br><span class="line">	time.Sleep(time.Duration(randNum) * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;睡醒了。。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time.Time</span><br><span class="line">2023-06-10 11:24:17.1424817 +0800 CST m=+0.003008901</span><br><span class="line">2008-07-15 16:30:28 +0800 CST</span><br><span class="line">2023-6-10 11:24:17</span><br><span class="line">2023/06/10</span><br><span class="line">1999-10-10 00:00:00 +0000 UTC</span><br><span class="line">time.Time</span><br><span class="line">2023-06-10 11:24:17.1424817 +0800 CST m=+0.003008901</span><br><span class="line">2023 June 10</span><br><span class="line">11 24 17</span><br><span class="line">年： 2023</span><br><span class="line">161</span><br><span class="line">月： June</span><br><span class="line">日： 10</span><br><span class="line">时： 11</span><br><span class="line">分钟： 24</span><br><span class="line">秒： 17</span><br><span class="line">纳秒： 142481700</span><br><span class="line">Saturday</span><br><span class="line">3600</span><br><span class="line">1686367457</span><br><span class="line">3600000000000</span><br><span class="line">1686367457142481700</span><br><span class="line">2023-06-10 11:24:17.1424817 +0800 CST m=+0.003008901</span><br><span class="line">2023-06-10 11:25:17.1424817 +0800 CST m=+60.003008901</span><br><span class="line">2023-06-11 11:24:17.1424817 +0800 CST m=+86400.003008901</span><br><span class="line">2024-06-10 11:24:17.1424817 +0800 CST</span><br><span class="line">1m0s</span><br><span class="line">main。。。over。。。。。</span><br><span class="line">7</span><br><span class="line">睡醒了。。</span><br></pre></td></tr></table></figure>

<h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> userInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Age   <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Hobby []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := userInfo&#123;Name: <span class="string">&quot;wang&quot;</span>, Age: <span class="number">18</span>, Hobby: []<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;TypeScript&quot;</span>&#125;&#125;</span><br><span class="line">	buf, err := json.Marshal(a)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(buf)         <span class="comment">// [123 34 78 97...]</span></span><br><span class="line">	fmt.Println(<span class="type">string</span>(buf)) <span class="comment">// &#123;&quot;Name&quot;:&quot;wang&quot;,&quot;age&quot;:18,&quot;Hobby&quot;:[&quot;Golang&quot;,&quot;TypeScript&quot;]&#125;</span></span><br><span class="line"></span><br><span class="line">	buf, err = json.MarshalIndent(a, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b userInfo</span><br><span class="line">	err = json.Unmarshal(buf, &amp;b)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, b) <span class="comment">// main.userInfo&#123;Name:&quot;wang&quot;, Age:18, Hobby:[]string&#123;&quot;Golang&quot;, &quot;TypeScript&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[123 34 78 97 109 101 34 58 34 119 97 110 103 34 44 34 97 103 101 34 58 49 56 44 34 72 111 98 98 121 34 58 91 34 71 111 108 97 110 103 34 44 34 84 121 112 101 83 99 114 105 112 116 34 93 125]</span><br><span class="line">&#123;&quot;Name&quot;:&quot;wang&quot;,&quot;age&quot;:18,&quot;Hobby&quot;:[&quot;Golang&quot;,&quot;TypeScript&quot;]&#125;</span><br><span class="line">&#123;</span><br><span class="line">	&quot;Name&quot;: &quot;wang&quot;,</span><br><span class="line">	&quot;age&quot;: 18,</span><br><span class="line">	&quot;Hobby&quot;: [</span><br><span class="line">		&quot;Golang&quot;,</span><br><span class="line">		&quot;TypeScript&quot;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">main.userInfo&#123;Name:&quot;wang&quot;, Age:18, Hobby:[]string&#123;&quot;Golang&quot;, &quot;TypeScript&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>代码定义了一个 userInfo 结构体，该结构体具有三个字段：Name、Age 和 Hobby，分别表示用户名、年龄和兴趣爱好。Age 字段使用 <code>json:&quot;age&quot;</code> 的标签，指示在 JSON 序列化和反序列化过程中，将其<code>映射到名为 age 的字段</code>。<br>在 main 函数中，首先创建了一个 userInfo 结构体实例 a，赋予了相应的字段值。然后使用 json.Marshal 将结构体实例 a 序列化为 JSON 字符串，得到一个<code>字节数组 buf</code>。fmt.Println(buf) 打印了字节数组的内容，由于是字节的 ASCII 表示，所以会打印一系列数字。接着使用 fmt.Println(string(buf)) 将字节数组<code>转换为字符串并打印</code>，得到 JSON 格式的字符串表示。接下来，使用 json.MarshalIndent 进行格式化序列化，生成<code>带缩进的 JSON 字符串</code>，并将其打印出来。然后，定义了一个空的 userInfo 结构体变量 b，使用 json.Unmarshal 将 JSON 字符串 buf 反序列化为结构体实例 b。反序列化的结果存储在 b 中。<code>%#v </code>用于打印变量 b 的详细信息。它会打印出结构体类型的名称以及字段的名称和对应的值。这种格式化输出对于调试和理解变量的结构非常有用。</p>
<h1 id="env"><a href="#env" class="headerlink" title="env"></a>env</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Println(os.Args)</span><br><span class="line">	fmt.Println(os.Getenv(<span class="string">&quot;PATH&quot;</span>))</span><br><span class="line">	fmt.Println(os.Setenv(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>))</span><br><span class="line"></span><br><span class="line">	buf, err := exec.Command(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;/etc/hosts&quot;</span>).CombinedOutput()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>在 main 函数中，首先使用 fmt.Println(os.Args) 打印出程序接收到的命令行参数。os.Args 是一个字符串切片，包含了程序运行时传递的命令行参数。<br>接下来，使用 os.Getenv(“PATH”) 获取名为 “PATH” 的环境变量的值，并使用 fmt.Println 打印出来。os.Getenv 函数用于获取环境变量的值。<br>然后，使用 os.Setenv(“AA”, “BB”) 将名为 “AA” 的环境变量的值设置为 “BB”。os.Setenv 函数用于设置环境变量的值。最后，使用 exec.Command 函数创建一个命令对象，并指定要执行的命令为 “grep”，参数为 “127.0.0.1” 和 “&#x2F;etc&#x2F;hosts”。然后，使用 CombinedOutput 方法执行命令并捕获命令的输出结果（包括标准输出和标准错误）。捕获的输出结果存储在 buf 变量中。如果执行命令过程中发生错误，代码会使用 panic 函数抛出异常。最后，使用 fmt.Println(string(buf)) 打印出命令的输出结果。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>type关键字与错误处理</title>
    <url>/2023/06/09/Go/12/</url>
    <content><![CDATA[<h1 id="type关键字"><a href="#type关键字" class="headerlink" title="type关键字"></a>type关键字</h1><p>type：用于类型定义和类型别名</p>
<ul>
<li>类型定义：type 类型名 Type</li>
<li>类型别名：type  类型名 &#x3D; Type</li>
</ul>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i1 myint</span><br><span class="line">	<span class="keyword">var</span> i2 = <span class="number">100</span> <span class="comment">//int</span></span><br><span class="line">	i1 = <span class="number">200</span></span><br><span class="line">	fmt.Println(i1, i2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> name mystr</span><br><span class="line">	name = <span class="string">&quot;王二狗&quot;</span></span><br><span class="line">	<span class="keyword">var</span> s1 <span class="type">string</span></span><br><span class="line">	s1 = <span class="string">&quot;李小花&quot;</span></span><br><span class="line">	fmt.Println(name, s1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//i1 = i2 //cannot use i2 (type int) as type myint in assignment</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//name = s1 //cannot use s1 (type string) as type mystr in assignment</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%T,%T,%T\n&quot;</span>, i1, i2, name, s1) <span class="comment">//main.myint,int,main.mystr,string</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;----------------------------------&quot;</span>)</span><br><span class="line">	res1 := fun1()</span><br><span class="line">	fmt.Println(res1(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;----------------------------------&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> i3 myint2</span><br><span class="line">	i3 = <span class="number">1000</span></span><br><span class="line">	fmt.Println(i3)</span><br><span class="line">	i3 = i2</span><br><span class="line">	fmt.Println(i3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%T,%T\n&quot;</span>, i1, i2, i3) <span class="comment">//main.myint,int,int</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义一个新的类型</span></span><br><span class="line"><span class="keyword">type</span> myint <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> mystr <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义函数类型</span></span><br><span class="line"><span class="keyword">type</span> myfun <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span> myfun &#123; <span class="comment">//fun1()函数的返回值是myfun类型</span></span><br><span class="line">	fun := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		s := strconv.Itoa(a) + strconv.Itoa(b)</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.类型别名</span></span><br><span class="line"><span class="keyword">type</span> myint2 = <span class="type">int</span> <span class="comment">//不是重新定义新的数据类型，只是给int起别名，和int可以通用</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 100</span><br><span class="line">王二狗 李小花</span><br><span class="line">main.myint,int,main.mystr,string</span><br><span class="line">----------------------------------</span><br><span class="line">1020</span><br><span class="line">----------------------------------</span><br><span class="line">1000</span><br><span class="line">100</span><br><span class="line">main.myint,int,int</span><br></pre></td></tr></table></figure>

<p>尽管类型别名可以方便地使用现有类型，但它们不会创建一个新的类型。因此，无法在类型别名上定义新方法。只有在本地类型上才能定义新方法。</p>
<p>错误代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyDuration = time.Duration</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyDuration)</span></span> SimpleSet() &#123; <span class="comment">//cannot define new methods on non-local type time.Duration</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要么在time包下定义新方法，要么建一个新的命名类型，而不是使用类型别名。</p>
<p>修正：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyDuration time.Duration</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyDuration)</span></span> SimpleSet() &#123;</span><br><span class="line">	<span class="comment">// 在这里实现SimpleSet方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在这里使用MyDuration类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在结构体成员嵌入时使用别名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> show() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Person---&gt;&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// People 类型别名</span></span><br><span class="line"><span class="keyword">type</span> People = Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span></span> show2() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;People---&gt;&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//嵌入两个结构体</span></span><br><span class="line">	Person</span><br><span class="line">	People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s Student</span><br><span class="line">	<span class="comment">//s.name = &quot;王二狗&quot; //ambiguous selector s.name</span></span><br><span class="line">	s.Person.name = <span class="string">&quot;王二狗&quot;</span></span><br><span class="line">	<span class="comment">//s.show() //ambiguous selector s.show</span></span><br><span class="line">	s.Person.show()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%T\n&quot;</span>, s.Person, s.People) <span class="comment">//main.Person,main.Person</span></span><br><span class="line"></span><br><span class="line">	s.People.name = <span class="string">&quot;李小花&quot;</span></span><br><span class="line">	s.People.show2()</span><br><span class="line"></span><br><span class="line">	s.Person.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person---&gt; 王二狗</span><br><span class="line">main.Person,main.Person</span><br><span class="line">People---&gt; 李小花</span><br><span class="line">Person---&gt; 王二狗</span><br></pre></td></tr></table></figure>

<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。Go语言没有提供像Java、c#语言中的try…catch异常处理方式，而是通过函数返回值逐层往上抛。这种设计，鼓励工程师在代码中显式的检查错误，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端,让代码啰嗦。</p>
<h2 id="什么是错误"><a href="#什么是错误" class="headerlink" title="什么是错误"></a>什么是错误</h2><p>错误是什么?<br>错误指的是可能出现问题的地方出现了问题。比如打开一个文件时失败，这种情况在人们的意料之中。<br>而异常指的是不应该出现问题的地方出现了问题。比如引用了空指针，这种情况在人们的意料之外。可见，错误是业务过程的一部分,而异常不是。<br>Go中的错误也是一种类型。错误用内置的error类型表示。就像其他类型的，如int，float64。错误值可以存储在变量中，从函数中返回，等等。</p>
<h2 id="演示错误"><a href="#演示错误" class="headerlink" title="演示错误"></a>演示错误</h2><p>让我们从一个示例程序开始,这个程序尝试打开一个不存在的文件。</p>
<p>示例代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//log.Fatal(err)</span></span><br><span class="line">		fmt.Println(err) <span class="comment">//open test.txt: no such file or directory</span></span><br><span class="line">		<span class="keyword">if</span> ins, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;1.Op:&quot;</span>, ins.Op)</span><br><span class="line">			fmt.Println(<span class="string">&quot;2.Path:&quot;</span>, ins.Path)</span><br><span class="line">			fmt.Println(<span class="string">&quot;3.Err:&quot;</span>, ins.Err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(f.Name(), <span class="string">&quot;打开文件成功。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open test.txt: The system cannot find the file specified.</span><br><span class="line">1.Op: open</span><br><span class="line">2.Path: test.txt</span><br><span class="line">3.Err: The system cannot find the file specified.</span><br></pre></td></tr></table></figure>

<p>这行代码尝试将错误值 <code>err</code> 转换为 <code>*os.PathError</code> 类型，并将结果存储在变量 <code>ins</code> 中。这是一个类型断言的示例，它检查错误类型是否是 <code>*os.PathError</code>，并且返回一个布尔值 <code>ok</code> 表示是否成功进行了类型转换。如果类型断言成功，这些代码将打印 <code>*os.PathError</code> 类型的特定字段信息。<code>Op</code> 字段表示操作类型，<code>Path</code> 字段表示操作的路径，<code>Err</code> 字段表示底层错误。</p>
<h2 id="自定义函数返回错误"><a href="#自定义函数返回错误" class="headerlink" title="自定义函数返回错误"></a>自定义函数返回错误</h2><p>error：内置的数据类型，内置的接口<br>定义方法：Error() string</p>
<p>使用go语言提供好的包：<br>errors包下的函数：New()，创建一个error对象，fmt包下的Errorf()函数：<br>func Errorf(format string, a …interface{}) error</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.创建一个error数据</span></span><br><span class="line">	err1 := errors.New(<span class="string">&quot;自己创建玩的。。&quot;</span>)</span><br><span class="line">	fmt.Println(err1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, err1) <span class="comment">//*errors.errorString</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.另一个创建error的方法</span></span><br><span class="line">	err2 := fmt.Errorf(<span class="string">&quot;错误的信息码:%d&quot;</span>, <span class="number">100</span>)</span><br><span class="line">	fmt.Println(err2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, err2)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">	err3 := checkAge(<span class="number">-30</span>)</span><br><span class="line">	<span class="keyword">if</span> err3 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err3)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;程序。。。go on。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计一个函数：验证年龄是否合法，如果为负数，就返回一个error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkAge</span><span class="params">(age <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> age &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">//返回error对象</span></span><br><span class="line">		<span class="comment">//return errors.New(&quot;年龄不合法&quot;)</span></span><br><span class="line">		err := fmt.Errorf(<span class="string">&quot;您给定的年龄是：%d,不合法&quot;</span>, age)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;年龄是：&quot;</span>, age)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自己创建玩的。。</span><br><span class="line">*errors.errorString</span><br><span class="line">错误的信息码:100</span><br><span class="line">*errors.errorString</span><br><span class="line">-----------------</span><br><span class="line">您给定的年龄是：-30,不合法</span><br></pre></td></tr></table></figure>

<h2 id="错误的类型表示"><a href="#错误的类型表示" class="headerlink" title="错误的类型表示"></a>错误的类型表示</h2><ol>
<li></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ins, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;1.Op:&quot;</span>, ins.Op)</span><br><span class="line">			fmt.Println(<span class="string">&quot;2.Path:&quot;</span>, ins.Path)</span><br><span class="line">			fmt.Println(<span class="string">&quot;3.Err:&quot;</span>, ins.Err)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获得更多信息的第二种方法是断言底层类型，并通过调用struct类型的方法获取更多信息。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	addr, err := net.LookupHost(<span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	<span class="keyword">if</span> ins, ok := err.(*net.DNSError); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> ins.Timeout() &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;操作超时。。&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ins.Temporary() &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;临时性错误。。&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;通常错误。。&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">[182.61.200.6 182.61.200.7]</span><br></pre></td></tr></table></figure>

<p>3.直接比较<br>获得更多关于错误的详细信息的第三种方法是直接与类型错误的变量进行比较。让我们通过一个例子来理解这个问题。<br>filepath包的Glob函数用于返回与模式匹配的所有文件的名称。当模式出现错误时，该函数将返回一个错误ErrBadPattern。<br>在filepath包中定义了ErrBadPattern，如下所述:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrBadPattern = errors.New(<span class="string">&quot;syntax error in pattern&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>errors.New()用于创建新的错误。<br>当模式出现错误时,由Glob函数返回ErrBadPattern。</p>
<p>让我们写一个小程序来检查这个错误:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	files, err := filepath.Glob(<span class="string">&quot;[&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err == filepath.ErrBadPattern &#123;</span><br><span class="line">		fmt.Println(err) <span class="comment">//syntax error in pattern</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;files:&quot;</span>, files)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax error in pattern</span><br></pre></td></tr></table></figure>

<p>记住永远不要忽略一个错误。忽视错误会招致麻烦。</p>
<h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	radius := <span class="number">-3.0</span></span><br><span class="line">	area, err := circleArea(radius)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">if</span> err, ok := err.(*areaError); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;半径是：%.2f\n&quot;</span>, err.radius)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;圆形的面积是：&quot;</span>, area)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义一个结构体，表示错误的类型</span></span><br><span class="line"><span class="keyword">type</span> areaError <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg    <span class="type">string</span></span><br><span class="line">	radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.实现error接口，就是实现Error()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;error：半径，%.2f，%s&quot;</span>, e.radius, e.msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleArea</span><span class="params">(radius <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, &amp;areaError&#123;<span class="string">&quot;半径是非法的&quot;</span>, radius&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> math.Pi * radius * radius, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error：半径，-3.00，半径是非法的</span><br><span class="line">半径是：-3.00</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	length, width := <span class="number">-6.7</span>, <span class="number">-9.1</span></span><br><span class="line">	area, err := rectArea(length, width)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">if</span> err, ok := err.(*areaError); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> err.legnthNegative() &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;error：长度，%.2f，小于零\n&quot;</span>, err.length)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err.widthNegative() &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;error：宽度，%.2f，小于零\n&quot;</span>, err.width)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;矩形的面积是：&quot;</span>, area)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> areaError <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg    <span class="type">string</span>  <span class="comment">//错误的描述</span></span><br><span class="line">	length <span class="type">float64</span> <span class="comment">//发生错误的时候，矩形的长度</span></span><br><span class="line">	width  <span class="type">float64</span> <span class="comment">//发生错误的时候，矩形的宽度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> legnthNegative() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.length &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> widthNegative() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.width &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectArea</span><span class="params">(length, width <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	msg := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">if</span> length &lt; <span class="number">0</span> &#123;</span><br><span class="line">		msg = <span class="string">&quot;长度小于零&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> width &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			msg = <span class="string">&quot;宽度小于零&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			msg += <span class="string">&quot;，宽度也小于零&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> msg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, &amp;areaError&#123;msg, length, width&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length * width, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">长度小于零，宽度也小于零</span><br><span class="line">error：长度，-6.70，小于零</span><br><span class="line">error：宽度，-9.10，小于零</span><br></pre></td></tr></table></figure>

<h2 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h2><p>Golang中引入两个内置函数panic和recover来触发和终止异常处理流程，同时引入关键字defer来延迟执行defer后面的函数。<br>一直等到包含defer语句的函数执行完毕时，延迟函数(defer后的函数）才会被执行，而不管包含defer语句的函数是通过return的正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。<br>当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生:函数停止执行，调用延迟执行函数等。如果一路在延迟函数中没有recover函数的调用，则会到达该协程的起点，该协程结束，然后终止其他所有协程,包括主协程(类似于C语言中的主线程,该协程ID为1)。<br><strong>panic</strong>:</p>
<ol>
<li><p>内建函数</p>
</li>
<li><p>假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表,按照defer的逆序执行</p>
</li>
<li><p>返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行，这里的defer有点类似 try-catch-finally中的finally</p>
</li>
<li><p>直到goroutine整个退出，并报告错误</p>
</li>
</ol>
<p><strong>recover</strong>:</p>
<ol>
<li>内建函数</li>
<li>用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为</li>
<li>一般的调用建议<br>a).在defer函数中，通过recover来终止一个gojroutine的panicking过程，从而恢复正常代码的执行<br>b).可以获取通过panic传递的error</li>
</ol>
<p><em><strong>简单来讲: go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理</strong></em>。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg := <span class="built_in">recover</span>(); msg != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(msg, <span class="string">&quot;程序恢复啦。。。&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	funA()</span><br><span class="line">	<span class="keyword">defer</span> myprint(<span class="string">&quot;defer main：3.....&quot;</span>)</span><br><span class="line">	funB()</span><br><span class="line">	<span class="keyword">defer</span> myprint(<span class="string">&quot;defer main：4.....&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;main..over。。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myprint</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funA</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是一个函数funA()....&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funB</span><span class="params">()</span></span> &#123; <span class="comment">//外围函数</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;我是函数funB()...&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> myprint(<span class="string">&quot;defer funB()：1.....&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;i:&quot;</span>, i)</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">			<span class="comment">//让程序中断</span></span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;funB函数，恐慌了&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="comment">//当外围函数的代码中发生了运行恐慌，只有其中所有的已经defer的函数全部都执行完毕后，该运行恐慌才会真正被扩展至调用处。</span></span><br><span class="line">	<span class="keyword">defer</span> myprint(<span class="string">&quot;defer funB()：2.....&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是一个函数funA()....</span><br><span class="line">我是函数funB()...</span><br><span class="line">i: 1</span><br><span class="line">i: 2</span><br><span class="line">i: 3</span><br><span class="line">i: 4</span><br><span class="line">i: 5</span><br><span class="line">defer funB()：1.....</span><br><span class="line">defer main：3.....</span><br><span class="line">funB函数，恐慌了 程序恢复啦。。。</span><br></pre></td></tr></table></figure>

<p>由于恐慌发生在循环内部，之后的语句将不会执行。然而，之前已经被<code>defer</code>关键字延迟执行的<code>myprint</code>函数仍然会执行。因此，”defer funB()：1…..”会被输出。funB函数的执行完毕后，恐慌会被传播到调用处，也就是<code>main</code>函数中的匿名函数。在这个匿名函数中，我们通过<code>recover</code>函数检测到了恐慌，所以会输出恐慌信息：”funB函数，恐慌了”，并打印”程序恢复啦。。。”。</p>
<p>错误和异常从Golang机制上讲，就是error和panic的区别。很多其他语言也一样,<br>比C++&#x2F;Java,没有error有errno，没有panic但有throw。<br>Golang错误和异常是可以互相转换的:<br>1．错误转异常，比如程序逻辑上尝试请求某个URL，最多尝试三次，尝试三次的过程中请求失败是错误，尝试完第三次还不成功的话，失败就被提升为异常了。<br>2．异常转错误，比如panic触发的异常被recover恢复后，将返回值中error类型的变量进行赋值，以便上层函数继续走错误处理流程。</p>
<p>什么情况下用错误表达，什么情况下用异常表达，就得有一套规则，否则很容易出现一切皆错误或一切皆异常的情况。<br>以下给出异常处理的作用域(场景)∶</p>
<blockquote>
<p>1．空指针引用<br>2．下标越界<br>3．除数为0<br>4．不应该出现的分支，比如default<br>5．输入不应该引起函数错误</p>
</blockquote>
<p>其他场景我们使用错误处理，这使得我们的函数接口很精炼。对于异常，我们可以选择在一个合适的上游去recover，并打印堆栈信息，使得部署后的程序不会终止。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>文件详细操作</title>
    <url>/2023/06/11/Go/14/</url>
    <content><![CDATA[<h1 id="File文件操作"><a href="#File文件操作" class="headerlink" title="File文件操作"></a>File文件操作</h1><p>首先，file类是在os包中的，封装了底层的文件描述符和相关信息，同时封装了Read和Write的实现</p>
<h2 id="FileInfo接口"><a href="#FileInfo接口" class="headerlink" title="FileInfo接口"></a>FileInfo接口</h2><p>FileInfo接口中定义了File信息相关的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="type">string</span>       <span class="comment">// base name of the file 文件名.扩展名 1.txt</span></span><br><span class="line">	Size() <span class="type">int64</span>        <span class="comment">// 文件大小，字节数 12540</span></span><br><span class="line">	Mode() FileMode     <span class="comment">// 文件权限 -rw-rw-rw-</span></span><br><span class="line">	ModTime() time.Time <span class="comment">// 修改时间 2018-04-13 16:30:53 +0800 CST</span></span><br><span class="line">	IsDir() <span class="type">bool</span>        <span class="comment">// 是否文件夹</span></span><br><span class="line">	Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 基础数据源接口(can return nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileInfo, err := os.Stat(<span class="string">&quot;main/1.md&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err :&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, fileInfo)</span><br><span class="line">	<span class="comment">//文件名</span></span><br><span class="line">	fmt.Println(fileInfo.Name())</span><br><span class="line">	<span class="comment">//文件大小</span></span><br><span class="line">	fmt.Println(fileInfo.Size())</span><br><span class="line">	<span class="comment">//是否是目录</span></span><br><span class="line">	fmt.Println(fileInfo.IsDir()) <span class="comment">//IsDirectory</span></span><br><span class="line">	<span class="comment">//修改时间</span></span><br><span class="line">	fmt.Println(fileInfo.ModTime())</span><br><span class="line">	<span class="comment">//权限</span></span><br><span class="line">	fmt.Println(fileInfo.Mode()) <span class="comment">//-rw-r--r--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*os.fileStat</span><br><span class="line">1.md</span><br><span class="line">47</span><br><span class="line">false</span><br><span class="line">2023-06-10 21:30:41.7576415 +0800 CST</span><br><span class="line">-rw-rw-rw-</span><br></pre></td></tr></table></figure>

<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>至于操作权限perm，除非创建文件时才需要指定，不需要创建新文件时可以将其设定为０。虽然go语言给perm权限设定了很多的常量，但是习惯上也可以直接使用数字，如0666(具体含义和Unix系统的一致)。</p>
<p>权限控制：</p>
<p>linux 下有2种文件权限表示方式，即“符号表示”和“八进制表示”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）符号表示方式:</span><br><span class="line"></span><br><span class="line">-      ---         ---        ---</span><br><span class="line"></span><br><span class="line">type   owner       group      others</span><br><span class="line">文件的权限是这样子分配的 读 写 可执行 分别对应的是 r w x 如果没有那一个权限，用 - 代替</span><br><span class="line">(-文件 d目录 |连接符号)</span><br><span class="line">例如：-rwxr-xr-x</span><br><span class="line"></span><br><span class="line">（2）八进制表示方式：	</span><br><span class="line">r ——&gt; 004</span><br><span class="line">w ——&gt; 002</span><br><span class="line">x ——&gt; 001</span><br><span class="line">- ——&gt; 000</span><br><span class="line"></span><br><span class="line">0755</span><br><span class="line">0777（owner，group，others都是可读可写可执行）</span><br><span class="line">0555</span><br><span class="line">0444</span><br><span class="line">0666</span><br></pre></td></tr></table></figure>

<h2 id="打开模式"><a href="#打开模式" class="headerlink" title="打开模式"></a>打开模式</h2><p>文件打开模式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="type">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line">    O_WRONLY <span class="type">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line">    O_RDWR   <span class="type">int</span> = syscall.O_RDWR   <span class="comment">// 读写模式打开文件</span></span><br><span class="line">    O_APPEND <span class="type">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line">    O_CREATE <span class="type">int</span> = syscall.O_CREAT  <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line">    O_EXCL   <span class="type">int</span> = syscall.O_EXCL   <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line">    O_SYNC   <span class="type">int</span> = syscall.O_SYNC   <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">    O_TRUNC  <span class="type">int</span> = syscall.O_TRUNC  <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="File操作"><a href="#File操作" class="headerlink" title="File操作"></a>File操作</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> File</span><br><span class="line"><span class="comment">//File代表一个打开的文件对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于I/O；对应的文件描述符具有O_RDWR模式。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (file *File, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">uintptr</span>, name <span class="type">string</span>)</span></span> *File</span><br><span class="line"><span class="comment">//NewFile使用给出的Unix文件描述符和名称创建一个文件。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span></span> (r *File, w *File, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Pipe返回一对关联的文件对象。从r的读取将返回写入w的数据。本函数会返回两个文件对象和可能的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Name() <span class="type">string</span></span><br><span class="line"><span class="comment">//Name方法返回（提供给Open/Create等方法的）文件名称。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Stat() (fi FileInfo, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Stat返回描述文件f的FileInfo类型值。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Fd() <span class="type">uintptr</span></span><br><span class="line"><span class="comment">//Fd返回与文件f对应的整数类型的Unix文件描述符。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Chdir() <span class="type">error</span></span><br><span class="line"><span class="comment">//Chdir将当前工作目录修改为f，f必须是一个目录。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Chmod(mode FileMode) <span class="type">error</span></span><br><span class="line"><span class="comment">//Chmod修改文件的模式。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Chown(uid, gid <span class="type">int</span>) <span class="type">error</span></span><br><span class="line"><span class="comment">//Chown修改文件的用户ID和组ID。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Close() <span class="type">error</span></span><br><span class="line"><span class="comment">//Close关闭文件f，使文件不能用于读写。它返回可能出现的错误。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.路径</span></span><br><span class="line">	fileName1 := <span class="string">&quot;C:\\GolandProjects\\GoProject1\\main\\1.md&quot;</span></span><br><span class="line">	fileName2 := <span class="string">&quot;main/1.md&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否是绝对路径</span></span><br><span class="line">	fmt.Println(filepath.IsAbs(fileName1)) <span class="comment">//true</span></span><br><span class="line">	fmt.Println(filepath.IsAbs(fileName2)) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//转化为绝对路径</span></span><br><span class="line">	<span class="comment">//fmt.Println(filepath.Abs(fileName1))</span></span><br><span class="line">	<span class="comment">//fmt.Println(filepath.Abs(fileName2)) // C:\GolandProjects\GoProject1\main\1.md &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.获取目录</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;获取父目录：&quot;, filepath.Join(fileName1, &quot;..&quot;))</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;获取父目录：&quot;, filepath.Dir(fileName1))</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;获取当前目录：&quot;, filepath.Join(fileName1, &quot;.&quot;))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.创建目录</span></span><br><span class="line">	err := os.Mkdir(<span class="string">&quot;main/app&quot;</span>, os.ModePerm) <span class="comment">//权限0777</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件夹创建成功。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//err := os.MkdirAll(&quot;main/a/b/c&quot;, os.ModePerm)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err:&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;多层文件夹创建成功&quot;)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.创建文件:Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）</span></span><br><span class="line">	<span class="comment">//file1, err := os.Create(fileName1)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err：&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(file1)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//file2, err := os.Create(fileName2) //创建相对路径的文件，是以当前工程为参照的</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err :&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(file2)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.打开文件：</span></span><br><span class="line">	<span class="comment">//file3, err := os.Open(fileName1) //只读的</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err:&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(file3)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		第一个参数：文件名称</span></span><br><span class="line"><span class="comment">		第二个参数：文件的打开方式</span></span><br><span class="line"><span class="comment">			const (</span></span><br><span class="line"><span class="comment">		// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.</span></span><br><span class="line"><span class="comment">			O_RDONLY int = syscall.O_RDONLY // open the file read-only.</span></span><br><span class="line"><span class="comment">			O_WRONLY int = syscall.O_WRONLY // open the file write-only.</span></span><br><span class="line"><span class="comment">			O_RDWR   int = syscall.O_RDWR   // open the file read-write.</span></span><br><span class="line"><span class="comment">			// The remaining values may be or&#x27;ed in to control behavior.</span></span><br><span class="line"><span class="comment">			O_APPEND int = syscall.O_APPEND // append data to the file when writing.</span></span><br><span class="line"><span class="comment">			O_CREATE int = syscall.O_CREAT  // create a new file if none exists.</span></span><br><span class="line"><span class="comment">			O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.</span></span><br><span class="line"><span class="comment">			O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.</span></span><br><span class="line"><span class="comment">			O_TRUNC  int = syscall.O_TRUNC  // truncate regular writable file when opened.</span></span><br><span class="line"><span class="comment">		)</span></span><br><span class="line"><span class="comment">		第三个参数：文件的权限：文件不存在创建文件，需要指定权限</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//file4, err := os.OpenFile(fileName1, os.O_RDONLY|os.O_WRONLY, os.ModePerm)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err:&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(file4)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//5关闭文件，</span></span><br><span class="line">	<span class="comment">//err := file4.Close()</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//6.删除文件或文件夹：</span></span><br><span class="line">	<span class="comment">//删除文件(该方法也可以删除空目录)</span></span><br><span class="line">	<span class="comment">//err := os.Remove(&quot;main/1.md&quot;)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err:&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;删除文件成功。。&quot;)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除目录</span></span><br><span class="line">	<span class="comment">//err := os.RemoveAll(&quot;main/a/b/c&quot;)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err:&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;删除目录成功。。</span></span><br></pre></td></tr></table></figure>

<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>文件的操作函数和方法的介绍：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Readdir(n <span class="type">int</span>) (fi []FileInfo, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Readdir读取目录f的内容，返回一个有n个成员的[]FileInfo，这些FileInfo是被Lstat返回的，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。如果n&gt;0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。如果n&lt;=0，Readdir函数返回目录中剩余所有文件对象的FileInfo构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的FileInfo构成的切片和该错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Readdirnames(n <span class="type">int</span>) (names []<span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Readdir读取目录f的内容，返回一个有n个成员的[]string，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。如果n&gt;0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。如果n&lt;=0，Readdir函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Truncate(size <span class="type">int64</span>) <span class="type">error</span></span><br><span class="line"><span class="comment">//Truncate改变文件的大小，它不会改变I/O的当前位置。 如果截断文件，多出的部分就会被丢弃。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Read方法从f中读取最多len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取0个字节且返回值err为io.EOF。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> ReadAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//ReadAt从指定的位置（相对于文件开始位置）读取len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。当n&lt;len(b)时，本方法总是会返回错误；如果是因为到达文件结尾，返回值err会是io.EOF。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Write向文件中写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> WriteString(s <span class="type">string</span>) (ret <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//WriteString类似Write，但接受一个字符串参数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> WriteAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//WriteAt在指定的位置（相对于文件开始位置）写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (ret <span class="type">int64</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Seek设置下一次读/写的位置。offset为相对偏移量，而whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Sync() (err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Sync递交文件的当前内容进行稳定的存储。一般来说，这表示将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="I-O操作"><a href="#I-O操作" class="headerlink" title="I&#x2F;O操作"></a>I&#x2F;O操作</h1><p>I&#x2F;O操作也叫输入输出操作。其中I是指Input，O是指Output，用于读或者写数据的，有些语言中也叫流操作，是指数据通信的通道。</p>
<p>Golang 标准库对 IO 的抽象非常精巧，各个组件可以随意组合，可以作为接口设计的典范。</p>
<h2 id="io包"><a href="#io包" class="headerlink" title="io包"></a>io包</h2><p>io包中提供I&#x2F;O原始操作的一系列接口。它主要包装了一些已有的实现，如 os 包中的那些，并将这些抽象成为实用性的功能和一些其他相关的接口。</p>
<p>由于这些接口和原始的操作以不同的实现包装了低级操作，客户不应假定它们对于并行执行是安全的。</p>
<p>在io包中最重要的是两个接口：Reader和Writer接口，首先来介绍这两个接口。</p>
<p>Reader接口的定义，Read()方法用于读取数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;&#x3D; n &lt;&#x3D; len(p)）以及任何遇到的错误。即使 Read 返回的 n &lt; len(p)，它也会在调用过程中使用 p的全部作为暂存空间。若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的东西，而不是等待更多。</p>
<p>当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或 EOF 情况，它就会返回读取的字节数。它会从相同的调用中返回（非nil的）错误或从随后的调用中返回错误（和 n &#x3D;&#x3D; 0）。这种一般情况的一个例子就是 Reader 在输入流结束时会返回一个非零的字节数，可能的返回不是 err &#x3D;&#x3D; EOF 就是 err &#x3D;&#x3D; nil。无论如何，下一个 Read 都应当返回 0, EOF。</p>
<p>调用者应当总在考虑到错误 err 前处理 n &gt; 0 的字节。这样做可以在读取一些字节，以及允许的 EOF 行为后正确地处理I&#x2F;O错误。</p>
<p>Read 的实现会阻止返回零字节的计数和一个 nil 错误，调用者应将这种情况视作空操作。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		读取数据：</span></span><br><span class="line"><span class="comment">			Reader接口：</span></span><br><span class="line"><span class="comment">				Read(p []byte)(n int, error)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//读取本地1.txt文件中的数据</span></span><br><span class="line">	<span class="comment">//step1：打开文件</span></span><br><span class="line">	fileName := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//step3：关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(file *os.File)</span></span> &#123;</span><br><span class="line">		err := file.Close()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//step2：读取数据</span></span><br><span class="line">	bs := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//第一次读取</span></span><br><span class="line"><span class="comment">		n, err := file.Read(bs)</span></span><br><span class="line"><span class="comment">		fmt.Println(err)        //&lt;nil&gt;</span></span><br><span class="line"><span class="comment">		fmt.Println(n)          //4</span></span><br><span class="line"><span class="comment">		fmt.Println(bs)         //[97 98 99 100]</span></span><br><span class="line"><span class="comment">		fmt.Println(string(bs)) //abcd</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//第二次读取</span></span><br><span class="line"><span class="comment">		n, err = file.Read(bs)</span></span><br><span class="line"><span class="comment">		fmt.Println(err)        //&lt;nil&gt;</span></span><br><span class="line"><span class="comment">		fmt.Println(n)          //4</span></span><br><span class="line"><span class="comment">		fmt.Println(bs)         //[101 102 103 104]</span></span><br><span class="line"><span class="comment">		fmt.Println(string(bs)) //efgh</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//第三次读取</span></span><br><span class="line"><span class="comment">		n, err = file.Read(bs)</span></span><br><span class="line"><span class="comment">		fmt.Println(err)        //&lt;nil&gt;</span></span><br><span class="line"><span class="comment">		fmt.Println(n)          //2</span></span><br><span class="line"><span class="comment">		fmt.Println(bs)         //[105 106 103 104]</span></span><br><span class="line"><span class="comment">		fmt.Println(string(bs)) //ijgh</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//第四次读取</span></span><br><span class="line"><span class="comment">		n, err = file.Read(bs)</span></span><br><span class="line"><span class="comment">		fmt.Println(err) //EOF，文件的末尾</span></span><br><span class="line"><span class="comment">		fmt.Println(n)   //0</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	n := <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err = file.Read(bs)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> || err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;读取到了文件的末尾，结束读取操作。。&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">		fmt.Println(<span class="type">string</span>(bs[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		abcd</span></span><br><span class="line"><span class="comment">		efgh</span></span><br><span class="line"><span class="comment">		ij</span></span><br><span class="line"><span class="comment">		读取到了文件的末尾，结束读取操作。。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Writer接口的定义，Write()方法用于写出数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">        Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数n（0 &lt;&#x3D; n &lt;&#x3D; len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的n &lt; len(p)，它就必须返回一个非nil的错误。Write 不能修改此切片的数据，即便它是临时的。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	fileName := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	<span class="comment">//step1：打开文件</span></span><br><span class="line">	<span class="comment">//step2：写出数据</span></span><br><span class="line">	<span class="comment">//step3：关闭文件</span></span><br><span class="line">	<span class="comment">//file, err := os.Open(fileName)</span></span><br><span class="line">	file, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写出数据</span></span><br><span class="line">	<span class="comment">//bs := []byte&#123;65, 66, 67, 68, 69, 70&#125; //A,B,C,D,E,F</span></span><br><span class="line">	<span class="comment">//bs := []byte&#123;97, 98, 99, 100&#125; //a,b,c,d</span></span><br><span class="line">	<span class="comment">//n,err := file.Write(bs)</span></span><br><span class="line">	<span class="comment">//n, err := file.Write(bs[:2])</span></span><br><span class="line">	<span class="comment">//fmt.Println(n)</span></span><br><span class="line">	<span class="comment">//HandleErr(err)</span></span><br><span class="line">	<span class="comment">//file.WriteString(&quot;\n&quot;)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//直接写出字符串</span></span><br><span class="line">	<span class="comment">//n, err := file.WriteString(&quot;HelloWorld&quot;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(n)</span></span><br><span class="line">	<span class="comment">//HandleErr(err)</span></span><br><span class="line">	<span class="comment">////</span></span><br><span class="line">	file.WriteString(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	n, err := file.Write([]<span class="type">byte</span>(<span class="string">&quot;today&quot;</span>))</span><br><span class="line">	fmt.Println(n)</span><br><span class="line">	HandleErr(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleErr</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Seeker接口的定义，封装了基本的 Seek 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">        Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Seeker 用来移动数据的读写指针<br>Seek 设置下一次读写操作的指针位置，每次的读写操作都是从指针位置开始的<br>whence 的含义：<br>    如果 whence 为 0：表示从数据的开头开始移动指针<br>    如果 whence 为 1：表示从数据的当前指针位置开始移动指针<br>    如果 whence 为 2：表示从数据的尾部开始移动指针<br>offset 是指针移动的偏移量<br>    返回移动后的指针位置和移动过程中遇到的任何错误</p>
</blockquote>
<p> ReaderFrom接口的定义，封装了基本的 ReadFrom 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderFrom <span class="keyword">interface</span> &#123;</span><br><span class="line">        ReadFrom(r Reader) (n <span class="type">int64</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReadFrom 从 r 中读取数据到对象的数据流中<br>    直到 r 返回 EOF 或 r 出现读取错误为止<br>    返回值 n 是读取的字节数<br>    返回值 err 就是 r 的返回值 err</p>
</blockquote>
<p>WriterTo接口的定义，封装了基本的 WriteTo 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterTo <span class="keyword">interface</span> &#123;</span><br><span class="line">        WriteTo(w Writer) (n <span class="type">int64</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WriterTo 将对象的数据流写入到 w 中<br>    直到对象的数据流全部写入完毕或遇到写入错误为止<br>    返回值 n 是写入的字节数<br>    返回值 err 就是 w 的返回值 err</p>
<p>定义ReaderAt接口，ReaderAt 接口封装了基本的 ReadAt 方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderAt <span class="keyword">interface</span> &#123;</span><br><span class="line">        ReadAt(p []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReadAt 从对象数据流的 off 处读出数据到 p 中<br>    忽略数据的读写指针，从数据的起始位置偏移 off 处开始读取<br>    如果对象的数据流只有部分可用，不足以填满 p<br>    则 ReadAt 将等待所有数据可用之后，继续向 p 中写入<br>    直到将 p 填满后再返回<br>    在这点上 ReadAt 要比 Read 更严格<br>    返回读取的字节数 n 和读取时遇到的错误<br>    如果 n &lt; len(p)，则需要返回一个 err 值来说明<br>    为什么没有将 p 填满（比如 EOF）<br>    如果 n &#x3D; len(p)，而且对象的数据没有全部读完，则<br>    err 将返回 nil<br>    如果 n &#x3D; len(p)，而且对象的数据刚好全部读完，则<br>    err 将返回 EOF 或者 nil（不确定）</p>
</blockquote>
<p>定义WriterAt接口，WriterAt 接口封装了基本的 WriteAt 方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterAt <span class="keyword">interface</span> &#123;</span><br><span class="line">        WriteAt(p []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>WriteAt 将 p 中的数据写入到对象数据流的 off 处<br>    忽略数据的读写指针，从数据的起始位置偏移 off 处开始写入<br>    返回写入的字节数和写入时遇到的错误<br>    如果 n &lt; len(p)，则必须返回一个 err 值来说明<br>    为什么没有将 p 完全写入</p>
</blockquote>
<h1 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h1><p>在io包中主要是操作流的一些方法，今天主要学习一下copy。就是把一个文件复制到另一个目录下。</p>
<p>它的原理就是通过程序，从源文件读取文件中的数据，在写出到目标文件里。</p>
<h2 id="io包下的Read-和Write"><a href="#io包下的Read-和Write" class="headerlink" title="io包下的Read()和Write()"></a>io包下的Read()和Write()</h2><p>我们可以通过io包下的Read()和Write()方法，边读边写，就能够实现文件的复制。这个方法是按块读取文件，块的大小也会影响到程序的性能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srcFile := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	destFile := <span class="string">&quot;main/2.txt&quot;</span></span><br><span class="line">	total, err := copyFile1(srcFile, destFile)</span><br><span class="line">	fmt.Println(total, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数的功能：实现文件的拷贝，返回值是拷贝的总数量(字节),错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile1</span><span class="params">(srcFile, destFile <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	file1, err := os.Open(srcFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	file2, err := os.OpenFile(destFile, os.O_WRONLY|os.O_CREATE, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file1.Close()</span><br><span class="line">	<span class="keyword">defer</span> file2.Close()</span><br><span class="line">	<span class="comment">// 拷贝数据</span></span><br><span class="line">	bs := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>, <span class="number">1024</span>)</span><br><span class="line">	n := <span class="number">-1</span> <span class="comment">//读取的数据量</span></span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err = file1.Read(bs)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF || n == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;拷贝完毕。。&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;报错了。。。&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> total, err</span><br><span class="line">		&#125;</span><br><span class="line">		total += n</span><br><span class="line">		file2.Write(bs[:n])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="io包下的Copy"><a href="#io包下的Copy" class="headerlink" title="io包下的Copy()"></a>io包下的Copy()</h2><p>我们也可以直接使用io包下的Copy()方法。</p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srcFile := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	destFile := <span class="string">&quot;main/2.txt&quot;</span></span><br><span class="line">	total, err := copyFile2(srcFile, destFile)</span><br><span class="line">	fmt.Println(total, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile2</span><span class="params">(srcFile, destFile <span class="type">string</span>)</span></span> (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	file1, err := os.Open(srcFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	file2, err := os.OpenFile(destFile, os.O_WRONLY|os.O_CREATE, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file1.Close()</span><br><span class="line">	<span class="keyword">defer</span> file2.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> io.Copy(file2, file1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在io包中，不止提供了Copy()方法，还有另外2个公开的copy方法：CopyN()，CopyBuffer()。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Copy（dst,src） <span class="comment">//为复制src 全部到 dst 中。</span></span><br><span class="line"></span><br><span class="line">CopyN(dst,src,n) <span class="comment">//为复制src 中 n 个字节到 dst。</span></span><br><span class="line"></span><br><span class="line">CopyBuffer（dst,src,buf）<span class="comment">//为指定一个buf缓存区，以这个大小完全复制。</span></span><br></pre></td></tr></table></figure>

<p>无论是哪个copy方法最终都是由copyBuffer（）这个私有方法实现的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyBuffer</span><span class="params">(dst Writer, src Reader, buf []<span class="type">byte</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// If the reader has a WriteTo method, use it to do the copy.</span></span><br><span class="line">	<span class="comment">// Avoids an allocation and a copy.</span></span><br><span class="line">	<span class="keyword">if</span> wt, ok := src.(WriterTo); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> wt.WriteTo(dst)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Similarly, if the writer has a ReadFrom method, use it to do the copy.</span></span><br><span class="line">	<span class="keyword">if</span> rt, ok := dst.(ReaderFrom); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> rt.ReadFrom(src)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> buf == <span class="literal">nil</span> &#123;</span><br><span class="line">		size := <span class="number">32</span> * <span class="number">1024</span></span><br><span class="line">		<span class="keyword">if</span> l, ok := src.(*LimitedReader); ok &amp;&amp; <span class="type">int64</span>(size) &gt; l.N &#123;</span><br><span class="line">			<span class="keyword">if</span> l.N &lt; <span class="number">1</span> &#123;</span><br><span class="line">				size = <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				size = <span class="type">int</span>(l.N)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		buf = <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		nr, er := src.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> nr &gt; <span class="number">0</span> &#123;</span><br><span class="line">			nw, ew := dst.Write(buf[<span class="number">0</span>:nr])</span><br><span class="line">			<span class="keyword">if</span> nw &gt; <span class="number">0</span> &#123;</span><br><span class="line">				written += <span class="type">int64</span>(nw)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ew != <span class="literal">nil</span> &#123;</span><br><span class="line">				err = ew</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> nr != nw &#123;</span><br><span class="line">				err = ErrShortWrite</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> er != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> er != EOF &#123;</span><br><span class="line">				err = er</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> written, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这部分代码可以看出，复制主要分为3种。</p>
<p> 1.如果被复制的Reader（src）会尝试能否断言成writerTo，如果可以则直接调用下面的writerTo方法</p>
<p> 2.如果 Writer（dst） 会尝试能否断言成ReadFrom ，如果可以则直接调用下面的readfrom方法</p>
<p> 3.如果都木有实现，则调用底层read实现复制。</p>
<p>其中，有这么一段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> buf == <span class="literal">nil</span> &#123;</span><br><span class="line">		size := <span class="number">32</span> * <span class="number">1024</span></span><br><span class="line">		<span class="keyword">if</span> l, ok := src.(*LimitedReader); ok &amp;&amp; <span class="type">int64</span>(size) &gt; l.N &#123;</span><br><span class="line">			<span class="keyword">if</span> l.N &lt; <span class="number">1</span> &#123;</span><br><span class="line">				size = <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				size = <span class="type">int</span>(l.N)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		buf = <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>这部分主要是实现了对Copy和CopyN的处理。通过上面的调用关系图，我们看出CopyN在调用后，会把Reader转成LimiteReader。</p>
<p>区别是如果Copy，直接建立一个缓存区默认大小为 32* 1024 的buf，如果是CopyN 会先判断 要复制的字节数，如果小于默认大小，会创建一个等于要复制字节数的buf。</p>
<h2 id="ioutil包"><a href="#ioutil包" class="headerlink" title="ioutil包"></a>ioutil包</h2><p>第三种方法是使用ioutil包中的 <code>ioutil.WriteFile()</code>和<code>ioutil.ReadFile()</code>，但由于使用一次性读取文件，再一次性写入文件的方式，所以该方法不适用于大文件，容易内存溢出。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srcFile := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	destFile := <span class="string">&quot;main/2.txt&quot;</span></span><br><span class="line">	total, err := copyFile3(srcFile, destFile)</span><br><span class="line">	fmt.Println(total, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile3</span><span class="params">(srcFile, destFile <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	input, err := ioutil.ReadFile(srcFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = ioutil.WriteFile(destFile, input, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;操作失败：&quot;</span>, destFile)</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(input), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前ReadFile和WriteFile已弃用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我们来测试一下这3种拷贝需要花费时间，拷贝的文件都是一样的一个mp4文件(400M)。</p>
<p>第一种：io包下Read()和Write()直接读写：我们自己创建读取数据的切片的大小，直接影响性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拷贝完毕。。</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">401386819</span><br><span class="line"></span><br><span class="line">real    0m7.911s</span><br><span class="line">user    0m2.900s</span><br><span class="line">sys     0m7.661s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种：io包下Copy()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">401386819</span><br><span class="line"></span><br><span class="line">real    0m1.594s</span><br><span class="line">user    0m0.533s</span><br><span class="line">sys     0m1.136s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三种：ioutil包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">401386819</span><br><span class="line"></span><br><span class="line">real    0m1.515s</span><br><span class="line">user    0m0.339s</span><br><span class="line">sys     0m0.625s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这3种方式，在性能上，不管是还是io.Copy()还是ioutil包，性能都是还不错的。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>断点续传与bufio包</title>
    <url>/2023/06/12/Go/15/</url>
    <content><![CDATA[<h1 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h1><h2 id="Seeker接口"><a href="#Seeker接口" class="headerlink" title="Seeker接口"></a>Seeker接口</h2><p>Seeker是包装基本Seek方法的接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">        Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>seek(offset,whence),设置指针光标的位置，随机读写文件：</p>
<p>​	第一个参数：偏移量<br>​	第二个参数：如何设置			</p>
<p>​				0：seekStart表示相对于文件开始，<br>​				1：seekCurrent表示相对于当前偏移量，<br>​				2：seek end表示相对于结束。</p>
<p>1.txt内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABCDEFababHelloWorldHelloWorld</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	fileName := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(fileName, os.O_RDWR, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">//读写</span></span><br><span class="line">	bs := []<span class="type">byte</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">	file.Read(bs)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bs))</span><br><span class="line"></span><br><span class="line">	file.Seek(<span class="number">4</span>, io.SeekStart)</span><br><span class="line">	file.Read(bs)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bs))</span><br><span class="line"></span><br><span class="line">	file.Seek(<span class="number">2</span>, <span class="number">0</span>) <span class="comment">//SeekStart</span></span><br><span class="line">	file.Read(bs)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bs))</span><br><span class="line"></span><br><span class="line">	file.Seek(<span class="number">3</span>, io.SeekCurrent)</span><br><span class="line">	file.Read(bs)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bs))</span><br><span class="line"></span><br><span class="line">	file.Seek(<span class="number">0</span>, io.SeekEnd)</span><br><span class="line">	file.WriteString(<span class="string">&quot;ABC&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">E</span><br><span class="line">C</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<h2 id="断点续传-1"><a href="#断点续传-1" class="headerlink" title="断点续传"></a>断点续传</h2><p>首先思考几个问题<br>Q1：如果你要传的文件，比较大，那么是否有方法可以缩短耗时？<br>Q2：如果在文件传递过程中，程序因各种原因被迫中断了，那么下次再重启时，文件是否还需要重头开始？<br>Q3：传递文件的时候，支持暂停和恢复么？即使这两个操作分布在程序进程被杀前后。</p>
<p>通过断点续传可以实现，不同的语言有不同的实现方式。我们看看Go语言中，通过Seek()方法如何实现：</p>
<p>先说一下思路：想实现断点续传，主要就是记住上一次已经传递了多少数据，那我们可以创建一个临时文件，记录已经传递的数据量，当恢复传递的时候，先从临时文件中读取上次已经传递的数据量，然后通过Seek()方法，设置到该读和该写的位置，再继续传递数据。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	srcFile := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	destFile := srcFile[strings.LastIndex(srcFile, <span class="string">&quot;/&quot;</span>)+<span class="number">1</span>:]</span><br><span class="line">	tempFile := destFile + <span class="string">&quot;temp.txt&quot;</span></span><br><span class="line"></span><br><span class="line">	file1, err := os.Open(srcFile)</span><br><span class="line">	file2, err := os.OpenFile(destFile, os.O_CREATE|os.O_WRONLY, os.ModePerm)</span><br><span class="line">	file3, err := os.OpenFile(tempFile, os.O_CREATE|os.O_RDWR, os.ModePerm)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file1.Close()</span><br><span class="line">	<span class="keyword">defer</span> file2.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//step1：先读取临时文件中的数据，再seek</span></span><br><span class="line">	file3.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">	bs := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">	n1, err := file3.Read(bs)</span><br><span class="line">	countStr := <span class="type">string</span>(bs[:n1])</span><br><span class="line">	count, err := strconv.ParseInt(countStr, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//step2：设置读，写的位置：</span></span><br><span class="line">	file1.Seek(count, io.SeekStart)</span><br><span class="line">	file2.Seek(count, io.SeekStart)</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>, <span class="number">1024</span>)</span><br><span class="line">	n2 := <span class="number">-1</span>            <span class="comment">//读取的数据量</span></span><br><span class="line">	n3 := <span class="number">-1</span>            <span class="comment">//写出的数据量</span></span><br><span class="line">	total := <span class="type">int</span>(count) <span class="comment">//读取的总量</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//step3：复制文件</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n2, err = file1.Read(data)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF || n2 == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;文件复制完毕。。&quot;</span>)</span><br><span class="line">			file3.Close()</span><br><span class="line">			os.Remove(tempFile)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		n3, err = file2.Write(data[:n2])</span><br><span class="line">		total += n3</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将复制的总量，存储到临时文件中</span></span><br><span class="line">		file3.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">		file3.WriteString(strconv.Itoa(total))</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;total:%d\n&quot;</span>, total)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//假装断电</span></span><br><span class="line">		<span class="comment">//if total &gt; 8000&#123;</span></span><br><span class="line">		<span class="comment">//	panic(&quot;假装断电了。。。&quot;)</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleErr</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="bufio包"><a href="#bufio包" class="headerlink" title="bufio包"></a>bufio包</h1><h2 id="bufio包原理"><a href="#bufio包原理" class="headerlink" title="bufio包原理"></a>bufio包原理</h2><p>bufio 是通过缓冲来提高效率。</p>
<p>io操作本身的效率并不低，低的是频繁的访问本地磁盘的文件。所以bufio就提供了缓冲区(分配一块内存)，读和写都先在缓冲区中，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。</p>
<p>简单的说就是，把文件读取进缓冲（内存）之后再读取的时候就可以避免文件系统的io 从而提高速度。同理，在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。看完以上解释有人可能会表示困惑了，直接把 内容-&gt;文件 和 内容-&gt;缓冲-&gt;文件相比， 缓冲区好像没有起到作用嘛。其实缓冲区的设计是为了存储多次的写入，最后一口气把缓冲区内容写入文件。</p>
<p>bufio 封装了io.Reader或io.Writer接口对象，并创建另一个也实现了该接口的对象。</p>
<p>io.Reader或io.Writer 接口实现read() 和 write() 方法，对于实现这个接口的对象都是可以使用这两个方法的。</p>
<h3 id="Reader对象"><a href="#Reader对象" class="headerlink" title="Reader对象"></a>Reader对象</h3><p>bufio.Reader 是bufio中对io.Reader 的封装</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reader implements buffering for an io.Reader object.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf          []<span class="type">byte</span></span><br><span class="line">	rd           io.Reader <span class="comment">// reader provided by the client</span></span><br><span class="line">	r, w         <span class="type">int</span>       <span class="comment">// buf read and write positions</span></span><br><span class="line">	err          <span class="type">error</span></span><br><span class="line">	lastByte     <span class="type">int</span> <span class="comment">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class="line">	lastRuneSize <span class="type">int</span> <span class="comment">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bufio.Read(p []byte) 相当于读取大小len(p)的内容，思路如下：</p>
<ol>
<li>当缓存区有内容的时，将缓存区内容全部填入p并清空缓存区</li>
<li>当缓存区没有内容的时候且len(p)&gt;len(buf),即要读取的内容比缓存区还要大，直接去文件读取即可</li>
<li>当缓存区没有内容的时候且len(p)&lt;len(buf),即要读取的内容比缓存区小，缓存区从文件读取内容充满缓存区，并将p填满（此时缓存区有剩余内容）</li>
<li>以后再次读取时缓存区有内容，将缓存区内容全部填入p并清空缓存区（此时和情况1一样）</li>
</ol>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(file *os.File)</span></span> &#123;</span><br><span class="line">		err := file.Close()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建Reader对象</span></span><br><span class="line">	<span class="comment">//b1 := bufio.NewReader(file)</span></span><br><span class="line">	<span class="comment">//1.Read()，高效读取</span></span><br><span class="line">	<span class="comment">//p := make([]byte, 1024)</span></span><br><span class="line">	<span class="comment">//n1, err := b1.Read(p)</span></span><br><span class="line">	<span class="comment">//fmt.Println(n1)</span></span><br><span class="line">	<span class="comment">//fmt.Println(string(p[:n1]))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.ReadLine()</span></span><br><span class="line">	<span class="comment">//data, flag, err := b1.ReadLine()</span></span><br><span class="line">	<span class="comment">//fmt.Println(flag)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(data)</span></span><br><span class="line">	<span class="comment">//fmt.Println(string(data))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.ReadString()</span></span><br><span class="line">	<span class="comment">//s1, err := b1.ReadString(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(s1)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//s1, err = b1.ReadString(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(s1)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//s1, err = b1.ReadString(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(s1)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//for &#123;</span></span><br><span class="line">	<span class="comment">//	s1, err := b1.ReadString(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//	if err == io.EOF &#123;</span></span><br><span class="line">	<span class="comment">//		fmt.Println(&quot;读取完毕。。&quot;)</span></span><br><span class="line">	<span class="comment">//		break</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(s1)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.ReadBytes()</span></span><br><span class="line">	<span class="comment">//data, err := b1.ReadBytes(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(string(data))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Scanner,输入的内容如果有空格，只能接收到空格前面的数据</span></span><br><span class="line">	<span class="comment">//s2 := &quot;&quot;</span></span><br><span class="line">	<span class="comment">//fmt.Scanln(&amp;s2)</span></span><br><span class="line">	<span class="comment">//fmt.Println(s2)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//可以接收到空格后面的数据</span></span><br><span class="line">	b2 := bufio.NewReader(os.Stdin)</span><br><span class="line">	s2, _ := b2.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Writer对象"><a href="#Writer对象" class="headerlink" title="Writer对象"></a>Writer对象</h3><p>bufio.Writer 是bufio中对io.Writer 的封装</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Writer implements buffering for an io.Writer object.</span></span><br><span class="line"><span class="comment">// If an error occurs writing to a Writer, no more data will be</span></span><br><span class="line"><span class="comment">// accepted and all subsequent writes, and Flush, will return the error.</span></span><br><span class="line"><span class="comment">// After all data has been written, the client should call the</span></span><br><span class="line"><span class="comment">// Flush method to guarantee all data has been forwarded to</span></span><br><span class="line"><span class="comment">// the underlying io.Writer.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> &#123;</span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">	buf []<span class="type">byte</span></span><br><span class="line">	n   <span class="type">int</span></span><br><span class="line">	wr  io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bufio.Write(p []byte) 的思路如下</p>
<ol>
<li>判断buf中可用容量是否可以放下 p</li>
<li>如果能放下，直接把p拼接到buf后面，即把内容放到缓冲区</li>
<li>如果缓冲区的可用容量不足以放下，且此时缓冲区是空的，直接把p写入文件即可</li>
<li>如果缓冲区的可用容量不足以放下，且此时缓冲区有内容，则用p把缓冲区填满，把缓冲区所有内容写入文件，并清空缓冲区</li>
<li>判断p的剩余内容大小能否放到缓冲区，如果能放下（此时和步骤1情况一样）则把内容放到缓冲区</li>
<li>如果p的剩余内容依旧大于缓冲区，（注意此时缓冲区是空的，情况和步骤3一样）则把p的剩余内容直接写入文件</li>
</ol>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;main/2.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(file *os.File)</span></span> &#123;</span><br><span class="line">		err := file.Close()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(file)</span><br><span class="line"></span><br><span class="line">	w1 := bufio.NewWriter(file)</span><br><span class="line">	<span class="comment">//n, err := w1.WriteString(&quot;helloworld&quot;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(n)</span></span><br><span class="line">	<span class="comment">//err = w1.Flush()</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125; //刷新缓冲区</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		_, err2 := w1.WriteString(fmt.Sprintf(<span class="string">&quot;%d:hello&quot;</span>, i))</span><br><span class="line">		<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err = w1.Flush()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bufio包-1"><a href="#bufio包-1" class="headerlink" title="bufio包"></a>bufio包</h2><p>bufio包实现了有缓冲的I&#x2F;O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I&#x2F;O的帮助函数的对象。</p>
<h3 id="bufio-Reader"><a href="#bufio-Reader" class="headerlink" title="bufio.Reader"></a>bufio.Reader</h3><p>bufio.Reader 实现了如下接口：<br>    io.Reader<br>    io.WriterTo<br>    io.ByteScanner<br>    io.RuneScanner</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewReaderSize 将 rd 封装成一个带缓存的 bufio.Reader 对象，</span></span><br><span class="line"><span class="comment">// 缓存大小由 size 指定（如果小于 16 则会被设置为 16）。</span></span><br><span class="line"><span class="comment">// 如果 rd 的基类型就是有足够缓存的 bufio.Reader 类型，则直接将</span></span><br><span class="line"><span class="comment">// rd 转换为基类型返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="type">int</span>)</span></span> *Reader</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewReader 相当于 NewReaderSize(rd, 4096)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *Reader</span><br><span class="line"></span><br><span class="line"><span class="comment">// Peek 返回缓存的一个切片，该切片引用缓存中前 n 个字节的数据，</span></span><br><span class="line"><span class="comment">// 该操作不会将数据读出，只是引用，引用的数据在下一次读取操作之</span></span><br><span class="line"><span class="comment">// 前是有效的。如果切片长度小于 n，则返回一个错误信息说明原因。</span></span><br><span class="line"><span class="comment">// 如果 n 大于缓存的总大小，则返回 ErrBufferFull。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Peek(n <span class="type">int</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read 从 b 中读出数据到 p 中，返回读出的字节数和遇到的错误。</span></span><br><span class="line"><span class="comment">// 如果缓存不为空，则只能读出缓存中的数据，不会从底层 io.Reader</span></span><br><span class="line"><span class="comment">// 中提取数据，如果缓存为空，则：</span></span><br><span class="line"><span class="comment">// 1、len(p) &gt;= 缓存大小，则跳过缓存，直接从底层 io.Reader 中读</span></span><br><span class="line"><span class="comment">// 出到 p 中。</span></span><br><span class="line"><span class="comment">// 2、len(p) &lt; 缓存大小，则先将数据从底层 io.Reader 中读取到缓存</span></span><br><span class="line"><span class="comment">// 中，再从缓存读取到 p 中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Buffered 返回缓存中未读取的数据的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Buffered() <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadBytes 功能同 ReadSlice，只不过返回的是缓存的拷贝。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadBytes(delim <span class="type">byte</span>) (line []<span class="type">byte</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadString 功能同 ReadBytes，只不过返回的是字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadString(delim <span class="type">byte</span>) (line <span class="type">string</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<h3 id="bufio-Writer"><a href="#bufio-Writer" class="headerlink" title="bufio.Writer"></a>bufio.Writer</h3><p>bufio.Writer 实现了如下接口：<br>    io.Writer<br>    io.ReaderFrom<br>    io.ByteWriter</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewWriterSize 将 wr 封装成一个带缓存的 bufio.Writer 对象，</span></span><br><span class="line"><span class="comment">// 缓存大小由 size 指定（如果小于 4096 则会被设置为 4096）。</span></span><br><span class="line"><span class="comment">// 如果 wr 的基类型就是有足够缓存的 bufio.Writer 类型，则直接将</span></span><br><span class="line"><span class="comment">// wr 转换为基类型返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(wr io.Writer, size <span class="type">int</span>)</span></span> *Writer</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewWriter 相当于 NewWriterSize(wr, 4096)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(wr io.Writer)</span></span> *Writer</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteString 功能同 Write，只不过写入的是字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> WriteString(s <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteRune 向 b 写入 r 的 UTF-8 编码，返回 r 的编码长度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> WriteRune(r <span class="type">rune</span>) (size <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush 将缓存中的数据提交到底层的 io.Writer 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Flush() <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Available 返回缓存中未使用的空间的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Available() <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Buffered 返回缓存中未提交的数据的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Buffered() <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 将 b 的底层 Writer 重新指定为 w，同时丢弃缓存中的所有数据，复位</span></span><br><span class="line"><span class="comment">// 所有标记和错误信息。相当于创建了一个新的 bufio.Writer。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Reset(w io.Writer)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>ioutil包与并发编程初识</title>
    <url>/2023/06/13/Go/16/</url>
    <content><![CDATA[<h1 id="ioutil包"><a href="#ioutil包" class="headerlink" title="ioutil包"></a>ioutil包</h1><p>除了io包可以读写数据，Go语言中还提供了一个辅助的工具包就是ioutil，里面的方法虽然不多，但是都还蛮好用的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;io/ioutil&quot;</span></span><br></pre></td></tr></table></figure>

<p>该包的介绍只有一句话：Package ioutil implements some I&#x2F;O utility functions。</p>
<h2 id="ioutil包的方法"><a href="#ioutil包的方法" class="headerlink" title="ioutil包的方法"></a>ioutil包的方法</h2><p>下面我们来看一下里面的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discard 是一个 io.Writer 接口，调用它的 Write 方法将不做任何事情</span></span><br><span class="line"><span class="comment">// 并且始终成功返回。</span></span><br><span class="line"><span class="keyword">var</span> Discard io.Writer = devNull(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadAll 读取 r 中的所有数据，返回读取的数据和遇到的错误。</span></span><br><span class="line"><span class="comment">// 如果读取成功，则 err 返回 nil，而不是 EOF，因为 ReadAll 定义为读取</span></span><br><span class="line"><span class="comment">// 所有数据，所以不会把 EOF 当做错误处理。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadFile 读取文件中的所有数据，返回读取的数据和遇到的错误。</span></span><br><span class="line"><span class="comment">// 如果读取成功，则 err 返回 nil，而不是 EOF</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteFile 向文件中写入数据，写入前会清空文件。</span></span><br><span class="line"><span class="comment">// 如果文件不存在，则会以指定的权限创建该文件。</span></span><br><span class="line"><span class="comment">// 返回遇到的错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="type">string</span>, data []<span class="type">byte</span>, perm os.FileMode)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadDir 读取指定目录中的所有目录和文件（不包括子目录）。</span></span><br><span class="line"><span class="comment">// 返回读取到的文件信息列表和遇到的错误，列表是经过排序的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="type">string</span>)</span></span> ([]os.FileInfo, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NopCloser 将 r 包装为一个 ReadCloser 类型，但 Close 方法不做任何事情。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NopCloser</span><span class="params">(r io.Reader)</span></span> io.ReadCloser</span><br><span class="line"></span><br><span class="line"><span class="comment">// TempFile 在 dir 目录中创建一个以 prefix 为前缀的临时文件，并将其以读</span></span><br><span class="line"><span class="comment">// 写模式打开。返回创建的文件对象和遇到的错误。</span></span><br><span class="line"><span class="comment">// 如果 dir 为空，则在默认的临时目录中创建文件（参见 os.TempDir），多次</span></span><br><span class="line"><span class="comment">// 调用会创建不同的临时文件，调用者可以通过 f.Name() 获取文件的完整路径。</span></span><br><span class="line"><span class="comment">// 调用本函数所创建的临时文件，应该由调用者自己删除。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, prefix <span class="type">string</span>)</span></span> (f *os.File, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TempDir 功能同 TempFile，只不过创建的是目录，返回目录的完整路径。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, prefix <span class="type">string</span>)</span></span> (name <span class="type">string</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		ioutil包：</span></span><br><span class="line"><span class="comment">			ReadFile()</span></span><br><span class="line"><span class="comment">			WriteFile()</span></span><br><span class="line"><span class="comment">			ReadDir()</span></span><br><span class="line"><span class="comment">			..</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.读取文件中的所有的数据</span></span><br><span class="line">	<span class="comment">//fileName := &quot;main/1.txt&quot;</span></span><br><span class="line">	<span class="comment">//data, err := ioutil.ReadFile(fileName)</span></span><br><span class="line">	<span class="comment">////fmt.Println(err)</span></span><br><span class="line">	<span class="comment">////fmt.Println(data)</span></span><br><span class="line">	<span class="comment">//fmt.Println(string(data))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.写出数据(覆盖写)</span></span><br><span class="line">	<span class="comment">//fileName := &quot;main/1.txt&quot;</span></span><br><span class="line">	<span class="comment">//s1 := &quot;床前明月光，地上鞋三双&quot;</span></span><br><span class="line">	<span class="comment">//err := ioutil.WriteFile(fileName, []byte(s1), os.ModePerm)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.ReadAll()</span></span><br><span class="line">	<span class="comment">//s2 := &quot;王二狗和李小花是两个好朋友，Ruby就是我，也是他们的朋友&quot;</span></span><br><span class="line">	<span class="comment">//r1 := strings.NewReader(s2)</span></span><br><span class="line">	<span class="comment">//data, err := ioutil.ReadAll(r1)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(data)</span></span><br><span class="line">	<span class="comment">//fmt.Println(string(data))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.ReadDir()，读取一个目录下的子内容：子文件和子目录，但是只能读取一层</span></span><br><span class="line">	<span class="comment">//dirName := &quot;main&quot;</span></span><br><span class="line">	<span class="comment">//fileInfos, err := ioutil.ReadDir(dirName)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(len(fileInfos))</span></span><br><span class="line">	<span class="comment">//for i := 0; i &lt; len(fileInfos); i++ &#123;</span></span><br><span class="line">	<span class="comment">//	//fmt.Printf(&quot;%T\n&quot;, fileInfos[i])</span></span><br><span class="line">	<span class="comment">//	fmt.Printf(&quot;第 %d 个：名称：%s，是否是目录：%t\n&quot;, i, fileInfos[i].Name(), fileInfos[i].IsDir())</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.临时目录和临时文件</span></span><br><span class="line">	dir, err := ioutil.TempDir(<span class="string">&quot;./&quot;</span>, <span class="string">&quot;Test&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> os.Remove(dir)</span><br><span class="line">	fmt.Println(dir)</span><br><span class="line"></span><br><span class="line">	file, err := ioutil.TempFile(dir, <span class="string">&quot;Test&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> os.Remove(file.Name())</span><br><span class="line">	fmt.Println(file.Name())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h2><p>因为文件夹下还有子文件夹，而ioutil包的ReadDir()只能获取一层目录，所以我们需要自己去设计算法来实现，最容易实现的思路就是使用递归。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dirName := <span class="string">&quot;C:\\Users\\19393\\Desktop\\操作系统&quot;</span></span><br><span class="line">	readDir(dirName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readDir</span><span class="params">(dirName <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fileInfos, err := ioutil.ReadDir(dirName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(fileInfos); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> fileInfos[i].IsDir() &#123;</span><br><span class="line">			dirName = dirName + <span class="string">&quot;\\&quot;</span> + fileInfos[i].Name()</span><br><span class="line">			readDir(dirName)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;文件名:%s\n&quot;</span>, fileInfos[i].Name())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>该包目前已弃用</strong></em></p>
<h1 id="并发性Concurrency"><a href="#并发性Concurrency" class="headerlink" title="并发性Concurrency"></a>并发性Concurrency</h1><h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p>
<p>CPU的速度太快啦。。。</p>
<h2 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h2><p>Go是并发语言，而不是并行语言。在讨论如何在Go中进行并发处理之前，我们首先必须了解什么是并发，以及它与并行性有什么不同。(Go is a concurrent language and not a parallel one. )</p>
<p><strong>并发性Concurrency是同时处理许多事情的能力。</strong></p>
<p>举个例子，假设一个人在晨跑。在晨跑时，他的鞋带松了。现在这个人停止跑步，系鞋带，然后又开始跑步。这是一个典型的并发性示例。这个人能够同时处理跑步和系鞋带，这是一个人能够同时处理很多事情。</p>
<p>什么是并行性parallelism，它与并发concurrency有什么不同?<br>并行就是同时做很多事情。这听起来可能与并发类似，但实际上是不同的。</p>
<p>让我们用同样的慢跑例子更好地理解它。在这种情况下，我们假设这个人正在慢跑，并且使用它的手机听音乐。在这种情况下，一个人一边慢跑一边听音乐，那就是他同时在做很多事情。这就是所谓的并行性(parallelism)。</p>
<p>并发性和并行性——<em>一种技术上的观点</em>。<br>假设我们正在编写一个web浏览器。web浏览器有各种组件。其中两个是web页面呈现区域和下载文件从internet下载的下载器。假设我们以这样的方式构建了浏览器的代码，这样每个组件都可以独立地执行。当这个浏览器运行在单个核处理器中时，处理器将在浏览器的两个组件之间进行上下文切换。它可能会下载一个文件一段时间，然后它可能会切换到呈现用户请求的网页的html。这就是所谓的并发性。并发进程从不同的时间点开始，它们的执行周期重叠。在这种情况下，下载和呈现从不同的时间点开始，它们的执行重叠。</p>
<p>假设同一浏览器运行在多核处理器上。在这种情况下，文件下载组件和HTML呈现组件可能同时在不同的内核中运行。这就是所谓的<strong>并行性</strong>。</p>
<p>并行性Parallelism不会总是导致更快的执行时间。这是因为并行运行的组件可能需要相互通信。例如，在我们的浏览器中，当文件下载完成时，应该将其传递给用户，比如使用弹出窗口。这种通信发生在负责下载的组件和负责呈现用户界面的组件之间。这种通信开销在并发concurrent 系统中很低。当组件在多个内核中并行concurrent 运行时，这种通信开销很高。因此，并行程序并不总是导致更快的执行时间!</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/t.png"></p>
<h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是一个程序在一个数据集中的一次动态执行过程，可以简单理解为“正在执行的程序”，它是CPU资源分配和调度的独立单位。<br>进程一般由程序、数据集、进程控制块三部分组成。我们编写的程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 <strong>进程的局限是创建、撤销和切换的开销比较大。</strong></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是在进程之后发展出来的概念。 线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成。一个进程可以包含多个线程。<br>线程的优点是减小了程序并发执行时的开销，提高了操作系统的并发性能，缺点是线程没有自己的系统资源，只拥有在运行时必不可少的资源，但同一进程的各线程可以共享进程所拥有的系统资源，如果把进程比作一个车间，那么线程就好比是车间里面的工人。不过对于某些独占性资源存在锁机制，处理不当可能会产生“死锁”。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程是一种用户态的轻量级线程，又称微线程，英文名Coroutine，协程的调度完全由用户控制。人们通常将协程和子程序（函数）比较着理解。<br>子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。 </p>
<p><strong>与传统的系统级线程和进程相比，协程的最大优势在于其”轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过1万的。这也是协程也叫轻量级线程的原因。</strong></p>
<blockquote>
<p>协程与多线程相比，其优势体现在：协程的执行效率极高。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
</blockquote>
<p><strong>Go语言对于并发的实现是靠协程，Goroutine</strong></p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>runtime包与临界资源</title>
    <url>/2023/07/06/Go/18/</url>
    <content><![CDATA[<h1 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h1><p>尽管 Go 编译器产生的是本地可执行代码，这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 runtime 包中找到）当中。这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。</p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p><strong><code>runtime</code> 调度器是个非常有用的东西，关于 <code>runtime</code> 包几个方法:</strong></p>
<ul>
<li><p><strong>NumCPU</strong>：返回当前系统的 <code>CPU</code> 核数量</p>
</li>
<li><p><strong>GOMAXPROCS</strong>：设置最大的可同时使用的 <code>CPU</code> 核数</p>
<p>通过runtime.GOMAXPROCS函数，应用程序何以在运行期间设置运行时系统中得P最大数量。但这会引起“Stop the World”。所以，应在应用程序最早的调用。并且最好是在运行Go程序之前设置好操作程序的环境变量GOMAXPROCS，而不是在程序中调用runtime.GOMAXPROCS函数。</p>
<p>无论我们传递给函数的整数值是什么值，运行时系统的P最大值总会在1~256之间。</p>
</li>
</ul>
<blockquote>
<p>go1.8后，默认让程序运行在多个核上,可以不用设置了<br>go1.8前，还是要设置一下，可以更高效的利益cpu</p>
</blockquote>
<ul>
<li><p><strong>Gosched</strong>：让当前线程让出 <code>cpu</code> 以让其它线程运行,它不会挂起当前线程，因此当前线程未来会继续执行</p>
<p>这个函数的作用是让当前 <code>goroutine</code> 让出 <code>CPU</code>，当一个 <code>goroutine</code> 发生阻塞，<code>Go</code> 会自动地把与该 <code>goroutine</code> 处于同一系统线程的其他 <code>goroutine</code> 转移到另一个系统线程上去，以使这些 <code>goroutine</code> 不阻塞。</p>
</li>
<li><p><strong>Goexit</strong>：退出当前 <code>goroutine</code>(但是<code>defer</code>语句会照常执行)</p>
</li>
<li><p><strong>NumGoroutine</strong>：返回正在执行和排队的任务总数</p>
<p>runtime.NumGoroutine函数在被调用后，会返回系统中的处于特定状态的Goroutine的数量。这里的特指是指Grunnable\Gruning\Gsyscall\Gwaition。处于这些状态的Groutine即被看做是活跃的或者说正在被调度。</p>
<p>注意：垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器。</p>
</li>
<li><p><strong>GOOS</strong>：目标操作系统</p>
</li>
<li><p><strong>runtime.GC</strong>:会让运行时系统进行一次强制性的垃圾收集</p>
<ol>
<li>强制的垃圾回收：不管怎样，都要进行的垃圾回收。</li>
<li>非强制的垃圾回收：只会在一定条件下进行的垃圾回收（即运行时，系统自上次垃圾回收之后新申请的堆内存的单元（也成为单元增量）达到指定的数值）。</li>
</ol>
</li>
<li><p><strong>GOROOT</strong> :获取goroot目录</p>
</li>
<li><p><strong>GOOS</strong> : 查看目标操作系统<br>很多时候，我们会根据平台的不同实现不同的操作，就而已用GOOS了：</p>
</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><ol>
<li>获取goroot和os：</li>
</ol>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取goroot目录：</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;GOROOT--&gt;&quot;</span>,runtime.GOROOT())</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取操作系统</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;os/platform--&gt;&quot;</span>,runtime.GOOS)  </span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOROOT--&gt; C:\Users\19393\sdk\go1.20.4</span><br><span class="line">os/platform--&gt; windows</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取CPU数量，和设置CPU数量：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.获取逻辑cpu的数量</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;逻辑CPU的核数：&quot;</span>,runtime.NumCPU())	<span class="comment">//16</span></span><br><span class="line">	<span class="comment">//2.设置go程序执行的最大的：[1,256]</span></span><br><span class="line">	n := runtime.GOMAXPROCS(runtime.NumCPU())	</span><br><span class="line">	fmt.Println(n)	<span class="comment">//16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Gosched()：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;goroutine&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//让出时间片，先让别的协议执行，它执行完，再回来执行此协程</span></span><br><span class="line">		runtime.Gosched()</span><br><span class="line">		fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goroutine</span><br><span class="line">goroutine</span><br><span class="line">goroutine</span><br><span class="line">goroutine</span><br><span class="line">goroutine</span><br><span class="line">main</span><br><span class="line">main</span><br><span class="line">main</span><br><span class="line">main</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Goexit的使用（终止协程）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建新建的协程</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;goroutine开始&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//调用了别的函数</span></span><br><span class="line">		fun()</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">&quot;goroutine结束&quot;</span>)</span><br><span class="line">	&#125;() <span class="comment">//别忘了()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//睡一会儿，不让主协程结束</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return //终止此函数</span></span><br><span class="line">	runtime.Goexit() <span class="comment">//终止所在的协程</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;fun函数&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goroutine开始</span><br><span class="line">defer</span><br></pre></td></tr></table></figure>

<h1 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h1><p><strong>临界资源:</strong> 指并发环境中多个进程&#x2F;线程&#x2F;协程共享的资源。</p>
<p>但是在并发编程中对临界资源的处理不当， 往往会导致数据不一致的问题。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		a = <span class="number">2</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;子goroutine&quot;</span>,a)</span><br><span class="line">	&#125;()</span><br><span class="line">	a = <span class="number">3</span></span><br><span class="line">	time.Sleep(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine&quot;</span>,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子goroutine 2</span><br><span class="line">main goroutine 2</span><br></pre></td></tr></table></figure>

<p>能够发现一处被多个goroutine共享的数据a。</p>
<h2 id="临界资源安全问题"><a href="#临界资源安全问题" class="headerlink" title="临界资源安全问题"></a>临界资源安全问题</h2><p>并发本身并不复杂，但是因为有了资源竞争的问题，就使得我们开发出好的并发程序变得复杂起来，因为会引起很多莫名其妙的问题。</p>
<p>如果多个goroutine在访问同一个数据资源的时候，其中一个线程修改了数据，那么这个数值就被修改了，对于其他的goroutine来讲，这个数值可能是不对的。</p>
<p>举个例子，我们通过并发来实现火车站售票这个程序。一共有10张票，4个售票口同时出售。</p>
<p>我们先来看一下示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> ticket = <span class="number">10</span> <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		4个goroutine，模拟4个售票口，4个子程序操作同一个共享数据。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口1&quot;</span>) <span class="comment">// g1,10</span></span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口2&quot;</span>) <span class="comment">// g2,10</span></span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口3&quot;</span>) <span class="comment">//g3,10</span></span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口4&quot;</span>) <span class="comment">//g4,10</span></span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saleTickets</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">//ticket=1</span></span><br><span class="line">		<span class="keyword">if</span> ticket &gt; <span class="number">0</span> &#123; <span class="comment">//g1,g3,g2,g4</span></span><br><span class="line">			<span class="comment">//睡眠</span></span><br><span class="line">			time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">			<span class="comment">// g1 ,g3, g2,g4</span></span><br><span class="line">			fmt.Println(name, <span class="string">&quot;售出：&quot;</span>, ticket) </span><br><span class="line">			ticket--                         </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;售罄，没有票了。。&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">售票口4 售出： 10</span><br><span class="line">售票口1 售出： 10</span><br><span class="line">售票口3 售出： 10</span><br><span class="line">售票口2 售出： 10</span><br><span class="line">售票口1 售出： 6</span><br><span class="line">售票口1 售出： 5</span><br><span class="line">售票口2 售出： 4</span><br><span class="line">售票口4 售出： 3</span><br><span class="line">售票口4 售出： 2</span><br><span class="line">售票口1 售出： 1</span><br><span class="line">售票口1 售罄，没有票了。。</span><br><span class="line">售票口3 售出： 0</span><br><span class="line">售票口3 售罄，没有票了。。</span><br><span class="line">售票口4 售出： -1</span><br><span class="line">售票口4 售罄，没有票了。。</span><br><span class="line">售票口2 售出： -2</span><br><span class="line">售票口2 售罄，没有票了。。</span><br></pre></td></tr></table></figure>

<p>我们为了更好的观察临界资源问题，每个goroutine先睡眠一个随机数，然后再售票，我们发现程序的运行结果，还可以卖出编号为负数的票。</p>
<p><strong>分析：</strong></p>
<p>我们的卖票逻辑是先判断票数的编号是否为负数，如果大于0，然后我们就进行卖票，只不过在卖票钱先睡眠，然后再卖，假如说此时已经卖票到只剩最后1张了，某一个goroutine持有了CPU的时间片，那么它再片段是否有票的时候，条件是成立的，所以它可以卖票编号为1的最后一张票。但是因为它在卖之前，先睡眠了，那么其他的goroutine就会持有CPU的时间片，而此时这张票还没有被卖出，那么第二个goroutine再判断是否有票的时候，条件也是成立的，那么它可以卖出这张票，然而它也进入了睡眠。其他的第三个第四个goroutine都是这样的逻辑，当某个goroutine醒来的时候，不会再判断是否有票，而是直接售出，这样就卖出最后一张票了，然而其他的goroutine醒来的时候，就会陆续卖出了第0张，-1张，-2张。</p>
<p>这就是临界资源的不安全问题。某一个goroutine在访问某个数据资源的时候，按照数值，已经判断好了条件，然后又被其他的goroutine抢占了资源，并修改了数值，等这个goroutine再继续访问这个数据的时候，数值已经不对了。</p>
<h2 id="临界资源安全问题的解决"><a href="#临界资源安全问题的解决" class="headerlink" title="临界资源安全问题的解决"></a>临界资源安全问题的解决</h2><p>要想解决临界资源安全的问题，很多编程语言的解决方案都是同步。通过上锁的方式，某一时间段，只能允许一个goroutine来访问这个共享数据，当前goroutine访问完毕，解锁后，其他的goroutine才能来访问。</p>
<p>我们可以借助于sync包下的锁操作。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> ticket = <span class="number">10</span> <span class="comment">// 10张票</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> matex sync.Mutex <span class="comment">// 创建锁头</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	4个goroutine，模拟4个售票口，4个子程序操作同一个共享数据。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	wg.Add(<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口1&quot;</span>) <span class="comment">// g1,100</span></span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口2&quot;</span>) <span class="comment">// g2,100</span></span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口3&quot;</span>) <span class="comment">//g3,100</span></span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口4&quot;</span>) <span class="comment">//g4,100</span></span><br><span class="line">	wg.Wait()              <span class="comment">// main要等待。。。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//time.Sleep(5*time.Second)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saleTickets</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="comment">//for i:=1;i&lt;=100;i++&#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(name,&quot;售出：&quot;,i)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">//ticket=1</span></span><br><span class="line">		matex.Lock()</span><br><span class="line">		<span class="keyword">if</span> ticket &gt; <span class="number">0</span> &#123; <span class="comment">//g1,g3,g2,g4</span></span><br><span class="line">			<span class="comment">//睡眠</span></span><br><span class="line">			time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">			<span class="comment">// g1 ,g3, g2,g4</span></span><br><span class="line">			fmt.Println(name, <span class="string">&quot;售出：&quot;</span>, ticket) <span class="comment">// 1 , 0, -1 , -2</span></span><br><span class="line">			ticket--                         <span class="comment">//0 , -1 ,-2 , -3</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			matex.Unlock() <span class="comment">//解锁</span></span><br><span class="line">			fmt.Println(name, <span class="string">&quot;售罄，没有票了。。&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		matex.Unlock() <span class="comment">//解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">售票口1 售出： 10</span><br><span class="line">售票口1 售出： 9</span><br><span class="line">售票口4 售出： 8</span><br><span class="line">售票口3 售出： 7</span><br><span class="line">售票口2 售出： 6</span><br><span class="line">售票口1 售出： 5</span><br><span class="line">售票口4 售出： 4</span><br><span class="line">售票口3 售出： 3</span><br><span class="line">售票口2 售出： 2</span><br><span class="line">售票口1 售出： 1</span><br><span class="line">售票口4 售罄，没有票了。。</span><br><span class="line">售票口1 售罄，没有票了。。</span><br><span class="line">售票口3 售罄，没有票了。。</span><br><span class="line">售票口2 售罄，没有票了。。</span><br></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在Go的并发编程中有一句很经典的话：<strong>不要以共享内存的方式去通信，而要以通信的方式去共享内存。</strong></p>
<p>在Go语言中并不鼓励用锁保护共享状态的方式在不同的Goroutine中分享信息(以共享内存的方式去通信)。而是鼓励通过<strong>channel</strong>将共享状态或共享状态的变化在各个Goroutine之间传递（以通信的方式去共享内存），这样同样能像用锁一样保证在同一的时间只有一个Goroutine访问共享状态。</p>
<p>当然，在主流的编程语言中为了保证多线程之间共享数据安全性和一致性，都会提供一套基本的同步工具集，如锁，条件变量，原子操作等等。Go语言标准库也毫不意外的提供了这些同步机制，使用方式也和其他语言也差不多。</p>
]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>go的基本介绍</title>
    <url>/2023/06/01/Go/2/</url>
    <content><![CDATA[<h2 id="Go的特点"><a href="#Go的特点" class="headerlink" title="Go的特点"></a>Go的特点</h2><ul>
<li>高性能，该并发</li>
<li>部署简单，学习简单</li>
<li>丰富的标准库</li>
<li>完善的工具链</li>
<li>静态链接</li>
<li>快速编译</li>
<li>跨平台</li>
<li>垃圾回收</li>
</ul>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（静态编译）。Go语言提供的工具都通过一个单独的命令<code>go</code>调用，<code>go</code>命令有一系列子命令。最简单的一个子命令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件。要想运行上述程序，命令行进入其目录，执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run helloworld.go</span></span><br></pre></td></tr></table></figure>

<p>Go语言原生支持Unicode，它可以处理全世界任何语言的文本。</p>
<p>如果不只是一次性实验，并且希望能够编译这个程序，保存编译结果以备将来之用。可以用build子命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build helloworld.go</span></span><br></pre></td></tr></table></figure>

<p>这个命令生成一个名为<code>helloworld</code>的<em><strong>可执行的二进制文件（Windows系统下生成的可执行文件是helloworld.exe），之后可以随时运行它</strong></em>（在Windows系统下在命令行直接输入helloworld.exe命令运行），不需任何处理（因为静态编译，所以不用担心在系统库更新的时候冲突，<em><strong>python也有相关的库<code>pyinstaller</code>将程序转为可执行文件</strong></em>）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./helloworld</span></span><br><span class="line">hello world </span><br></pre></td></tr></table></figure>

<h2 id="Go的简介-挺有意思的，建议看看"><a href="#Go的简介-挺有意思的，建议看看" class="headerlink" title="Go的简介(挺有意思的，建议看看)"></a>Go的简介(挺有意思的，建议看看)</h2><p>​		Go语言的代码通过<em><strong>包</strong></em>（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。每个源文件都以一条<code>package</code>声明语句开始，上述例子里就是<code>package main</code>，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。</p>
<p>​		Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如<code>fmt</code>包，就含有格式化输出、接收输入的函数。<code>Println</code>是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。</p>
<p>​		<strong><code>	main</code>包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在<code>main</code>里的<code>main</code> <em>函数</em> 也很特殊，它是整个程序执行时的入口（C系语言类似）</strong>。<code>main</code>函数所做的事情就是程序做的。当然了，<code>main</code>函数一般调用其它包里的函数完成很多工作（例如：<code>fmt.Println</code>）。</p>
<ul>
<li><p>必须告诉编译器源文件需要哪些包，这就是跟随在<code>package</code>声明后面的<code>import</code>声明扮演的角色。hello world例子只用到了一个包，大多数程序需要导入多个包。</p>
</li>
<li><p>必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。<em><strong>这项严格要求避免了程序开发过程中引入未使用的包</strong></em>（<em><strong>Go语言编译过程没有警告信息</strong></em>）。</p>
<p>  <code>import</code>声明必须跟在文件的<code>package</code>声明之后。随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字<code>func</code>、<code>var</code>、<code>const</code>、<code>type</code>定义）。这些内容的声明顺序并不重要（最好按照规范要求自己）。上述例子的程序已经尽可能短了，只声明了一个函数，其中只调用了一个其他函数。为了节省篇幅，有些时候示例程序会省略<code>package</code>和<code>import</code>声明，但是，这些声明在源代码里有，并且必须得有才能编译。</p>
<p>  一个函数的声明由<code>func</code>关键字、函数名、参数列表、返回值列表（上述例子里的<code>main</code>函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。</p>
<p>  Go语言<em><strong>不需要在语句或者声明的末尾添加分号</strong></em>，除非一行上有多条语句。实际上，编译器<em><strong>会主动把特定符号后的换行符转换为分号</strong></em>，因此<em><strong>换行符添加的位置会影响Go代码的正确解析</strong></em>（比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字<code>break</code>、<code>continue</code>、<code>fallthrough</code>或<code>return</code>中的一个、运算符和分隔符<code>++</code>、<code>--</code>、<code>)</code>、<code>]</code>或<code>&#125;</code>中的一个）。举个例子，函数的左括号<code>&#123;</code>必须和<code>func</code>函数声明在同一行上，且位于末尾，不能独占一行，而在表达式<code>x + y</code>中，可在<code>+</code>后换行，不能在<code>+</code>前换行（以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编译错误）</p>
</li>
</ul>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a><strong>go clean</strong></h3><p>go clean 命令是用来移除当前源码包里面编译生成的文件，这些文件包括</p>
<ul>
<li>_obj&#x2F; 旧的object目录，由Makefiles遗留</li>
<li>_test&#x2F; 旧的test目录，由Makefiles遗留</li>
<li>_testmain.go 旧的gotest文件，由Makefiles遗留</li>
<li>test.out 旧的test记录，由Makefiles遗留</li>
<li>build.out 旧的test记录，由Makefiles遗留</li>
<li>*.[568ao] object文件，由Makefiles遗留</li>
<li>DIR(.exe) 由 go build 产生</li>
<li>DIR.test(.exe) 由 go test -c 产生</li>
<li>MAINFILE(.exe) 由 go build MAINFILE.go产生</li>
</ul>
<h3 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a><strong>go test</strong></h3><p>go test 命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag</p>
<h3 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a><strong>go doc</strong></h3><p>go doc 命令其实就是一个很强大的文档工具。</p>
<p>如何查看相应package的文档呢？ 例如builtin包，那么执行go doc builtin；如果是http包，那么执行go doc net&#x2F;http；查看某一个包里面的函数，那么执行go doc fmt Printf；也可以查看相应的代码，执行go doc -src fmt Printf；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看net/http包</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go doc net/http</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看time包</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go doc time</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个包里的指定函数</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go doc <span class="built_in">fmt</span> Printf</span></span><br></pre></td></tr></table></figure>

<p>通过命令在命令行执行 go doc -http&#x3D;:端口号，比如godoc -http&#x3D;:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被限制访问的用户来说是一个不错的选择。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">godoc -http=:9527</span></span><br></pre></td></tr></table></figure>

<hr>
<p>go fix 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1</p>
<p>go version 查看go当前的版本</p>
<p>go env 查看当前go的环境变量</p>
<p>go list 列出当前全部安装的package</p>
<h2 id="gofmt和goimports的配置"><a href="#gofmt和goimports的配置" class="headerlink" title="gofmt和goimports的配置"></a><code>gofmt</code>和<code>goimports</code>的配置</h2><p>​		<em><strong>Go语言在代码格式上采取了很强硬的态度</strong></em>。<code>gofmt</code>工具把代码格式化为标准格式（这个格式化工具没有任何可以调整代码格式的参数，Go语言就是这么任性），并且<code>go</code>工具中的<code>fmt</code>子命令会对指定包，否则默认为当前目录中所有.go源文件应用<code>gofmt</code>命令。我们应该养成格式化自己的代码的习惯。以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执导致了Go语言的<a href="https://baike.baidu.com/item/Tiobe/2830870?fr=aladdin"><code>TIOBE</code></a>排名较低，争议的话题较少。更重要的是，这样可以做多种自动源码转换，如果放任Go语言代码格式，这些转换就不大可能了。</p>
<p>很多文本编辑器都可以配置为保存文件时自动执行<code>gofmt</code>，这样源代码总会被恰当地格式化，<code>gofmt</code>包含在标准的分发包中。还有个相关的工具，<code>goimports</code>，可以根据代码需要，自动地添加或删除<code>import</code>声明。这个工具并没有包含在标准的分发包中，可以用下面的命令在在<code>goland</code>中在任意一个项目的终端执行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get -v golang.org/x/tools/cmd/goimports</span><br></pre></td></tr></table></figure>


<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df0d744ab4bc4f0f9204e4f4d0eb0a90~tplv-k3u1fbpfcp-watermark.image" alt="image-20230513220732135.png"></p>
<p>进入<code>GOPATH</code>(Go语言安装目录)，执行以下命令安装<code>goimports</code>,没有加版本号会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> install golang.org/x/tools/cmd/goimports@latest</span><br></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc5eae7c83743338f84058f08c881ca~tplv-k3u1fbpfcp-watermark.image" alt="image-20230513221248033.png"></p>
<p>至此，我们可以在 <code>GOPATH/bin </code>目录下看到 <code>goimports.exe</code></p>
<p>然后在<code>goland</code>的设置中点击工具&gt;File Watcher</p>
<p>添加<code>gofmt</code>和<code>goimports</code></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2632d630f887491b9370e03f4b43b1ba~tplv-k3u1fbpfcp-watermark.image" alt="image-20230513221553805.png"></p>
<p><code>goimports.exe</code>在<code>GOPATH/bin </code>目录下,其实<code>goland</code>能够自动找到它</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc409d417dc34f17a299b7e35691e9d6~tplv-k3u1fbpfcp-watermark.image" alt="image-20230513221658244.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c31c5998d814a3f9e30de7b2b7c91af~tplv-k3u1fbpfcp-watermark.image" alt="image-20230513221724453.png"></p>
<p>点击确定，<code>gofmt</code>和<code>goimports</code>配置成功</p>
<p>原文链接：<a href="https://juejin.cn/post/7232689996821495865">Go的基本介绍（附gofmt和goimports配置）|青训营笔记 - 掘金 (juejin.cn)</a></p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>select语句与CSP模型</title>
    <url>/2023/07/07/Go/21/</url>
    <content><![CDATA[<h1 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h1><p>select 是 Go 中的一个控制结构。select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</p>
<h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><p>select语句的语法结构和switch语句很相似，也有case语句和default语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>每个case都必须是一个通信</p>
</li>
<li><p>所有channel表达式都会被求值</p>
</li>
<li><p>所有被发送的表达式都会被求值</p>
</li>
<li><p>如果有多个case都可以运行，select会随机公平地选出一个执行。其他不会执行。 </p>
</li>
<li><p>否则：</p>
<p>如果有default子句，则执行该语句。</p>
<p>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</p>
</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		ch2 &lt;- <span class="number">200</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		ch1 &lt;- <span class="number">100</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> num1 := &lt;-ch1:</span><br><span class="line">		fmt.Println(<span class="string">&quot;ch1中取数据。。&quot;</span>, num1)</span><br><span class="line">	<span class="keyword">case</span> num2, ok := &lt;-ch2:</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;ch2中取数据。。&quot;</span>, num2)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;ch2通道已经关闭。。&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：可能执行第一个case，打印100，也可能执行第二个case，打印200。(多运行几次，结果就不同了)</p>
<p>select语句结合time包的和chan相关函数，示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch1 &lt;- <span class="number">100</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">		fmt.Println(<span class="string">&quot;case1可以执行。。&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch2:</span><br><span class="line">		fmt.Println(<span class="string">&quot;case2可以执行。。&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">		fmt.Println(<span class="string">&quot;case3执行。。timeout。。&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;执行了default。。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：case1可以执行。。或者执行了default。。</p>
<h1 id="Go语言的CSP模型"><a href="#Go语言的CSP模型" class="headerlink" title="Go语言的CSP模型"></a>Go语言的CSP模型</h1><p>go语言的最大两个亮点，一个是goroutine，一个就是chan了。二者合体的典型应用CSP，基本就是大家认可的并行开发神器，简化了并行程序的开发难度，我们来看一下CSP。 </p>
<h2 id="CSP是什么"><a href="#CSP是什么" class="headerlink" title="CSP是什么"></a>CSP是什么</h2><p>CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，是一个很强大的并发数据模型，是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。</p>
<p>严格来说，CSP 是一门形式语言（类似于 ℷ calculus），用于描述并发系统中的互动模式，也因此成为一众面向并发的编程语言的理论源头，并衍生出了 Occam&#x2F;Limbo&#x2F;Golang…</p>
<p>而具体到编程语言，如 Golang，其实只用到了 CSP 的很小一部分，即理论中的 Process&#x2F;Channel（对应到语言中的 goroutine&#x2F;channel）：这两个并发原语之间没有从属关系， Process 可以订阅任意个 Channel，Channel 也并不关心是哪个 Process 在利用它进行通信；Process 围绕 Channel 进行读写，形成一套有序阻塞和可预测的并发模型。</p>
<h2 id="Golang-CSP"><a href="#Golang-CSP" class="headerlink" title="Golang CSP"></a>Golang CSP</h2><p>与主流语言通过共享内存来进行并发控制方式不同，Go 语言采用了 CSP 模式。这是一种用于描述两个独立的并发实体通过共享的通讯 Channel（管道）进行通信的并发模型。</p>
<p>Golang 就是借用CSP模型的一些概念为之实现并发进行理论支持，其实从实际上出发，go语言并没有完全实现CSP模型的所有理论，仅仅是借用了 process和channel这两个概念。process是在go语言上的表现就是 goroutine 是实际并发执行的实体，每个实体之间是通过channel通讯来实现数据共享。</p>
<p>Go语言的CSP模型是由协程Goroutine与通道Channel实现：</p>
<ul>
<li>Go协程goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。</li>
<li>通道channel: 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。</li>
</ul>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Goroutine 和 channel 是 Go 语言并发编程的两大基石。Goroutine 用于执行并发任务，channel 用于 goroutine 之间的同步、通信。</p>
<p>Channel 在 gouroutine 间架起了一条管道，在管道里传输数据，实现 gouroutine 间的通信；由于它是线程安全的，所以用起来非常方便；channel 还提供 “先进先出” 的特性；它还能影响 goroutine 的阻塞和唤醒。</p>
<p>相信大家一定见过一句话：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>不要通过共享内存来通信，而要通过通信来实现内存共享。</p>
<p>这就是 Go 的并发哲学，它依赖 CSP 模型，基于 channel 实现。</p>
<p><strong>channel 实现 CSP</strong></p>
<p>Channel 是 Go 语言中一个非常重要的类型，是 Go 里的第一对象。通过 channel，Go 实现了通过通信来实现内存共享。Channel 是在多个 goroutine 之间传递数据和同步的重要手段。</p>
<p>使用原子函数、读写锁可以保证资源的共享访问安全，但使用 channel 更优雅。</p>
<p>channel 字面意义是 “通道”，类似于 Linux 中的管道。声明 channel 的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span> T <span class="comment">// 声明一个双向通道</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- T <span class="comment">// 声明一个只能用于发送的通道</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> T <span class="comment">// 声明一个只能用于接收的通道</span></span><br></pre></td></tr></table></figure>

<p>单向通道的声明，用 <code>&lt;-</code> 来表示，它指明通道的方向。你只要明白，代码的书写顺序是从左到右就马上能掌握通道的方向是怎样的。</p>
<p>因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。</p>
<p>两者有一些差别：非缓冲型 channel 无法缓冲元素，对它的操作一定顺序是 “发送 -&gt; 接收 -&gt; 发送 -&gt; 接收 -&gt; ……”，如果想连续向一个非缓冲 chan 发送 2 个元素，并且没有接收的话，第一次一定会被阻塞；对于缓冲型 channel 的操作，则要 “宽松” 一些，毕竟是带了 “缓冲” 光环。</p>
<p>对 chan 的发送和接收操作都会在编译期间转换成为底层的发送接收函数。</p>
<p>Channel 分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作 “同步模式”，带缓冲的则称为 “异步模式”。</p>
<p>同步模式下，发送方和接收方要同步就绪，只有在两者都 ready 的情况下，数据才能在两者间传输（后面会看到，实际上就是内存拷贝）。否则，任意一方先行进行发送或接收操作，都会被挂起，等待另一方的出现才能被唤醒。</p>
<p>异步模式下，在缓冲槽可用的情况下（有剩余容量），发送和接收操作都可以顺利进行。否则，操作的一方（如写入）同样会被挂起，直到出现相反操作（如接收）才会被唤醒。</p>
<p>小结一下：同步模式下，必须要使发送方和接收方配对，操作才会成功，否则会被阻塞；异步模式下，缓冲槽要有剩余容量，操作才会成功，否则也会被阻塞。</p>
<p>简单来说，CSP 模型由并发执行的实体（线程或者进程或者协程）所组成，实体之间通过发送消息进行通信，<br>这里发送消息时使用的就是通道，或者叫 channel。</p>
<p>CSP 模型的关键是关注 channel，而不关注发送消息的实体。Go 语言实现了 CSP 部分理论，goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。</p>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>Goroutine 是实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点：</p>
<ul>
<li>用户空间 避免了内核态和用户态的切换导致的成本</li>
<li>可以由语言和框架层进行调度</li>
<li>更小的栈空间允许创建大量的实例</li>
</ul>
<p>可以看到第二条 用户空间线程的调度不是由操作系统来完成的，像在java 1.3中使用的greenthread的是由JVM统一调度的(后java已经改为内核线程)，还有在ruby中的fiber(半协程) 是需要在重新中自己进行调度的，而goroutine是在golang层面提供了调度器，并且对网络IO库进行了封装，屏蔽了复杂的细节，对外提供统一的语法关键字支持，简化了并发程序编写的成本。</p>
<h2 id="Goroutine-调度器"><a href="#Goroutine-调度器" class="headerlink" title="Goroutine 调度器"></a>Goroutine 调度器</h2><p>Go并发调度: G-P-M模型</p>
<p>在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。goroutine机制实现了M : N的线程模型，goroutine机制是协程（coroutine）的一种实现，golang内置的调度器，可以让多核CPU中每个CPU执行一个协程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/goroutine22.png"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Golang 的 channel 将 goroutine 隔离开，并发编程的时候可以将注意力放在 channel 上。在一定程度上，这个和消息队列的解耦功能还是挺像的。如果大家感兴趣，还是来看看 channel 的源码吧，对于更深入地理解 channel 还是挺有用的。</p>
<p>Go 通过 channel 实现 CSP 通信模型，主要用于 goroutine 之间的消息传递和事件通知。</p>
<p>有了 channel 和 goroutine 之后，Go 的并发编程变得异常容易和安全，得以让程序员把注意力留到业务上去，实现开发效率的提升。</p>
<p>要知道，技术并不是最重要的，它只是实现业务的工具。一门高效的开发语言让你把节省下来的时间，留着去做更有意义的事情，比如写写文章。</p>
]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>反射详解</title>
    <url>/2023/07/07/Go/22/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>先看官方Doc中Rob Pike给出的关于反射的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reflection in computing is the ability of a program to examine its own structure, particularly through types; it’s a form of metaprogramming. It’s also a great source of confusion.</span><br><span class="line">(在计算机领域，反射是一种让程序——主要是通过类型——理解其自身结构的一种能力。它是元编程的组成之一，同时它也是一大引人困惑的难题。)</span><br></pre></td></tr></table></figure>

<p>维基百科中的定义：</p>
<blockquote>
<p>在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</p>
</blockquote>
<p>不同语言的反射模型不尽相同，有些语言还不支持反射。《Go 语言圣经》中是这样定义反射的：</p>
<blockquote>
<p>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。</p>
</blockquote>
<p>为什么要用反射</p>
<p>需要反射的 2 个常见场景：</p>
<ol>
<li>有时你需要编写一个函数，但是并不知道传给你的参数类型是什么，可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。这时反射就会用的上了。</li>
<li>有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。</li>
</ol>
<p>但是对于反射，还是有几点不太建议使用反射的理由：</p>
<ol>
<li>与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。</li>
<li>Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。</li>
<li>反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。</li>
</ol>
<h2 id="相关基础"><a href="#相关基础" class="headerlink" title="相关基础"></a>相关基础</h2><p>反射是如何实现的？我们以前学习过 interface，它是 Go 语言实现抽象的一个非常强大的工具。当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，反射就是通过接口的类型信息实现的，反射建立在类型的基础上。</p>
<p>Go 语言在 reflect 包里定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。在进行更加详细的了解之前，我们需要重新温习一下Go语言相关的一些特性，所谓温故知新，从这些特性中了解其反射机制是如何使用的。</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>go语言是静态类型语言。</td>
<td>编译时类型已经确定，比如对已基本数据类型的再定义后的类型，反射时候需要确认返回的是何种类型。</td>
</tr>
<tr>
<td>空接口interface{}</td>
<td>go的反射机制是要通过接口来进行的，而类似于Java的Object的空接口可以和任何类型进行交互，因此对基本数据类型等的反射也直接利用了这一特点</td>
</tr>
<tr>
<td>Go语言的类型：</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>变量包括（type, value）两部分</p>
<blockquote>
<p>理解这一点就知道为什么nil !&#x3D; nil了</p>
</blockquote>
</li>
<li><p>type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型</p>
</li>
<li><p>类型断言能否成功，取决于变量的concrete type，而不是static type。因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer。</p>
</li>
</ul>
<p>Go语言的反射就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p>
<p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(value, <span class="keyword">type</span>)</span><br></pre></td></tr></table></figure>

<p>value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。</p>
<p>例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure>

<p>接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure>

<p>接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。</p>
<p>interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。</p>
<p>所以我们要理解两个基本概念 Type 和 Value，它们也是 Go语言包中 reflect 空间里最重要的两个类型。</p>
<h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h2><p>我们一般用到的包是reflect包。</p>
<h3 id="TypeOf和ValueOf"><a href="#TypeOf和ValueOf" class="headerlink" title="TypeOf和ValueOf"></a>TypeOf和ValueOf</h3><p>既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ValueOf returns a new Value initialized to the concrete value</span></span><br><span class="line"><span class="comment">// stored in the interface i.  ValueOf(nil) returns the zero </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span></span><br><span class="line"><span class="comment">// If i is a nil interface value, TypeOf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回<span class="literal">nil</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value。</p>
<p>首先需要把它转化成reflect对象(reflect.Type或者reflect.Value，根据不同的情况调用不同的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := reflect.TypeOf(i) <span class="comment">//得到类型的元数据,通过t我们能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i) <span class="comment">//得到实际的值，通过v我们获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//反射操作：通过反射，可以获取一个接口类型变量的 类型和数值</span></span><br><span class="line">	<span class="keyword">var</span> x = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;type:&quot;</span>, reflect.TypeOf(x))   <span class="comment">//type: float64</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;value:&quot;</span>, reflect.ValueOf(x)) <span class="comment">//value: 3.4</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//根据反射的值，来获取对应的类型和数值</span></span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	fmt.Println(<span class="string">&quot;kind is float64: &quot;</span>, v.Kind() == reflect.Float64)</span><br><span class="line">	fmt.Println(<span class="string">&quot;type : &quot;</span>, v.Type())</span><br><span class="line">	fmt.Println(<span class="string">&quot;value : &quot;</span>, v.Float())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: float64</span><br><span class="line">value: 3.14</span><br><span class="line">-------------------</span><br><span class="line">kind is float64:  true</span><br><span class="line">type :  float64</span><br><span class="line">value :  3.14</span><br></pre></td></tr></table></figure>

<p>说明</p>
<ol>
<li>reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型</li>
<li>reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值</li>
<li>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种</li>
</ol>
<p>Type 和 Value 都包含了大量的方法，其中第一个有用的方法应该是 Kind，这个方法返回该类型的具体信息：Uint、Float64 等。Value 类型还包含了一系列类型方法，比如 Int()，用于返回对应的值。以下是Kind的种类：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Kind represents the specific kind of type that a Type represents.</span></span><br><span class="line"><span class="comment">// The zero Kind is not a valid kind.</span></span><br><span class="line"><span class="keyword">type</span> Kind <span class="type">uint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Invalid Kind = <span class="literal">iota</span></span><br><span class="line">	Bool</span><br><span class="line">	Int</span><br><span class="line">	Int8</span><br><span class="line">	Int16</span><br><span class="line">	Int32</span><br><span class="line">	Int64</span><br><span class="line">	Uint</span><br><span class="line">	Uint8</span><br><span class="line">	Uint16</span><br><span class="line">	Uint32</span><br><span class="line">	Uint64</span><br><span class="line">	Uintptr</span><br><span class="line">	Float32</span><br><span class="line">	Float64</span><br><span class="line">	Complex64</span><br><span class="line">	Complex128</span><br><span class="line">	Array</span><br><span class="line">	Chan</span><br><span class="line">	Func</span><br><span class="line">	Interface</span><br><span class="line">	Map</span><br><span class="line">	Ptr</span><br><span class="line">	Slice</span><br><span class="line">	String</span><br><span class="line">	Struct</span><br><span class="line">	UnsafePointer</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="从relfect-Value中获取接口interface的信息"><a href="#从relfect-Value中获取接口interface的信息" class="headerlink" title="从relfect.Value中获取接口interface的信息"></a>从relfect.Value中获取接口interface的信息</h3><p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。</p>
<h4 id="已知原有类型【进行“强制转换”】"><a href="#已知原有类型【进行“强制转换”】" class="headerlink" title="已知原有类型【进行“强制转换”】"></a>已知原有类型【进行“强制转换”】</h4><p>已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">realValue := value.Interface().(已知的类型)</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="type">float64</span> = <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">	pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">	value := reflect.ValueOf(num)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span></span><br><span class="line">	<span class="comment">// Golang 对类型要求非常严格，类型一定要完全符合</span></span><br><span class="line">	<span class="comment">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span></span><br><span class="line">	convertPointer := pointer.Interface().(*<span class="type">float64</span>)</span><br><span class="line">	convertValue := value.Interface().(<span class="type">float64</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(convertPointer)</span><br><span class="line">	fmt.Println(convertValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xc000098000</span><br><span class="line">1.2345</span><br></pre></td></tr></table></figure>

<p>说明</p>
<ol>
<li>转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！</li>
<li>转换的时候，要区分是指针类型还是非指针类型</li>
<li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li>
</ol>
<h4 id="未知原有类型【遍历探测其Filed】"><a href="#未知原有类型【遍历探测其Filed】" class="headerlink" title="未知原有类型【遍历探测其Filed】"></a>未知原有类型【遍历探测其Filed】</h4><p>很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">	Sex  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Say(msg <span class="type">string</span>) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello,&quot;</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> PrintInfo() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;姓名：%s，年龄：%d，性别：%s\n&quot;</span>, p.Name, p.Age, p.Sex)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Person&#123;<span class="string">&quot;王二狗&quot;</span>, <span class="number">30</span>, <span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line">	GetMessage(p1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetMessage 获取input的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMessage</span><span class="params">(input <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	getType := reflect.TypeOf(input)             <span class="comment">//先获取input的类型</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;get Type is :&quot;</span>, getType.Name()) <span class="comment">//Person</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;get Kind is :&quot;</span>, getType.Kind()) <span class="comment">//struct</span></span><br><span class="line"></span><br><span class="line">	getValue := reflect.ValueOf(input)</span><br><span class="line">	fmt.Println(<span class="string">&quot;get all Fields is :&quot;</span>, getValue) <span class="comment">//&#123;王二狗 30 男&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取字段</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		step1：先获取Type对象：reflect.Type，</span></span><br><span class="line"><span class="comment">			NumField()</span></span><br><span class="line"><span class="comment">			Field(index)</span></span><br><span class="line"><span class="comment">		step2：通过Filed()获取每一个Filed字段</span></span><br><span class="line"><span class="comment">		step3：Interface()，得到对应的Value</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; getType.NumField(); i++ &#123;</span><br><span class="line">		filed := getType.Field(i)</span><br><span class="line">		value := getValue.Field(i).Interface() <span class="comment">//获取第一个数值</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;字段名称：%s，字段类型：%s，字段数值：%v\n&quot;</span>, filed.Name, filed.Type, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取方法</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; getType.NumMethod(); i++ &#123;</span><br><span class="line">		method := getType.Method(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;方法名称：%s，方法类型：%v\n&quot;</span>, method.Name, method.Type)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get Type is : Person</span><br><span class="line">get Kind is : struct</span><br><span class="line">get all Fields is : &#123;王二狗 30 男&#125;</span><br><span class="line">字段名称：Name，字段类型：string，字段数值：王二狗</span><br><span class="line">字段名称：Age，字段类型：int，字段数值：30</span><br><span class="line">字段名称：Sex，字段类型：string，字段数值：男</span><br><span class="line">方法名称：PrintInfo，方法类型：func(main.Person)</span><br><span class="line">方法名称：Say，方法类型：func(main.Person, string)</span><br></pre></td></tr></table></figure>

<p>说明</p>
<p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p>
<ol>
<li>先获取interface的reflect.Type，然后通过NumField进行遍历</li>
<li>再通过reflect.Type的Field获取其Field</li>
<li>最后通过Field的Interface()得到对应的value</li>
</ol>
<p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p>
<ol>
<li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li>
<li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li>
<li>最后对结果取其Name和Type得知具体的方法名</li>
<li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li>
<li>struct 或者 struct 的嵌套都是一样的判断处理方式</li>
</ol>
<h3 id="通过reflect-ValueOf设置实际变量的值"><a href="#通过reflect-ValueOf设置实际变量的值" class="headerlink" title="通过reflect.ValueOf设置实际变量的值"></a>通过reflect.ValueOf设置实际变量的值</h3><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p>
<p>这里需要一个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> Elem() Value</span><br></pre></td></tr></table></figure>

<p>解释起来就是：Elem返回接口v包含的值或指针v指向的值。如果v的类型不是interface或ptr，它会恐慌。如果v为零，则返回零值。</p>
<p>如果你的变量是一个指针、map、slice、channel、Array。那么你可以使用reflect.Typeof(v).Elem()来确定包含的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//1.“接口类型变量”=&gt;“反射类型对象”</span></span><br><span class="line">	<span class="keyword">var</span> circle <span class="type">float64</span> = <span class="number">6.28</span></span><br><span class="line">	<span class="keyword">var</span> icir <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	icir = circle</span><br><span class="line">	fmt.Println(<span class="string">&quot;Reflect : circle.Value = &quot;</span>, reflect.ValueOf(icir)) <span class="comment">//Reflect : circle.Value =  6.28</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Reflect : circle.Type  = &quot;</span>, reflect.TypeOf(icir)) <span class="comment">//Reflect : circle.Type =  float64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. “反射类型对象”=&gt;“接口类型变量</span></span><br><span class="line">	v1 := reflect.ValueOf(icir)</span><br><span class="line">	fmt.Println(v1) <span class="comment">//6.28</span></span><br><span class="line">	fmt.Println(v1.Interface()) <span class="comment">//6.28</span></span><br><span class="line"></span><br><span class="line">	y := v1.Interface().(<span class="type">float64</span>)</span><br><span class="line">	fmt.Println(y) <span class="comment">//6.28</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//v1.SetFloat(4.13) //panic: reflect: reflect.Value.SetFloat using unaddressable value</span></span><br><span class="line">	<span class="comment">//fmt.Println(v1)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.修改</span></span><br><span class="line">	fmt.Println(v1.CanSet())<span class="comment">//是否可以进行修改</span></span><br><span class="line">	v2 := reflect.ValueOf(&amp;circle) <span class="comment">// 传递指针才能修改</span></span><br><span class="line">	v4:=v2.Elem()<span class="comment">// 传递指针才能修改,获取Elem()才能修改</span></span><br><span class="line">	fmt.Println(v4.CanSet()) <span class="comment">//true</span></span><br><span class="line">	v4.SetFloat(<span class="number">3.14</span>)</span><br><span class="line">	fmt.Println(circle) <span class="comment">//3.14</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reflect : circle.Value =  6.28</span><br><span class="line">Reflect : circle.Type  =  float64</span><br><span class="line">6.28</span><br><span class="line">6.28</span><br><span class="line">6.28</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure>

<p>说明</p>
<ol>
<li>需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<strong>注意一定要是指针</strong>。</li>
<li>如果传入的参数不是指针，而是变量，那么<ul>
<li>通过Elem获取原始值对应的对象则直接panic</li>
<li>通过CanSet方法查询是否可以设置返回false</li>
</ul>
</li>
<li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li>
<li>reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</li>
<li>也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】</li>
<li>struct 或者 struct 的嵌套都是一样的判断处理方式</li>
</ol>
<h3 id="通过reflect-ValueOf来进行方法的调用"><a href="#通过reflect-ValueOf来进行方法的调用" class="headerlink" title="通过reflect.ValueOf来进行方法的调用"></a>通过reflect.ValueOf来进行方法的调用</h3><p>这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定。</p>
<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Sex <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Say(msg <span class="type">string</span>)&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello,&quot;</span>,msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> PrintInfo()&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;姓名：%s，年龄：%d，性别：%s\n&quot;</span>,p.Name,p.Age,p.Sex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Test(i,j <span class="type">int</span>,s <span class="type">string</span>)&#123;</span><br><span class="line">	fmt.Println(i,j,s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	通过反射来进行方法的调用</span></span><br><span class="line"><span class="comment">	思路：</span></span><br><span class="line"><span class="comment">	step1：接口变量--&gt;对象反射对象：Value</span></span><br><span class="line"><span class="comment">	step2：获取对应的方法对象：MethodByName()</span></span><br><span class="line"><span class="comment">	step3：将方法对象进行调用：Call()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 p1 := Person&#123;<span class="string">&quot;Ruby&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line">	 value :=reflect.ValueOf(p1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;kind : %s, type:%s\n&quot;</span>,value.Kind(),value.Type()) <span class="comment">//kind : struct, type:main.Person</span></span><br><span class="line"></span><br><span class="line">	methodValue1 :=value.MethodByName(<span class="string">&quot;PrintInfo&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;kind:%s,type:%s\n&quot;</span>,methodValue1.Kind(),methodValue1.Type()) <span class="comment">//kind:func,type:func()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//没有参数，进行调用</span></span><br><span class="line">	methodValue1.Call(<span class="literal">nil</span>) <span class="comment">//没有参数，直接写nil</span></span><br><span class="line"></span><br><span class="line">	args1 := <span class="built_in">make</span>([]reflect.Value,<span class="number">0</span>) <span class="comment">//或者创建一个空的切片也可以</span></span><br><span class="line">	methodValue1.Call(args1)</span><br><span class="line"></span><br><span class="line">	methodValue2:=value.MethodByName(<span class="string">&quot;Say&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;kind:%s, type:%s\n&quot;</span>,methodValue2.Kind(),methodValue2.Type()) <span class="comment">//kind:func, type:func(string)</span></span><br><span class="line">	args2:=[]reflect.Value&#123;reflect.ValueOf(<span class="string">&quot;反射机制&quot;</span>)&#125;</span><br><span class="line">	methodValue2.Call(args2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	methodValue3:=value.MethodByName(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;kind:%s,type:%s\n&quot;</span>,methodValue3.Kind(),methodValue3.Type())<span class="comment">//kind:func,type:func(int, int, string)</span></span><br><span class="line">	args3:=[]reflect.Value&#123;reflect.ValueOf(<span class="number">100</span>),reflect.ValueOf(<span class="number">200</span>),reflect.ValueOf(<span class="string">&quot;Hello World&quot;</span>)&#125;</span><br><span class="line">	methodValue3.Call(args3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kind : struct, type:main.Person</span><br><span class="line">kind:func,type:func()</span><br><span class="line">姓名：Ruby，年龄：20，性别：男</span><br><span class="line">姓名：Ruby，年龄：20，性别：男</span><br><span class="line">kind:func, type:func(string)</span><br><span class="line">hello, 反射机制</span><br><span class="line">kind:func,type:func(int, int, string)</span><br><span class="line">100 200 Hello World</span><br></pre></td></tr></table></figure>

<h3 id="通过反射，调用函数"><a href="#通过反射，调用函数" class="headerlink" title="通过反射，调用函数"></a>通过反射，调用函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//函数的反射</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		思路：函数也是看做接口变量类型</span></span><br><span class="line"><span class="comment">		step1：函数---&gt;反射对象，Value</span></span><br><span class="line"><span class="comment">		step2：kind--&gt;func</span></span><br><span class="line"><span class="comment">		step3：call()</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	f1 := fun1</span><br><span class="line">	value := reflect.ValueOf(f1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;kind:%s, type :%s\n&quot;</span>, value.Kind(), value.Type()) <span class="comment">//kind:func, type :func()</span></span><br><span class="line">	value2 := reflect.ValueOf(fun2)</span><br><span class="line"></span><br><span class="line">	value3 := reflect.ValueOf(fun3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;kind:%s,type:%s\n&quot;</span>, value2.Kind(), value2.Type()) <span class="comment">//kind:func,type:func(int, string)</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;kind:%s,type:%s\n&quot;</span>, value3.Kind(), value3.Type()) <span class="comment">//kind:func,type:func(int, string) string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过反射调用函数</span></span><br><span class="line">	value.Call(<span class="literal">nil</span>)</span><br><span class="line">	value2.Call([]reflect.Value&#123;reflect.ValueOf(<span class="number">1000</span>), reflect.ValueOf(<span class="string">&quot;张三&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line">	resultValue := value3.Call([]reflect.Value&#123;reflect.ValueOf(<span class="number">2000</span>), reflect.ValueOf(<span class="string">&quot;Ruby&quot;</span>)&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, resultValue)                                               <span class="comment">//[]reflect.Value</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(resultValue))                                                 <span class="comment">//1</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;kind:%s,type:%s\n&quot;</span>, resultValue[<span class="number">0</span>].Kind(), resultValue[<span class="number">0</span>].Type()) <span class="comment">//kind:string,type:string</span></span><br><span class="line"></span><br><span class="line">	s := resultValue[<span class="number">0</span>].Interface().(<span class="type">string</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, s)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是函数fun1(),无参的...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun2</span><span class="params">(i <span class="type">int</span>, s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是函数fun2(),有参的。。&quot;</span>, i, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun3</span><span class="params">(i <span class="type">int</span>, s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是函数fun3()，有参的，也有返回值。。&quot;</span>, i, s)</span><br><span class="line">	<span class="keyword">return</span> s + strconv.Itoa(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kind:func, type :func()</span><br><span class="line">kind:func,type:func(int, string)</span><br><span class="line">kind:func,type:func(int, string) string</span><br><span class="line">我是函数fun1(),无参的...</span><br><span class="line">我是函数fun2(),有参的。。 1000 张三</span><br><span class="line">我是函数fun3()，有参的，也有返回值。。 2000 Ruby</span><br><span class="line">[]reflect.Value</span><br><span class="line">1</span><br><span class="line">kind:string,type:string</span><br><span class="line">Ruby2000</span><br><span class="line">string</span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Animal</span><br><span class="line">	Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取匿名字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := Cat&#123;Animal&#123;<span class="string">&quot;猫咪&quot;</span>, <span class="number">1</span>&#125;, <span class="string">&quot;白色&quot;</span>&#125;</span><br><span class="line">	t1 := reflect.TypeOf(c1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t1.NumField(); i++ &#123;</span><br><span class="line">		fmt.Println(t1.Field(i))</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			&#123;Animal  main.Animal  0 [0] true&#125;</span></span><br><span class="line"><span class="comment">			&#123;Color  string  24 [1] false&#125;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// FiledByIndex()的参数是一个切片，第一个数是Animal字段，第二个参数是Animal的第一个字段</span></span><br><span class="line">	f1 := t1.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;)</span><br><span class="line">	f2 := t1.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line">	fmt.Println(f1) <span class="comment">//&#123;Name  string  0 [0] false&#125;</span></span><br><span class="line">	fmt.Println(f2) <span class="comment">//&#123;Age  int  16 [1] false&#125;</span></span><br><span class="line"></span><br><span class="line">	v1 := reflect.ValueOf(c1)</span><br><span class="line">	fmt.Println(v1.Field(<span class="number">0</span>))                  <span class="comment">//&#123;猫咪 1&#125;</span></span><br><span class="line">	fmt.Println(v1.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;)) <span class="comment">//猫咪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;Animal  main.Animal  0 [0] true&#125;</span><br><span class="line">&#123;Color  string  24 [1] false&#125;</span><br><span class="line">&#123;Name  string  0 [0] false&#125;</span><br><span class="line">&#123;Age  int  16 [1] false&#125;</span><br><span class="line">&#123;猫咪 1&#125;</span><br><span class="line">猫咪</span><br></pre></td></tr></table></figure>

<h3 id="通过反射，修改结构体的数据"><a href="#通过反射，修改结构体的数据" class="headerlink" title="通过反射，修改结构体的数据"></a>通过反射，修改结构体的数据</h3><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	School <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	修改内容</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s1:= Student&#123;<span class="string">&quot;王二狗&quot;</span>,<span class="number">18</span>,<span class="string">&quot;清华大学&quot;</span>&#125;</span><br><span class="line">	v1 := reflect.ValueOf(&amp;s1)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> v1.Kind() ==reflect.Ptr &amp;&amp; v1.Elem().CanSet()&#123;</span><br><span class="line">		v1 = v1.Elem()</span><br><span class="line">		fmt.Println(<span class="string">&quot;可以修改。。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	f1:=v1.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">	fmt.Println(f1.CanSet())</span><br><span class="line">	f1.SetString(<span class="string">&quot;王三狗&quot;</span>)</span><br><span class="line">	f2:=v1.FieldByName(<span class="string">&quot;Age&quot;</span>)</span><br><span class="line">	fmt.Println(f2.CanSet())</span><br><span class="line">	f2.SetInt(<span class="number">20</span>)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以修改。。</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">&#123;王三狗 20 清华大学&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>channel通道详解</title>
    <url>/2023/07/07/Go/20/</url>
    <content><![CDATA[<h1 id="channel通道"><a href="#channel通道" class="headerlink" title="channel通道"></a>channel通道</h1><p>通道可以被认为是Goroutines通信的管道。类似于管道中的水从一端到另一端的流动，数据可以从一端发送到另一端，通过通道接收。</p>
<p>在前面讲Go语言的并发时候，我们就说过，当多个Goroutine想实现共享数据的时候，虽然也提供了传统的同步机制，但是Go语言强烈建议的是使用Channel通道来实现Goroutines之间的通信。</p>
<blockquote>
<p>“不要通过共享内存来通信，而应该通过通信来共享内存” 这是一句风靡golang社区的经典语</p>
</blockquote>
<p>Go语言中，要传递某个数据给另一个goroutine(协程)，可以把这个数据封装成一个对象，然后把这个对象的指针传入某个channel中，另外一个goroutine从这个channel中读出这个指针，并处理其指向的内存对象。Go从语言层面保证同一个时间只有一个goroutine能够访问channel里面的数据，为开发者提供了一种优雅简单的工具，所以Go的做法就是使用channel来通信，通过通信来传递内存数据，使得内存数据在不同的goroutine中传递，而不是使用共享内存来通信。</p>
<h2 id="什么是通道"><a href="#什么是通道" class="headerlink" title="什么是通道"></a>什么是通道</h2><h3 id="通道的概念"><a href="#通道的概念" class="headerlink" title="通道的概念"></a>通道的概念</h3><p>通道是什么，通道就是goroutine之间的通道。它可以让goroutine之间相互通信。</p>
<p>每个通道都有与其相关的类型。该类型是通道允许传输的数据类型。(通道的零值为nil。nil通道没有任何用处，因此通道必须使用类似于map和切片的方法来定义。)</p>
<h3 id="通道的声明"><a href="#通道的声明" class="headerlink" title="通道的声明"></a>通道的声明</h3><p>声明一个通道和定义一个变量的语法一样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明通道</span></span><br><span class="line"><span class="keyword">var</span> 通道名 <span class="keyword">chan</span> 数据类型</span><br><span class="line"><span class="comment">//创建通道：如果通道为nil(就是不存在)，就需要先创建通道</span></span><br><span class="line">通道名 = <span class="built_in">make</span>(<span class="keyword">chan</span> 数据类型)</span><br></pre></td></tr></table></figure>



<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	<span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;channel 是 nil 的, 不能使用，需要先创建通道。。&quot;</span>)</span><br><span class="line">		a = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;数据类型是： %T&quot;</span>, a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel 是 nil 的, 不能使用，需要先创建通道。。</span><br><span class="line">数据类型是： chan int</span><br></pre></td></tr></table></figure>

<p>也可以简短的声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) </span><br></pre></td></tr></table></figure>

<h3 id="channel的数据类型"><a href="#channel的数据类型" class="headerlink" title="channel的数据类型"></a>channel的数据类型</h3><p>channel是引用类型的数据，在作为参数传递的时候，传递的是内存地址。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%p\n&quot;</span>,ch1,ch1)</span><br><span class="line"></span><br><span class="line">	test1(ch1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%p\n&quot;</span>,ch,ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chan int,0xc00001e180</span><br><span class="line">chan int,0xc00001e180</span><br></pre></td></tr></table></figure>

<p>我们能够看到，ch和ch1的地址是一样的，说明它们是同一个通道。</p>
<h3 id="通道的注意点"><a href="#通道的注意点" class="headerlink" title="通道的注意点"></a>通道的注意点</h3><p>Channel通道在使用的时候，有以下几个注意点：</p>
<ul>
<li><p>1.用于goroutine，传递消息的。</p>
</li>
<li><p>2.通道，每个都有相关联的数据类型,<br>nil chan，不能使用，类似于nil map，不能直接存储键值对</p>
</li>
<li><p>3.使用通道传递数据：&lt;-<br> chan &lt;- data,发送数据到通道。向通道中写数据<br>data &lt;- chan,从通道中获取数据。从通道中读数据</p>
</li>
<li><p>4.阻塞：<br> 发送数据：chan &lt;- data,阻塞的，直到另一条goroutine，读取数据来解除阻塞<br>读取数据：data &lt;- chan,也是阻塞的。直到另一条goroutine，写出数据解除阻塞。</p>
</li>
<li><p>5.本身channel就是同步的，意味着同一时间，只能有一条goroutine来操作。</p>
</li>
</ul>
<p>最后：通道是goroutine之间的连接，所以通道的发送和接收必须处在不同的goroutine中。</p>
<h2 id="通道的使用语法"><a href="#通道的使用语法" class="headerlink" title="通道的使用语法"></a>通道的使用语法</h2><h3 id="发送和接收"><a href="#发送和接收" class="headerlink" title="发送和接收"></a>发送和接收</h3><p>发送和接收的语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data := &lt;- a <span class="comment">// read from channel a  </span></span><br><span class="line">a &lt;- data <span class="comment">// write to channel a</span></span><br></pre></td></tr></table></figure>

<p>在通道上箭头的方向指定数据是发送还是接收。</p>
<p>另外：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;- a <span class="comment">//从一个channel中读取</span></span><br></pre></td></tr></table></figure>

<h3 id="发送和接收默认是阻塞的"><a href="#发送和接收默认是阻塞的" class="headerlink" title="发送和接收默认是阻塞的"></a>发送和接收默认是阻塞的</h3><p>一个通道发送和接收数据，默认是阻塞的。当一个数据被发送到通道时，在发送语句中被阻塞，直到另一个Goroutine从该通道读取数据。相对地，当从通道读取数据时，读取被阻塞，直到一个Goroutine将数据写入该通道。</p>
<p>这些通道的特性是帮助Goroutines有效地进行通信，而无需像使用其他编程语言中非常常见的显式锁或条件变量。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">bool</span>       <span class="comment">//声明，没有创建</span></span><br><span class="line">	fmt.Println(ch1)        <span class="comment">//&lt;nil&gt;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, ch1) <span class="comment">//chan bool</span></span><br><span class="line">	ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)   <span class="comment">//0xc0000a4000,是引用类型的数据</span></span><br><span class="line">	fmt.Println(ch1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;子goroutine中，i：&quot;</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 循环结束后，向通道中写数据，表示要结束了。。</span></span><br><span class="line">		ch1 &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">&quot;结束。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	data := &lt;-ch1 <span class="comment">// 从ch1通道中读取数据</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;data--&gt;&quot;</span>, data)</span><br><span class="line">	fmt.Println(<span class="string">&quot;main。。over。。。。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">chan bool</span><br><span class="line">0xc000086120</span><br><span class="line">子goroutine中，i： 0</span><br><span class="line">子goroutine中，i： 1</span><br><span class="line">子goroutine中，i： 2</span><br><span class="line">子goroutine中，i： 3</span><br><span class="line">子goroutine中，i： 4</span><br><span class="line">子goroutine中，i： 5</span><br><span class="line">子goroutine中，i： 6</span><br><span class="line">子goroutine中，i： 7</span><br><span class="line">子goroutine中，i： 8</span><br><span class="line">子goroutine中，i： 9</span><br><span class="line">结束。。</span><br><span class="line">data--&gt; true</span><br><span class="line">main。。over。。。。</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们先创建了一个chan bool通道。然后启动了一条子Goroutine，并循环打印10个数字。然后我们向通道ch1中写入输入true。然后在主goroutine中，我们从ch1中读取数据。这一行代码是阻塞的，这意味着在子Goroutine将数据写入到该通道之前，主goroutine将不会执行到下一行代码。因此，我们可以通过channel实现子goroutine和主goroutine之间的通信。当子goroutine执行完毕前，主goroutine会因为读取ch1中的数据而阻塞。从而保证了子goroutine会先执行完毕。这就消除了对时间的需求。在之前的程序中，我们要么让主goroutine进入睡眠，以防止主要的Goroutine退出。要么通过WaitGroup来保证子goroutine先执行完毕，主goroutine才结束。</p>
<p>示例代码：以下代码加入了睡眠，可以更好的理解channel的阻塞</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>) <span class="comment">// 通道</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;子goroutine执行。。。&quot;</span>)</span><br><span class="line">		time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">		data := &lt;-ch1 <span class="comment">// 从通道中读取数据</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;data：&quot;</span>, data)</span><br><span class="line">		done &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 向通道中写数据。。</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	ch1 &lt;- <span class="number">100</span></span><br><span class="line"></span><br><span class="line">	&lt;-done</span><br><span class="line">	fmt.Println(<span class="string">&quot;main。。over&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子goroutine执行。。。</span><br><span class="line">data： 100</span><br><span class="line">main。。over</span><br></pre></td></tr></table></figure>

<p>再举一个例子，下面这段程序将打印一个数字的各位的平方和以及立方和。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcSquares</span><span class="params">(number <span class="type">int</span>, squareop <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> number != <span class="number">0</span> &#123;</span><br><span class="line">		digit := number % <span class="number">10</span></span><br><span class="line">		sum += digit * digit</span><br><span class="line">		number /= <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	squareop &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCubes</span><span class="params">(number <span class="type">int</span>, cubeop <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> number != <span class="number">0</span> &#123;</span><br><span class="line">		digit := number % <span class="number">10</span></span><br><span class="line">		sum += digit * digit * digit</span><br><span class="line">		number /= <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	cubeop &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	number := <span class="number">123</span></span><br><span class="line">	sqrch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	cubech := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> calcSquares(number, sqrch)</span><br><span class="line">	<span class="keyword">go</span> calcCubes(number, cubech)</span><br><span class="line">	squares, cubes := &lt;-sqrch, &lt;-cubech</span><br><span class="line">	fmt.Println(<span class="string">&quot;Final output&quot;</span>, squares, cubes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Final output 14 36</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>使用通道时要考虑的一个重要因素是死锁。如果Goroutine在一个通道上发送数据，那么预计其他的Goroutine应该接收数据。如果这种情况不发生，那么程序将在运行时出现死锁。</p>
<p>类似地，如果Goroutine正在等待从通道接收数据，那么另一些Goroutine将会在该通道上写入数据，否则程序将会死锁。</p>
<h2 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h2><p>发送者可以通过关闭信道，来通知接收方不会有更多的数据被发送到channel上。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>接收者可以在接收来自通道的数据时使用额外的变量来检查通道是否已经关闭。</p>
<p>语法结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;- ch  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>类似map操作，存储key，value键值对</p>
<p>v,ok :&#x3D; map[key] &#x2F;&#x2F;根据key从map中获取value，如果key存在， v就是对应的数据，如果key不存在，v是默认值</p>
</blockquote>
<p>在上面的语句中，如果ok的值是true，表示成功的从通道中读取了一个数据value。如果ok是false，这意味着我们正在从一个封闭的通道读取数据。从闭通道读取的值将是通道类型的零值。</p>
<p>例如，如果通道是一个int通道，那么从封闭通道接收的值将为0。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> sendData(ch1)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		子goroutine，写出数据10个</span></span><br><span class="line"><span class="comment">				每写一个，阻塞一次，主程序读取一次，解除阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		主goroutine：循环读</span></span><br><span class="line"><span class="comment">				每次读取一个，堵塞一次，子程序，写出一个，解除阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		发送发，关闭通道的---&gt;接收方，接收到的数据是该类型的零值，以及false</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//主程序中获取通道的数据</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		v, ok := &lt;-ch1 <span class="comment">//其他goroutine，显示的调用close方法关闭通道。</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;已经读取了所有的数据，&quot;</span>, ok, v)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;取出数据：&quot;</span>, v, ok)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;main...over....&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch1 <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 发送方：10条数据</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		ch1 &lt;- i <span class="comment">//将i写入通道中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch1) <span class="comment">//将ch1通道关闭了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">取出数据： 0 true</span><br><span class="line">取出数据： 1 true</span><br><span class="line">取出数据： 2 true</span><br><span class="line">取出数据： 3 true</span><br><span class="line">取出数据： 4 true</span><br><span class="line">取出数据： 5 true</span><br><span class="line">取出数据： 6 true</span><br><span class="line">取出数据： 7 true</span><br><span class="line">取出数据： 8 true</span><br><span class="line">取出数据： 9 true</span><br><span class="line">已经读取了所有的数据， false 0</span><br><span class="line">main...over....</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，send Goroutine将0到9写入chl通道，然后关闭通道。主函数里有一个无限循环。它检查通道是否在发送数据后，使用变量ok关闭。如果ok是假的，则意味着通道关闭，因此循环结束。还可以打印接收到的值和ok的值。</p>
<h2 id="通道上的范围循环"><a href="#通道上的范围循环" class="headerlink" title="通道上的范围循环"></a>通道上的范围循环</h2><p>我们可以循环从通道上获取数据，直到通道关闭。for循环的for range形式可用于从通道接收值，直到它关闭为止。</p>
<p>使用range循环，示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> sendData(ch1)</span><br><span class="line">	<span class="comment">// for循环的for range形式可用于从通道接收值，直到它关闭为止。</span></span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch1 &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;读取数据：&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;main..over.....&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch1 <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		ch1 &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch1) <span class="comment">//通知对方，通道关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取数据： 0</span><br><span class="line">读取数据： 1</span><br><span class="line">读取数据： 2</span><br><span class="line">读取数据： 3</span><br><span class="line">读取数据： 4</span><br><span class="line">读取数据： 5</span><br><span class="line">读取数据： 6</span><br><span class="line">读取数据： 7</span><br><span class="line">读取数据： 8</span><br><span class="line">读取数据： 9</span><br><span class="line">main..over.....</span><br></pre></td></tr></table></figure>

<h2 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h2><h3 id="非缓冲通道"><a href="#非缓冲通道" class="headerlink" title="非缓冲通道"></a>非缓冲通道</h3><p>之前学习的所有通道基本上都没有缓冲。发送和接收到一个未缓冲的通道是阻塞的。</p>
<p>一次发送操作对应一次接收操作，对于一个goroutine来讲，它的一次发送，在另一个goroutine接收之前都是阻塞的。同样的，对于接收来讲，在另一个goroutine发送之前，它也是阻塞的。</p>
<h3 id="缓冲通道-1"><a href="#缓冲通道-1" class="headerlink" title="缓冲通道"></a>缓冲通道</h3><p>缓冲通道就是指一个通道，带有一个缓冲区。发送到一个缓冲通道只有在缓冲区满时才被阻塞。类似地，从缓冲通道接收的信息只有在缓冲区为空时才会被阻塞。</p>
<p>可以通过将额外的容量参数传递给make函数来创建缓冲通道，该函数指定缓冲区的大小。</p>
<p>语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, capacity)  </span><br></pre></td></tr></table></figure>

<p>上述语法的容量应该大于0，以便通道具有缓冲区。默认情况下，无缓冲通道的容量为0，因此在之前创建通道时省略了容量参数。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下的代码中，chan通道，是带有缓冲区的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		非缓存通道：make(chan T)</span></span><br><span class="line"><span class="comment">		缓存通道：make(chan T ,size)</span></span><br><span class="line"><span class="comment">			缓存通道，理解为是队列：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		非缓存，发送还是接受，都是阻塞的</span></span><br><span class="line"><span class="comment">		缓存通道,缓存区的数据满了，才会阻塞状态。。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">go</span> sendData3(ch)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Second / <span class="number">2</span>)</span><br><span class="line">		v, ok := &lt;-ch</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;读完了，，&quot;</span>, ok)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;\t读取的数据是：&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;main...over...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData3</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		ch &lt;- <span class="string">&quot;数据&quot;</span> + strconv.Itoa(i)</span><br><span class="line">		fmt.Println(<span class="string">&quot;子goroutine，写出第&quot;</span>, i, <span class="string">&quot;个数据&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子goroutine，写出第 0 个数据</span><br><span class="line">子goroutine，写出第 1 个数据</span><br><span class="line">子goroutine，写出第 2 个数据</span><br><span class="line">子goroutine，写出第 3 个数据</span><br><span class="line">	读取的数据是： 数据0</span><br><span class="line">子goroutine，写出第 4 个数据</span><br><span class="line">子goroutine，写出第 5 个数据</span><br><span class="line">	读取的数据是： 数据1</span><br><span class="line">子goroutine，写出第 6 个数据</span><br><span class="line">	读取的数据是： 数据2</span><br><span class="line">	读取的数据是： 数据3</span><br><span class="line">子goroutine，写出第 7 个数据</span><br><span class="line">	读取的数据是： 数据4</span><br><span class="line">子goroutine，写出第 8 个数据</span><br><span class="line">	读取的数据是： 数据5</span><br><span class="line">子goroutine，写出第 9 个数据</span><br><span class="line">	读取的数据是： 数据6</span><br><span class="line">	读取的数据是： 数据7</span><br><span class="line">	读取的数据是： 数据8</span><br><span class="line">	读取的数据是： 数据9</span><br><span class="line">读完了，， false</span><br><span class="line">main...over...</span><br></pre></td></tr></table></figure>

<h2 id="定向通道"><a href="#定向通道" class="headerlink" title="定向通道"></a>定向通道</h2><h3 id="双向通道"><a href="#双向通道" class="headerlink" title="双向通道"></a>双向通道</h3><p>通道，channel，是用于实现goroutine之间的通信的。一个goroutine可以向通道中发送数据，另一条goroutine可以从该通道中获取数据。截止到现在我们所学习的通道，都是既可以发送数据，也可以读取数据，我们又把这种通道叫做双向通道。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data := &lt;- a <span class="comment">// read from channel a  </span></span><br><span class="line">a &lt;- data <span class="comment">// write to channel a</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>) <span class="comment">// 双向，可读，可写</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> sendData(ch1, done)</span><br><span class="line">	data := &lt;-ch1 <span class="comment">//阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;子goroutine传来：&quot;</span>, data)</span><br><span class="line">	ch1 &lt;- <span class="string">&quot;我是main。。&quot;</span> <span class="comment">// 阻塞</span></span><br><span class="line"></span><br><span class="line">	&lt;-done</span><br><span class="line">	fmt.Println(<span class="string">&quot;main...over....&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子goroutine--&gt;写数据到ch1通道中</span></span><br><span class="line"><span class="comment">// main goroutine--&gt;从ch1通道中取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch1 <span class="keyword">chan</span> <span class="type">string</span>, done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	ch1 &lt;- <span class="string">&quot;我是小明&quot;</span> <span class="comment">// 阻塞</span></span><br><span class="line">	data := &lt;-ch1 <span class="comment">// 阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine传来：&quot;</span>, data)</span><br><span class="line"></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子goroutine传来： 我是小明</span><br><span class="line">main goroutine传来： 我是main。。</span><br><span class="line">main...over....</span><br></pre></td></tr></table></figure>

<h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>单向通道，也就是定向通道。</p>
<p>之前我们学习的通道都是双向通道，我们可以通过这些通道接收或者发送数据。我们也可以创建单向通道，这些通道只能发送或者接收数据。</p>
<p>创建仅能发送数据的通道，示例代码：</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		单向：定向</span></span><br><span class="line"><span class="comment">		chan &lt;- T,</span></span><br><span class="line"><span class="comment">			只支持写，</span></span><br><span class="line"><span class="comment">		&lt;- chan T,</span></span><br><span class="line"><span class="comment">			只读</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)<span class="comment">//双向，读，写</span></span><br><span class="line">	<span class="comment">//ch2 := make(chan &lt;- int) // 单向，只写，不能读</span></span><br><span class="line">	<span class="comment">//ch3 := make(&lt;- chan int) //单向，只读，不能写</span></span><br><span class="line">	<span class="comment">//ch1 &lt;- 100</span></span><br><span class="line">	<span class="comment">//data :=&lt;-ch1</span></span><br><span class="line">	<span class="comment">//ch2 &lt;- 1000</span></span><br><span class="line">	<span class="comment">//data := &lt;- ch2</span></span><br><span class="line">	<span class="comment">//fmt.Println(data)</span></span><br><span class="line">	<span class="comment">//	&lt;-ch2 //invalid operation: &lt;-ch2 (receive from send-only type chan&lt;- int)</span></span><br><span class="line">	<span class="comment">//ch3 &lt;- 100</span></span><br><span class="line">	<span class="comment">//	&lt;-ch3</span></span><br><span class="line">	<span class="comment">//	ch3 &lt;- 100 //invalid operation: ch3 &lt;- 100 (send to receive-only type &lt;-chan int)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//go fun1(ch2)</span></span><br><span class="line">	<span class="keyword">go</span> fun1(ch1)</span><br><span class="line">	data:= &lt;- ch1</span><br><span class="line">	fmt.Println(<span class="string">&quot;fun1中写出的数据是：&quot;</span>,data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//fun2(ch3)</span></span><br><span class="line">	<span class="keyword">go</span> fun2(ch1)</span><br><span class="line">	ch1 &lt;- <span class="number">200</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main。。over。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该函数接收，只写的通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">(ch <span class="keyword">chan</span> &lt;- <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 函数内部，对于ch只能写数据，不能读数据</span></span><br><span class="line">	ch &lt;- <span class="number">100</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;fun1函数结束。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun2</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数内部，对于ch只能读数据，不能写数据</span></span><br><span class="line">	data := &lt;- ch</span><br><span class="line">	fmt.Println(<span class="string">&quot;fun2函数，从ch中读取的数据是：&quot;</span>,data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun1函数结束。。</span><br><span class="line">fun1中写出的数据是： 100</span><br><span class="line">fun2函数，从ch中读取的数据是： 200</span><br><span class="line">main。。over。。</span><br></pre></td></tr></table></figure>

<h2 id="time包中的通道相关函数"><a href="#time包中的通道相关函数" class="headerlink" title="time包中的通道相关函数"></a>time包中的通道相关函数</h2><p>主要就是定时器，标准库中的Timer让用户可以定义自己的超时逻辑，尤其是在应对select处理多个channel的超时、单channel读写的超时等情形时尤为方便。</p>
<p>Timer是一次性的时间触发事件，这点与Ticker不同，Ticker是按一定时间间隔持续触发时间事件。</p>
<p>Timer常见的创建方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t:= time.NewTimer(d)</span><br><span class="line">t:= time.AfterFunc(d, f)</span><br><span class="line">c:= time.After(d)</span><br></pre></td></tr></table></figure>

<p>虽然说创建方式不同，但是原理是相同的。</p>
<p>Timer有3个要素：</p>
<blockquote>
<p>定时时间：就是那个d<br>触发动作：就是那个f<br>时间channel： 也就是t.C</p>
</blockquote>
<h3 id="time-NewTimer"><a href="#time-NewTimer" class="headerlink" title="time.NewTimer()"></a>time.NewTimer()</h3><p>NewTimer()创建一个新的计时器，该计时器将在其通道上至少持续d之后发送当前时间。它的返回值是一个Timer。</p>
<p>源代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewTimer creates a new Timer that will send</span></span><br><span class="line"><span class="comment">// the current time on its channel after at least duration d.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span></span> *Timer &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">	t := &amp;Timer&#123;</span><br><span class="line">		C: c,</span><br><span class="line">		r: runtimeTimer&#123;</span><br><span class="line">			when: when(d),</span><br><span class="line">			f:    sendTime,</span><br><span class="line">			arg:  c,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	startTimer(&amp;t.r)</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源代码我们可以看出，首先创建一个channel，关联的类型为Time，然后创建了一个Timer并返回。</p>
<ul>
<li>用于在指定的Duration类型时间后调用函数或计算表达式。</li>
<li>如果只是想指定时间之后执行,使用time.Sleep()</li>
<li>使用NewTimer(),可以返回的Timer类型在计时器到期之前,取消该计时器</li>
<li>直到使用&lt;-timer.C发送一个值,该计时器才会过期</li>
</ul>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		func NewTimer(d Duration) *Timer</span></span><br><span class="line"><span class="comment">			创建一个计时器：d时间以后触发，go触发计时器的方法比较特别，就是在计时器的channel中发送值</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//新建一个计时器：timer</span></span><br><span class="line">	timer := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, timer) <span class="comment">//*time.Timer</span></span><br><span class="line">	fmt.Println(time.Now())   <span class="comment">//2023-07-07 16:26:45.5207225 +0800 CST m=+0.001542901</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//此处在等待channel中的信号，执行此段代码时会阻塞3秒</span></span><br><span class="line">	ch2 := timer.C     <span class="comment">//&lt;-chan time.Time</span></span><br><span class="line">	fmt.Println(&lt;-ch2) <span class="comment">//2023-07-07 16:26:48.5308961 +0800 CST m=+3.011716501</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="timer-Stop"><a href="#timer-Stop" class="headerlink" title="timer.Stop"></a>timer.Stop</h3><p>计时器停止：</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//新建计时器，一秒后触发</span></span><br><span class="line"></span><br><span class="line">	timer2 := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//新开启一个线程来处理触发后的事件</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//等触发时的信号</span></span><br><span class="line"></span><br><span class="line">		&lt;-timer2.C</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">&quot;Timer 2 结束。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//由于上面的等待信号是在新线程中，所以代码会继续往下执行，停掉计时器</span></span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	stop := timer2.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> stop &#123;</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">&quot;Timer 2 停止。。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Timer 2 停止。。</span><br></pre></td></tr></table></figure>

<h3 id="time-After"><a href="#time-After" class="headerlink" title="time.After()"></a>time.After()</h3><p>在等待持续时间之后，然后在返回的通道上发送当前时间。它相当于NewTimer(d).C。在计时器触发之前，垃圾收集器不会恢复底层计时器。如果效率有问题，使用NewTimer代替，并调用Timer。如果不再需要计时器，请停止。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		func After(d Duration) &lt;-chan Time</span></span><br><span class="line"><span class="comment">			返回一个通道：chan，存储的是d时间间隔后的当前时间。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	ch1 := time.After(<span class="number">3</span> * time.Second) <span class="comment">//3s后</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, ch1)            <span class="comment">// &lt;-chan time.Time</span></span><br><span class="line">	fmt.Println(time.Now())            <span class="comment">//2023-07-07 16:36:10.8553299 +0800 CST m=+0.001792901</span></span><br><span class="line">	time2 := &lt;-ch1</span><br><span class="line">	fmt.Println(time2) <span class="comment">//2023-07-07 16:36:13.8602885 +0800 CST m=+3.006751501</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现在线词典翻译(三种翻译接口，结合sync)</title>
    <url>/2023/07/08/Go/24/</url>
    <content><![CDATA[<h1 id="火山翻译"><a href="#火山翻译" class="headerlink" title="火山翻译"></a>火山翻译</h1><p>首先介绍用火山翻译英译汉。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DictRequestHS <span class="keyword">struct</span> &#123;</span><br><span class="line">	Source         <span class="type">string</span>   <span class="string">`json:&quot;source&quot;`</span></span><br><span class="line">	Words          []<span class="type">string</span> <span class="string">`json:&quot;words&quot;`</span></span><br><span class="line">	SourceLanguage <span class="type">string</span>   <span class="string">`json:&quot;source_language&quot;`</span></span><br><span class="line">	TargetLanguage <span class="type">string</span>   <span class="string">`json:&quot;target_language&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> DictResponseHS <span class="keyword">struct</span> &#123;</span><br><span class="line">	Details []<span class="keyword">struct</span> &#123;</span><br><span class="line">		Detail <span class="type">string</span> <span class="string">`json:&quot;detail&quot;`</span></span><br><span class="line">		Extra  <span class="type">string</span> <span class="string">`json:&quot;extra&quot;`</span></span><br><span class="line">	&#125; <span class="string">`json:&quot;details&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DictResponseHSData <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result []<span class="keyword">struct</span> &#123;</span><br><span class="line">		Ec <span class="keyword">struct</span> &#123;</span><br><span class="line">			Basic <span class="keyword">struct</span> &#123;</span><br><span class="line">				Explains []<span class="keyword">struct</span> &#123;</span><br><span class="line">					Pos   <span class="type">string</span> <span class="string">`json:&quot;pos&quot;`</span></span><br><span class="line">					Trans <span class="type">string</span> <span class="string">`json:&quot;trans&quot;`</span></span><br><span class="line">				&#125; <span class="string">`json:&quot;explains&quot;`</span></span><br><span class="line">			&#125; <span class="string">`json:&quot;basic&quot;`</span></span><br><span class="line">		&#125; <span class="string">`json:&quot;ec&quot;`</span></span><br><span class="line">	&#125; <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;请输入要查询的内容:&quot;</span>)</span><br><span class="line">		reader := bufio.NewReader(os.Stdin)</span><br><span class="line">		word, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		word = strings.Trim(word, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> IsEnglishString(word) &#123;</span><br><span class="line">			queryHS(word)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;请输入英语&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryHS</span><span class="params">(word <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	request := DictRequestHS&#123;<span class="string">&quot;youdao&quot;</span>, []<span class="type">string</span>&#123;word&#125;, <span class="string">&quot;en&quot;</span>, <span class="string">&quot;zh&quot;</span>&#125;</span><br><span class="line">	buf, err := json.Marshal(request)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> data = bytes.NewReader(buf)</span><br><span class="line">	req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;https://translate.volcengine.com/web/dict/detail/v1/?msToken=&amp;X-Bogus=DFSzswVOQDaibrQ3tJHN7cppgiFh&amp;_signature=_02B4Z6wo00001g0lO6gAAIDD-FrRNX0w-.4NJT8AAOfuf7&quot;</span>, data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	req.Header.Set(<span class="string">&quot;authority&quot;</span>, <span class="string">&quot;translate.volcengine.com&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;accept&quot;</span>, <span class="string">&quot;application/json, text/plain, */*&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;accept-language&quot;</span>, <span class="string">&quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;cookie&quot;</span>, <span class="string">&quot;x-jupiter-uuid=16888064002651706; i18next=zh-CN; s_v_web_id=verify_ljtrq6kx_UW3ieIzP_8gQX_4abc_B8D8_AoHwuLysn026; ttcid=db98bce9149b4f09b905a71503d9331e36&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;origin&quot;</span>, <span class="string">&quot;https://translate.volcengine.com&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;referer&quot;</span>, <span class="string">&quot;https://translate.volcengine.com/?category=&amp;home_language=zh&amp;source_language=detect&amp;target_language=zh&amp;text=bad&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;sec-ch-ua&quot;</span>, <span class="string">`&quot;Not.A/Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;114&quot;, &quot;Microsoft Edge&quot;;v=&quot;114&quot;`</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;sec-ch-ua-mobile&quot;</span>, <span class="string">&quot;?0&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;sec-ch-ua-platform&quot;</span>, <span class="string">`&quot;Windows&quot;`</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;sec-fetch-dest&quot;</span>, <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;sec-fetch-mode&quot;</span>, <span class="string">&quot;cors&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;sec-fetch-site&quot;</span>, <span class="string">&quot;same-origin&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;user-agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.43&quot;</span>)</span><br><span class="line">	resp, err := client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	bodyText, err := io.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode != <span class="number">200</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;bad StatusCode:&quot;</span>, resp.StatusCode, <span class="string">&quot;body&quot;</span>, <span class="type">string</span>(bodyText))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> dictResponse DictResponseHS</span><br><span class="line"></span><br><span class="line">	err = json.Unmarshal(bodyText, &amp;dictResponse)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;火山翻译&quot;</span>)</span><br><span class="line">	item := dictResponse.Details[<span class="number">0</span>]</span><br><span class="line">	jsonStr := item.Detail</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> HSData DictResponseHSData</span><br><span class="line">	err = json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;HSData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> HSData.Result[<span class="number">0</span>].Ec.Basic.Explains &#123;</span><br><span class="line">		fmt.Println(item.Pos, item.Trans)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsEnglishString</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> unicode.IsLetter(r) &amp;&amp; !unicode.Is(unicode.Scripts[<span class="string">&quot;Han&quot;</span>], r) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg := <span class="built_in">recover</span>(); msg != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(msg, <span class="string">&quot;输入不合法,请重新输入&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	query()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230708201714905.png"></p>
<h1 id="彩云翻译和百度翻译"><a href="#彩云翻译和百度翻译" class="headerlink" title="彩云翻译和百度翻译"></a>彩云翻译和百度翻译</h1><p>然后运用goroutine，结合sync包，同时实现彩云翻译和百度翻译。可对输入的内容自动检测，完成英译汉，汉译英。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DictRequestCY <span class="keyword">struct</span> &#123;</span><br><span class="line">	TransType <span class="type">string</span> <span class="string">`json:&quot;trans_type&quot;`</span></span><br><span class="line">	Source    <span class="type">string</span> <span class="string">`json:&quot;source&quot;`</span></span><br><span class="line">	UserID    <span class="type">string</span> <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DictResponseCY <span class="keyword">struct</span> &#123;</span><br><span class="line">	Rc   <span class="type">int</span> <span class="string">`json:&quot;rc&quot;`</span></span><br><span class="line">	Wiki <span class="keyword">struct</span> &#123;</span><br><span class="line">		KnownInLaguages <span class="type">int</span> <span class="string">`json:&quot;known_in_laguages&quot;`</span></span><br><span class="line">		Description     <span class="keyword">struct</span> &#123;</span><br><span class="line">			Source <span class="type">string</span>      <span class="string">`json:&quot;source&quot;`</span></span><br><span class="line">			Target <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;target&quot;`</span></span><br><span class="line">		&#125; <span class="string">`json:&quot;description&quot;`</span></span><br><span class="line">		ID   <span class="type">string</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">		Item <span class="keyword">struct</span> &#123;</span><br><span class="line">			Source <span class="type">string</span> <span class="string">`json:&quot;source&quot;`</span></span><br><span class="line">			Target <span class="type">string</span> <span class="string">`json:&quot;target&quot;`</span></span><br><span class="line">		&#125; <span class="string">`json:&quot;item&quot;`</span></span><br><span class="line">		ImageURL  <span class="type">string</span> <span class="string">`json:&quot;image_url&quot;`</span></span><br><span class="line">		IsSubject <span class="type">string</span> <span class="string">`json:&quot;is_subject&quot;`</span></span><br><span class="line">		Sitelink  <span class="type">string</span> <span class="string">`json:&quot;sitelink&quot;`</span></span><br><span class="line">	&#125; <span class="string">`json:&quot;wiki&quot;`</span></span><br><span class="line">	Dictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">		Prons <span class="keyword">struct</span> &#123;</span><br><span class="line">			EnUs <span class="type">string</span> <span class="string">`json:&quot;en-us&quot;`</span></span><br><span class="line">			En   <span class="type">string</span> <span class="string">`json:&quot;en&quot;`</span></span><br><span class="line">		&#125; <span class="string">`json:&quot;prons&quot;`</span></span><br><span class="line">		Explanations []<span class="type">string</span>      <span class="string">`json:&quot;explanations&quot;`</span></span><br><span class="line">		Synonym      []<span class="type">string</span>      <span class="string">`json:&quot;synonym&quot;`</span></span><br><span class="line">		Antonym      []<span class="type">string</span>      <span class="string">`json:&quot;antonym&quot;`</span></span><br><span class="line">		WqxExample   [][]<span class="type">string</span>    <span class="string">`json:&quot;wqx_example&quot;`</span></span><br><span class="line">		Entry        <span class="type">string</span>        <span class="string">`json:&quot;entry&quot;`</span></span><br><span class="line">		Type         <span class="type">string</span>        <span class="string">`json:&quot;type&quot;`</span></span><br><span class="line">		Related      []<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;related&quot;`</span></span><br><span class="line">		Source       <span class="type">string</span>        <span class="string">`json:&quot;source&quot;`</span></span><br><span class="line">	&#125; <span class="string">`json:&quot;dictionary&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DictResponseBD <span class="keyword">struct</span> &#123;</span><br><span class="line">	Errno <span class="type">int</span> <span class="string">`json:&quot;errno&quot;`</span></span><br><span class="line">	Data  []<span class="keyword">struct</span> &#123;</span><br><span class="line">		K <span class="type">string</span> <span class="string">`json:&quot;k&quot;`</span></span><br><span class="line">		V <span class="type">string</span> <span class="string">`json:&quot;v&quot;`</span></span><br><span class="line">	&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryBD</span><span class="params">(word <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> data = strings.NewReader(<span class="string">&quot;kw=&quot;</span> + word)</span><br><span class="line">	req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;https://fanyi.baidu.com/sug&quot;</span>, data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json, text/javascript, */*; q=0.01&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Cookie&quot;</span>, <span class="string">&quot;BIDUPSID=1CDF4C78BCFB3D90B2D6A594920DA6E4; PSTM=1630726121; __yjs_duid=1_02f9d28d226309370f287ee032114e3f1630763189674; REALTIME_TRANS_SWITCH=1; HISTORY_SWITCH=1; FANYI_WORD_SWITCH=1; SOUND_SPD_SWITCH=1; SOUND_PREFER_SWITCH=1; BAIDUID=396D4FB45E415311D3C31A0DE0D1AF80:FG=1; BDUSS=V6NWkyMzJnaTB-OWplSFdUR25tRkxsTzFnVnBDanN4ZEs2bHFMc2EzaXJOcDVrRVFBQUFBJCQAAAAAAAAAAAEAAACpaydUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKupdmSrqXZkMV; BDUSS_BFESS=V6NWkyMzJnaTB-OWplSFdUR25tRkxsTzFnVnBDanN4ZEs2bHFMc2EzaXJOcDVrRVFBQUFBJCQAAAAAAAAAAAEAAACpaydUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKupdmSrqXZkMV; APPGUIDE_10_6_2=1; MCITY=-75%3A; MAWEBCUID=web_jcjIPqwGUVRAlyJeYpGiILrRIWXcMWNDAjChgRXUZoHLpLyApr; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; PSINO=1; BAIDUID_BFESS=396D4FB45E415311D3C31A0DE0D1AF80:FG=1; BA_HECTOR=2h852l8h2ha5840k8k0k050g1iai2fd1o; ZFY=kYWZ1Y6d6SV8cMcgDFNKAhwEEhlIK7W5gu1C:APN07HM:C; H_PS_PSSID=36546_39026_39022_38858_38957_38954_39009_38918_38972_38815_38637_26350_39041_38948_39046; ab_sr=1.0.1_MjBiYTAxMmUwMWE2MzIyODYxY2JiYzIxNjFjMWY2OTIwOTc5NTA1MTI5MzAzZGI2OWNiMGEwM2I1Y2IwNjJiZWEzNDQwOTg1ZTkyYTJkNmU1OTc3MjY1MTJhZTM1MGEwNWNlM2NkM2VjNWM0NDMwZjY0ZWJlZTEyOTQyZjFkZjE1YzhiYzY4YjBhYzQ4NzE2NWI4MjNkZjA1NTVkMDk2MmRjMjZhYTA4NThmOTYwMmEzOWMxMjAxMGM2OTdjODhm&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Origin&quot;</span>, <span class="string">&quot;https://fanyi.baidu.com&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot;https://fanyi.baidu.com/&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Sec-Fetch-Dest&quot;</span>, <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Sec-Fetch-Mode&quot;</span>, <span class="string">&quot;cors&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Sec-Fetch-Site&quot;</span>, <span class="string">&quot;same-origin&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.43&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;X-Requested-With&quot;</span>, <span class="string">&quot;XMLHttpRequest&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;sec-ch-ua&quot;</span>, <span class="string">`&quot;Not.A/Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;114&quot;, &quot;Microsoft Edge&quot;;v=&quot;114&quot;`</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;sec-ch-ua-mobile&quot;</span>, <span class="string">&quot;?0&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;sec-ch-ua-platform&quot;</span>, <span class="string">`&quot;Windows&quot;`</span>)</span><br><span class="line">	resp, err := client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	bodyText, err := io.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode != <span class="number">200</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;bad StatusCode:&quot;</span>, resp.StatusCode, <span class="string">&quot;body&quot;</span>, <span class="type">string</span>(bodyText))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> dictResponse DictResponseBD</span><br><span class="line">	err = json.Unmarshal(bodyText, &amp;dictResponse)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;百度翻译&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> dictResponse.Data &#123;</span><br><span class="line">		fmt.Println(item.V)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Done()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryCY</span><span class="params">(word <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	request := DictRequestCY&#123;TransType: <span class="string">&quot;en2zh&quot;</span>, Source: word&#125;</span><br><span class="line">	buf, err := json.Marshal(request)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> data = bytes.NewReader(buf)</span><br><span class="line">	req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;https://api.interpreter.caiyunai.com/v1/dict&quot;</span>, data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;DNT&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;os-version&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;sec-ch-ua-mobile&quot;</span>, <span class="string">&quot;?0&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;app-name&quot;</span>, <span class="string">&quot;xy&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json, text/plain, */*&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;device-id&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;os-type&quot;</span>, <span class="string">&quot;web&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;X-Authorization&quot;</span>, <span class="string">&quot;token:qgemv4jr1y38jyq6vhvi&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Origin&quot;</span>, <span class="string">&quot;https://fanyi.caiyunapp.com&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Sec-Fetch-Site&quot;</span>, <span class="string">&quot;cross-site&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Sec-Fetch-Mode&quot;</span>, <span class="string">&quot;cors&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Sec-Fetch-Dest&quot;</span>, <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot;https://fanyi.caiyunapp.com/&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>)</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Cookie&quot;</span>, <span class="string">&quot;_ym_uid=16456948721020430059; _ym_d=1645694872&quot;</span>)</span><br><span class="line">	resp, err := client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	bodyText, err := io.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode != <span class="number">200</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;bad StatusCode:&quot;</span>, resp.StatusCode, <span class="string">&quot;body&quot;</span>, <span class="type">string</span>(bodyText))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> dictResponse DictResponseCY</span><br><span class="line">	err = json.Unmarshal(bodyText, &amp;dictResponse)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;彩云翻译&quot;</span>)</span><br><span class="line">	fmt.Println(word, <span class="string">&quot;UK:&quot;</span>, dictResponse.Dictionary.Prons.En, <span class="string">&quot;US:&quot;</span>, dictResponse.Dictionary.Prons.EnUs)</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> dictResponse.Dictionary.Explanations &#123;</span><br><span class="line">		fmt.Println(item)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入要查询的内容:&quot;</span>)</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	word, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	word = strings.Trim(word, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> queryCY(word)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> queryBD(word)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230708202352141.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230708202412883.png"></p>
<h1 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h1><p>1.json格式数据转golang结构体</p>
<p><a href="https://oktools.net/json2go">JSON转Golang Struct - 在线工具 - OKTools</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230708202645156.png"></p>
<p>2.curl转爬虫代码</p>
<p><a href="https://curlconverter.com/">Convert curl commands to code (curlconverter.com)</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230708203618156.png"></p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现socks5代理服务器</title>
    <url>/2023/07/09/Go/25/</url>
    <content><![CDATA[<p>SOCKS5 是一个代理协议，它在使用TCP&#x2F;IP协议通讯的前端机器和服务器机器之间扮演一个中介角色，使得内部网中的前端机器变得能够访问Internet网中的服务器，或者使通讯更加安全。SOCKS5 服务器通过将前端发来的请求转发给真正的目标服务器， 模拟了一个前端的行为。在这里，前端和SOCKS5之间也是通过TCP&#x2F;IP协议进行通讯，前端将原本要发送给真正服务器的请求发送给SOCKS5服务器，然后SOCKS5服务器将请求转发给真正的服务器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image101.png"></p>
<p>我们先来看一下最终写完的代理服务器的效果。我们启动这个程序，然后在浏览器里面配置使用这个代理，此时我们打开网页。<br>代理服务器的日志，会打印出你访问的网站的域名或者IP，这说明我们的网络流量是通过这个代理服务器的。我们也能在命令行去测试我们的代理服务器。我们可以用curl –socks5 +代理服务器地址，后面加一个可访问的URL，如果代理服务器工作正常的话，那么 curl命令就会正常返回。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image102.png"></p>
<p>socks5协议原理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-07-09_10-43-11.png"></p>
<p>源代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socks5Ver = <span class="number">0x05</span></span><br><span class="line"><span class="keyword">const</span> cmdBind = <span class="number">0x01</span></span><br><span class="line"><span class="keyword">const</span> atypeIPV4 = <span class="number">0x01</span></span><br><span class="line"><span class="keyword">const</span> atypeHOST = <span class="number">0x03</span></span><br><span class="line"><span class="keyword">const</span> atypeIPV6 = <span class="number">0x04</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:1080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		client, err := server.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Accept failed %v&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> process(client)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	reader := bufio.NewReader(conn)</span><br><span class="line">	err := auth(reader, conn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;client %v auth failed:%v&quot;</span>, conn.RemoteAddr(), err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = connect(reader, conn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;client %v auth failed:%v&quot;</span>, conn.RemoteAddr(), err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">auth</span><span class="params">(reader *bufio.Reader, conn net.Conn)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// +----+----------+----------+</span></span><br><span class="line">	<span class="comment">// |VER | NMETHODS | METHODS  |</span></span><br><span class="line">	<span class="comment">// +----+----------+----------+</span></span><br><span class="line">	<span class="comment">// | 1  |    1     | 1 to 255 |</span></span><br><span class="line">	<span class="comment">// +----+----------+----------+</span></span><br><span class="line">	<span class="comment">// VER: 协议版本，socks5为0x05</span></span><br><span class="line">	<span class="comment">// NMETHODS: 支持认证的方法数量</span></span><br><span class="line">	<span class="comment">// METHODS: 对应NMETHODS，NMETHODS的值为多少，METHODS就有多少个字节。RFC预定义了一些值的含义，内容如下:</span></span><br><span class="line">	<span class="comment">// X’00’ NO AUTHENTICATION REQUIRED</span></span><br><span class="line">	<span class="comment">// X’02’ USERNAME/PASSWORD</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read VER, NMETHODS, and METHODS</span></span><br><span class="line">	ver, err := reader.ReadByte()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read ver failed:%w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ver != socks5Ver &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not supported ver:%v&quot;</span>, ver)</span><br><span class="line">	&#125;</span><br><span class="line">	methodSize, err := reader.ReadByte()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read methodSize failed:%w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	method := <span class="built_in">make</span>([]<span class="type">byte</span>, methodSize)</span><br><span class="line">	_, err = io.ReadFull(reader, method)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read method failed:%w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// +----+--------+</span></span><br><span class="line">	<span class="comment">// |VER | METHOD |</span></span><br><span class="line">	<span class="comment">// +----+--------+</span></span><br><span class="line">	<span class="comment">// | 1  |   1    |</span></span><br><span class="line">	<span class="comment">// +----+--------+</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write VER and METHOD</span></span><br><span class="line">	_, err = conn.Write([]<span class="type">byte</span>&#123;socks5Ver, <span class="number">0x00</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write failed:%w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(reader *bufio.Reader, conn net.Conn)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line">	<span class="comment">// |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |</span></span><br><span class="line">	<span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line">	<span class="comment">// | 1  |  1  | X&#x27;00&#x27; |  1   | Variable |    2     |</span></span><br><span class="line">	<span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line">	<span class="comment">// VER 版本号，socks5的值为0x05</span></span><br><span class="line">	<span class="comment">// CMD 0x01表示CONNECT请求</span></span><br><span class="line">	<span class="comment">// RSV 保留字段，值为0x00</span></span><br><span class="line">	<span class="comment">// ATYP 目标地址类型，DST.ADDR的数据对应这个字段的类型。</span></span><br><span class="line">	<span class="comment">//   0x01表示IPv4地址，DST.ADDR为4个字节</span></span><br><span class="line">	<span class="comment">//   0x03表示域名，DST.ADDR是一个可变长度的域名</span></span><br><span class="line">	<span class="comment">// DST.ADDR 一个可变长度的值</span></span><br><span class="line">	<span class="comment">// DST.PORT 目标端口，固定2个字节</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read VER, CMD, RSV, and ATYP</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>)</span><br><span class="line">	_, err = io.ReadFull(reader, buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read header failed:%w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	ver, cmd, atyp := buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">3</span>]</span><br><span class="line">	<span class="keyword">if</span> ver != socks5Ver &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not supported ver:%v&quot;</span>, ver)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> cmd != cmdBind &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not supported cmd:%v&quot;</span>, cmd)</span><br><span class="line">	&#125;</span><br><span class="line">	addr := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">switch</span> atyp &#123;</span><br><span class="line">	<span class="keyword">case</span> atypeIPV4:</span><br><span class="line">		_, err = io.ReadFull(reader, buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read atyp failed:%w&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		addr = fmt.Sprintf(<span class="string">&quot;%d.%d.%d.%d&quot;</span>, buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">2</span>], buf[<span class="number">3</span>])</span><br><span class="line">	<span class="keyword">case</span> atypeHOST:</span><br><span class="line">		hostSize, err := reader.ReadByte()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read hostSize failed:%w&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		host := <span class="built_in">make</span>([]<span class="type">byte</span>, hostSize)</span><br><span class="line">		_, err = io.ReadFull(reader, host)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read host failed:%w&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		addr = <span class="type">string</span>(host)</span><br><span class="line">	<span class="keyword">case</span> atypeIPV6:</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;IPv6: no supported yet&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;invalid atyp&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = io.ReadFull(reader, buf[:<span class="number">2</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read port failed:%w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	port := binary.BigEndian.Uint16(buf[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">	dest, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;%v:%v&quot;</span>, addr, port))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;dial dst failed:%w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> dest.Close()</span><br><span class="line">	log.Println(<span class="string">&quot;dial&quot;</span>, addr, port)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line">	<span class="comment">// |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |</span></span><br><span class="line">	<span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line">	<span class="comment">// | 1  |  1  | X&#x27;00&#x27; |  1   | Variable |    2     |</span></span><br><span class="line">	<span class="comment">// +----+-----+-------+------+----------+----------+</span></span><br><span class="line">	<span class="comment">// VER socks版本，这里为0x05</span></span><br><span class="line">	<span class="comment">// REP Relay field,内容取值如下 X’00’ succeeded</span></span><br><span class="line">	<span class="comment">// RSV 保留字段</span></span><br><span class="line">	<span class="comment">// ATYPE 地址类型</span></span><br><span class="line">	<span class="comment">// BND.ADDR 服务绑定的地址</span></span><br><span class="line">	<span class="comment">// BND.PORT 服务绑定的端口DST.PORT</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Send response to client</span></span><br><span class="line">	_, err = conn.Write([]<span class="type">byte</span>&#123;<span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write failed: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		_, _ = io.Copy(dest, reader)</span><br><span class="line">		cancel()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		_, _ = io.Copy(conn, dest)</span><br><span class="line">		cancel()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：主函数开始监听在本地地址（127.0.0.1）的1080端口上，接受客户端的连接请求，并在新的goroutine中处理客户端连接。<code>process</code>函数用于处理客户端连接。首先关闭连接，然后创建一个<code>bufio.Reader</code>用于读取数据。接下来调用<code>auth</code>函数进行认证，然后调用<code>connect</code>函数进行连接。<code>auth</code>函数用于处理认证过程。根据SOCKS5协议规定的格式，从<code>reader</code>中读取协议版本和支持的认证方法，然后向客户端返回协议版本和选择的认证方法。这里只实现了不需要认证的方式。<code>connect</code>函数用于处理连接请求。根据SOCKS5协议规定的格式，从<code>reader</code>中读取版本、命令、地址类型和目标地址信息。根据地址类型的不同，解析出目标地址和端口号。然后建立与目标服务器的连接，并将连接成功的响应发送给客户端。接下来，使用goroutine并发地将客户端的数据复制到目标服务器和将目标服务器的数据复制回客户端，从而实现了数据的转发。最后，使用<code>&lt;-ctx.Done()</code>阻塞等待上述goroutine的完成。</p>
<p>将这段代码在goland上运行，并在cmd命令行（管理员）中输入<code>curl --socks5 127.0.0.1 1080 -v http://www.baidu.com</code>以测试：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/20230709110101.png"></p>
<p>socks5服务器实现成功。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>猜谜游戏(Go实现)</title>
    <url>/2023/07/08/Go/23/</url>
    <content><![CDATA[<h1 id="猜谜游戏"><a href="#猜谜游戏" class="headerlink" title="猜谜游戏"></a>猜谜游戏</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	maxNum := <span class="number">100</span></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	secretNumber := rand.Intn(maxNum)</span><br><span class="line">	<span class="comment">//fmt.Println(&quot;The secret number is &quot;, secretNumber)</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Please input your guess:&quot;</span>)</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		input, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;An error occured while reading input. Please try again&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		input = strings.Trim(input, <span class="string">&quot;\r\n&quot;</span>) <span class="comment">////去除字符串开头和结尾处的回车符和换行符</span></span><br><span class="line"></span><br><span class="line">		guess, err := strconv.Atoi(input)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Invalid input. Please enter an integer value&quot;</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;You guess is&quot;</span>, guess)</span><br><span class="line">		<span class="keyword">if</span> guess &gt; secretNumber &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Your guess is bigger than the secret number. Please try again&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> guess &lt; secretNumber &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Your guess is smaller than the secret number. Please try again&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Correct, you Legend!&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：这段代码是一个简单的猜数字游戏程序，使用 Go 语言编写。</p>
<p>首先，代码导入了一些需要使用的包，包括 <code>&quot;bufio&quot;</code>、<code>&quot;fmt&quot;</code>、<code>&quot;math/rand&quot;</code>、<code>&quot;os&quot;</code>、<code>&quot;strconv&quot;</code> 和 <code>&quot;strings&quot;</code>，这些包提供了处理输入输出、生成随机数和字符串处理的功能。</p>
<p>接下来，在 <code>main</code> 函数中，定义了一个变量 <code>maxNum</code>，它表示可猜测的最大数字。然后使用 <code>rand.Seed(time.Now().UnixNano())</code> 设置随机数生成器的种子，以确保每次程序运行时生成的随机数是不同的。然后使用 <code>rand.Intn(maxNum)</code> 生成一个介于 0 和 <code>maxNum</code> 之间的随机整数作为秘密数字。</p>
<p>然后程序提示用户输入猜测的数字，并使用 <code>bufio.NewReader(os.Stdin)</code> 创建一个读取标准输入的读取器。</p>
<p>之后进入一个无限循环，在循环中不断读取用户输入的猜测数字，直到猜测正确为止。循环开始时，调用 <code>reader.ReadString(&#39;\n&#39;)</code> 读取用户输入的完整一行字符串，包括换行符。然后使用 <code>strings.Trim(input, &quot;\r\n&quot;)</code> 去除字符串开头和结尾处的回车符和换行符，并将修剪后的字符串赋值给 <code>input</code> 变量。</p>
<p>接下来，使用 <code>strconv.Atoi(input)</code> 将修剪后的字符串转换为整数类型，并将转换后的结果赋值给 <code>guess</code> 变量。如果转换出错，则输出错误信息并要求用户重新输入。</p>
<p>然后程序输出用户猜测的数字，并与秘密数字进行比较。如果猜测数字大于秘密数字，则输出提示信息告诉用户猜测数字太大；如果猜测数字小于秘密数字，则输出提示信息告诉用户猜测数字太小。如果猜测数字与秘密数字相等，则输出提示信息告诉用户猜测正确，并跳出循环。</p>
<p>整个过程会循环进行，直到用户猜测正确为止。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin框架详解</title>
    <url>/2023/07/09/Go/26/</url>
    <content><![CDATA[<h2 id="Gin框架简介"><a href="#Gin框架简介" class="headerlink" title="Gin框架简介"></a>Gin框架简介</h2><p>Gin是一个简单、快速而强大的Web框架，适用于构建各种规模的Web应用程序。它的设计理念是简洁、高效和易用，可以帮助开发人员快速构建高性能的Web服务。无论是构建API服务、Web应用还是微服务，Gin都是一个不错的选择。它具有类似martini的API，但性能要好得多，多亏了httprouter，速度提高了40倍。如果您需要性能和良好的生产力，您一定会喜欢Gin 。</p>
<h3 id="不用gin框架实现简单web程序"><a href="#不用gin框架实现简单web程序" class="headerlink" title="不用gin框架实现简单web程序"></a>不用gin框架实现简单web程序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注册路由处理函数</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, sayhello)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动HTTP服务器并监听指定端口</span></span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;错误：%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sayhello 是处理 /hello 路由的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	_, _ = fmt.Fprintf(w, <span class="string">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将以上代码运行后在浏览器输入网址localhost:9090，返回内容&lt;h1&gt;Hello&lt;&#x2F;h1&gt;</p>
<h3 id="下载并安装Gin"><a href="#下载并安装Gin" class="headerlink" title="下载并安装Gin"></a>下载并安装<code>Gin</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>

<h3 id="第一个Gin示例"><a href="#第一个Gin示例" class="headerlink" title="第一个Gin示例"></a>第一个Gin示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建默认的Gin引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义路由和处理函数</span></span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动HTTP服务器并监听指定端口，默认在0.0.0.0:8080启动服务</span></span><br><span class="line">	err := r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”或“表现层状态转化”。</p>
<p>推荐阅读<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">阮一峰 理解RESTful架构</a></p>
<p>简单来说，REST的含义就是客户端与Web服务器之间进行交互的时候，使用HTTP协议中的4个请求方法代表不同的动作。</p>
<ul>
<li><code>GET</code>用来获取资源</li>
<li><code>POST</code>用来新建资源</li>
<li><code>PUT</code>用来更新资源</li>
<li><code>PATCH</code>用来更新部分资源</li>
<li><code>DELETE</code>用来删除资源</li>
</ul>
<p>只要API程序遵循了REST风格，那就可以称其为RESTful API。目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。</p>
<p>例如，我们现在要编写一个会议管理系统，我们可以对会议进行查询、创建、更新和删除等操作，我们在编写程序的时候就要设计客户端浏览器与我们Web服务端交互的方式和路径。按照经验我们通常会设计成如下模式：</p>
<table>
<thead>
<tr>
<th align="center">请求方法</th>
<th align="center">URL</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td align="center">&#x2F;meeting</td>
<td align="center">查询会议信息</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">&#x2F;create_meeting</td>
<td align="center">创建会议记录</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">&#x2F;update_meeting</td>
<td align="center">更新会议信息</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">&#x2F;delete_meeting</td>
<td align="center">删除会议信息</td>
</tr>
</tbody></table>
<p>同样的需求我们按照RESTful API设计如下：</p>
<table>
<thead>
<tr>
<th align="center">请求方法</th>
<th align="center">URL</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td align="center">&#x2F;meeting</td>
<td align="center">查询会议信息</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">&#x2F;meeting</td>
<td align="center">创建会议记录</td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="center">&#x2F;meeting</td>
<td align="center">更新会议信息</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">&#x2F;meeting</td>
<td align="center">删除会议信息</td>
</tr>
</tbody></table>
<p>Gin框架支持开发RESTful API的开发。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// GET请求，获取资源</span></span><br><span class="line">	r.GET(<span class="string">&quot;/meeting&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">		context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// POST请求，新建资源</span></span><br><span class="line">	r.POST(<span class="string">&quot;/meeting&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">		context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// PUT请求，更新资源</span></span><br><span class="line">	r.PUT(<span class="string">&quot;/meeting&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">		context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;PUT&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// PATCH请求，部分更新资源</span></span><br><span class="line">	r.PATCH(<span class="string">&quot;/meeting&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">		context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;PATCH&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DELETE请求，删除资源</span></span><br><span class="line">	r.DELETE(<span class="string">&quot;/meeting&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">		context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;DELETE&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动HTTP服务器并监听指定端口</span></span><br><span class="line">	err := r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发RESTful API的时候我们通常使用<a href="https://www.getpostman.com/">Postman</a>来作为客户端的测试工具。</p>
<h2 id="go模板语法"><a href="#go模板语法" class="headerlink" title="go模板语法"></a>go模板语法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="type">string</span></span><br><span class="line">	Gender <span class="type">string</span></span><br><span class="line">	Age    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义函数</span></span><br><span class="line">	admire := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>, gender <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> praise <span class="type">string</span></span><br><span class="line">		<span class="keyword">if</span> gender == <span class="string">&quot;男&quot;</span> &#123;</span><br><span class="line">			praise = <span class="string">&quot;真帅气!!!!!!!!&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> gender == <span class="string">&quot;女&quot;</span> &#123;</span><br><span class="line">			praise = <span class="string">&quot;真漂亮!!!!!!!!&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;invalid gender&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> name + praise, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析指定文件生成模板对象(并注册自定义函数)</span></span><br><span class="line">	tmpl, err := template.New(<span class="string">&quot;hello.tmpl&quot;</span>).Funcs(template.FuncMap&#123;<span class="string">&quot;admire&quot;</span>: admire&#125;).ParseFiles(<span class="string">&quot;./hello.tmpl&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;create template failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 利用给定数据渲染模板，并将结果写入w</span></span><br><span class="line">	user1 := UserInfo&#123;</span><br><span class="line">		Name:   <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">		Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">		Age:    <span class="number">17</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	user2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">&quot;name&quot;</span>:   <span class="string">&quot;小公主&quot;</span>,</span><br><span class="line">		<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">		<span class="string">&quot;age&quot;</span>:    <span class="number">19</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hobbylist := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;跑步&quot;</span>,</span><br><span class="line">		<span class="string">&quot;听音乐&quot;</span>,</span><br><span class="line">		<span class="string">&quot;学习&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = tmpl.Execute(w, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">&quot;user1&quot;</span>: user1,</span><br><span class="line">		<span class="string">&quot;user2&quot;</span>: user2,</span><br><span class="line">		<span class="string">&quot;hobby&quot;</span>: hobbylist,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">qianTao</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	tmpl, err := template.ParseFiles(<span class="string">&quot;./t.tmpl&quot;</span>, <span class="string">&quot;./ul.tmpl&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;create template failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	user := UserInfo&#123;</span><br><span class="line">		Name:   <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">		Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">		Age:    <span class="number">17</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	err = tmpl.Execute(w, user)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, sayHello)</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/demo&quot;</span>, qianTao)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;HTTP server failed,err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是<code>hello.tmpl</code>示例文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello &#123;&#123;.user1.Name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>性别：&#123;&#123;.user1.Gender&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：&#123;&#123;.user1.Age&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello &#123;&#123;.user2.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>性别：&#123;&#123;.user2.gender&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：&#123;&#123;.user2.age&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123;/*自定义变量*/&#125;&#125;</span><br><span class="line">&#123;&#123; $a := 100 &#125;&#125;</span><br><span class="line">&#123;&#123; $b := .user1.Age &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123;/*移除空格*/&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：&#123;&#123;- .user2.age -&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123;/*条件判断*/&#125;&#125;</span><br><span class="line">&#123;&#123; if $a&#125;&#125;</span><br><span class="line">    &#123;&#123;$a&#125;&#125;</span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">    a 不存在</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">&#123;&#123; if lt .user1.Age 18&#125;&#125;</span><br><span class="line">    未成年</span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">    上大学了</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">&#123;&#123;range $index,$hobby :=.hobby&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$index&#125;&#125;------&#123;&#123;$hobby&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">    没有爱好</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">&#123;&#123;/*with作用域*/&#125;&#125;</span><br><span class="line">&#123;&#123;with .user1&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello &#123;&#123;.Name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>性别：&#123;&#123;.Gender&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：&#123;&#123;.Age&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">&#123;&#123;index .hobby 2&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123;/*自定义函数*/&#125;&#125;</span><br><span class="line">&#123;&#123;admire .user1.Name .user1.Gender&#125;&#125;</span><br><span class="line">&#123;&#123;admire .user2.name .user2.gender&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="预定义函数"><a href="#预定义函数" class="headerlink" title="预定义函数"></a>预定义函数</h3><p>执行模板时，函数从两个函数字典中查找：首先是模板函数字典，然后是全局函数字典。一般不在模板内定义函数，而是使用Funcs方法添加函数到模板里。</p>
<p>预定义的全局函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and</span><br><span class="line">    函数返回它的第一个empty参数或者最后一个参数；</span><br><span class="line">    就是说&quot;and x y&quot;等价于&quot;if x then y else x&quot;；所有参数都会执行；</span><br><span class="line">or</span><br><span class="line">    返回第一个非empty参数或者最后一个参数；</span><br><span class="line">    亦即&quot;or x y&quot;等价于&quot;if x then x else y&quot;；所有参数都会执行；</span><br><span class="line">not</span><br><span class="line">    返回它的单个参数的布尔值的否定</span><br><span class="line">len</span><br><span class="line">    返回它的参数的整数类型长度</span><br><span class="line">index</span><br><span class="line">    执行结果为第一个参数以剩下的参数为索引/键指向的值；</span><br><span class="line">    如&quot;index x 1 2 3&quot;返回x[1][2][3]的值；每个被索引的主体必须是数组、切片或者字典。</span><br><span class="line">print</span><br><span class="line">    即fmt.Sprint</span><br><span class="line">printf</span><br><span class="line">    即fmt.Sprintf</span><br><span class="line">println</span><br><span class="line">    即fmt.Sprintln</span><br><span class="line">html</span><br><span class="line">    返回与其参数的文本表示形式等效的转义HTML。</span><br><span class="line">    这个函数在html/template中不可用。</span><br><span class="line">urlquery</span><br><span class="line">    以适合嵌入到网址查询中的形式返回其参数的文本表示的转义值。</span><br><span class="line">    这个函数在html/template中不可用。</span><br><span class="line">js</span><br><span class="line">    返回与其参数的文本表示形式等效的转义JavaScript。</span><br><span class="line">call</span><br><span class="line">    执行结果是调用第一个参数的返回值，该参数必须是函数类型，其余参数作为调用该函数的参数；</span><br><span class="line">    如&quot;call .X.Y 1 2&quot;等价于go语言里的dot.X.Y(1, 2)；</span><br><span class="line">    其中Y是函数类型的字段或者字典的值，或者其他类似情况；</span><br><span class="line">    call的第一个参数的执行结果必须是函数类型的值（和预定义函数如print明显不同）；</span><br><span class="line">    该函数类型值必须有1到2个返回值，如果有2个则后一个必须是error接口类型；</span><br><span class="line">    如果有2个返回值的方法返回的error非nil，模板执行会中断并返回给调用模板执行者该错误；</span><br></pre></td></tr></table></figure>

<h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h3><p>布尔函数会将任何类型的零值视为假，其余视为真。</p>
<p>下面是定义为函数的二元比较运算的集合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eq      如果arg1 == arg2则返回真</span><br><span class="line">ne      如果arg1 != arg2则返回真</span><br><span class="line">lt      如果arg1 &lt; arg2则返回真</span><br><span class="line">le      如果arg1 &lt;= arg2则返回真</span><br><span class="line">gt      如果arg1 &gt; arg2则返回真</span><br><span class="line">ge      如果arg1 &gt;= arg2则返回真</span><br></pre></td></tr></table></figure>

<p>为了简化多参数相等检测，eq（只有eq）可以接受2个或更多个参数，它会将第一个参数和其余参数依次比较，返回下式的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;eq arg1 arg2 arg3&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>比较函数只适用于基本类型（或重定义的基本类型，如”type Celsius float32”）。但是，整数和浮点数不能互相比较。</p>
<h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>具体示例参照以上模板语法提到的main.go文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义函数</span></span><br><span class="line">	admire := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>, gender <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> praise <span class="type">string</span></span><br><span class="line">		<span class="keyword">if</span> gender == <span class="string">&quot;男&quot;</span> &#123;</span><br><span class="line">			praise = <span class="string">&quot;真帅气!!!!!!!!&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> gender == <span class="string">&quot;女&quot;</span> &#123;</span><br><span class="line">			praise = <span class="string">&quot;真漂亮!!!!!!!!&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;invalid gender&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> name + praise, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析指定文件生成模板对象(并注册自定义函数)</span></span><br><span class="line">	tmpl, err := template.New(<span class="string">&quot;hello.tmpl&quot;</span>).Funcs(template.FuncMap&#123;<span class="string">&quot;admire&quot;</span>: admire&#125;).ParseFiles(<span class="string">&quot;./hello.tmpl&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;create template failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;admire .user1.Name .user1.Gender&#125;&#125;</span><br><span class="line">&#123;&#123;admire .user2.name .user2.gender&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板嵌套"><a href="#模板嵌套" class="headerlink" title="模板嵌套"></a>模板嵌套</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">qianTao</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	tmpl, err := template.ParseFiles(<span class="string">&quot;./t.tmpl&quot;</span>, <span class="string">&quot;./ul.tmpl&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;create template failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	user := UserInfo&#123;</span><br><span class="line">		Name:   <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">		Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">		Age:    <span class="number">17</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	err = tmpl.Execute(w, user)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>t.tmpl文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>tmpl test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试嵌套template语法<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">&#123;&#123;template &quot;ul.tmpl&quot;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">&#123;&#123;template &quot;ol.tmpl&quot;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123; define &quot;ol.tmpl&quot;&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>吃饭<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>睡觉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>打豆豆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>你好,&#123;&#123;.Name&#125;&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ul.html文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>注释<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>日志<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h3><p>main.go文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义模板</span></span><br><span class="line">	<span class="comment">//解析模板</span></span><br><span class="line">	tmpl, err := template.ParseFiles(<span class="string">&quot;./base.tmpl&quot;</span>, <span class="string">&quot;./index.tmpl&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;parse error: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	msg := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	<span class="comment">//渲染模板</span></span><br><span class="line">	err = tmpl.ExecuteTemplate(w, <span class="string">&quot;index.tmpl&quot;</span>, msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">base</span><span class="params">(w http.ResponseWriter, _ *http.Request)</span></span> &#123;</span><br><span class="line">	tmpl, err := template.ParseFiles(<span class="string">&quot;./base.tmpl&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;parse error: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	msg := <span class="string">&quot;这是base页面&quot;</span></span><br><span class="line">	<span class="comment">//渲染模板</span></span><br><span class="line">	err = tmpl.Execute(w, msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/index&quot;</span>, index)</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/base&quot;</span>, base)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:9000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;HTTP server failed,err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>base.tmpl文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>模板继承<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-css">        ;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.nav</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: burlywood;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.menu</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: cornflowerblue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;menu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content center&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;.&#125;&#125;</span><br><span class="line">        &#123;&#123;block &quot;content&quot; .&#125;&#125;</span><br><span class="line">        &#123;&#123;end&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>index.tmpl文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;/*继承根模板*/&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;template &quot;base.tmpl&quot; .&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;/*重新定义模板*/&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;define &quot;content&quot;&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是index页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们的模板名称冲突了，例如不同业务线下都定义了一个<code>index.tmpl</code>模板，我们可以通过下面两种方法来解决。</p>
<ol>
<li>在模板文件开头使用<code>&#123;&#123;define 模板名&#125;&#125;</code>语句显式的为模板命名。</li>
<li>可以把模板文件存放在<code>templates</code>文件夹下面的不同目录中，然后使用<code>template.ParseGlob(&quot;templates/**/*.tmpl&quot;)</code>解析模板。</li>
</ol>
<h3 id="模板补充"><a href="#模板补充" class="headerlink" title="模板补充"></a>模板补充</h3><h4 id="修改默认的标识符"><a href="#修改默认的标识符" class="headerlink" title="修改默认的标识符"></a>修改默认的标识符</h4><p>Go标准库的模板引擎使用的花括号<code>&#123;&#123;`和`&#125;&#125;</code>作为标识，而许多前端框架（如<code>Vue</code>和 <code>AngularJS</code>）也使用<code>&#123;&#123;`和`&#125;&#125;</code>作为标识符，所以当我们同时使用Go语言模板引擎和以上前端框架时就会出现冲突，这个时候我们需要修改标识符，修改前端的或者修改Go语言的。这里演示如何修改Go语言模板引擎默认的标识符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template.New(&quot;t.tmpl&quot;).Delims(&quot;&#123;[&quot;, &quot;]&#125;&quot;).ParseFiles(&quot;./t.tmpl&quot;)</span><br></pre></td></tr></table></figure>

<p>最后我们在渲染的时候</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;自定义模板函数&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;姓名: &#123;[.Name]&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;性别: &#123;[.Gender]&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;年龄: &#123;[.Age]&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="text-template与html-tempalte的区别"><a href="#text-template与html-tempalte的区别" class="headerlink" title="text&#x2F;template与html&#x2F;tempalte的区别"></a>text&#x2F;template与html&#x2F;tempalte的区别</h4><p><code>html/template</code>针对的是需要返回HTML内容的场景，在模板渲染过程中会对一些有风险的内容进行转义，以此来防范跨站脚本攻击（XSS）。</p>
<p>例如，我定义下面的模板文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;.&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个时候传入一段JS代码并使用<code>html/template</code>去渲染该文件，会在页面上显示出转义后的JS内容。 </p>
<p>但是在某些场景下，我们如果相信用户输入的内容，不想转义的话，可以自行编写一个safe函数，手动返回一个<code>template.HTML</code>类型的内容。示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xss</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">	tmpl,err := template.New(<span class="string">&quot;xss.tmpl&quot;</span>).Funcs(template.FuncMap&#123;</span><br><span class="line">		<span class="string">&quot;safe&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span>template.HTML &#123;</span><br><span class="line">			<span class="keyword">return</span> template.HTML(s)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;).ParseFiles(<span class="string">&quot;./xss.tmpl&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;create template failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	jsStr := <span class="string">`&lt;script&gt;alert(&#x27;123&#x27;)&lt;/script&gt;`</span></span><br><span class="line">	err = tmpl.Execute(w, jsStr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们只需要在模板文件不需要转义的内容后面使用我们定义好的safe函数就可以了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; . | safe &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gin渲染"><a href="#Gin渲染" class="headerlink" title="Gin渲染"></a>Gin渲染</h2><p>我们首先定义一个存放模板文件的<code>templates</code>文件夹，然后在其内部按照业务分别定义一个<code>posts</code>文件夹和一个<code>users</code>文件夹。 <code>posts/index.html</code>文件的内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;define &quot;posts/index.tmpl&quot;&#125;&#125;</span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/xxx/index.css&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>posts/index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;.title |safe&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/xxx/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><code>users/index.html</code>文件的内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;define &quot;users/index.tmpl&quot;&#125;&#125;</span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>users/index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>Gin框架中使用<code>LoadHTMLGlob()</code>或者<code>LoadHTMLFiles()</code>方法进行HTML模板渲染。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;html/template&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置静态文件路由，表示以/xxx开头的静态文件都会去statics目录下找</span></span><br><span class="line">	r.Static(<span class="string">&quot;/xxx&quot;</span>, <span class="string">&quot;./statics&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置模板函数</span></span><br><span class="line">	r.SetFuncMap(template.FuncMap&#123;</span><br><span class="line">		<span class="string">&quot;safe&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> template.HTML &#123;</span><br><span class="line">			<span class="keyword">return</span> template.HTML(s)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	r.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理/posts/index请求</span></span><br><span class="line">	r.GET(<span class="string">&quot;/posts/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;posts/index.tmpl&quot;</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;title&quot;</span>: <span class="string">&quot;&lt;a href= https://uestcwxy.love&gt;wxy的博客&lt;/a&gt;&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理/users/index请求</span></span><br><span class="line">	r.GET(<span class="string">&quot;/users/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;users/index.tmpl&quot;</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;title&quot;</span>: <span class="string">&quot;https://uestcwxy.top&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动服务器</span></span><br><span class="line">	err := r.Run(<span class="string">&quot;:9000&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;服务器启动失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用模板继承"><a href="#使用模板继承" class="headerlink" title="使用模板继承"></a>使用模板继承</h3><p>Gin框架默认都是使用单模板，如果需要使用<code>block template</code>功能，可以通过<code>&quot;github.com/gin-contrib/multitemplate&quot;</code>库实现，具体示例如下：</p>
<p>首先，假设我们项目目录下的templates文件夹下有以下模板文件，其中<code>home.tmpl</code>和<code>index.tmpl</code>继承了<code>base.tmpl</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">templates</span><br><span class="line">├── includes</span><br><span class="line">│   ├── home.tmpl</span><br><span class="line">│   └── index.tmpl</span><br><span class="line">├── layouts</span><br><span class="line">│   └── base.tmpl</span><br><span class="line">└── scripts.tmpl</span><br></pre></td></tr></table></figure>

<p>然后我们定义一个<code>loadTemplates</code>函数如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadTemplates</span><span class="params">(templatesDir <span class="type">string</span>)</span></span> multitemplate.Renderer &#123;</span><br><span class="line">	<span class="comment">// 创建一个新的 multitemplate.Renderer 实例</span></span><br><span class="line">	r := multitemplate.NewRenderer()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载 layouts 目录下的模板文件</span></span><br><span class="line">	layouts, err := filepath.Glob(templatesDir + <span class="string">&quot;/layouts/*.tmpl&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载 includes 目录下的模板文件</span></span><br><span class="line">	includes, err := filepath.Glob(templatesDir + <span class="string">&quot;/includes/*.tmpl&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为 layouts/ 和 includes/ 目录生成 templates map</span></span><br><span class="line">	<span class="keyword">for</span> _, include := <span class="keyword">range</span> includes &#123;</span><br><span class="line">		<span class="comment">// 创建 layouts 的副本</span></span><br><span class="line">		layoutCopy := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(layouts))</span><br><span class="line">		<span class="built_in">copy</span>(layoutCopy, layouts)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将 layouts 和 include 组合成一个文件切片</span></span><br><span class="line">		files := <span class="built_in">append</span>(layoutCopy, include)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将文件切片添加到 multitemplate.Renderer 实例中</span></span><br><span class="line">		r.AddFromFiles(filepath.Base(include), files...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>main</code>函数中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexFunc</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 渲染 index.tmpl 模板并返回给客户端</span></span><br><span class="line">	c.HTML(http.StatusOK, <span class="string">&quot;index.tmpl&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">homeFunc</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 渲染 home.tmpl 模板并返回给客户端</span></span><br><span class="line">	c.HTML(http.StatusOK, <span class="string">&quot;home.tmpl&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个默认的 Gin 引擎实例</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件，并将返回的 multitemplate.Renderer 实例赋值给 Gin 引擎的 HTMLRender 字段</span></span><br><span class="line">	r.HTMLRender = loadTemplates(<span class="string">&quot;./templates&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置路由处理函数，处理 /index 请求</span></span><br><span class="line">	r.GET(<span class="string">&quot;/index&quot;</span>, indexFunc)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置路由处理函数，处理 /home 请求</span></span><br><span class="line">	r.GET(<span class="string">&quot;/home&quot;</span>, homeFunc)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动服务器，监听默认端口</span></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充文件路径处理"><a href="#补充文件路径处理" class="headerlink" title="补充文件路径处理"></a>补充文件路径处理</h3><p>关于模板文件和静态文件的路径，我们需要根据公司&#x2F;项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCurrentPath</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 获取可执行文件的路径</span></span><br><span class="line">	<span class="keyword">if</span> ex, err := os.Executable(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 返回可执行文件的目录路径</span></span><br><span class="line">		<span class="keyword">return</span> filepath.Dir(ex)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果获取路径失败，则返回当前目录路径</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;./&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSON渲染"><a href="#JSON渲染" class="headerlink" title="JSON渲染"></a>JSON渲染</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">	r.GET(<span class="string">&quot;/someJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">			<span class="string">&quot;name&quot;</span>:    <span class="string">&quot;wxy&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/moreJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 方法二：使用结构体</span></span><br><span class="line">		<span class="keyword">type</span> msg <span class="keyword">struct</span> &#123;</span><br><span class="line">			Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">			Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">			Age     <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">		&#125;</span><br><span class="line">		data := msg&#123;<span class="string">&quot;121&quot;</span>, <span class="string">&quot;hh&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">		c.JSON(http.StatusOK, data)</span><br><span class="line">	&#125;)</span><br><span class="line">	err := r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XML渲染"><a href="#XML渲染" class="headerlink" title="XML渲染"></a>XML渲染</h3><p>注意需要使用具名的结构体类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">	r.GET(<span class="string">&quot;/someXML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">		c.XML(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.GET(<span class="string">&quot;/moreXML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 方法二：使用结构体</span></span><br><span class="line">		<span class="keyword">type</span> MessageRecord <span class="keyword">struct</span> &#123;</span><br><span class="line">			Name    <span class="type">string</span></span><br><span class="line">			Message <span class="type">string</span></span><br><span class="line">			Age     <span class="type">int</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> msg MessageRecord</span><br><span class="line">		msg.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">		msg.Message = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">		msg.Age = <span class="number">18</span></span><br><span class="line">		c.XML(http.StatusOK, msg)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="YMAL渲染"><a href="#YMAL渲染" class="headerlink" title="YMAL渲染"></a>YMAL渲染</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/someYAML&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.YAML(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;status&quot;</span>: http.StatusOK&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="protobuf渲染"><a href="#protobuf渲染" class="headerlink" title="protobuf渲染"></a>protobuf渲染</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/someProtoBuf&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	reps := []<span class="type">int64</span>&#123;<span class="type">int64</span>(<span class="number">1</span>), <span class="type">int64</span>(<span class="number">2</span>)&#125;</span><br><span class="line">	label := <span class="string">&quot;test&quot;</span></span><br><span class="line">	<span class="comment">// protobuf 的具体定义写在 testdata/protoexample 文件中。</span></span><br><span class="line">	data := &amp;protoexample.Test&#123;</span><br><span class="line">		Label: &amp;label,</span><br><span class="line">		Reps:  reps,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 请注意，数据在响应中变为二进制数据</span></span><br><span class="line">	<span class="comment">// 将输出被 protoexample.Test protobuf 序列化了的数据</span></span><br><span class="line">	c.ProtoBuf(http.StatusOK, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><h3 id="获取querystring参数"><a href="#获取querystring参数" class="headerlink" title="获取querystring参数"></a>获取querystring参数</h3><p><code>querystring</code>指的是URL中<code>?</code>后面携带的参数，例如：<code>/user/search?username=wxy&amp;address=沙河校区</code>。 获取请求的querystring参数的方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/user/search&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		username := c.DefaultQuery(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;wxy&quot;</span>)</span><br><span class="line">		<span class="comment">//username := c.Query(&quot;username&quot;)</span></span><br><span class="line">		address := c.Query(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">		<span class="comment">//输出json结果给调用方</span></span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">			<span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">			<span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	err := r.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取form参数"><a href="#获取form参数" class="headerlink" title="获取form参数"></a>获取form参数</h3><p>当前端请求的数据通过form表单提交时，例如向<code>/user/search</code>发送一个POST请求，获取请求数据的方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.POST(<span class="string">&quot;/user/search&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// DefaultPostForm取不到值时会返回指定的默认值</span></span><br><span class="line">		<span class="comment">//username := c.DefaultPostForm(&quot;username&quot;, &quot;wxy&quot;)</span></span><br><span class="line">		username, ok := c.GetPostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			username = <span class="string">&quot;hhh&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//username := c.PostForm(&quot;username&quot;)</span></span><br><span class="line">		address := c.PostForm(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">		<span class="comment">//输出json结果给调用方</span></span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">			<span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">			<span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	err := r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取json参数"><a href="#获取json参数" class="headerlink" title="获取json参数"></a>获取json参数</h3><p>当前端请求的数据通过JSON提交时，例如向<code>/json</code>发送一个POST请求，则获取请求参数的方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意：下面为了举例子方便，暂时忽略了错误处理</span></span><br><span class="line">	b, _ := c.GetRawData()  <span class="comment">// 从c.Request.Body读取请求数据</span></span><br><span class="line">	<span class="comment">// 定义map或结构体</span></span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 反序列化</span></span><br><span class="line">	_ = json.Unmarshal(b, &amp;m)</span><br><span class="line"></span><br><span class="line">	c.JSON(http.StatusOK, m)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>更便利的获取请求参数的方式，参见下面的<strong>参数绑定</strong>小节。</p>
<h3 id="获取path参数"><a href="#获取path参数" class="headerlink" title="获取path参数"></a>获取path参数</h3><p>请求的参数通过URL路径传递，例如：<code>/user/search/wxy/沙河校区</code>。 获取请求URL路径中的参数的方式如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/user/search/:username/:address&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		username := c.Param(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">		address := c.Param(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">		<span class="comment">//输出json结果给调用方</span></span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">			<span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">			<span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	err := r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的<code>Content-Type</code>识别请求数据类型并利用反射机制自动提取请求中<code>QueryString</code>、<code>form表单</code>、<code>JSON</code>、<code>XML</code>等参数到结构体中。 下面的示例代码演示了<code>.ShouldBind()</code>强大的功能，它能够基于请求自动提取<code>JSON</code>、<code>form表单</code>和<code>QueryString</code>类型的数据，并把值绑定到指定的结构体对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Login 结构体用于绑定JSON数据</span></span><br><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">	User     <span class="type">string</span> <span class="string">`form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;`</span></span><br><span class="line">	Password <span class="type">string</span> <span class="string">`form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理绑定JSON的示例请求 (&#123;&quot;user&quot;: &quot;wxy&quot;, &quot;password&quot;: &quot;123456&quot;&#125;)</span></span><br><span class="line">	r.POST(<span class="string">&quot;/loginJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> login Login</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将请求中的JSON数据绑定到Login结构体</span></span><br><span class="line">		<span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;登录信息：%#v\n&quot;</span>, login)</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;user&quot;</span>:     login.User,</span><br><span class="line">				<span class="string">&quot;password&quot;</span>: login.Password,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理绑定form表单的示例请求 (user=q1mi&amp;password=123456)</span></span><br><span class="line">	r.POST(<span class="string">&quot;/loginForm&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> login Login</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据请求的Content-Type自动选择绑定器进行绑定</span></span><br><span class="line">		<span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;user&quot;</span>:     login.User,</span><br><span class="line">				<span class="string">&quot;password&quot;</span>: login.Password,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理绑定QueryString的示例请求 (/loginQuery?user=q1mi&amp;password=123456)</span></span><br><span class="line">	r.GET(<span class="string">&quot;/loginForm&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> login Login</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据请求的Content-Type自动选择绑定器进行绑定</span></span><br><span class="line">		<span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;user&quot;</span>:     login.User,</span><br><span class="line">				<span class="string">&quot;password&quot;</span>: login.Password,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在0.0.0.0:8080上提供服务</span></span><br><span class="line">	err := r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ShouldBind</code> 函数会根据请求的方法和内容类型选择适当的绑定引擎进行数据绑定。对于 <code>GET</code> 请求，只使用查询参数绑定；对于 <code>POST</code> 请求，优先考虑 JSON 或 XML 数据绑定，如果不是 JSON 或 XML，则使用表单数据绑定。这样可以方便地将请求中的数据解析并绑定到结构体中，以便在处理请求时使用这些数据。</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="单个文件上传"><a href="#单个文件上传" class="headerlink" title="单个文件上传"></a>单个文件上传</h3><p>文件上传前端页面代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>后端gin框架部分代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	<span class="comment">// 处理multipart forms提交文件时默认的内存限制是32 MiB</span></span><br><span class="line">	<span class="comment">// 可以通过下面的方式修改</span></span><br><span class="line">	<span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">	router.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 单个文件</span></span><br><span class="line">		file, err := c.FormFile(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusInternalServerError, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;message&quot;</span>: err.Error(),</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		log.Println(file.Filename)</span><br><span class="line">		dst := fmt.Sprintf(<span class="string">&quot;C:/tmp/%s&quot;</span>, file.Filename)</span><br><span class="line">		<span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">		c.SaveUploadedFile(file, dst)</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: fmt.Sprintf(<span class="string">&quot;&#x27;%s&#x27; uploaded!&quot;</span>, file.Filename),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	router.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个文件上传"><a href="#多个文件上传" class="headerlink" title="多个文件上传"></a>多个文件上传</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	<span class="comment">// 处理multipart forms提交文件时默认的内存限制是32 MiB</span></span><br><span class="line">	<span class="comment">// 可以通过下面的方式修改</span></span><br><span class="line">	<span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">	router.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// Multipart form</span></span><br><span class="line">		form, _ := c.MultipartForm()</span><br><span class="line">		files := form.File[<span class="string">&quot;file&quot;</span>]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> index, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">			log.Println(file.Filename)</span><br><span class="line">			dst := fmt.Sprintf(<span class="string">&quot;./upload/%s_%d&quot;</span>, file.Filename, index)</span><br><span class="line">			<span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">			c.SaveUploadedFile(file, dst)</span><br><span class="line">		&#125;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: fmt.Sprintf(<span class="string">&quot;%d files uploaded!&quot;</span>, <span class="built_in">len</span>(files)),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	router.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h3><p>HTTP 重定向很容易。 内部、外部重定向均支持。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.Redirect(http.StatusMovedPermanently, <span class="string">&quot;https://www.baidu.com/&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// Listen and serve on 0.0.0.0:8080</span></span><br><span class="line">	err := r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>路由重定向，使用<code>HandleContext</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 指定重定向的URL</span></span><br><span class="line">		c.Request.URL.Path = <span class="string">&quot;/test2&quot;</span></span><br><span class="line">		r.HandleContext(c)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.GET(<span class="string">&quot;/test2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// Listen and serve on 0.0.0.0:8080</span></span><br><span class="line">	err := r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gin路由"><a href="#Gin路由" class="headerlink" title="Gin路由"></a>Gin路由</h2><h3 id="普通路由"><a href="#普通路由" class="headerlink" title="普通路由"></a>普通路由</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">r.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure>

<p>此外，还有一个可以匹配所有请求方法的<code>Any</code>方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.Any(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> c.Request.Method &#123;</span><br><span class="line">		<span class="keyword">case</span> http.MethodGet:</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;method&quot;</span>: http.MethodGet&#125;)</span><br><span class="line">		<span class="keyword">case</span> http.MethodPost:</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;method&quot;</span>: http.MethodPost&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	err := r.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为没有配置处理函数的路由添加处理程序，默认情况下它返回404代码，下面的代码为没有匹配到路由的请求都返回<code>views/404.html</code>页面。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusNotFound, <span class="string">&quot;views/404.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><p>我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对<code>&#123;&#125;</code>包裹同组的路由，这只是为了看着清晰，你用不用<code>&#123;&#125;</code>包裹功能上没什么区别。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	userGroup := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		userGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">		userGroup.GET(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">		userGroup.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">		shopGroup.GET(<span class="string">&quot;/cart&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">		shopGroup.POST(<span class="string">&quot;/checkout&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	err := r.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由组也是支持嵌套的，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">		shopGroup.GET(<span class="string">&quot;/cart&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">		shopGroup.POST(<span class="string">&quot;/checkout&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">		<span class="comment">// 嵌套路由组</span></span><br><span class="line">		xx := shopGroup.Group(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">		xx.GET(<span class="string">&quot;/oo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>通常我们将路由分组用在划分业务逻辑或划分API版本时。</p>
<h3 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h3><p>Gin框架的路由原理是使用前缀树的方式实现的动态路由。它使用了定制版本的httprouter，其路由原理是大量使用公共前缀的树结构，基本上是一个紧凑的Trie tree（或者只是Radix Tree）。</p>
<h2 id="Gin中间件"><a href="#Gin中间件" class="headerlink" title="Gin中间件"></a>Gin中间件</h2><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p>
<h3 id="定义中间件"><a href="#定义中间件" class="headerlink" title="定义中间件"></a>定义中间件</h3><p>Gin中的中间件必须是一个<code>gin.HandlerFunc</code>类型。</p>
<h4 id="记录接口耗时的中间件"><a href="#记录接口耗时的中间件" class="headerlink" title="记录接口耗时的中间件"></a>记录接口耗时的中间件</h4><p>例如我们像下面的代码一样定义一个统计请求耗时的中间件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StatCost 是一个统计耗时请求耗时的中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StatCost</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		c.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wxy&quot;</span>) <span class="comment">// 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值</span></span><br><span class="line">		<span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">		c.Next()</span><br><span class="line">		<span class="comment">// 不调用该请求的剩余处理程序</span></span><br><span class="line">		<span class="comment">// c.Abort()</span></span><br><span class="line">		<span class="comment">// 计算耗时</span></span><br><span class="line">		cost := time.Since(start)</span><br><span class="line">		log.Println(cost)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="记录响应体的中间件"><a href="#记录响应体的中间件" class="headerlink" title="记录响应体的中间件"></a>记录响应体的中间件</h4><p>我们有时候可能会想要记录下某些情况下返回给客户端的响应数据，这个时候就可以编写一个中间件来搞定。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bodyLogWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	gin.ResponseWriter               <span class="comment">// 嵌入gin框架ResponseWriter</span></span><br><span class="line">	body               *bytes.Buffer <span class="comment">// 我们记录用的response</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write 写入响应体数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w bodyLogWriter)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	w.body.Write(b)                  <span class="comment">// 我们记录一份</span></span><br><span class="line">	<span class="keyword">return</span> w.ResponseWriter.Write(b) <span class="comment">// 真正写入响应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ginBodyLogMiddleware 一个记录返回给客户端响应体的中间件</span></span><br><span class="line"><span class="comment">// https://stackoverflow.com/questions/38501325/how-to-log-response-body-in-gin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ginBodyLogMiddleware</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	blw := &amp;bodyLogWriter&#123;body: bytes.NewBuffer([]<span class="type">byte</span>&#123;&#125;), ResponseWriter: c.Writer&#125;</span><br><span class="line">	c.Writer = blw <span class="comment">// 使用我们自定义的类型替换默认的</span></span><br><span class="line"></span><br><span class="line">	c.Next() <span class="comment">// 执行业务逻辑</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Response body: &quot;</span> + blw.body.String()) <span class="comment">// 事后按需记录返回的响应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跨域中间件cors"><a href="#跨域中间件cors" class="headerlink" title="跨域中间件cors"></a>跨域中间件cors</h4><p>推荐使用社区的<a href="https://github.com/gin-contrib/cors">https://github.com/gin-contrib/cors</a> 库，一行代码解决前后端分离架构下的跨域问题。</p>
<p><strong>注意：</strong> 该中间件需要注册在业务处理函数前面。</p>
<p>这个库支持各种常用的配置项，具体使用方法如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-contrib/cors&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  router := gin.Default()</span><br><span class="line">  <span class="comment">// CORS for https://foo.com and https://github.com origins, allowing:</span></span><br><span class="line">  <span class="comment">// - PUT and PATCH methods</span></span><br><span class="line">  <span class="comment">// - Origin header</span></span><br><span class="line">  <span class="comment">// - Credentials share</span></span><br><span class="line">  <span class="comment">// - Preflight requests cached for 12 hours</span></span><br><span class="line">  router.Use(cors.New(cors.Config&#123;</span><br><span class="line">    AllowOrigins:     []<span class="type">string</span>&#123;<span class="string">&quot;https://foo.com&quot;</span>&#125;,  <span class="comment">// 允许跨域发来请求的网站</span></span><br><span class="line">    AllowMethods:     []<span class="type">string</span>&#123;<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>,  <span class="string">&quot;OPTIONS&quot;</span>&#125;,  <span class="comment">// 允许的请求方法</span></span><br><span class="line">    AllowHeaders:     []<span class="type">string</span>&#123;<span class="string">&quot;Origin&quot;</span>, <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>&#125;,</span><br><span class="line">    ExposeHeaders:    []<span class="type">string</span>&#123;<span class="string">&quot;Content-Length&quot;</span>&#125;,</span><br><span class="line">    AllowCredentials: <span class="literal">true</span>,</span><br><span class="line">    AllowOriginFunc: <span class="function"><span class="keyword">func</span><span class="params">(origin <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;  <span class="comment">// 自定义过滤源站的方法</span></span><br><span class="line">      <span class="keyword">return</span> origin == <span class="string">&quot;https://github.com&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    MaxAge: <span class="number">12</span> * time.Hour,</span><br><span class="line">  &#125;))</span><br><span class="line">  router.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你可以简单的像下面的示例代码那样使用默认配置，允许所有的跨域请求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  router := gin.Default()</span><br><span class="line">  <span class="comment">// same as</span></span><br><span class="line">  <span class="comment">// config := cors.DefaultConfig()</span></span><br><span class="line">  <span class="comment">// config.AllowAllOrigins = true</span></span><br><span class="line">  <span class="comment">// router.Use(cors.New(config))</span></span><br><span class="line">  router.Use(cors.Default())</span><br><span class="line">  router.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h3><p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p>
<h4 id="为全局路由注册"><a href="#为全局路由注册" class="headerlink" title="为全局路由注册"></a>为全局路由注册</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">	r := gin.New()</span><br><span class="line">	<span class="comment">// 注册一个全局中间件</span></span><br><span class="line">	r.Use(StatCost())</span><br><span class="line">	</span><br><span class="line">	r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		name := c.MustGet(<span class="string">&quot;name&quot;</span>).(<span class="type">string</span>) <span class="comment">// 从上下文取值</span></span><br><span class="line">		log.Println(name)</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为某个路由单独注册"><a href="#为某个路由单独注册" class="headerlink" title="为某个路由单独注册"></a>为某个路由单独注册</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给/test2路由单独注册中间件（可注册多个）</span></span><br><span class="line">	r.GET(<span class="string">&quot;/test2&quot;</span>, StatCost(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		name := c.MustGet(<span class="string">&quot;name&quot;</span>).(<span class="type">string</span>) <span class="comment">// 从上下文取值</span></span><br><span class="line">		log.Println(name)</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="为路由组注册中间件"><a href="#为路由组注册中间件" class="headerlink" title="为路由组注册中间件"></a>为路由组注册中间件</h4><p>为路由组注册中间件有以下两种写法。</p>
<p>写法1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>, StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法2：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">shopGroup.Use(StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中间件注意事项"><a href="#中间件注意事项" class="headerlink" title="中间件注意事项"></a>中间件注意事项</h3><h4 id="gin默认中间件"><a href="#gin默认中间件" class="headerlink" title="gin默认中间件"></a>gin默认中间件</h4><p><code>gin.Default()</code>默认使用了<code>Logger</code>和<code>Recovery</code>中间件，其中：</p>
<ul>
<li><code>Logger</code>中间件将日志写入<code>gin.DefaultWriter</code>，即使配置了<code>GIN_MODE=release</code>。</li>
<li><code>Recovery</code>中间件会recover任何<code>panic</code>。如果有panic的话，会写入500响应码。</li>
</ul>
<p>如果不想使用上面两个默认的中间件，可以使用<code>gin.New()</code>新建一个没有任何默认中间件的路由。</p>
<h4 id="gin中间件中使用goroutine"><a href="#gin中间件中使用goroutine" class="headerlink" title="gin中间件中使用goroutine"></a>gin中间件中使用goroutine</h4><p>当在中间件或<code>handler</code>中启动新的<code>goroutine</code>时，<strong>不能使用</strong>原始的上下文（c *gin.Context），必须使用其只读副本（<code>c.Copy()</code>）。</p>
<h2 id="运行多个服务"><a href="#运行多个服务" class="headerlink" title="运行多个服务"></a>运行多个服务</h2><p>我们可以在多个端口启动服务，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	g errgroup.Group</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">router01</span><span class="params">()</span></span> http.Handler &#123;</span><br><span class="line">	e := gin.New()</span><br><span class="line">	e.Use(gin.Recovery())</span><br><span class="line">	e.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(</span><br><span class="line">			http.StatusOK,</span><br><span class="line">			gin.H&#123;</span><br><span class="line">				<span class="string">&quot;code&quot;</span>:  http.StatusOK,</span><br><span class="line">				<span class="string">&quot;error&quot;</span>: <span class="string">&quot;Welcome server 01&quot;</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">router02</span><span class="params">()</span></span> http.Handler &#123;</span><br><span class="line">	e := gin.New()</span><br><span class="line">	e.Use(gin.Recovery())</span><br><span class="line">	e.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(</span><br><span class="line">			http.StatusOK,</span><br><span class="line">			gin.H&#123;</span><br><span class="line">				<span class="string">&quot;code&quot;</span>:  http.StatusOK,</span><br><span class="line">				<span class="string">&quot;error&quot;</span>: <span class="string">&quot;Welcome server 02&quot;</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server01 := &amp;http.Server&#123;</span><br><span class="line">		Addr:         <span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">		Handler:      router01(),</span><br><span class="line">		ReadTimeout:  <span class="number">5</span> * time.Second,</span><br><span class="line">		WriteTimeout: <span class="number">10</span> * time.Second,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server02 := &amp;http.Server&#123;</span><br><span class="line">		Addr:         <span class="string">&quot;:8081&quot;</span>,</span><br><span class="line">		Handler:      router02(),</span><br><span class="line">		ReadTimeout:  <span class="number">5</span> * time.Second,</span><br><span class="line">		WriteTimeout: <span class="number">10</span> * time.Second,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 借助 errgroup.Group 或者自行开启两个 goroutine 分别启动两个服务</span></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 启动 server01 服务</span></span><br><span class="line">		<span class="keyword">return</span> server01.ListenAndServe()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 启动 server02 服务</span></span><br><span class="line">		<span class="keyword">return</span> server02.ListenAndServe()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待所有 goroutine 完成，并返回可能发生的错误</span></span><br><span class="line">	<span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考<a href="https://www.liwenzhou.com/">李文周的博客</a>进行整理</p>
]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Gorm（结合官方文档）</title>
    <url>/2023/07/16/Go/27/</url>
    <content><![CDATA[<h1 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h1><h2 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h2><p>Object Relational Mapping：对象关系映射</p>
<p>结构体 和 SQL数据库存在映射，这个时候就有了ORM语句</p>
<p>一句话说：就是将数据库中的表数据和结构体进行对应的关系</p>
<h2 id="ORM的优缺点"><a href="#ORM的优缺点" class="headerlink" title="ORM的优缺点"></a>ORM的优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li>提高开发效率</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>牺牲执行性能【中间多了一个环节】</li>
<li>牺牲灵活性</li>
<li>弱化SQL能力</li>
</ul>
<h2 id="gorm介绍"><a href="#gorm介绍" class="headerlink" title="gorm介绍"></a>gorm介绍</h2><p><a href="https://gitee.com/link?target=https://gorm.io/zh_CN/">中文官方网站</a>内含十分齐全的中文文档，有了它你甚至不需要再继续向下阅读本文。</p>
<p>gorm是一个使用Go语言编写的ORM框架。它文档齐全，对开发者友好，支持主流数据库。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u gorm.io/gorm</span><br><span class="line">go get -u gorm.io/driver/mysql</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>GORM 的开发已经迁移至 <a href="https://github.com/go-gorm">github.com&#x2F;go-gorm</a>，import 路径也修改为 <code>gorm.io/gorm</code> ，对于以前的项目，您可以继续使用 <code>github.com/jinzhu/gorm</code> </li>
<li>数据库驱动被拆分为独立的项目，例如：<a href="https://github.com/go-gorm/mysql">github.com&#x2F;go-gorm&#x2F;mysql</a>，且它的 import 路径也变更为 <code>gorm.io/driver/mysql</code></li>
</ul>
<h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dsn := <span class="string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">	db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;failed to connect database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>想要正确的处理 <code>time.Time</code> ，您需要带上 <code>parseTime</code> 参数， (<a href="https://github.com/go-sql-driver/mysql#parameters">更多参数</a>) 要支持完整的 UTF-8 编码，您需要将 <code>charset=utf8</code> 更改为 <code>charset=utf8mb4</code> 查看 <a href="https://mathiasbynens.be/notes/mysql-utf8mb4">此文章</a> 获取详情。</p>
</blockquote>
<h2 id="GORM基本示例"><a href="#GORM基本示例" class="headerlink" title="GORM基本示例"></a>GORM基本示例</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>在使用GORM前手动创建数据库<code>gorm</code>，推荐使用图形化数据库管理软件，例如<a href="https://navicat.com.cn/products">Navicat</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE gorm;</span><br></pre></td></tr></table></figure>

<h3 id="GORM操作MySQL"><a href="#GORM操作MySQL" class="headerlink" title="GORM操作MySQL"></a>GORM操作MySQL</h3><p>使用GORM连接上面的<code>gorm</code>进行创建、查询、更新、删除操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo 用户信息</span></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="type">uint</span></span><br><span class="line">	Name   <span class="type">string</span></span><br><span class="line">	Gender <span class="type">string</span></span><br><span class="line">	Hobby  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dsn := <span class="string">&quot;root:@tcp(127.0.0.1:3306)/gorm?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">	db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;failed to connect database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动迁移</span></span><br><span class="line">	err = db.AutoMigrate(&amp;UserInfo&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;failed to migrate&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	u1 := UserInfo&#123;<span class="number">1</span>, <span class="string">&quot;杨洋&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;篮球&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建记录</span></span><br><span class="line">	db.Create(&amp;u1)</span><br><span class="line">	db.Create(&amp;UserInfo&#123;<span class="number">2</span>, <span class="string">&quot;王楚然&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;足球&quot;</span>&#125;)</span><br><span class="line">	<span class="comment">// 查询</span></span><br><span class="line">	<span class="keyword">var</span> u = <span class="built_in">new</span>(UserInfo)</span><br><span class="line">	db.First(&amp;u, <span class="number">1</span>) <span class="comment">// 根据整型主键查找</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, u)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> uu UserInfo</span><br><span class="line">	db.First(&amp;uu, <span class="string">&quot;hobby=?&quot;</span>, <span class="string">&quot;足球&quot;</span>) <span class="comment">//查找 hobby 字段值为 足球 的记录</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, uu)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新</span></span><br><span class="line">	db.Model(&amp;u).Update(<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;排球&quot;</span>)</span><br><span class="line">	<span class="comment">//Update - 更新多个字段</span></span><br><span class="line">	db.Model(&amp;u).Updates(UserInfo&#123;Name: <span class="string">&quot;肖战&quot;</span>, Hobby: <span class="string">&quot;跳舞&quot;</span>&#125;) <span class="comment">// 仅更新非零值字段</span></span><br><span class="line">	db.Model(&amp;uu).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Hobby&quot;</span>: <span class="string">&quot;演戏&quot;</span>, <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;赵丽颖&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	db.Delete(&amp;u, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GORM-Model定义"><a href="#GORM-Model定义" class="headerlink" title="GORM Model定义"></a>GORM Model定义</h2><p>在使用ORM工具时，通常我们需要在代码中定义模型（Models）与数据库中的数据表进行映射，在GORM中模型（Models）通常是正常定义的结构体、基本的go类型或它们的指针。 同时也支持<code>sql.Scanner</code>及<code>driver.Valuer</code>接口（interfaces）。</p>
<h3 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h3><p>为了方便模型定义，GORM内置了一个<code>gorm.Model</code>结构体。<code>gorm.Model</code>是一个包含了<code>ID</code>, <code>CreatedAt</code>, <code>UpdatedAt</code>, <code>DeletedAt</code>四个字段的Golang结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gorm.Model 定义</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt *time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以将它嵌入到你自己的模型中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`字段注入到`User`模型中</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过标签 <code>embedded</code> 将其嵌入，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Author <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Author  Author <span class="string">`gorm:&quot;embedded&quot;`</span></span><br><span class="line">  Upvotes <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID    <span class="type">int64</span></span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">  Email <span class="type">string</span></span><br><span class="line">  Upvotes  <span class="type">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用标签 <code>embeddedPrefix</code> 来为 db 中的字段名添加前缀，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Author  Author <span class="string">`gorm:&quot;embedded;embeddedPrefix:author_&quot;`</span></span><br><span class="line">  Upvotes <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID          <span class="type">int64</span></span><br><span class="line">  AuthorName <span class="type">string</span></span><br><span class="line">  AuthorEmail <span class="type">string</span></span><br><span class="line">  Upvotes     <span class="type">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以完全自己定义模型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用gorm.Model，自行定义模型</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模型定义示例"><a href="#模型定义示例" class="headerlink" title="模型定义示例"></a>模型定义示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name         <span class="type">string</span></span><br><span class="line">  Age          sql.NullInt64	<span class="comment">//零值类型</span></span><br><span class="line">  Birthday     *time.Time</span><br><span class="line">  Email        <span class="type">string</span>  <span class="string">`gorm:&quot;type:varchar(100);unique_index&quot;`</span></span><br><span class="line">  Role         <span class="type">string</span>  <span class="string">`gorm:&quot;size:255&quot;`</span> <span class="comment">// 设置字段大小为255</span></span><br><span class="line">  MemberNumber *<span class="type">string</span> <span class="string">`gorm:&quot;unique;not null&quot;`</span> <span class="comment">// 设置会员号（member number）唯一并且不为空</span></span><br><span class="line">  Num          <span class="type">int</span>     <span class="string">`gorm:&quot;AUTO_INCREMENT&quot;`</span> <span class="comment">// 设置 num 为自增类型</span></span><br><span class="line">  Address      <span class="type">string</span>  <span class="string">`gorm:&quot;index:addr&quot;`</span> <span class="comment">// 给address字段创建名为addr的索引</span></span><br><span class="line">  IgnoreMe     <span class="type">int</span>     <span class="string">`gorm:&quot;-&quot;`</span> <span class="comment">// 忽略本字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GORM 倾向于约定优于配置 默认情况下，GORM 使用 <code>ID</code> 作为主键，使用结构体名的 <code>蛇形复数</code> 作为表名，字段名的 <code>蛇形</code> 作为列名，并使用 <code>CreatedAt</code>、<code>UpdatedAt</code> 字段追踪创建、更新时间。</p>
<p>如果您遵循 GORM 的约定，您就可以少写的配置、代码。 如果约定不符合您的实际要求，<a href="https://gorm.io/zh_CN/docs/conventions.html">GORM 允许你配置它们</a></p>
<h3 id="结构体标记（tags）"><a href="#结构体标记（tags）" class="headerlink" title="结构体标记（tags）"></a>结构体标记（tags）</h3><p>声明 model 时，tag 是可选的，GORM 支持以下 tag： tag 名大小写不敏感，但建议使用 <code>camelCase</code> 风格</p>
<h4 id="支持的结构体标记（Struct-tags）"><a href="#支持的结构体标记（Struct-tags）" class="headerlink" title="支持的结构体标记（Struct tags）"></a>支持的结构体标记（Struct tags）</h4><table>
<thead>
<tr>
<th align="center">标签名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">column</td>
<td align="center">指定 db 列名</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td>
</tr>
<tr>
<td align="center">serializer</td>
<td align="center">指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td>
</tr>
<tr>
<td align="center">size</td>
<td align="center">定义列数据类型的大小或长度，例如 <code>size: 256</code></td>
</tr>
<tr>
<td align="center">primaryKey</td>
<td align="center">将列定义为主键</td>
</tr>
<tr>
<td align="center">unique</td>
<td align="center">将列定义为唯一键</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">定义列的默认值</td>
</tr>
<tr>
<td align="center">precision</td>
<td align="center">指定列的精度</td>
</tr>
<tr>
<td align="center">scale</td>
<td align="center">指定列大小</td>
</tr>
<tr>
<td align="center">not null</td>
<td align="center">指定列为 NOT NULL</td>
</tr>
<tr>
<td align="center">autoIncrement</td>
<td align="center">指定列为自动增长</td>
</tr>
<tr>
<td align="center">autoIncrementIncrement</td>
<td align="center">自动步长，控制连续记录之间的间隔</td>
</tr>
<tr>
<td align="center">embedded</td>
<td align="center">嵌套字段</td>
</tr>
<tr>
<td align="center">embeddedPrefix</td>
<td align="center">嵌入字段的列名前缀</td>
</tr>
</tbody></table>
<h4 id="关联相关标记（tags）"><a href="#关联相关标记（tags）" class="headerlink" title="关联相关标记（tags）"></a>关联相关标记（tags）</h4><table>
<thead>
<tr>
<th align="left">标签</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">foreignKey</td>
<td align="left">指定当前模型的列作为连接表的外键</td>
</tr>
<tr>
<td align="left">references</td>
<td align="left">指定引用表的列名，其将被映射为连接表外键</td>
</tr>
<tr>
<td align="left">polymorphic</td>
<td align="left">指定多态类型，比如模型名</td>
</tr>
<tr>
<td align="left">polymorphicValue</td>
<td align="left">指定多态值、默认表名</td>
</tr>
<tr>
<td align="left">many2many</td>
<td align="left">指定连接表表名</td>
</tr>
<tr>
<td align="left">joinForeignKey</td>
<td align="left">指定连接表的外键列名，其将被映射到当前表</td>
</tr>
<tr>
<td align="left">joinReferences</td>
<td align="left">指定连接表的外键列名，其将被映射到引用表</td>
</tr>
<tr>
<td align="left">constraint</td>
<td align="left">关系约束，例如：<code>OnUpdate</code>、<code>OnDelete</code></td>
</tr>
</tbody></table>
<h2 id="主键、表名、列名的约定"><a href="#主键、表名、列名的约定" class="headerlink" title="主键、表名、列名的约定"></a>主键、表名、列名的约定</h2><h3 id="主键（Primary-Key）"><a href="#主键（Primary-Key）" class="headerlink" title="主键（Primary Key）"></a>主键（Primary Key）</h3><p>GORM 默认会使用名为ID的字段作为表的主键。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">string</span> <span class="comment">// 名为`ID`的字段会默认作为表的主键</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用`AnimalID`作为主键</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  AnimalID <span class="type">int64</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">  Name     <span class="type">string</span></span><br><span class="line">  Age      <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复数表名（Table-Name）"><a href="#复数表名（Table-Name）" class="headerlink" title="复数表名（Table Name）"></a>复数表名（Table Name）</h3><p>GORM 使用结构体名的 <code>蛇形命名</code> 作为表名。对于结构体 <code>User</code>，根据约定，其表名为 <code>users</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;&#125; <span class="comment">// 默认表名是 `users`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tabler <span class="keyword">interface</span> &#123;</span><br><span class="line">    TableName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TableName 会将 User 的表名重写为 `profiles`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;profiles&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> <code>TableName</code> 不支持动态变化，它会被缓存下来以便后续使用。想要使用动态表名，你可以使用 <code>Scopes</code>，例如：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserTable</span><span class="params">(user User)</span></span> <span class="function"><span class="keyword">func</span> <span class="params">(tx *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(tx *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">    <span class="keyword">if</span> user.Admin &#123;</span><br><span class="line">      <span class="keyword">return</span> tx.Table(<span class="string">&quot;admin_users&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tx.Table(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Scopes(UserTable(user)).Create(&amp;user)</span><br></pre></td></tr></table></figure>

<p>还可以禁用默认表名的复数形式，如果置为 true，则 <code>User</code> 的默认表名是 <code>user</code>，该方法适用于v1版，也就是<code>import &quot;github.com/jinzhu/gorm&quot;</code> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.SingularTable(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>Table()</code>指定表名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 User 的字段创建 `deleted_users` 表</span></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从另一张表查询数据</span></span><br><span class="line"><span class="keyword">var</span> deletedUsers []User</span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Find(&amp;deletedUsers)</span><br><span class="line"><span class="comment">// SELECT * FROM deleted_users;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM deleted_users WHERE name = &#x27;jinzhu&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>GORM还支持更改默认表名称规则：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gorm.DefaultTableNameHandler = <span class="function"><span class="keyword">func</span> <span class="params">(db *gorm.DB, defaultTableName <span class="type">string</span>)</span></span> <span class="type">string</span>  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;prefix_&quot;</span> + defaultTableName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="列名（Column-Name）"><a href="#列名（Column-Name）" class="headerlink" title="列名（Column Name）"></a>列名（Column Name）</h3><p>列名由字段名称进行下划线分割来生成( <code>蛇形命名</code>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span>      <span class="comment">// column name is `id`</span></span><br><span class="line">  Name      <span class="type">string</span>    <span class="comment">// column name is `name`</span></span><br><span class="line">  Birthday  time.Time <span class="comment">// column name is `birthday`</span></span><br><span class="line">  CreatedAt time.Time <span class="comment">// column name is `created_at`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用结构体tag指定列名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  AnimalId    <span class="type">int64</span>     <span class="string">`gorm:&quot;column:beast_id&quot;`</span>         <span class="comment">// set column name to `beast_id`</span></span><br><span class="line">  Birthday    time.Time <span class="string">`gorm:&quot;column:day_of_the_beast&quot;`</span> <span class="comment">// set column name to `day_of_the_beast`</span></span><br><span class="line">  Age         <span class="type">int64</span>     <span class="string">`gorm:&quot;column:age_of_the_beast&quot;`</span> <span class="comment">// set column name to `age_of_the_beast`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间戳跟踪"><a href="#时间戳跟踪" class="headerlink" title="时间戳跟踪"></a>时间戳跟踪</h2><h3 id="CreatedAt"><a href="#CreatedAt" class="headerlink" title="CreatedAt"></a>CreatedAt</h3><p>如果模型有 <code>CreatedAt</code>字段，该字段的值将会是初次创建记录的时间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Create(&amp;user) <span class="comment">// `CreatedAt`将会是当前时间</span></span><br><span class="line"></span><br><span class="line">user2 := User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, CreatedAt: time.Now()&#125;</span><br><span class="line">db.Create(&amp;user2) <span class="comment">// user2 的 `CreatedAt` 不会被修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用`Update`方法来改变`CreateAt`的值</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;CreatedAt&quot;</span>, time.Now())</span><br></pre></td></tr></table></figure>

<p>你可以通过将 <code>autoCreateTime</code> 标签置为 <code>false</code> 来禁用时间戳追踪，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  CreatedAt time.Time <span class="string">`gorm:&quot;autoCreateTime:false&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UpdatedAt"><a href="#UpdatedAt" class="headerlink" title="UpdatedAt"></a>UpdatedAt</h3><p>如果模型有<code>UpdatedAt</code>字段，该字段的值将会是每次更新记录的时间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Save(&amp;user) <span class="comment">// `UpdatedAt`将会是当前时间</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>) <span class="comment">// `UpdatedAt`将会是当前时间</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).UpdateColumn(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>) <span class="comment">// `UpdatedAt` 不会被修改</span></span><br><span class="line"></span><br><span class="line">user2 := User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, UpdatedAt: time.Now()&#125;</span><br><span class="line">db.Create(&amp;user2) <span class="comment">// 创建记录时，user2 的 `UpdatedAt` 不会被修改</span></span><br><span class="line"></span><br><span class="line">user3 := User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, UpdatedAt: time.Now()&#125;</span><br><span class="line">db.Save(&amp;user3) <span class="comment">// 更新时，user3 的 `UpdatedAt` 会修改为当前时间</span></span><br></pre></td></tr></table></figure>

<p>你可以通过将 <code>autoUpdateTime</code> 标签置为 <code>false</code> 来禁用时间戳追踪，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  UpdatedAt time.Time <span class="string">`gorm:&quot;autoUpdateTime:false&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DeletedAt"><a href="#DeletedAt" class="headerlink" title="DeletedAt"></a>DeletedAt</h3><p>如果模型有<code>DeletedAt</code>字段，调用<code>Delete</code>删除该记录时，将会设置<code>DeletedAt</code>字段为当前时间，而不是直接将记录从数据库中删除。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="创建记录"><a href="#创建记录" class="headerlink" title="创建记录"></a>创建记录</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID       <span class="type">uint</span></span><br><span class="line">	Name     <span class="type">string</span></span><br><span class="line">	Age      <span class="type">uint8</span></span><br><span class="line">	Birthday time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dsn := <span class="string">&quot;root:@tcp(127.0.0.1:3306)/gorm?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">	db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;failed to connect database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 自动迁移</span></span><br><span class="line">	err = db.AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;failed to migrate&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line"></span><br><span class="line">	result := db.Create(&amp;user)       <span class="comment">// 通过数据的指针来创建</span></span><br><span class="line">	fmt.Println(user.ID)             <span class="comment">// 返回插入数据的主键</span></span><br><span class="line">	fmt.Println(result.Error)        <span class="comment">// 返回 error</span></span><br><span class="line">	fmt.Println(result.RowsAffected) <span class="comment">// 返回插入记录的条数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以使用 <code>Create()</code> 创建多项记录：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">users := []User&#123;</span><br><span class="line">		&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;Jackson&quot;</span>, Age: <span class="number">19</span>, Birthday: time.Now()&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := db.Create(users) <span class="comment">// pass a slice to insert multiple row</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(result.Error)        <span class="comment">// returns error</span></span><br><span class="line">	fmt.Println(result.RowsAffected) <span class="comment">// returns inserted records count</span></span><br></pre></td></tr></table></figure>

<h3 id="用指定的字段创建记录"><a href="#用指定的字段创建记录" class="headerlink" title="用指定的字段创建记录"></a>用指定的字段创建记录</h3><p>创建记录并为指定的字段分配值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (&quot;jinzhu&quot;, 18, &quot;2020-07-04 11:05:21.775&quot;)</span></span><br></pre></td></tr></table></figure>

<p>创建记录并忽略要省略的传递字段的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Omit(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`birthday`,`updated_at`) VALUES (&quot;2020-01-01 00:00:00.000&quot;, &quot;2020-07-04 11:05:21.775&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p>若要有效地插入大量记录，请将一个切片传递给 <code>Create </code>方法。GORM 将生成一个单独的 SQL 语句来插入所有数据并回填主键值，钩子方法也将被调用。当记录可以分成多个批处理时，它将开始一个事务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">	db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">		fmt.Println(user.ID) <span class="comment">// 1,2,3</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>可以在使用 <code>CreateInBatches </code>创建时指定批处理大小，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu_1&quot;</span>&#125;, ...,&#123;Name: <span class="string">&quot;jinzhu_10000&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// batch size 100</span></span><br><span class="line">	db.CreateInBatches(users, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="根据-Map-创建"><a href="#根据-Map-创建" class="headerlink" title="根据 Map 创建"></a>根据 Map 创建</h3><p>GORM 支持从<code> map [ string ] interface &#123;&#125;</code>和<code>[] map [ string ] interface &#123;&#125;&#123;&#125;</code>创建，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// batch insert from `[]map[string]interface&#123;&#125;&#123;&#125;`</span></span><br><span class="line">	db.Model(&amp;User&#123;&#125;).Create([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_1&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_2&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 从 map 创建时，不会调用 hook，不会保存关联，主键值也不会返回填充</p>
</blockquote>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>可以通过 tag 定义字段的默认值，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int64</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;default:galeone&quot;`</span></span><br><span class="line">  Age  <span class="type">int64</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>通过tag定义字段的默认值，在创建记录时候生成的 SQL 语句会排除没有值或值为 零值 的字段。 在将记录插入到数据库后，Gorm会从数据库加载那些字段的默认值。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = User&#123;Name: <span class="string">&quot;&quot;</span>, Age: <span class="number">99</span>&#125;</span><br><span class="line">db.Create(&amp;user)</span><br></pre></td></tr></table></figure>

<p>上面代码实际执行的SQL语句是<code>INSERT INTO users(&quot;age&quot;) values(&#39;99&#39;);</code>，排除了零值字段<code>Name</code>，而在数据库中这一条数据会使用设置的默认值作为Name字段的值。</p>
<p><strong>注意：</strong>所有字段的零值, 比如<code>0</code>, <code>&quot;&quot;</code>,<code>false</code>或者其它<code>零值</code>，都不会保存到数据库内，但会使用他们的默认值。 如果你想避免这种情况，可以考虑使用指针或实现 <code>Scanner/Valuer</code>接口，比如：</p>
<h4 id="使用指针方式实现零值存入数据库"><a href="#使用指针方式实现零值存入数据库" class="headerlink" title="使用指针方式实现零值存入数据库"></a>使用指针方式实现零值存入数据库</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用指针</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID   <span class="type">int64</span></span><br><span class="line">	Name *<span class="type">string</span> <span class="string">`gorm:&quot;default:galeone&quot;`</span></span><br><span class="line">	Age  <span class="type">int64</span>   </span><br><span class="line">&#125;</span><br><span class="line">user := User&#123;Name: <span class="built_in">new</span>(<span class="type">string</span>), Age: <span class="number">18</span>&#125;</span><br><span class="line">db.Create(&amp;user)  <span class="comment">// 此时数据库中该条记录name字段的值就是&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用Scanner-Valuer接口方式实现零值存入数据库"><a href="#使用Scanner-Valuer接口方式实现零值存入数据库" class="headerlink" title="使用Scanner&#x2F;Valuer接口方式实现零值存入数据库"></a>使用Scanner&#x2F;Valuer接口方式实现零值存入数据库</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Scanner/Valuer</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID <span class="type">int64</span></span><br><span class="line">	Name sql.NullString <span class="string">`gorm:&quot;default:&#x27;galeone&#x27;&quot;`</span> <span class="comment">// sql.NullString 实现了Scanner/Valuer接口</span></span><br><span class="line">	Age  <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line">user := User&#123;Name: sql.NullString&#123;Valid: <span class="literal">true</span>&#125;, Age: <span class="number">18</span>&#125;</span><br><span class="line">db.Create(&amp;user)  <span class="comment">// 此时数据库中该条记录name字段的值就是&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展创建选项"><a href="#扩展创建选项" class="headerlink" title="扩展创建选项"></a>扩展创建选项</h3><p>例如<code>PostgreSQL</code>数据库中可以使用下面的方式实现合并插入, 有则更新, 无则插入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为Instert语句添加扩展SQL选项</span></span><br><span class="line">db.Set(<span class="string">&quot;gorm:insert_option&quot;</span>, <span class="string">&quot;ON CONFLICT&quot;</span>).Create(&amp;product)</span><br><span class="line"><span class="comment">// INSERT INTO products (name, code) VALUES (&quot;name&quot;, &quot;code&quot;) ON CONFLICT;</span></span><br></pre></td></tr></table></figure>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="一般查询"><a href="#一般查询" class="headerlink" title="一般查询"></a>一般查询</h3><p>GORM 提供了 <code>First</code>、<code>Take</code>、<code>Last</code> 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 <code>LIMIT 1</code> 条件，且没有找到记录时，它会返回 <code>ErrRecordNotFound</code> 错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据主键查询第一条记录</span></span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">result := db.First(&amp;user)</span><br><span class="line">fmt.Println(result.RowsAffected) <span class="comment">// 返回找到的记录数</span></span><br><span class="line">fmt.Println(result.Error)        <span class="comment">// returns error or nil</span></span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机获取一条记录</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主键查询最后一条记录</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有的记录</span></span><br><span class="line">db.Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询指定的某条记录(仅当主键为整型时可用)</span></span><br><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主键为字符串</span></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;1b74413f-f3b8-409f-ac47-e8c062e3472a&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = &quot;1b74413f-f3b8-409f-ac47-e8c062e3472a&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你想避免<code>ErrRecordNotFound</code>错误，你可以使用<code>Find</code>，比如<code>db.Limit(1).Find(&amp;user)</code>，<code>Find</code>方法可以接受struct和slice的数据。</p>
</blockquote>
<blockquote>
<p>对单个对象使用<code>Find</code>而不带limit，<code>db.Find(&amp;user)</code>将会查询整个表并且只返回第一个对象，这是性能不高并且不确定的。</p>
</blockquote>
<h3 id="Where-条件"><a href="#Where-条件" class="headerlink" title="Where 条件"></a>Where 条件</h3><h4 id="普通SQL查询"><a href="#普通SQL查询" class="headerlink" title="普通SQL查询"></a>普通SQL查询</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get first matched record</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; limit 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all matched records</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;&gt;</span></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN (?)&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name in (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br></pre></td></tr></table></figure>

<h4 id="Struct-Map查询"><a href="#Struct-Map查询" class="headerlink" title="Struct &amp; Map查询"></a>Struct &amp; Map查询</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主键的切片</span></span><br><span class="line">db.Where([]<span class="type">int64</span>&#123;<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong>当通过结构体进行查询时，GORM将会只通过非零值字段查询，这意味着如果你的字段值为<code>0</code>，<code>&#39;&#39;</code>，<code>false</code>或者其他<code>零值</code>时，将不会被用于构建查询条件，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">0</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure>

<p>若要在查询条件中包含零值，可以使用映射，该映射将包含所有键值作为查询条件，例如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">0</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 0;</span></span><br></pre></td></tr></table></figure>

<h3 id="指定结构体查询字段"><a href="#指定结构体查询字段" class="headerlink" title="指定结构体查询字段"></a>指定结构体查询字段</h3><p>在使用 struct 进行搜索时，可以通过传递相关的字段名或 dbname 到 Where ()来指定在查询条件中使用 struct 中的哪些特定值，例如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)<span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 0;</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)<span class="comment">// SELECT * FROM users WHERE age = 0;</span></span><br></pre></td></tr></table></figure>

<h3 id="Not-条件"><a href="#Not-条件" class="headerlink" title="Not 条件"></a>Not 条件</h3><p>作用与 Where 类似的情形如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Not(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In</span></span><br><span class="line">db.Not(<span class="string">&quot;name&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In slice of primary keys</span></span><br><span class="line">db.Not([]<span class="type">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id NOT IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line">db.Not([]<span class="type">int64</span>&#123;&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Not(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE NOT(name = &quot;jinzhu&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Not(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure>

<h3 id="Or条件"><a href="#Or条件" class="headerlink" title="Or条件"></a>Or条件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Or(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;super_admin&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(User&#123;Name: <span class="string">&quot;jinzhu 2&quot;</span>, Age: <span class="number">18</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR (name = &#x27;jinzhu 2&#x27; AND age = 18);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu 2&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR (name = &#x27;jinzhu 2&#x27; AND age = 18);</span></span><br></pre></td></tr></table></figure>

<h3 id="内联条件"><a href="#内联条件" class="headerlink" title="内联条件"></a>内联条件</h3><p>作用与<code>Where</code>查询类似，当内联条件与多个<a href="https://www.liwenzhou.com/posts/Go/gorm-crud/#autoid-1-3-1">立即执行方法</a>一起使用时, 内联条件不会传递给后面的立即执行方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据主键获取记录 (只适用于整形主键)</span></span><br><span class="line">db.First(&amp;user, <span class="number">23</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 23 LIMIT 1;</span></span><br><span class="line"><span class="comment">// 根据主键获取记录, 如果它是一个非整形主键</span></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;string_primary_key&quot;</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = &#x27;string_primary_key&#x27; LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Find(&amp;user, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, <span class="string">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Find(&amp;users, User&#123;Age: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Find(&amp;users, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充：<code>&lt;&gt;</code> 是 SQL 中的比较运算符，用于检查两个值是否不相等。在 Go 语言中，<code>&lt;&gt;</code> 被用作 <code>db.Find</code> 方法的查询条件。</p>
</blockquote>
<h3 id="额外查询选项"><a href="#额外查询选项" class="headerlink" title="额外查询选项"></a>额外查询选项</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为查询 SQL 添加额外的 SQL 操作</span></span><br><span class="line">db.Set(<span class="string">&quot;gorm:query_option&quot;</span>, <span class="string">&quot;FOR UPDATE&quot;</span>).First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 10 FOR UPDATE;</span></span><br></pre></td></tr></table></figure>

<h3 id="Find-至-map"><a href="#Find-至-map" class="headerlink" title="Find 至 map"></a>Find 至 map</h3><p>GORM 允许扫描结果至 <code>map[string]interface&#123;&#125;</code> 或 <code>[]map[string]interface&#123;&#125;</code>，此时别忘了指定 <code>Model</code> 或 <code>Table</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result := map[string]interface&#123;&#125;&#123;&#125;</span><br><span class="line">db.Model(&amp;User&#123;&#125;).First(&amp;result, &quot;id = ?&quot;, 1)</span><br><span class="line"></span><br><span class="line">var results []map[string]interface&#123;&#125;</span><br><span class="line">db.Table(&quot;users&quot;).Find(&amp;results)</span><br></pre></td></tr></table></figure>

<h3 id="FirstOrInit"><a href="#FirstOrInit" class="headerlink" title="FirstOrInit"></a>FirstOrInit</h3><p>获取第一条匹配的记录，或者根据给定的条件初始化一个实例（仅支持 sturct 和 map 条件）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未找到 user，则根据给定的条件初始化一条记录</span></span><br><span class="line">db.FirstOrInit(&amp;user, User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// user -&gt; User&#123;Name: &quot;non_existing&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到了 `name` = `jinzhu` 的 user</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;Jinzhu&quot;, Age: 18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到了 `name` = `jinzhu` 的 user</span></span><br><span class="line">db.FirstOrInit(&amp;user, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;Jinzhu&quot;, Age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果没有找到记录，可以使用包含更多的属性的结构体初始化 user，<code>Attrs</code> 不会被用于生成查询 SQL</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未找到 user，则根据给定的条件以及 Attrs 初始化 user</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 未找到 user，则根据给定的条件以及 Attrs 初始化 user</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到了 `name` = `jinzhu` 的 user，则忽略 Attrs</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM USERS WHERE name = jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;Jinzhu&quot;, Age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>不管是否找到记录，<code>Assign</code> 都会将属性赋值给 struct，但这些属性不会被用于生成查询 SQL，也不会被保存到数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未找到 user，根据条件和 Assign 属性初始化 struct</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到 `name` = `jinzhu` 的记录，依然会更新 Assign 相关的属性</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM USERS WHERE name = jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="FirstOrCreate"><a href="#FirstOrCreate" class="headerlink" title="FirstOrCreate"></a>FirstOrCreate</h3><p>获取匹配的第一条记录或者根据给定条件创建一条新纪录（仅 struct, map 条件有效），<code>RowsAffected</code> 返回创建、更新的记录数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未找到 User，根据给定条件创建一条新纪录</span></span><br><span class="line">result := db.FirstOrCreate(&amp;user, User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO &quot;users&quot; (name) VALUES (&quot;non_existing&quot;);</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 112, Name: &quot;non_existing&quot;&#125;</span></span><br><span class="line"><span class="comment">// result.RowsAffected // =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到 `name` = `jinzhu` 的 User</span></span><br><span class="line">result := db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;jinzhu&quot;, &quot;Age&quot;: 18&#125;</span></span><br><span class="line"><span class="comment">// result.RowsAffected // =&gt; 0</span></span><br></pre></td></tr></table></figure>

<p>如果没有找到记录，可以使用包含更多的属性的结构体创建记录，<code>Attrs</code> 不会被用于生成查询 SQL 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未找到 user，根据条件和 Assign 属性创建记录</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;non_existing&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// INSERT INTO &quot;users&quot; (name, age) VALUES (&quot;non_existing&quot;, 20);</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 112, Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到了 `name` = `jinzhu` 的 user，则忽略 Attrs</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;jinzhu&quot;, Age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>不管是否找到记录，<code>Assign</code> 都会将属性赋值给 struct，并将结果写回数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未找到 user，根据条件和 Assign 属性创建记录</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;non_existing&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// INSERT INTO &quot;users&quot; (name, age) VALUES (&quot;non_existing&quot;, 20);</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 112, Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到了 `name` = `jinzhu` 的 user，依然会根据 Assign 更新记录</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// UPDATE users SET age=20 WHERE id = 111;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>基于 <code>*gorm.expr</code> 的子查询</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;amount &gt; (?)&quot;</span>, db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;AVG(amount)&quot;</span>)).Find(&amp;orders)</span><br><span class="line"><span class="comment">// SELECT * FROM &quot;orders&quot; WHERE amount &gt; (SELECT AVG(amount) FROM &quot;orders&quot;);</span></span><br><span class="line"></span><br><span class="line">subQuery := db.Select(<span class="string">&quot;AVG(age)&quot;</span>).Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;name%&quot;</span>).Table(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">db.Select(<span class="string">&quot;AVG(age) as avgage&quot;</span>).Group(<span class="string">&quot;name&quot;</span>).Having(<span class="string">&quot;AVG(age) &gt; (?)&quot;</span>, subQuery).Find(&amp;results)</span><br><span class="line"><span class="comment">// SELECT AVG(age) as avgage FROM `users` GROUP BY `name` HAVING AVG(age) &gt; (SELECT AVG(age) FROM `users` WHERE name LIKE &quot;name%&quot;)</span></span><br></pre></td></tr></table></figure>

<h5 id="From-子查询"><a href="#From-子查询" class="headerlink" title="From 子查询"></a>From 子查询</h5><p>GORM 允许您在 <code>Table</code> 方法中通过 FROM 子句使用子查询，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Table(<span class="string">&quot;(?) as u&quot;</span>, db.Model(&amp;User&#123;&#125;).Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>)).Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">18</span>).Find(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM (SELECT `name`,`age` FROM `users`) as u WHERE `age` = 18</span></span><br><span class="line"></span><br><span class="line">subQuery1 := db.Model(&amp;User&#123;&#125;).Select(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">subQuery2 := db.Model(&amp;Pet&#123;&#125;).Select(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">db.Table(<span class="string">&quot;(?) as u, (?) as p&quot;</span>, subQuery1, subQuery2).Find(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM (SELECT `name` FROM `users`) as u, (SELECT `name` FROM `pets`) as p</span></span><br></pre></td></tr></table></figure>

<h4 id="选择字段"><a href="#选择字段" class="headerlink" title="选择字段"></a>选择字段</h4><p>Select，指定你想从数据库中检索出的字段，默认会选择全部字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;name, age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Select([]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;COALESCE(age,?)&quot;</span>, <span class="number">42</span>).Rows()</span><br><span class="line"><span class="comment">//// SELECT COALESCE(age,&#x27;42&#x27;) FROM users;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：<code>.Select(&quot;COALESCE(age, ?)&quot;, 42)</code>: 这是指定查询的字段。在这里使用了 <code>COALESCE</code> 函数，它是一个 SQL 函数，用于在结果集中选择第一个非 NULL 的值。<code>age</code> 是字段名，如果 <code>age</code> 字段的值为 NULL，则会选择后面提供的替代值 <code>42</code>。因此，该查询将会返回 “users” 表中每行的 “age” 字段值，如果 “age” 字段为 NULL，则返回 42。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID     <span class="type">uint</span></span><br><span class="line">  Name   <span class="type">string</span></span><br><span class="line">  Age    <span class="type">int</span></span><br><span class="line">  Gender <span class="type">string</span></span><br><span class="line">  <span class="comment">// 假设后面还有几百个字段...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> APIUser <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">uint</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询时会自动选择 `id`, `name` 字段</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Limit(<span class="number">10</span>).Find(&amp;APIUser&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT `id`, `name` FROM `users` LIMIT 10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> <code>QueryFields</code> 模式会根据当前 model 的所有字段名称进行 select。</p>
</blockquote>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>Order，指定从数据库中检索出记录的顺序。设置第二个参数 reorder 为 <code>true</code> ，可以覆盖前面定义的排序条件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多字段排序</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc&quot;</span>).Order(<span class="string">&quot;name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖排序</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc&quot;</span>).Find(&amp;users1).Order(<span class="string">&quot;age&quot;</span>, <span class="literal">true</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age desc; (users1)</span></span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age; (users2)</span></span><br></pre></td></tr></table></figure>

<h4 id="数量和偏移"><a href="#数量和偏移" class="headerlink" title="数量和偏移"></a>数量和偏移</h4><p>Limit，指定从数据库检索出的最大记录数。Offset，指定开始返回记录前要跳过的记录数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Limit(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel limit condition with -1</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Find(&amp;users1).Limit(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 10; (users1)</span></span><br><span class="line"><span class="comment">// SELECT * FROM users; (users2)</span></span><br><span class="line"></span><br><span class="line">db.Offset(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 3;</span></span><br><span class="line"></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 5 LIMIT 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel offset condition with -1</span></span><br><span class="line">db.Offset(<span class="number">10</span>).Find(&amp;users1).Offset(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 10; (users1)</span></span><br><span class="line"><span class="comment">// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure>

<h4 id="总数"><a href="#总数" class="headerlink" title="总数"></a>总数</h4><p>Count，该 model 能获取的记录总数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Or(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>).Find(&amp;users).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT * from USERS WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;; (users)</span></span><br><span class="line"><span class="comment">//// SELECT count(*) FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;; (count)</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT count(*) FROM users WHERE name = &#x27;jinzhu&#x27;; (count)</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT count(*) FROM deleted_users;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Select(<span class="string">&quot;count(distinct(name))&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT count( distinct(name) ) FROM deleted_users; (count)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> <code>Count</code> 必须是链式查询的最后一个操作 ，因为它会覆盖前面的 <code>SELECT</code>，但如果里面使用了 <code>count</code> 时不会覆盖</p>
<h4 id="Group-Having"><a href="#Group-Having" class="headerlink" title="Group &amp; Having"></a>Group &amp; Having</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Scan将多条结果扫描进事先准备好的结构体切片中</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	Date time.Time</span><br><span class="line">	Total <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rets []Result</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(age) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Scan(&amp;rets)</span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Date  time.Time</span><br><span class="line">  Total <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line">db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Scan(&amp;results)</span><br></pre></td></tr></table></figure>

<h4 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h4><p>从模型中选择不同的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Distinct(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Order(<span class="string">&quot;name, age desc&quot;</span>).Find(&amp;results)</span><br></pre></td></tr></table></figure>

<p><code>Distinct</code> works with <a href="https://gorm.io/zh_CN/docs/advanced_query.html#pluck"><code>Pluck</code></a> and <a href="https://gorm.io/zh_CN/docs/advanced_query.html#count"><code>Count</code></a> too.</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>Joins，指定连接条件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">  Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Scan(&amp;result&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT users.name, emails.email FROM `users` left join emails on emails.user_id = users.id</span></span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Scan(&amp;results)</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple joins with parameter</span></span><br><span class="line">db.Joins(<span class="string">&quot;JOIN emails ON emails.user_id = users.id AND emails.email = ?&quot;</span>, <span class="string">&quot;jinzhu@example.org&quot;</span>).Joins(<span class="string">&quot;JOIN credit_cards ON credit_cards.user_id = users.id&quot;</span>).Where(<span class="string">&quot;credit_cards.number = ?&quot;</span>, <span class="string">&quot;411111111111&quot;</span>).Find(&amp;user)</span><br></pre></td></tr></table></figure>

<h4 id="Pluck"><a href="#Pluck" class="headerlink" title="Pluck"></a>Pluck</h4><p>Pluck，查询 model 中的一个列作为切片，如果您想要查询多个列，您应该使用 <a href="https://www.liwenzhou.com/posts/Go/gorm-crud/#Scan"><code>Scan</code></a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ages []<span class="type">int64</span></span><br><span class="line">db.Find(&amp;users).Pluck(<span class="string">&quot;age&quot;</span>, &amp;ages)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []<span class="type">string</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Pluck(<span class="string">&quot;name&quot;</span>, &amp;names)</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Pluck(<span class="string">&quot;name&quot;</span>, &amp;names)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想查询多个字段？ 这样做：</span></span><br><span class="line">db.Select(<span class="string">&quot;name, age&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<h4 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h4><p>Scan，扫描结果至一个 struct.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result Result</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;name, age&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Antonio&quot;</span>).Scan(&amp;result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results []Result</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;name, age&quot;</span>).Where(<span class="string">&quot;id &gt; ?&quot;</span>, <span class="number">0</span>).Scan(&amp;results)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生 SQL</span></span><br><span class="line">db.Raw(<span class="string">&quot;SELECT name, age FROM users WHERE name = ?&quot;</span>, <span class="string">&quot;Antonio&quot;</span>).Scan(&amp;result)</span><br></pre></td></tr></table></figure>

<h4 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h4><p>Count 用于获取匹配的记录数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="type">int64</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Or(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SELECT count(1) FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SELECT count(1) FROM users WHERE name = &#x27;jinzhu&#x27;; (count)</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SELECT count(1) FROM deleted_users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Count with Distinct</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Distinct(<span class="string">&quot;name&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SELECT COUNT(DISTINCT(`name`)) FROM `users`</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Select(<span class="string">&quot;count(distinct(name))&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SELECT count(distinct(name)) FROM deleted_users</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Count with Group</span></span><br><span class="line">users := []User&#123;</span><br><span class="line">  &#123;Name: <span class="string">&quot;name1&quot;</span>&#125;,</span><br><span class="line">  &#123;Name: <span class="string">&quot;name2&quot;</span>&#125;,</span><br><span class="line">  &#123;Name: <span class="string">&quot;name3&quot;</span>&#125;,</span><br><span class="line">  &#123;Name: <span class="string">&quot;name3&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Group(<span class="string">&quot;name&quot;</span>).Count(&amp;count)</span><br><span class="line">count <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>

<h3 id="链式操作相关"><a href="#链式操作相关" class="headerlink" title="链式操作相关"></a>链式操作相关</h3><h4 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h4><p>Method Chaining，Gorm 实现了链式操作接口，所以你可以把代码写成这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个查询</span></span><br><span class="line">tx := db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加更多条件</span></span><br><span class="line"><span class="keyword">if</span> someCondition &#123;</span><br><span class="line">  tx = tx.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">20</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  tx = tx.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">30</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> yetAnotherCondition &#123;</span><br><span class="line">  tx = tx.Where(<span class="string">&quot;active = ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用立即执行方法前不会生成<code>Query</code>语句，借助这个特性你可以创建一个函数来处理一些通用逻辑。</p>
<h4 id="立即执行方法"><a href="#立即执行方法" class="headerlink" title="立即执行方法"></a>立即执行方法</h4><p>Immediate methods ，立即执行方法是指那些会立即生成<code>SQL</code>语句并发送到数据库的方法, 他们一般是<code>CRUD</code>方法，比如：</p>
<p><code>Create</code>, <code>First</code>, <code>Find</code>, <code>Take</code>, <code>Save</code>, <code>UpdateXXX</code>, <code>Delete</code>, <code>Scan</code>, <code>Row</code>, <code>Rows</code>…</p>
<p>这有一个基于上面链式方法代码的立即执行方法的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tx.Find(&amp;user)</span><br></pre></td></tr></table></figure>

<p>生成的SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> active <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p><code>Scopes</code>，Scope是建立在链式操作的基础之上的。</p>
<p>基于它，你可以抽取一些通用逻辑，写出更多可重用的函数库。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AmountGreaterThan1000</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">&quot;amount &gt; ?&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PaidWithCreditCard</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">&quot;pay_mode_sign = ?&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PaidWithCod</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">&quot;pay_mode_sign = ?&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderStatus</span><span class="params">(status []<span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span> <span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">    <span class="keyword">return</span> db.Scopes(AmountGreaterThan1000).Where(<span class="string">&quot;status IN (?)&quot;</span>, status)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(&amp;orders)</span><br><span class="line"><span class="comment">// 查找所有金额大于 1000 的信用卡订单</span></span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(&amp;orders)</span><br><span class="line"><span class="comment">// 查找所有金额大于 1000 的 COD 订单</span></span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, OrderStatus([]<span class="type">string</span>&#123;<span class="string">&quot;paid&quot;</span>, <span class="string">&quot;shipped&quot;</span>&#125;)).Find(&amp;orders)</span><br><span class="line"><span class="comment">// 查找所有金额大于 1000 且已付款或者已发货的订单</span></span><br></pre></td></tr></table></figure>

<h4 id="多个立即执行方法"><a href="#多个立即执行方法" class="headerlink" title="多个立即执行方法"></a>多个立即执行方法</h4><p>Multiple Immediate Methods，在 GORM 中使用多个立即执行方法时，后一个立即执行方法会复用前一个<strong>立即执行方法</strong>的条件 (不包括内联条件) 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;jinzhu%&quot;</span>).Find(&amp;users, <span class="string">&quot;id IN (?)&quot;</span>, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).Count(&amp;count)</span><br></pre></td></tr></table></figure>

<p>生成的 Sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;jinzhu%&#x27;</span> <span class="keyword">AND</span> id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;jinzhu%&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="保存所有字段"><a href="#保存所有字段" class="headerlink" title="保存所有字段"></a>保存所有字段</h3><p><code>Save()</code>默认会更新该对象的所有字段，即使你没有赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;jinzhu 2&quot;</span></span><br><span class="line">user.Age = <span class="number">100</span></span><br><span class="line">db.Save(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;jinzhu 2&#x27;, age=100, birthday=&#x27;2016-01-01&#x27;, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure>

<h3 id="更新单个列"><a href="#更新单个列" class="headerlink" title="更新单个列"></a>更新单个列</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Update with conditions</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE active=true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User&#x27;s ID is `111`:</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update with conditions and model value</span></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br></pre></td></tr></table></figure>

<h3 id="更新多列"><a href="#更新多列" class="headerlink" title="更新多列"></a>更新多列</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Update attributes with `struct`, will only update non-zero fields</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update attributes with `map`</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 当使用 struct 更新时，GORM 将只更新非零字段。您可能希望使用<code> map</code> 更新属性或使用 <code>Select </code>指定要更新的字段</p>
</blockquote>
<h3 id="无Hooks更新"><a href="#无Hooks更新" class="headerlink" title="无Hooks更新"></a>无Hooks更新</h3><p>上面的更新操作会自动运行 model 的 <code>BeforeUpdate</code>, <code>AfterUpdate</code> 方法，更新 <code>UpdatedAt</code> 时间戳, 在更新时保存其 <code>Associations</code>, 如果你不想调用这些方法，你可以使用 <code>UpdateColumn</code>， <code>UpdateColumns</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新单个属性，类似于 `Update`</span></span><br><span class="line">db.Model(&amp;user).UpdateColumn(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新多个属性，类似于 `Updates`</span></span><br><span class="line">db.Model(&amp;user).UpdateColumns(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id = 111;</span></span><br></pre></td></tr></table></figure>

<h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>如果我们没有使用 Model 指定主键值的记录，GORM 将执行批量更新，批量更新时<code>Hooks（钩子函数）</code>不会运行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Update with struct</span></span><br><span class="line">db.Model(User&#123;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE role = &#x27;admin&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update with map</span></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Where(<span class="string">&quot;id IN ?&quot;</span>, []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">11</span>&#125;).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id IN (10, 11);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `RowsAffected` 获取更新记录总数</span></span><br><span class="line">db.Model(User&#123;&#125;).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;).RowsAffected</span><br></pre></td></tr></table></figure>

<h3 id="使用SQL表达式更新"><a href="#使用SQL表达式更新" class="headerlink" title="使用SQL表达式更新"></a>使用SQL表达式更新</h3><p>先查询表中的第一条数据保存至user变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">db.First(&amp;user)</span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment">//// UPDATE `users` SET `age` = age * 2 + 100, `updated_at` = &#x27;2020-02-16 13:10:20&#x27;  WHERE `users`.`id` = 1;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: gorm.Expr(<span class="string">&quot;age * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>)&#125;)</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age * &#x27;2&#x27; + &#x27;100&#x27;, &quot;updated_at&quot; = &#x27;2020-02-16 13:05:51&#x27; WHERE `users`.`id` = 1;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).UpdateColumn(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27;;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;age &gt; 10&quot;</span>).UpdateColumn(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27; AND quantity &gt; 10;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改Hooks中的值"><a href="#修改Hooks中的值" class="headerlink" title="修改Hooks中的值"></a>修改Hooks中的值</h3><p>如果你想修改 <code>BeforeUpdate</code>, <code>BeforeSave</code> 等 Hooks 中更新的值，你可以使用 <code>scope.SetColumn</code>, 例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> BeforeSave(scope *gorm.Scope) (err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> pw, err := bcrypt.GenerateFromPassword(user.Password, <span class="number">0</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    scope.SetColumn(<span class="string">&quot;EncryptedPassword&quot;</span>, pw)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它更新选项"><a href="#其它更新选项" class="headerlink" title="其它更新选项"></a>其它更新选项</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为 update SQL 添加其它的 SQL</span></span><br><span class="line">db.Model(&amp;user).Set(<span class="string">&quot;gorm:update_option&quot;</span>, <span class="string">&quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111 OPTION (OPTIMIZE FOR UNKNOWN);</span></span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><p><strong>警告</strong> 删除记录时，请确保主键字段有值，GORM 会通过主键去删除记录，如果主键为空，GORM 会删除该 model 的所有记录。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除现有记录</span></span><br><span class="line">db.Delete(&amp;email)</span><br><span class="line"><span class="comment">//// DELETE from emails where id=10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带额外条件的删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10 AND name = &quot;jinzhu&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为删除 SQL 添加额外的 SQL 操作</span></span><br><span class="line">db.Set(<span class="string">&quot;gorm:delete_option&quot;</span>, <span class="string">&quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;</span>).Delete(&amp;email)</span><br><span class="line"><span class="comment">//// DELETE from emails where id=10 OPTION (OPTIMIZE FOR UNKNOWN);</span></span><br></pre></td></tr></table></figure>

<h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>如果指定的值不包括主属性，那么 GORM 会执行批量删除，它将删除所有匹配的记录。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(Email&#123;&#125;)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Delete(Email&#123;&#125;, <span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br></pre></td></tr></table></figure>

<p>可以将一个主键切片传递给<code>Delete</code> 方法，以便更高效的删除数据量大的记录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;ID: <span class="number">1</span>&#125;, &#123;ID: <span class="number">2</span>&#125;, &#123;ID: <span class="number">3</span>&#125;&#125;</span><br><span class="line">db.Delete(&amp;users)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, <span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE name LIKE &quot;%jinzhu%&quot; AND id IN (1,2,3); </span></span><br></pre></td></tr></table></figure>

<h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p>如果一个 model 有 <code>DeletedAt</code> 字段，他将自动获得软删除的功能！ 当调用 <code>Delete</code> 方法时， 记录不会真正的从数据库中被删除， 只会将<code>DeletedAt</code> 字段的值会被设置为当前时间</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Delete(&amp;user)</span><br><span class="line"><span class="comment">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line">db.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">20</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询记录时会忽略被软删除的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unscoped 方法可以查询被软删除的记录</span></span><br><span class="line">db.Unscoped().Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure>

<p>如果你并不想嵌套<code>gorm.Model</code>，你也可以像下方例子那样开启软删除特性：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Deleted gorm.DeletedAt</span><br><span class="line">  Name    <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="永久删除"><a href="#永久删除" class="headerlink" title="永久删除"></a>永久删除</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unscoped 方法可以物理删除记录</span></span><br><span class="line">db.Unscoped().Delete(&amp;order)</span><br><span class="line"><span class="comment">//// DELETE FROM orders WHERE id=10;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>sync包</title>
    <url>/2023/07/06/Go/19/</url>
    <content><![CDATA[<h1 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h1><p>sync是synchronization同步这个词的缩写，所以也会叫做同步包。这里提供了基本同步的操作，比如互斥锁等等。这里除了Once和WaitGroup类型之外，大多数类型都是供低级库例程使用的。更高级别的同步最好通过channel通道和communication通信来完成。</p>
<h2 id="WaitGroup-1"><a href="#WaitGroup-1" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>WaitGroup，同步等待组。</p>
<p>在类型上，它是一个结构体。一个WaitGroup的用途是等待一个goroutine的集合执行完成。主goroutine调用了Add()方法来设置要等待的goroutine的数量。然后，每个goroutine都会执行并且执行完成后调用Done()这个方法。与此同时，可以使用Wait()方法来阻塞，直到所有的goroutine都执行完成。</p>
<h2 id="Add-方法"><a href="#Add-方法" class="headerlink" title="Add()方法"></a>Add()方法</h2><p>Add这个方法，用来设置到WaitGroup的计数器的值。我们可以理解为每个waitgroup中都有一个计数器<br>用来表示这个同步等待组中要执行的goroutin的数量。</p>
<p>如果计数器的数值变为0，那么就表示等待时被阻塞的goroutine都被释放，如果计数器的数值为负数，那么就会引发恐慌，程序就报错了。</p>
<h2 id="Done-方法"><a href="#Done-方法" class="headerlink" title="Done()方法"></a>Done()方法</h2><p>Done()方法，就是当WaitGroup同步等待组中的某个goroutine执行完毕后，设置这个WaitGroup的counter数值减1。</p>
<p>其实Done()的底层代码就是调用了Add()方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Done decrements the WaitGroup counter by one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() &#123;</span><br><span class="line">	wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Wait-方法"><a href="#Wait-方法" class="headerlink" title="Wait()方法"></a>Wait()方法</h2><p>Wait()方法，表示让当前的goroutine等待，进入阻塞状态。一直到WaitGroup的计数器为零。才能解除阻塞，<br>这个goroutine才能继续执行。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>我们创建并启动两个goroutine，来打印数字和字母，并在main goroutine中，将这两个子goroutine加入到一个WaitGroup中，同时让main goroutine进入Wait()，让两个子goroutine先执行。当每个子goroutine执行完毕后，调用Done()方法，设置WaitGroup的counter减1。当两条子goroutine都执行完毕后，WaitGroup中的counter的数值为零，解除main goroutine的阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// 创建同步等待组对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		WaitGroup：同步等待组</span></span><br><span class="line"><span class="comment">			可以使用Add(),设置等待组中要 执行的子goroutine的数量，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			在main 函数中，使用wait(),让主程序处于等待状态。直到等待组中子程序执行完毕。解除阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			子gorotuine对应的函数中。wg.Done()，用于让等待组中的子程序的数量减1</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//设置等待组中，要执行的goroutine的数量</span></span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> fun1()</span><br><span class="line">	<span class="keyword">go</span> fun2()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main进入阻塞状态。。。等待wg中的子goroutine结束。。&quot;</span>)</span><br><span class="line">	wg.Wait() <span class="comment">//表示main goroutine进入等待，意味着阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main，解除阻塞。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;fun1.。。i:&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done() <span class="comment">//给wg等待中的执行的goroutine数量减1.同Add(-1)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;\tfun2..j,&quot;</span>, j)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main进入阻塞状态。。。等待wg中的子goroutine结束。。</span><br><span class="line">	fun2..j, 1</span><br><span class="line">	fun2..j, 2</span><br><span class="line">	fun2..j, 3</span><br><span class="line">	fun2..j, 4</span><br><span class="line">	fun2..j, 5</span><br><span class="line">	fun2..j, 6</span><br><span class="line">	fun2..j, 7</span><br><span class="line">	fun2..j, 8</span><br><span class="line">	fun2..j, 9</span><br><span class="line">	fun2..j, 10</span><br><span class="line">fun1.。。i: 1</span><br><span class="line">fun1.。。i: 2</span><br><span class="line">fun1.。。i: 3</span><br><span class="line">fun1.。。i: 4</span><br><span class="line">fun1.。。i: 5</span><br><span class="line">fun1.。。i: 6</span><br><span class="line">fun1.。。i: 7</span><br><span class="line">fun1.。。i: 8</span><br><span class="line">fun1.。。i: 9</span><br><span class="line">fun1.。。i: 10</span><br><span class="line">main，解除阻塞。。</span><br></pre></td></tr></table></figure>

<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><h2 id="Mutex-互斥锁"><a href="#Mutex-互斥锁" class="headerlink" title="Mutex(互斥锁)"></a>Mutex(互斥锁)</h2><p>在并发程序中，会存在临界资源问题。就是当多个协程来访问共享的数据资源，那么这个共享资源是不安全的。为了解决协程同步的问题我们使用了channel，但是Go语言也提供了传统的同步工具。</p>
<p>什么是锁呢？就是某个协程（线程）在访问某个资源时先锁住，防止其它协程的访问，等访问完毕解锁后其他协程再来加锁进行访问。一般用于处理并发中的临界资源问题。</p>
<p>Go语言包中的 sync 包提供了两种锁类型：sync.Mutex 和 sync.RWMutex。</p>
<p>Mutex 是最简单的一种锁类型，互斥锁，同时也比较暴力，当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖等到这个 goroutine 释放该 Mutex。</p>
<p>每个资源都对应于一个可称为 “互斥锁” 的标记，这个标记用来保证在任意时刻，只能有一个协程（线程）访问该资源。其它的协程只能等待。</p>
<p>互斥锁是传统并发编程对共享资源进行访问控制的主要手段，它由标准库sync中的Mutex结构体类型表示。sync.Mutex类型只有两个公开的指针方法，Lock和Unlock。Lock锁定当前的共享资源，Unlock进行解锁。</p>
<p>在使用互斥锁时，一定要注意：对资源操作完成后，一定要解锁，否则会出现流程执行异常，死锁等问题。通常借助defer。锁定后，立即使用defer语句保证互斥锁及时解锁。</p>
<h2 id="Lock-方法"><a href="#Lock-方法" class="headerlink" title="Lock()方法"></a>Lock()方法</h2><p>Lock()这个方法，锁定m。如果该锁已在使用中，则调用goroutine将阻塞，直到互斥体可用。</p>
<h2 id="Unlock-方法"><a href="#Unlock-方法" class="headerlink" title="Unlock()方法"></a>Unlock()方法</h2><p>Unlock()方法，解锁m。如果m未在要解锁的条目上锁定，则为运行时错误。</p>
<p>锁定的互斥体不与特定的goroutine关联。允许一个goroutine锁定互斥体，然后安排另一个goroutine解锁互斥体。</p>
<h2 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h2><p>使用goroutine，模拟4个售票口出售火车票的案例。4个售票口同时卖票，会发生临界资源数据安全问题。我们使用互斥锁解决一下。(Go语言推崇的是使用Channel来实现数据共享，但是也还是提供了传统的同步处理方式)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，表示票</span></span><br><span class="line"><span class="keyword">var</span> ticket = <span class="number">10</span> <span class="comment">//10张票</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex <span class="comment">//创建锁头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//同步等待组对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口1&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口2&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口3&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> saleTickets(<span class="string">&quot;售票口4&quot;</span>)</span><br><span class="line"></span><br><span class="line">	wg.Wait() <span class="comment">//main要等待</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;程序结束了。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saleTickets</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//上锁</span></span><br><span class="line">		mutex.Lock()    <span class="comment">//g2</span></span><br><span class="line">		<span class="keyword">if</span> ticket &gt; <span class="number">0</span> &#123; <span class="comment">//ticket 1 g1</span></span><br><span class="line">			time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;售出：&quot;</span>, ticket) <span class="comment">// 1</span></span><br><span class="line">			ticket--                         <span class="comment">// 0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mutex.Unlock() <span class="comment">//条件不满足，也要解锁</span></span><br><span class="line">			fmt.Println(name, <span class="string">&quot;售罄，没有票了。。&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		mutex.Unlock() <span class="comment">//解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">售票口1 售出： 10</span><br><span class="line">售票口1 售出： 9</span><br><span class="line">售票口2 售出： 8</span><br><span class="line">售票口4 售出： 7</span><br><span class="line">售票口3 售出： 6</span><br><span class="line">售票口1 售出： 5</span><br><span class="line">售票口2 售出： 4</span><br><span class="line">售票口4 售出： 3</span><br><span class="line">售票口3 售出： 2</span><br><span class="line">售票口1 售出： 1</span><br><span class="line">售票口3 售罄，没有票了。。</span><br><span class="line">售票口2 售罄，没有票了。。</span><br><span class="line">售票口4 售罄，没有票了。。</span><br><span class="line">售票口1 售罄，没有票了。。</span><br><span class="line">程序结束了。。。</span><br></pre></td></tr></table></figure>

<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><h2 id="RWMutex-读写锁"><a href="#RWMutex-读写锁" class="headerlink" title="RWMutex(读写锁)"></a>RWMutex(读写锁)</h2><p>通过对互斥锁的学习，我们已经知道了锁的概念以及用途。主要是用于处理并发中的临界资源问题。</p>
<p>Go语言包中的 sync 包提供了两种锁类型：sync.Mutex 和 sync.RWMutex。其中RWMutex是基于Mutex实现的，只读锁的实现使用类似引用计数器的功能。</p>
<p>RWMutex是读&#x2F;写互斥锁。锁可以由任意数量的读取器或单个编写器持有。RWMutex的零值是未锁定的mutex。</p>
<p>如果一个goroutine持有一个rRWMutex进行读取，而另一个goroutine可能调用lock，那么在释放初始读取锁之前，任何goroutine都不应该期望能够获取读取锁。特别是，这禁止递归读取锁定。这是为了确保锁最终可用；被阻止的锁调用会将新的读卡器排除在获取锁之外。</p>
<p>我们怎么理解读写锁呢？当有一个 goroutine 获得写锁定，其它无论是读锁定还是写锁定都将阻塞直到写解锁；当有一个 goroutine 获得读锁定，其它读锁定仍然可以继续；当有一个或任意多个读锁定，写锁定将等待所有读锁定解锁之后才能够进行写锁定。所以说这里的读锁定（RLock）目的其实是告诉写锁定：有很多人正在读取数据，你给我站一边去，等它们读（读解锁）完你再来写（写锁定）。我们可以将其总结为如下三条：</p>
<ol>
<li>同时只能有一个 goroutine 能够获得写锁定。</li>
<li>同时可以有任意多个 gorouinte 获得读锁定。</li>
<li>同时只能存在写锁定或读锁定（读和写互斥）。</li>
</ol>
<p>所以，RWMutex这个读写锁，该锁可以加多个读锁或者一个写锁，<strong>其经常用于读次数远远多于写次数的场景</strong>。</p>
<p>读写锁的写锁只能锁定一次，解锁前不能多次锁定，读锁可以多次，但读解锁次数最多只能比读锁次数多一次，一般情况下我们不建议读解锁次数多余读锁次数。</p>
<p>基本遵循两大原则：</p>
<p>​	1、可以随便读，多个goroutine同时读。</p>
<p>​	2、写的时候，啥也不能干。不能读也不能写。</p>
<p>读写锁即是针对于读写操作的互斥锁。它与普通的互斥锁最大的不同就是，它可以分别针对读操作和写操作进行锁定和解锁操作。读写锁遵循的访问控制规则与互斥锁有所不同。在读写锁管辖的范围内，它允许任意个读操作的同时进行。但是在同一时刻，它只允许有一个写操作在进行。</p>
<p>并且在某一个写操作被进行的过程中，读操作的进行也是不被允许的。也就是说读写锁控制下的多个写操作之间都是互斥的，并且写操作与读操作之间也都是互斥的。但是，多个读操作之间却不存在互斥关系。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="RLock-方法"><a href="#RLock-方法" class="headerlink" title="RLock()方法"></a>RLock()方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock()</span><br></pre></td></tr></table></figure>

<p>读锁，当有写锁时，无法加载读锁，当只有读锁或者没有锁时，可以加载读锁，读锁可以加载多个，所以适用于“读多写少”的场景。</p>
<h3 id="RUnlock-方法"><a href="#RUnlock-方法" class="headerlink" title="RUnlock()方法"></a>RUnlock()方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock()</span><br></pre></td></tr></table></figure>

<p>读锁解锁，RUnlock 撤销单次RLock调用，它对于其它同时存在的读取器则没有效果。若rw并没有为读取而锁定，调用RUnlock就会引发一个运行时错误。</p>
<h3 id="Lock-方法-1"><a href="#Lock-方法-1" class="headerlink" title="Lock()方法"></a>Lock()方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock()</span><br></pre></td></tr></table></figure>

<p>写锁，如果在添加写锁之前已经有其他的读锁和写锁，则Lock就会阻塞直到该锁可用，为确保该锁最终可用，已阻塞的Lock调用会从获得的锁中排除新的读取锁，即写锁权限高于读锁，有写锁时优先进行写锁定。</p>
<h3 id="Unlock-方法-1"><a href="#Unlock-方法-1" class="headerlink" title="Unlock()方法"></a>Unlock()方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock()</span><br></pre></td></tr></table></figure>

<p>写锁解锁，如果没有进行写锁定，则就会引起一个运行时错误。</p>
<h2 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwMutex *sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> wg *sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rwMutex = <span class="built_in">new</span>(sync.RWMutex)</span><br><span class="line">	wg = <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//wg.Add(2)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">////多个同时读取</span></span><br><span class="line">	<span class="comment">//go readData(1)</span></span><br><span class="line">	<span class="comment">//go readData(2)</span></span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">go</span> writeData(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> readData(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> writeData(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main..over...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	fmt.Println(i, <span class="string">&quot;开始写：write start。。&quot;</span>)</span><br><span class="line">	rwMutex.Lock() <span class="comment">//写操作上锁</span></span><br><span class="line">	fmt.Println(i, <span class="string">&quot;正在写：writing。。。。&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	rwMutex.Unlock()</span><br><span class="line">	fmt.Println(i, <span class="string">&quot;写结束：write over。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	fmt.Println(i, <span class="string">&quot;开始读：read start。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">	rwMutex.RLock() <span class="comment">//读操作上锁</span></span><br><span class="line">	fmt.Println(i, <span class="string">&quot;正在读取数据：reading。。。&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	rwMutex.RUnlock() <span class="comment">//读操作解锁</span></span><br><span class="line">	fmt.Println(i, <span class="string">&quot;读结束：read over。。。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 开始写：write start。。</span><br><span class="line">2 开始读：read start。。</span><br><span class="line">3 正在写：writing。。。。</span><br><span class="line">1 开始写：write start。。</span><br><span class="line">3 写结束：write over。。</span><br><span class="line">2 正在读取数据：reading。。。</span><br><span class="line">2 读结束：read over。。。</span><br><span class="line">1 正在写：writing。。。。</span><br><span class="line">1 写结束：write over。。</span><br><span class="line">main..over...</span><br></pre></td></tr></table></figure>

<p>最后概括：</p>
<ol>
<li>读锁不能阻塞读锁</li>
<li>读锁需要阻塞写锁，直到所有读锁都释放</li>
<li>写锁需要阻塞读锁，直到所有写锁都释放</li>
<li>写锁需要阻塞写锁</li>
</ol>
]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin+Gorm练手小项目bubble清单企业级结构剖析</title>
    <url>/2023/07/19/Go/28/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本项目来源于<a href="https://github.com/Q1mi/bubble">Qimi老师的小清单项目</a>——基于gin+gorm开发的练手小项目，通过该项目可初识go web开发该有的姿势。笔者对代码有些许修改，以下是项目成功运行的截图，主要功能有添加，删除，确认，查看待办事项等（所以是小项目啦~）<br><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/c1792813df104b18bcbac92e88839992.png"></p>
<h1 id="项目结构树"><a href="#项目结构树" class="headerlink" title="项目结构树"></a>项目结构树</h1><p>这个项目虽然比较小，但是还是可以用企业级代码结构去划分，以下是项目结构树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─controllers</span><br><span class="line">├─dao</span><br><span class="line">├─models</span><br><span class="line">├─routers</span><br><span class="line">├─static</span><br><span class="line">│  ├─css</span><br><span class="line">│  ├─fonts</span><br><span class="line">│  └─js</span><br><span class="line">└─template</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/6766336abdff4a11b0df9785c80ba4f1.png"><br>划分项目结构，利于代码组织和可维护，也有利于团队协作。</p>
<h1 id="后端源码"><a href="#后端源码" class="headerlink" title="后端源码"></a>后端源码</h1><p><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bubble/dao&quot;</span></span><br><span class="line">	<span class="string">&quot;bubble/models&quot;</span></span><br><span class="line">	<span class="string">&quot;bubble/routers&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	err := dao.InitMySQL()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = dao.DB.AutoMigrate(&amp;models.Todo&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	r := routers.SetupRouter()</span><br><span class="line">	err = r.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>controller.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bubble/models&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//url --&gt;controller --&gt;logic --&gt;model</span></span><br><span class="line"><span class="comment">//请求来了 --&gt;控制器 --&gt;业务逻辑 --&gt;模型层的增删改查</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.HTML(http.StatusOK, <span class="string">&quot;index.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateTodo</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> todo models.Todo</span><br><span class="line">	err := c.BindJSON(&amp;todo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := models.CTodo(&amp;todo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;success&quot;</span>,</span><br><span class="line">			<span class="string">&quot;data&quot;</span>: todo,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetTodo</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> todoList, err := models.GTodo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusBadRequest, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, todoList)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateTodo</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	id, ok := c.Params.Get(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;无效的id&quot;</span>&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	todo, err := models.UTodo(id)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = c.BindJSON(&amp;todo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err = models.STodo(todo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, todo)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteTodo</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	id, ok := c.Params.Get(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;无效的id&quot;</span>&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := models.DTodo(id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;id: <span class="string">&quot;deleted&quot;</span>&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mysql.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DB *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitMySQL</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	dsn := <span class="string">&quot;root:@tcp(127.0.0.1:3306)/bubble?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">	DB, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>todo.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bubble/dao&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Todo Model</span></span><br><span class="line"><span class="keyword">type</span> Todo <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">	Title  <span class="type">string</span> <span class="string">`json:&quot;title&quot;`</span></span><br><span class="line">	Status <span class="type">bool</span>   <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Todo 增删改查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CTodo 创建todo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CTodo</span><span class="params">(todo *Todo)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err = dao.DB.Create(&amp;todo).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GTodo 查询todo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GTodo</span><span class="params">()</span></span> (todoList []*Todo, err <span class="type">error</span>) &#123;</span><br><span class="line">	err = dao.DB.Find(&amp;todoList).Error</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UTodo</span><span class="params">(id <span class="type">string</span>)</span></span> (todo *Todo, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err := dao.DB.Where(<span class="string">&quot;id=?&quot;</span>, id).First(&amp;todo).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">STodo</span><span class="params">(todo *Todo)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	err = dao.DB.Save(&amp;todo).Error</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DTodo</span><span class="params">(id <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	err = dao.DB.Where(<span class="string">&quot;id=?&quot;</span>, id).Delete(&amp;Todo&#123;&#125;).Error</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>routers.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bubble/controllers&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupRouter</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.Static(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;static&quot;</span>)</span><br><span class="line">	r.LoadHTMLGlob(<span class="string">&quot;template/*&quot;</span>)</span><br><span class="line">	r.GET(<span class="string">&quot;/&quot;</span>, controllers.IndexHandler)</span><br><span class="line"></span><br><span class="line">	v1Group := r.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		v1Group.POST(<span class="string">&quot;/todo&quot;</span>, controllers.CreateTodo)</span><br><span class="line"></span><br><span class="line">		v1Group.GET(<span class="string">&quot;todo/&quot;</span>, controllers.GetTodo)</span><br><span class="line"></span><br><span class="line">		v1Group.PUT(<span class="string">&quot;todo/:id&quot;</span>, controllers.UpdateTodo)</span><br><span class="line"></span><br><span class="line">		v1Group.DELETE(<span class="string">&quot;todo/:id&quot;</span>, controllers.DeleteTodo)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="学习使用"><a href="#学习使用" class="headerlink" title="学习使用"></a>学习使用</h1><p>前后端所有源码都已经上传至我的资源里：<a href="https://download.csdn.net/download/m0_63230155/88064315?spm=1001.2014.3001.5503">https://download.csdn.net/download/m0_63230155/88064315?spm=1001.2014.3001.5503</a>，供其他小伙伴学习使用，这个是免费下载的！</p>
]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>go的编码规范</title>
    <url>/2023/06/01/Go/3/</url>
    <content><![CDATA[<h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><p>本规范旨在为日常Go项目开发提供一个代码的规范指导，方便团队形成一个统一的代码风格，提高代码的可读性，规范性和统一性。本规范将从命名规范，注释规范，代码风格和 Go 语言提供的常用的工具这几个方面做一个说明。该规范参考了 go 语言官方代码的风格制定。</p>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>命名是代码规范中很重要的一部分，统一的命名规则有利于提高的代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。</p>
<p>Go在命名时以字母a到Z或a到Z或下划线开头，后面跟着零或更多的字母、下划线和数字(0到9)。Go不允许在命名时中使用@、$和%等标点符号。Go是一种区分大小写的编程语言。因此，Manpower和manpower是两个不同的命名。</p>
<blockquote>
<ol>
<li>当命名（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就<strong>可以被外部包的代码所使用</strong>（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；</li>
<li><strong>命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的</strong>（像面向对象语言中的 private ）</li>
</ol>
</blockquote>
<h3 id="包命名：package"><a href="#包命名：package" class="headerlink" title="包命名：package"></a>包命名：package</h3><p>保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为<strong>小写</strong>单词，不要使用下划线或者混合大小写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo</span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure>

<h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>尽量采取有意义的文件名，简短，有意义，应该为<strong>小写</strong>单词，使用<strong>下划线</strong>分隔各个单词。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">my_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<h3 id="结构体命名"><a href="#结构体命名" class="headerlink" title="结构体命名"></a>结构体命名</h3><ul>
<li><p>采用驼峰命名法，首字母根据访问控制大写或者小写</p>
</li>
<li><p>struct 申明和初始化格式采用多行，例如下面：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多行申明</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="type">string</span></span><br><span class="line">    Email     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多行初始化</span></span><br><span class="line">u := User&#123;</span><br><span class="line">    Username: <span class="string">&quot;astaxie&quot;</span>,</span><br><span class="line">    Email:    <span class="string">&quot;astaxie@gmail.com&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名"></a>接口命名</h3><ul>
<li>命名规则基本和上面的结构体类型保持一致。</li>
<li>单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><ul>
<li>和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则： <ul>
<li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient</li>
<li>其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID</li>
<li>错误示例：UrlArray，应该写成 urlArray 或者 URLArray</li>
</ul>
</li>
<li>若变量类型为 bool 类型，则名称应以 has, is, can 或 allow 开头</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isExist <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> hasConflict <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> canManage <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> allowGitHook <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><p>常量均需使用全部大写字母组成，并使用下划线分词</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> APP_VER = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure>


<p>如果是枚举类型的常量，需要先创建相应类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="type">string</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    HTTP  Scheme = <span class="string">&quot;http&quot;</span></span><br><span class="line">    HTTPS Scheme = <span class="string">&quot;https&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>下面的列表显示了Go中的保留字。这些保留字不能用作常量或变量或任何其他标识符名称。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24fd930b2dd64516845b351960d1df8b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="guanjianzi"></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Go提供C风格的<code>/* */</code>块注释和C ++风格的<code>//</code>行注释。行注释是常态；块注释主要显示为包注释，但在表达式中很有用或禁用大量代码。</p>
<ul>
<li>单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释</li>
<li>多行注释也叫块注释，均已以 &#x2F;* 开头，并以 *&#x2F; 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段</li>
</ul>
<p>go 语言自带的 godoc 工具可以根据注释生成文档，生成可以自动生成对应的网站（ golang.org 就是使用 godoc 工具直接生成的），注释的质量决定了生成的文档的质量。每个包都应该有一个包注释，在package子句之前有一个块注释。对于多文件包，包注释只需要存在于一个文件中，任何一个都可以。包评论应该介绍包，并提供与整个包相关的信息。它将首先出现在<code>godoc</code>页面上，并应设置下面的详细文档。</p>
<p>详细的如何写注释可以<br>参考：<a href="http://golang.org/doc/effective_go.html#commentary">http://golang.org/doc/effective_go.html#commentary</a></p>
<h3 id="包注释"><a href="#包注释" class="headerlink" title="包注释"></a>包注释</h3><p>每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中（一般是和包同名的文件）即可。 包注释应该包含下面基本信息(请严格按照这个顺序，简介，创建人，创建时间）：</p>
<ul>
<li>包的基本简介（包名，简介）</li>
<li>创建者，格式： 创建人： rtx 名</li>
<li>创建时间，格式：创建时间： yyyyMMdd</li>
</ul>
<p>例如 util 包的注释示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。</span></span><br><span class="line"><span class="comment">// 创建人： wxy</span></span><br><span class="line"><span class="comment">// 创建时间： 20230601</span></span><br></pre></td></tr></table></figure>

<h3 id="结构（接口）注释"><a href="#结构（接口）注释" class="headerlink" title="结构（接口）注释"></a>结构（接口）注释</h3><p>每个自定义的结构体或者接口都应该有注释说明，该注释对结构进行简要介绍，放在结构体定义的前一行，格式为： 结构体名， 结构体说明。同时结构体内的每个成员变量都要有说明，该说明放在成员变量的后面（注意对齐），实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User ， 用户对象，定义了用户的基础信息</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="type">string</span> <span class="comment">// 用户名</span></span><br><span class="line">    Email     <span class="type">string</span> <span class="comment">// 邮箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数（方法）注释"><a href="#函数（方法）注释" class="headerlink" title="函数（方法）注释"></a>函数（方法）注释</h3><p>每个函数，或者方法（结构体或者接口下的函数称为方法）都应该有注释说明，函数的注释应该包括三个方面（严格按照此顺序撰写）：</p>
<ul>
<li>简要说明，格式说明：以函数名开头，“，”分隔说明部分</li>
<li>参数列表：每行一个参数，参数名开头，“，”分隔说明部分</li>
<li>返回值： 每行一个返回值</li>
</ul>
<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewtAttrModel ， 属性数据层操作类的工厂方法</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      ctx ： 上下文信息</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      属性操作类指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAttrModel</span><span class="params">(ctx *common.Context)</span></span> *AttrModel &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码逻辑注释"><a href="#代码逻辑注释" class="headerlink" title="代码逻辑注释"></a>代码逻辑注释</h3><p>对于一些关键位置的代码逻辑，或者局部较为复杂的逻辑，需要有相应的逻辑说明，方便其他开发者阅读该段代码，实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br><span class="line">xxxxx</span><br><span class="line">xxxxxxx</span><br><span class="line">xxxxxxx</span><br></pre></td></tr></table></figure>

<h3 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h3><p>统一使用中文注释，对于中英文字符之间严格使用空格分隔， 这个不仅仅是中文和英文之间，英文和中文标点之间也都要使用空格分隔，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br></pre></td></tr></table></figure>


<p>上面 Redis 、 id 、 DB 和其他中文字符之间都是用了空格分隔。 </p>
<ul>
<li>建议全部使用单行注释</li>
<li>和代码的规范一样，单行注释不要过长，禁止超过 120 字符。</li>
</ul>
<h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><h3 id="缩进和折行"><a href="#缩进和折行" class="headerlink" title="缩进和折行"></a>缩进和折行</h3><ul>
<li>缩进直接使用 gofmt 工具格式化即可（gofmt 是使用 tab 缩进的）；</li>
<li>折行方面，一行最长不超过120个字符，超过的请使用换行展示，尽量保持格式优雅。</li>
</ul>
<p>我们使用Goland开发工具，可以直接使用快捷键：ctrl+alt+L，即可。</p>
<h3 id="语句的结尾"><a href="#语句的结尾" class="headerlink" title="语句的结尾"></a>语句的结尾</h3><p>Go语言中是不需要类似于Java需要冒号结尾，默认一行就是一条数据</p>
<p>如果你打算将多个语句写在同一行，它们则必须使用 <strong>;</strong> </p>
<h3 id="括号和空格"><a href="#括号和空格" class="headerlink" title="括号和空格"></a>括号和空格</h3><p>括号和空格方面，也可以直接使用 gofmt 工具格式化（go 会强制左大括号不换行，换行会报语法错误），所有的运算符和操作数之间要留空格。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的方式</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 错误的方式</span></span><br><span class="line"><span class="keyword">if</span> a&gt;<span class="number">0</span>  <span class="comment">// a ，0 和 &gt; 之间应该空格</span></span><br><span class="line">&#123;       <span class="comment">// 左大括号不可以换行，会报语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="import-规范"><a href="#import-规范" class="headerlink" title="import 规范"></a>import 规范</h3><p>import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;myproject/models&quot;</span></span><br><span class="line">    <span class="string">&quot;myproject/controller&quot;</span></span><br><span class="line">    <span class="string">&quot;myproject/utils&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/astaxie/beego&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)   </span><br></pre></td></tr></table></figure>

<p>有顺序的引入包，不同的类型采用空格分离，第一种是标准库，第二是项目包，第三是第三方包。</p>
<p>在项目中不要使用相对路径引入包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是不好的导入</span></span><br><span class="line"><span class="keyword">import</span> “../net”</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是正确的做法</span></span><br><span class="line"><span class="keyword">import</span> “github.com/repo/proj/src/net”</span><br></pre></td></tr></table></figure>

<p>但是如果是引入本项目中的其他包，最好使用相对路径。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul>
<li>错误处理的原则就是不能丢弃任何有返回err的调用，不要使用 _ 丢弃，必须全部处理。接收到错误，要么返回err，或者使用log记录下来</li>
<li>尽早return：一旦有错误发生，马上返回</li>
<li>尽量不要使用panic，除非你知道你在做什么</li>
<li>错误描述如果是英文必须为小写，不需要标点结尾</li>
<li>采用独立的错误流进行处理</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// normal code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>单元测试文件名命名规范为 example_test.go<br>测试用例的函数名称必须以 Test 开头，例如：TestExample<br>每个重要的函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试</p>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><p>上面提到了很过规范， go 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范，</p>
<p><strong>gofmt</strong><br>大部分的格式问题可以通过gofmt解决， gofmt 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 gofmt 的结果为准。</p>
<p><strong>goimport</strong><br>我们强烈建议使用 goimport ，该工具在 gofmt 的基础上增加了自动删除和引入包.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go get golang.org/x/tools/cmd/goimports</span></span><br></pre></td></tr></table></figure>

<p><em><strong>以上两种工具上一篇文章已经介绍过怎么配置</strong></em></p>
<p><strong>go vet</strong><br>vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go get golang.org/x/tools/cmd/vet</span></span><br></pre></td></tr></table></figure>


<p>使用如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go vet .</span></span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次对github项目提PR请求——以修改casdoor项目的swagger文档为例</title>
    <url>/2023/07/20/Go/29/</url>
    <content><![CDATA[<h1 id="PR简介"><a href="#PR简介" class="headerlink" title="PR简介"></a>PR简介</h1><p>PR(Pull Request) 即<code>拉取请求</code>,是 GitHub 上进行协同开发的一种非常常用的方式。<br>它的基本流程是：</p>
<ol>
<li>开发者fork一个开源项目的代码库,将其克隆到本地。</li>
<li>在本地对代码进行修改、添加新功能等。</li>
<li>将本地修改后的代码push到开发者自己的代码库中。</li>
<li>在开源项目的代码库中,发起一个pull request,请求项目维护者将开发者的代码merge到项目主代码库中。</li>
<li>项目维护者review代码,如果没有问题则approve并merge该PR。</li>
<li>开发者的代码就正式成为了该开源项目的一部分。</li>
</ol>
<h1 id="fork-与clone"><a href="#fork-与clone" class="headerlink" title="fork 与clone"></a>fork 与clone</h1><p>接下来按照步骤，逐步进行。<br>把<a href="https://github.com/casdoor/casdoor">casdoor</a>的github代码fork到自己的仓库里，通过这种方法，开发者可以在fork后的代码库中进行修改、新增功能，然后通过pull request将代码贡献回原项目。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/ae37a196fa664a68a768e35498885deb.png"></p>
<p>通过fork，你的仓库里就会多一个项目。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/33f331c4ad2f4e4a9f4d5a7ec7828bd5.png"></p>
<p>怎样对fork后的代码库进行修改呢？当然得将代码克隆到本地噻！右键点击空白处——你想保存该项目的路径下，用git打开：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/05c8810b72d14ed0906c57a7582bb049.png"></p>
<p>然后克隆你的代码库到本地，在git上输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/此处应该是你的github用户名/casdoor.git</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/b21ec60fc87145b3ac14b537ff31804a.png"></p>
<p>此时你会发现该路径下多了一个文件夹，名为casdoor，克隆成功。</p>
<h1 id="修改本地swagger文件（含bee的使用）"><a href="#修改本地swagger文件（含bee的使用）" class="headerlink" title="修改本地swagger文件（含bee的使用）"></a>修改本地swagger文件（含bee的使用）</h1><p>如何修改casdoor的<code>swagger</code>文件呢？简单来说就是修改注释代码然后用casbin魔改的bee工具生成<code>swagg.json</code>文件。我们知道，beego框架为生成交换文件提供支持，以便通过称为“bee”的命令行工具清除api。 Casdoor也以beego为基础。 但我们发现bee生成的swagger文件未能将api分类为“@Tag”标签， 我们修改了原bee以执行功能。那么如何写注释呢？</p>
<p>大多数规则与原bee comment格式完全相同， 唯一的差异是api必须按照”@Tag”标签分成不同的组别， 因此，开发者有义务确保正确添加此标签。 下面是一个示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GetLdap</span></span><br><span class="line"><span class="comment">// @Title GetLdap</span></span><br><span class="line"><span class="comment">// @Tag Account API</span></span><br><span class="line"><span class="comment">// @Description get ldap</span></span><br><span class="line"><span class="comment">// @Param	id	query	string	true	&quot;id&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;object&#125; object.Ldap The Response object</span></span><br><span class="line"><span class="comment">// @router /get-ldap [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ApiController)</span></span> GetLdap() &#123;</span><br><span class="line">	id := c.Input().Get(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> util.IsStringsEmpty(id) &#123;</span><br><span class="line">		c.ResponseError(c.T(<span class="string">&quot;general:Missing parameter&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, name := util.GetOwnerAndNameFromId(id)</span><br><span class="line">	c.ResponseOk(object.GetMaskedLdap(object.GetLdap(name)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具有相同”@Tag”标签的 api 将会被放入同一个组。</p>
<p>我们可以把注释分类：</p>
<p>@Title</p>
<p>接口的标题，用来标示唯一性，唯一，可选</p>
<p>格式：之后跟一个描述字符串</p>
<p>@Description</p>
<p>接口的作用，用来描述接口的用途，唯一，可选</p>
<p>格式：之后跟一个描述字符串</p>
<p>@Param</p>
<p>请求的参数，用来描述接受的参数，多个，可选</p>
<p>格式：变量名 传输类型 类型 是否必须 描述</p>
<p>变量名：字符串</p>
<p>传输类型：path or body or query or form or header</p>
<ul>
<li><p>query 表示带在url串里面?aa&#x3D;bb&amp;cc&#x3D;dd</p>
</li>
<li><p>form 表示使用表单递交数据</p>
</li>
<li><p>path 表示URL串中得字符，例如&#x2F;user&#x2F;{uid} 那么uid就是一个path类型的参数</p>
</li>
<li><p>body 表示使用raw body进行数据的传输</p>
</li>
<li><p>header 表示通过header进行数据的传输<br>类型：</p>
</li>
<li><p>string</p>
</li>
<li><p>int</p>
</li>
<li><p>int64</p>
</li>
<li><p>对象，这个地方大家写的时候需要注意，需要是相对于当前项目的路径.对象，例如models.Object表示models目录下的Object对象，这样bee在生成文档的时候会去扫描改对象并显示给用户改对象。<br>是否必须：true 或者false</p>
</li>
</ul>
<p>描述：字符串</p>
<p>@Success</p>
<p>成功返回的code和对象或者信息</p>
<p>格式：code 对象类型 信息或者对象路径</p>
<p>code：表示HTTP的标准status code，200 201等</p>
<p>对象类型：{object}表示对象，其他默认都认为是字符类型，会显示第三个参数给用户，如果是{object}类型，那么就会去扫描改对象，并显示给用户</p>
<p>对象路径和上面Param中得对象类型一样，使用路径.对象的方式来描述</p>
<p>@Failure</p>
<p>错误返回的信息，</p>
<p>格式： code 信息</p>
<p>code:同上Success</p>
<p>错误信息：字符串描述信息</p>
<p>@router</p>
<p>上面已经描述过支持两个参数，第一个是路由，第二个表示支持的HTTP方法。</p>
<p>注释写完后，就要用casbin提供的bee工具生成<code>swagger</code>文档。以下是<a href="https://casdoor.org/zh/docs/developer-guide/swagger">casdoor官方文档</a>提供的解决办法：</p>
<ol>
<li><p>以正确的格式写入 api</p>
</li>
<li><p>获取资源库 <a href="https://github.com/casbin/bee">https://github.com/casbin/bee</a></p>
</li>
<li><p>build the modified bee, for example, in the root directory of casbin&#x2F;bee, run</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build -o mybee .</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>copy mybee to the base directory of casdoor</p>
</li>
<li><p>in that directory, run</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mybee generate docs</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>之后你会发现生成新的swagger文件。</li>
</ol>
<p>以下是对以上步骤的理解与使用：</p>
<p>注释写完后先去<a href="https://github.com/casbin/bee">https://github.com/casbin/bee</a>获取bee工具，具体过程是将该仓库的代码克隆到本地（你也可以先fork，再克隆，因为不需要修改这个仓库的代码，所以可以不用fork）<br>在你想保存该bee工具代码的路径处用git bash打开，输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/casbin/bee.git</span><br></pre></td></tr></table></figure>
<p>然后进入该项目目录，也就是bee目录，输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build -o bee.exe</span><br></pre></td></tr></table></figure>
<p>使用该命令，可以在该项目目录下生成bee.exe文件，接下来为了使用它，将它复制一份存放在 <code>$GOPATH/bin</code> 里面，当然你需要把<code>$GOPATH/bin</code> 添加到你的环境变量中，我是将<code>$GOPATH/bin</code> 添加到用户变量的 path中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/e4b7edba08a04999aa3486868bb2018f.png"></p>
<p>至于为什么将<code>bee.exe</code>放在<code>$GOPATH/bin</code> 里面，这似乎是一种规范。配好环境变量后，打开casdoor的项目目录，在终端输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bee generate docs</span><br></pre></td></tr></table></figure>
<p>你会发现，项目中swagger目录里的<code>swagger.json</code>文件和<code>swagger.yml</code>文件均已更新，检查后确认casdoor的<code>swagger</code>文件修改成功。</p>
<h1 id="更新github仓库"><a href="#更新github仓库" class="headerlink" title="更新github仓库"></a>更新github仓库</h1><p>由于本地的casdoor项目有文件修改，比如上述的<code>swagger.json</code>文件和<code>swagger.yml</code>文件，接下来就要将他们提交到你的github仓库中。首先输入<code>git status</code>查看本地仓库与远程仓库的文件差异，再输入<code>git add -a</code>将工作目录中的文件添加到暂存区(staging area)，我输入的是<code> git add swagger</code>，表示只添加<code>swagger</code>这个目录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/29f3b13dea1b4e6eb1ecf660a080225e.png"></p>
<p>然后输入<code>git commit -m &quot;对这次提交的描述&quot;</code>，最后使用<code>git push origin matser</code>将本地的master分支推送到origin远程仓库的master分支。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/e9d6d8c9ad484323ab793581d2e67fb6.png"></p>
<p>但是经常会出现这个报错：<code>fatal: unable to access &#39;https://github.com/uestc-wxy/casdoor.git/&#39;: Failed to connect to github.com port 443 after 21065 ms: Couldn&#39;t connect to server</code>，或者其他类似于连接的错误，这就需要你在git输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy </span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<p>这个bug我已经习以为常了，接下来重新push你的master分支就行了。（万一还是不行，试试换换网络啥的，我当时换成热点突然就push成功了，难绷）</p>
<h1 id="提PR"><a href="#提PR" class="headerlink" title="提PR"></a>提PR</h1><p>这时你的github仓库已经更新完成了，下一步就是提PR，打开你要提PR的官方仓库（注意不是你自己fork后的仓库哈），点击<code>pull requests</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/14f4a03640d949dbac95f5ff3e797bc8.png"></p>
<p>再点击<code>New pull request</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/1b0bb874fcd441fa9ee7d537700b9f2f.png"></p>
<p>然后github会自动比较你的仓库和这个官方仓库代码的差异，符合要求后，可以点击<code>Create pull request</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/029e866a7f574f1d8de6b2996ab03af1.png"></p>
<p>其实我是通过如下方式提交PR的</p>
<p>fork的仓库代码被修改过后github会出现类似的语句：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/ce9fab66599841b6bb986669569740ba.png"></p>
<p>点击就能直接进入提PR的界面，符合要求后，就可以点击<code>Create pull request</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/5d7622cbd1514c3a84c71977ed8588d2.png"></p>
<p>你提的PR需要标题，你也可以做评论。标题一定要符合规范，否则PR将不予通过。即标题要以属性开头，后面跟上简要描述。</p>
<blockquote>
<p>feat: 新功能（feature）<br>fix: 修补bug<br>docs: 文档（documentation）<br>style: 格式（不影响代码运行的变动）<br>refactor: 重构（即不是新增功能，也不是修改bug的代码变动）<br>chore: 构建过程或辅助工具的变动<br>revert: 撤销，版本回退<br>perf: 性能优化<br>test：测试<br>improvement: 改进<br>build: 打包<br>ci: 持续集成</p>
</blockquote>
<p>比如fix: provide detailed description of ldap in swagger</p>
<p>另外还需要签订CLA协议，提交PR之后你会收到相关邮件，同意该协议即可。</p>
<p>至此，第一次提PR之旅纠结束了，感慨颇多，磕磕绊绊，到处查阅资料，最终也算圆满完成了。</p>
]]></content>
      <tags>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言性能优化建议与pprof性能调优详解</title>
    <url>/2023/08/01/Go/31/</url>
    <content><![CDATA[<h1 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h1><p>简介：</p>
<ul>
<li>性能优化的前提是满足正确可靠、简洁清晰等质量因素</li>
<li>性能优化是综合评估，有时候时间效率和空间效率可能对立</li>
<li>针对Go语言特性，介绍Go相关的性能优化建议</li>
</ul>
<h2 id="Benchmark的使用"><a href="#Benchmark的使用" class="headerlink" title="Benchmark的使用"></a>Benchmark的使用</h2><p>性能表现需要实际数据衡量，Go语言提供了支持基准性能测试的benchmark工具。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fib.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fib_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib10</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">       Fib(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>benchmark 和普通的单元测试用例一样，都位于 <code>_test.go</code> 文件中。</li>
<li>函数名以 <code>Benchmark</code> 开头，参数是 <code>b *testing.B</code>。和普通的单元测试用例很像，单元测试函数名以 <code>Test</code> 开头，参数是 <code>t *testing.T</code>。</li>
</ul>
<p>运行示例：</p>
<ul>
<li>运行当前 package 内的用例：<code>go test .</code></li>
<li>运行子 package 内的用例： <code>go test ./&lt;package name&gt;</code></li>
<li>如果想递归测试当前目录下的所有的 package：<code>go test ./...</code></li>
</ul>
<p><code>go test</code> 命令默认不运行 benchmark 用例的，如果我们想运行 benchmark 用例，需要加上 <code>-bench</code> 参数。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: GoProject1</span><br><span class="line">cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz</span><br><span class="line">BenchmarkFib10-16        5496252               212.5 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      GoProject1      1.454s</span><br></pre></td></tr></table></figure>

<ol>
<li><code>goos: windows</code>：这行显示运行基准测试的操作系统，此处为 Windows。</li>
<li><code>goarch: amd64</code>：这行显示运行基准测试的机器架构，此处为 64 位 AMD 架构。</li>
<li><code>pkg: GoProject1</code>：这行显示包含基准测试代码的包名，此处为 “GoProject1”。</li>
<li><code>cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz</code>：这行显示运行基准测试的机器 CPU 信息，包括 CPU 型号和时钟频率。</li>
<li><code>PASS</code>：这行表示所有的测试，包括基准测试，都已成功通过。</li>
<li><code>ok GoProject1 1.454s</code>：这行显示所有测试，包括基准测试，的整体执行时间。在这种情况下，整个测试套件执行时间大约为 1.454 秒。</li>
</ol>
<p><code>BenchmarkFib10-16 </code>是测试函数名，<code>-16</code>表示<code>GOMAXPROCS</code>的值为16，<code>GOMAXPROCS 1.5</code>版本后，默认值为<code>CPU</code>核数 。<code>5496252</code> 表示一共执行<code>5496252</code> 次，即<code>b.N</code>的值。<code>212.5 ns/op</code>表示每次执行花费<code>212.5ns</code>。</p>
<h2 id="slice优化"><a href="#slice优化" class="headerlink" title="slice优化"></a>slice优化</h2><h3 id="预分配内存"><a href="#预分配内存" class="headerlink" title="预分配内存"></a>预分配内存</h3><p>接下来看两个函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NoPreAlloc</span><span class="params">(size <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++ &#123;</span><br><span class="line">		data = <span class="built_in">append</span>(data, k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreAlloc</span><span class="params">(size <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, size)</span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++ &#123;</span><br><span class="line">		data = <span class="built_in">append</span>(data, k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别为它们编写基准测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkNoPreAlloc</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		NoPreAlloc(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPreAlloc</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		PreAlloc(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: GoProject1</span><br><span class="line">cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz</span><br><span class="line">BenchmarkNoPreAlloc-16               193           5968006 ns/op</span><br><span class="line">BenchmarkPreAlloc-16                1498            825965 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      GoProject1      3.164s</span><br></pre></td></tr></table></figure>

<p>可以看到预分配内存后，性能更好。因此应尽可能在使用make()初始化切片时提供容量信息。</p>
<h3 id="大内存未释放"><a href="#大内存未释放" class="headerlink" title="大内存未释放"></a>大内存未释放</h3><p>当我们在已有切片基础上创建新的切片时，新切片并不会创建一个新的底层数组。相反，它会共享同一个底层数组。这种情况下，如果我们从一个大切片中截取出一个小切片，并且在代码中保留对大切片的引用，那么原底层数组将会一直存在于内存中，得不到释放，即使大切片的内容对我们来说已经不再需要了。</p>
<p>举例说明： 假设有一个名为<code>bigSlice</code>的大切片，其底层数组非常大。然后我们基于<code>bigSlice</code>创建一个新的小切片<code>smallSlice</code>，并且在代码中保留对<code>bigSlice</code>的引用。这样一来，即使我们只使用<code>smallSlice</code>，底层数组也不会被释放，导致占用大量的内存。</p>
<p>优化建议：使用copy替代re-slice 为了避免上述陷阱，我们可以使用copy操作来创建一个新的切片，而不是在已有切片基础上使用re-slice。copy操作会将源切片的内容复制到一个新的底层数组中，这样就不会和原始切片共享底层数组，避免了底层数组无法释放的问题。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">goCopy codebigSlice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1000000</span>) <span class="comment">// 假设bigSlice是一个非常大的切片</span></span><br><span class="line"><span class="comment">// 使用re-slice，smallSlice和bigSlice共享同一个底层数组</span></span><br><span class="line">smallSlice := bigSlice[:<span class="number">100</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用copy，创建一个新的切片，底层数组得到释放</span></span><br><span class="line">smallSlice = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">copy</span>(smallSlice, bigSlice[:<span class="number">100</span>])</span><br></pre></td></tr></table></figure>

<p>通过使用copy操作，我们可以避免因为底层数组无法释放而导致的内存浪费问题。</p>
<h2 id="map优化"><a href="#map优化" class="headerlink" title="map优化"></a>map优化</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NoPreAlloc</span><span class="params">(size <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++ &#123;</span><br><span class="line">       data[k] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreAlloc</span><span class="params">(size <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, size)</span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++ &#123;</span><br><span class="line">       data[k] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkNoPreAlloc</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		NoPreAlloc(<span class="number">1000000</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPreAlloc</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		PreAlloc(<span class="number">1000000</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: GoProject1</span><br><span class="line">cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz</span><br><span class="line">BenchmarkNoPreAlloc-16                12          90044942 ns/op</span><br><span class="line">BenchmarkPreAlloc-16                  26          50461700 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      GoProject1      2.637s</span><br></pre></td></tr></table></figure>

<p>可以发现map预分配内存后效果更好。</p>
<p>分析：</p>
<ul>
<li>不断向map中添加元素的操作会触发map的扩容</li>
<li>提前分配好空间可以减少内存拷贝和Rehash的消耗。</li>
<li>建议根据实际需求提前预估好需要的空间</li>
</ul>
<h2 id="字符串处理优化"><a href="#字符串处理优化" class="headerlink" title="字符串处理优化"></a>字符串处理优化</h2><p>使用<code>strings.Builder</code>、预分配内存。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Plus</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    s := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">       s += str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StrBuilder</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> builder strings.Builder</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">       builder.WriteString(str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ByteBuffer</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">       buf.WriteString(str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreStrBuilder</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> builder strings.Builder</span><br><span class="line">	builder.Grow(n * <span class="built_in">len</span>(str))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		builder.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreStrByteBuffer</span><span class="params">(n <span class="type">int</span>, str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	buf.Grow(n * <span class="built_in">len</span>(str))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		buf.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPlus</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		Plus(<span class="number">100000</span>, <span class="string">&quot;wxy&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStrBuilder</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		StrBuilder(<span class="number">100000</span>, <span class="string">&quot;wxy&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkByteBuffer</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		ByteBuffer(<span class="number">100000</span>, <span class="string">&quot;wxy&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPreStrBuilder</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		PreStrBuilder(<span class="number">100000</span>, <span class="string">&quot;wxy&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPreByteBuffer</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		PreStrByteBuffer(<span class="number">100000</span>, <span class="string">&quot;wxy&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: GoProject1</span><br><span class="line">cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz</span><br><span class="line">BenchmarkPlus-16                       1        1126084200 ns/op</span><br><span class="line">BenchmarkStrBuilder-16              3982            284773 ns/op</span><br><span class="line">BenchmarkByteBuffer-16              2947            485091 ns/op</span><br><span class="line">BenchmarkPreStrBuilder-16           4771            278961 ns/op</span><br><span class="line">BenchmarkPreByteBuffer-16           3310            364676 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      GoProject1      6.457s</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>＋</code>拼接性能最差，<code>strings.Builder</code>，<code>bytes.Buffer</code>相近，<code>strings.Builder</code>更快</li>
<li>字符串在Go语言中是不可变类型，占用内存大小是固定的</li>
<li>使用<code>＋</code>每次都会重新分配内存</li>
<li><code>strings.Builder</code>， <code>bytes.Buffer</code>底层都是[]byte数组。内存扩容策略，不需要每次拼接重新分配内存</li>
<li>预分配内存后，<code>strings.Builder</code>， <code>bytes.Buffer</code>性能都有所提升</li>
</ul>
<h2 id="结构体优化"><a href="#结构体优化" class="headerlink" title="结构体优化"></a>结构体优化</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmptyStructMap</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">       m[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BoolMap</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">       m[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkEmptyStructMap</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">       EmptyStructMap(<span class="number">100000000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkBoolMap</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">       BoolMap(<span class="number">100000000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: GoProject1</span><br><span class="line">cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz</span><br><span class="line">BenchmarkEmptyStructMap-16             1        13943515100 ns/op</span><br><span class="line">BenchmarkBoolMap-16                    1        14002905100 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      GoProject1      28.215s</span><br></pre></td></tr></table></figure>

<p>可以发现使用空结构体性能较好。</p>
<p>使用空结构体节省内存：</p>
<ul>
<li>空结构体struct{}实例不占据任何的内存空间</li>
<li>可作为各种场景下的占位符使用</li>
<li>节省资源</li>
<li>空结构体本身具备很强的语义，即这里不需要任何值，仅作为占位符</li>
</ul>
<h2 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> atomicCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AtomicAddOne</span><span class="params">(c *atomicCounter)</span></span> &#123;</span><br><span class="line">    atomic.AddInt32(&amp;c.i, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mutexCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="type">int32</span></span><br><span class="line">    m sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MutexAddOne</span><span class="params">(c *mutexCounter)</span></span> &#123;</span><br><span class="line">    c.m.Lock()</span><br><span class="line">    c.i++</span><br><span class="line">    c.m.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAtomicAddOne</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c atomicCounter</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">       AtomicAddOne(&amp;c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMutexAddOne</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c mutexCounter</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">       MutexAddOne(&amp;c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: GoProject1</span><br><span class="line">cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz</span><br><span class="line">BenchmarkAtomicAddOne-16        255736488                4.565 ns/op</span><br><span class="line">BenchmarkMutexAddOne-16         99685160                13.66 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      GoProject1      3.101s</span><br></pre></td></tr></table></figure>

<p>使用atomic包：</p>
<ul>
<li>锁的实现是通过操作系统来实现，属于系统调用</li>
<li>atomic操作是通过硬件实现，效率比锁高</li>
<li>sync.Mutex应该用来保护一段逻辑，不仅仅用于保护一个变量</li>
<li>对于非数值操作，可以使用atomic.Value，能承载一个interface{}</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>避免常见的性能陷阱可以保证大部分程序的性能</li>
<li>普通应用代码，不要一味地追求程序的性能</li>
<li>越高级的性能优化手段越容易出现问题</li>
<li>在满足正确可靠、简洁清晰的质量要求的前提下提高程序性能</li>
</ul>
<h1 id="pprof性能调优"><a href="#pprof性能调优" class="headerlink" title="pprof性能调优"></a>pprof性能调优</h1><p>在计算机性能调试领域里，profiling 是指对应用程序的画像，画像就是应用程序使用 CPU 和内存的情况。 Go语言是一个对性能特别看重的语言，因此语言中自带了 profiling 的库。</p>
<p>Go语言项目中的性能优化主要有以下几个方面：</p>
<ul>
<li>CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据</li>
<li>Memory Profile（Heap Profile）：报告程序的内存使用情况</li>
<li>Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈</li>
<li>Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的</li>
</ul>
<h2 id="采集性能数据"><a href="#采集性能数据" class="headerlink" title="采集性能数据"></a>采集性能数据</h2><p>Go语言内置了获取程序的运行数据的工具，包括以下两个标准库：</p>
<ul>
<li><code>runtime/pprof</code>：采集工具型应用运行数据进行分析</li>
<li><code>net/http/pprof</code>：采集服务型应用运行时数据进行分析</li>
</ul>
<p>pprof开启后，每隔一段时间（10ms）就会收集下当前的堆栈信息，获取各个函数占用的CPU以及内存资源；最后通过对这些采样数据进行分析，形成一个性能分析报告。</p>
<p>注意，我们只应该在性能测试的时候才在代码中引入pprof。</p>
<p>本篇文章只对服务型应用进行性能分析。</p>
<h2 id="服务型应用"><a href="#服务型应用" class="headerlink" title="服务型应用"></a>服务型应用</h2><p>如果你的应用程序是一直运行的，比如 web 应用，那么可以使用<code>net/http/pprof</code>库，它能够在提供 HTTP 服务进行分析。</p>
<p>如果使用了默认的<code>http.DefaultServeMux</code>（通常是代码直接使用 http.ListenAndServe(“0.0.0.0:8000”, nil)），只需要在你的web server端代码中按如下方式导入<code>net/http/pprof</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你使用自定义的 Mux，则需要手动注册一些路由规则：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/&quot;</span>, pprof.Index)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/cmdline&quot;</span>, pprof.Cmdline)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/profile&quot;</span>, pprof.Profile)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/symbol&quot;</span>, pprof.Symbol)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/trace&quot;</span>, pprof.Trace)</span><br></pre></td></tr></table></figure>

<p>如果你使用的是gin框架，那么推荐使用<a href="https://github.com/gin-contrib/pprof">github.com&#x2F;gin-contrib&#x2F;pprof</a>，在代码中通过以下命令注册pprof相关路由。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.Register(router)</span><br></pre></td></tr></table></figure>

<p>不管哪种方式，你的 HTTP 服务都会多出<code>http://host:port/debug/pprof</code> ，访问它会得到类似下面的内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230801142327134.png"></p>
<p>这个路径下还有几个子页面：</p>
<ul>
<li>&#x2F;debug&#x2F;pprof&#x2F;profile：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载</li>
<li>&#x2F;debug&#x2F;pprof&#x2F;heap： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件</li>
<li>&#x2F;debug&#x2F;pprof&#x2F;block：block Profiling 的路径</li>
<li>&#x2F;debug&#x2F;pprof&#x2F;goroutines：运行的 goroutines 列表，以及调用关系</li>
</ul>
<p>下面是详细的解释：</p>
<blockquote>
<p>Allocs: 过去所有内存分配的抽样</p>
<p>Block: 导致同步原语阻塞的堆栈跟踪</p>
<p>Cmdline: 当前程序的命令行调用</p>
<p>Goroutine: 所有当前 goroutine 的堆栈跟踪。使用 debug &#x3D; 2作为查询参数，以与未恢复的惊慌相同的格式导出。</p>
<p>Heap: 活动对象的内存分配的抽样。在获取堆示例之前，可以指定 gc GET 参数来运行 GC。</p>
<p>Mutex: 对争用的互斥对象的持有者进行跟踪堆栈</p>
<p>profile: CPU 配置文件。可以在秒 GET 参数中指定持续时间。获得概要文件之后，使用 go 工具 pprof 命令调查概要文件。</p>
<p>Threadcreate: 导致创建新操作系统线程的堆栈跟踪</p>
<p>Trace: 当前程序执行的跟踪。可以在秒 GET 参数中指定持续时间。获得跟踪文件后，使用 go tool trace 命令调查跟踪。</p>
</blockquote>
<h2 id="go-tool-pprof命令"><a href="#go-tool-pprof命令" class="headerlink" title="go tool pprof命令"></a>go tool pprof命令</h2><p>不管是工具型应用还是服务型应用，我们使用相应的pprof库获取数据之后，下一步的都要对这些数据进行分析，我们可以使用<code>go tool pprof</code>命令行工具。</p>
<p><code>go tool pprof</code>最简单的使用方式为:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof [binary] [<span class="built_in">source</span>]</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>binary 是应用的二进制文件，用来解析各种符号；</li>
<li>source 表示 profile 数据的来源，可以是本地的文件，也可以是 http 地址。</li>
</ul>
<p><strong>注意事项：</strong> 获取的 Profiling 数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。</p>
<h2 id="项目调优分析"><a href="#项目调优分析" class="headerlink" title="项目调优分析"></a>项目调优分析</h2><p>本案例使用了blob项目——类似博客的管理系统，用beego实现，源码我已经放到了github仓库里：<a href="https://github.com/uestc-wxy/blob">https://github.com/uestc-wxy/blob</a>，里面也有详细的使用说明。</p>
<h3 id="修改main-go"><a href="#修改main-go" class="headerlink" title="修改main.go"></a>修改<code>main.go</code></h3><p>为了能对这个项目进行调优分析，需要在<code>main.go</code>文件里添加几行代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       http.ListenAndServe(<span class="string">&quot;localhost:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure>

<p>下面是修改后的<code>main.go</code>（只需要修改这一个文件）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;blob/models&quot;</span></span><br><span class="line">    _ <span class="string">&quot;blob/routers&quot;</span></span><br><span class="line">    <span class="string">&quot;blob/utils&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/beego/beego/v2/client/orm&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    username, _ := web.AppConfig.String(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    password, _ := web.AppConfig.String(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">    host, _ := web.AppConfig.String(<span class="string">&quot;host&quot;</span>)</span><br><span class="line">    port, _ := web.AppConfig.String(<span class="string">&quot;port&quot;</span>)</span><br><span class="line">    database, _ := web.AppConfig.String(<span class="string">&quot;database&quot;</span>)</span><br><span class="line"></span><br><span class="line">    datasource := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;loc=Local&quot;</span>, username, password, host, port, database)</span><br><span class="line">    err := orm.RegisterDataBase(<span class="string">&quot;default&quot;</span>, <span class="string">&quot;mysql&quot;</span>, datasource)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = orm.RunSyncdb(<span class="string">&quot;default&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    web.InsertFilter(<span class="string">&quot;/cms/index/*&quot;</span>, web.BeforeRouter, utils.CmsLoginFilter)</span><br><span class="line">    orm.RunCommand()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       http.ListenAndServe(<span class="string">&quot;localhost:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    web.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装go-wrk"><a href="#安装go-wrk" class="headerlink" title="安装go-wrk"></a>安装go-wrk</h3><p>为了使数据直观便于分析，需要使用压测工具。</p>
<p>推荐使用：<a href="https://github.com/wg/wrk">https://github.com/wg/wrk</a> 或 <a href="https://github.com/adjust/go-wrk">https://github.com/adjust/go-wrk</a>，由于我是Windows系统，于是选择了后者，因为前者对Windows并不是很友好，虽然它的star数还要多些。</p>
<p>在<code>GOPATH/src</code>路径终端依次运行下列命令，注意是<code>GOPATH/src</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/adjust/go-wrk.git</span><br><span class="line"><span class="built_in">cd</span> go-wrk</span><br><span class="line">go mod init</span><br><span class="line">go mod tidy</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>

<p>这时你会发现<code>go-wrk</code>项目里会多出<code>go-wrk.exe</code>文件，为了方便使用我选择把它放在（也就是复制粘贴过去）<code>GOPATH/bin</code>目录下，当然你得把<code>GOPATH/bin</code>放在环境变量里面，至于为什么将<code>go-wrk.exe</code>放在<code>$GOPATH/bin</code> 里面，这似乎是一种规范。我的其他文章也有提到过。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/e4b7edba08a04999aa3486868bb2018f.png"></p>
<p>通过上述操作就可以在任何地方使用<code>go-wrk</code>命令了。</p>
<h3 id="命令行交互界面"><a href="#命令行交互界面" class="headerlink" title="命令行交互界面"></a>命令行交互界面</h3><p>首先需要保证我们的项目需要在本地跑起来。在项目根目录终端运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build</span><br><span class="line">./blob</span><br></pre></td></tr></table></figure>

<p>当然也可以使用<code>bee run</code>命令，毕竟这是beego项目特有的运行方式。</p>
<p>然后在该路径下再开一个终端，用来跑压测，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go-wrk -n 50000 http://localhost:8080/</span><br></pre></td></tr></table></figure>

<p>执行上面的代码会进入交互界面如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) PS F:\GolandProjects\beegoProject\blob&gt; go-wrk -n 50000 http://localhost:8080/</span><br><span class="line">==========================BENCHMARK==========================</span><br><span class="line">URL:                            http://localhost:8080/</span><br><span class="line"></span><br><span class="line">Used Connections:               100</span><br><span class="line">Used Threads:                   1</span><br><span class="line">Total number of calls:          50000</span><br><span class="line"></span><br><span class="line">===========================TIMINGS===========================</span><br><span class="line">Total time passed:              22.95s</span><br><span class="line">Avg time per request:           45.76ms</span><br><span class="line">Requests per second:            2179.05</span><br><span class="line">Median time per request:        45.14ms</span><br><span class="line">99th percentile time:           53.77ms</span><br><span class="line">Slowest time for request:       119.00ms</span><br><span class="line"></span><br><span class="line">=============================DATA=============================</span><br><span class="line">Total response body sizes:              251100000</span><br><span class="line">Avg response body per request:          5022.00 Byte</span><br><span class="line">Transfer rate per second:               10943208.24 Byte/s (10.94 MByte/s)</span><br><span class="line">==========================RESPONSES==========================</span><br><span class="line">20X Responses:          50000   (100.00%)</span><br><span class="line">30X Responses:          0       (0.00%)</span><br><span class="line">40X Responses:          0       (0.00%)</span><br><span class="line">50X Responses:          0       (0.00%)</span><br><span class="line">Errors:                 0       (0.00%)</span><br></pre></td></tr></table></figure>

<p>接着再开一个终端，以使用<code>pprof</code>来分析。</p>
<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof http://127.0.0.1:8080/debug/pprof/profile</span><br></pre></td></tr></table></figure>

<p>执行上面的代码会进入交互界面如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) PS F:\GolandProjects\beegoProject\blob&gt; go tool pprof http://127.0.0.1:8080/debug/pprof/profile</span><br><span class="line">Fetching profile over HTTP from http://127.0.0.1:8080/debug/pprof/profile</span><br><span class="line">Saved profile in C:\Users\19393\pprof\pprof.blob.exe.samples.cpu.004.pb.gz</span><br><span class="line">File: blob.exe</span><br><span class="line">Build ID: F:\GolandProjects\beegoProject\blob\blob.exe2023-08-01 16:06:16.7719208 +0800 CST   </span><br><span class="line">Type: cpu</span><br><span class="line">Time: Aug 1, 2023 at 4:10pm (CST)</span><br><span class="line">Duration: 30s, Total samples = 44.41s (148.02%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure>

<p>我们可以在交互界面输入<code>top5</code>来查看程序中占用CPU前5位的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(pprof) top5</span><br><span class="line">Showing nodes accounting for 27510ms, 61.95% of 44410ms total</span><br><span class="line">Dropped 859 nodes (cum &lt;= 222.05ms)</span><br><span class="line">Showing top 5 nodes out of 246</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">   21960ms 49.45% 49.45%    22080ms 49.72%  runtime.cgocall</span><br><span class="line">    2010ms  4.53% 53.97%     5980ms 13.47%  runtime.scanobject</span><br><span class="line">    1410ms  3.17% 57.15%     1740ms  3.92%  runtime.greyobject</span><br><span class="line">    1340ms  3.02% 60.17%     1730ms  3.90%  runtime.findObject</span><br><span class="line">     790ms  1.78% 61.95%      790ms  1.78%  runtime.stdcall2</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>flat：当前函数占用CPU的耗时</li>
<li>flat：:当前函数占用CPU的耗时百分比</li>
<li>sun%：函数占用CPU的耗时累计百分比</li>
<li>cum：当前函数加上调用当前函数的函数占用CPU的总耗时</li>
<li>cum%：当前函数加上调用当前函数的函数占用CPU的总耗时百分比</li>
<li>最后一列：函数名称</li>
</ul>
<p>我们发现上面并没有我们自己写的函数，所以本项目的性能还是不错的。在大多数的情况下，我们可以通过分析这五列得出一个应用程序的运行情况，并对程序进行优化。</p>
<p>我们还可以使用<code>list 函数名</code>命令查看具体的函数分析，例如执行<code>list cgocall</code>查看我们编写的函数的详细分析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(pprof) list cgocall</span><br><span class="line">Total: 44.41s</span><br><span class="line">ROUTINE ======================== runtime.cgocall in F:\Users\19393\sdk\go1.20.4\src\runtime\cgocall.go</span><br><span class="line">    21.96s     22.08s (flat, cum) 49.72% of Total</span><br><span class="line">         .          .    123:func cgocall(fn, arg unsafe.Pointer) int32 &#123;</span><br><span class="line">         .          .    124:   if !iscgo &amp;&amp; GOOS != &quot;solaris&quot; &amp;&amp; GOOS != &quot;illumos&quot; &amp;&amp; GOOS != &quot;windows&quot; &#123;</span><br><span class="line">         .          .    125:           throw(&quot;cgocall unavailable&quot;)</span><br><span class="line">         .          .    126:   &#125;</span><br><span class="line">         .          .    127:</span><br><span class="line">         .          .    128:   if fn == nil &#123;</span><br><span class="line">         .          .    129:           throw(&quot;cgocall nil&quot;)</span><br><span class="line">         .          .    130:   &#125;</span><br><span class="line">         .          .    131:</span><br><span class="line">         .          .    132:   if raceenabled &#123;</span><br><span class="line">         .          .    133:           racereleasemerge(unsafe.Pointer(&amp;racecgosync))        </span><br><span class="line">         .          .    134:   &#125;</span><br><span class="line">         .          .    135:</span><br><span class="line">         .          .    136:   mp := getg().m</span><br><span class="line">         .          .    137:   mp.ncgocall++</span><br><span class="line">         .          .    138:   mp.ncgo++</span><br><span class="line">         .          .    139:</span><br><span class="line">         .          .    140:   // Reset traceback.</span><br><span class="line">         .          .    141:   mp.cgoCallers[0] = 0</span><br><span class="line">         .          .    142:</span><br><span class="line">         .          .    143:   // Announce we are entering a system call</span><br><span class="line">         .          .    144:   // so that the scheduler knows to create another</span><br><span class="line">         .          .    145:   // M to run goroutines while we are in the</span><br><span class="line">         .          .    146:   // foreign code.</span><br><span class="line">         .          .    147:   //</span><br><span class="line">         .          .    148:   // The call to asmcgocall is guaranteed not to</span><br><span class="line">         .          .    149:   // grow the stack and does not allocate memory,</span><br><span class="line">         .          .    150:   // so it is safe to call while &quot;in a system call&quot;, outside    </span><br><span class="line">         .          .    151:   // the $GOMAXPROCS accounting.</span><br><span class="line">         .          .    152:   //</span><br><span class="line">         .          .    153:   // fn may call back into Go code, in which case we&#x27;ll exit the</span><br><span class="line">         .          .    154:   // &quot;system call&quot;, run the Go code (which may grow the stack), </span><br><span class="line">         .          .    155:   // and then re-enter the &quot;system call&quot; reusing the PC and SP  </span><br><span class="line">         .          .    156:   // saved by entersyscall here.</span><br><span class="line">    21.94s     21.94s    157:   entersyscall()</span><br><span class="line">         .          .    158:</span><br><span class="line">         .          .    159:   // Tell asynchronous preemption that we&#x27;re entering external  </span><br><span class="line">         .          .    168:</span><br><span class="line">         .          .    169:   // Update accounting before exitsyscall because exitsyscall may</span><br><span class="line">         .          .    170:   // reschedule us on to a different M.</span><br><span class="line">         .          .    171:   mp.incgo = false</span><br><span class="line">         .          .    172:   mp.ncgo--</span><br><span class="line">         .          .    173:</span><br><span class="line">      20ms       40ms    174:   osPreemptExtExit(mp)</span><br><span class="line">         .          .    175:</span><br><span class="line">         .      100ms    176:   exitsyscall()</span><br><span class="line">         .          .    177:</span><br><span class="line">         .          .    178:   // Note that raceacquire must be called only after exitsyscall has</span><br><span class="line">         .          .    179:   // wired this M to a P.</span><br><span class="line">         .          .    180:   if raceenabled &#123;</span><br><span class="line">         .          .    181:           raceacquire(unsafe.Pointer(&amp;racecgosync))</span><br></pre></td></tr></table></figure>

<p>通过分析发现大部分CPU资源被157行占用，耗时21.94s。</p>
<h3 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h3><p>或者可以直接输入web，通过svg图的方式查看程序中详细的CPU占用情况。 想要查看图形化的界面首先需要安装<a href="https://graphviz.gitlab.io/">graphviz</a>图形化工具。由于我是Windows系统，进入官网下载graphviz：<a href="https://graphviz.gitlab.io/download/">https://graphviz.gitlab.io/download/</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230801162336635.png"></p>
<p>下载完后打开<code>exe</code>文件进行安装。</p>
<p>这里勾选第二个，自动帮你配置环境变量。后面快捷方式我选择不创建。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230801162838369.png"></p>
<p>安装完毕后打开终端运行<code>dot -v</code>检查是否安装成功，安装成功应该会显示以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) PS C:\Users\19393&gt; dot -v</span><br><span class="line">dot - graphviz version 8.1.0 (20230707.0739)</span><br><span class="line">libdir = &quot;F:\Program Files\Graphviz\bin&quot;</span><br><span class="line">Activated plugin library: gvplugin_dot_layout.dll</span><br><span class="line">Using layout: dot:dot_layout</span><br><span class="line">Activated plugin library: gvplugin_core.dll</span><br><span class="line">Using render: dot:core</span><br><span class="line">Using device: dot:dot:core</span><br><span class="line">The plugin configuration file:</span><br><span class="line">        F:\Program Files\Graphviz\bin\config6</span><br><span class="line">                was successfully loaded.</span><br><span class="line">    render      :  cairo dot dot_json fig gdiplus json json0 map mp pic pov ps svg tk xdot xdot_json</span><br><span class="line">    layout      :  circo dot fdp neato nop nop1 nop2 osage patchwork sfdp twopi</span><br><span class="line">    textlayout  :  textlayout</span><br><span class="line">    device      :  bmp canon cmap cmapx cmapx_np dot dot_json emf emfplus eps fig gif gv imap imap_np ismap jpe jpeg jpg json json0 metafile mp pdf pic plain plain-ext png pov ps ps2 svg tif tiff tk xdot xdot1.2 xdot1.4 xdot_json</span><br><span class="line">    loadimage   :  (lib) bmp eps gif jpe jpeg jpg png ps svg</span><br></pre></td></tr></table></figure>

<p>输入web前确认<code>graphviz</code>安装目录下的bin文件夹有无被添加到Path环境变量（我添加的系统变量）中。</p>
<p>接下来我们尝试用图形化的界面来进行分析。</p>
<p>先保证自己的<code>beego</code>项目运行在本地上，再开一个终端跑压测：<code>go-wrk -n 50000 http://localhost:8080/</code>，另外再来一个和终端跑<code>pprof</code>，执行命令：<code>go tool pprof http://127.0.0.1:8080/debug/pprof/profile</code>。</p>
<p>跑<code>pprof</code>的终端如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) PS F:\GolandProjects\beegoProject\blob&gt; go tool pprof http://127.0.0.1:8080/debug/pprof/profile</span><br><span class="line">Fetching profile over HTTP from http://127.0.0.1:8080/debug/pprof/profile</span><br><span class="line">Saved profile in C:\Users\19393\pprof\pprof.blob.exe.samples.cpu.008.pb.gz</span><br><span class="line">File: blob.exe</span><br><span class="line">Build ID: F:\GolandProjects\beegoProject\blob\blob.exe2023-08-01 16:06:16.7719208 +0800 CST</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Aug 1, 2023 at 7:02pm (CST)</span><br><span class="line">Duration: 30s, Total samples = 44.25s (147.48%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) web</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure>

<p>由于输入了web命令，浏览器会自动弹出查看<code>svg</code>的页面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230801190806595.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230801190826155.png"></p>
<p>关于图形的说明： 每个框代表一个函数，理论上框的越大表示占用的CPU资源越多。 方框之间的线条代表函数之间的调用关系。 线条上的数字表示函数调用的时间。 方框中的第一行数字表示当前函数占用CPU的百分比，第二行数字表示当前函数累计占用CPU的百分比。</p>
<p>除了分析CPU性能数据，pprof也支持分析内存性能数据。比如，使用下面的命令分析http服务的heap性能数据，查看当前程序的内存占用以及热点内存对象使用的情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看内存占用数据</span></span><br><span class="line">go tool pprof -inuse_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof -inuse_objects http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line"><span class="comment"># 查看临时内存分配数据</span></span><br><span class="line">go tool pprof -alloc_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof -alloc_objects http://127.0.0.1:8080/debug/pprof/heap</span><br></pre></td></tr></table></figure>

<p>以下是查看内存占用数据的示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230801191312749.png"></p>
<h3 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h3><p>火焰图（Flame Graph）是 Bredan Gregg 创建的一种性能分析图表，因为它的样子近似 🔥而得名。</p>
<p>可以通过如下方式来打开火焰图：</p>
<ol>
<li>先把压测跑上：<code>go-wrk -n 50000 http://localhost:8080/</code></li>
<li>项目根目录新开一个终端，运行<code>go tool pprof -http=:5200 http://127.0.0.1:8080/debug/pprof/profile</code>，30s后，浏览器会自动跳出新界面：<a href="http://localhost:5200/ui/">http://localhost:5200/ui/</a>，如下：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230801210039574.png"></p>
<ol start="3">
<li>跟之前的图形化界面差不多，接下来点击下图中图示任一个便能看到火焰图。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230801210150456.png"></p>
<p>老版火焰图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230801210344921.png"></p>
<p>新版火焰图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230801210420366.png"></p>
<p>火焰图的优点是它是动态的：可以通过点击每个方块来 分析它下面的内容。</p>
<p>火焰图的调用顺序从上到下，每个方块代表一个函数，它下面一层表示这个函数会调用哪些函数，方块的大小代表了占用 CPU 使用的长短。火焰图的配色并没有特殊的意义，默认的红、黄配色是为了更像火焰而已。</p>
<p>火焰图的y轴表示cpu调用方法的先后，x轴表示在每个采样调用时间内，方法所占的时间百分比，越宽代表占据cpu时间越多。通过火焰图我们就可以更清楚的找出耗时长的函数调用，然后不断的修正代码，重新采样，不断优化。</p>
<p>此外还可以借助火焰图分析内存性能数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:5200 -inuse_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof -http=:5200 -inuse_objects http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof -http=:5200 -alloc_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof -http=:5200 -alloc_objects http://127.0.0.1:8080/debug/pprof/heap</span><br></pre></td></tr></table></figure>

<p>内存性能火焰图示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230801211052678.png"></p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Goroutine并发模型</title>
    <url>/2023/06/14/Go/17/</url>
    <content><![CDATA[<h1 id="Go语言的协程——Goroutine"><a href="#Go语言的协程——Goroutine" class="headerlink" title="Go语言的协程——Goroutine"></a>Go语言的协程——Goroutine</h1><p><strong>进程(Process)，线程(Thread)，协程(Coroutine，也叫轻量级线程)</strong></p>
<ul>
<li><p>进程<br>进程是一个程序在一个数据集中的一次动态执行过程，可以简单理解为“正在执行的程序”，它是CPU资源分配和调度的独立单位。<br>进程一般由程序、数据集、进程控制块三部分组成。我们编写的程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 <strong>进程的局限是创建、撤销和切换的开销比较大。</strong></p>
</li>
<li><p>线程<br>线程是在进程之后发展出来的概念。 线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成。一个进程可以包含多个线程。<br>线程的优点是减小了程序并发执行时的开销，提高了操作系统的并发性能，缺点是线程没有自己的系统资源，只拥有在运行时必不可少的资源，但同一进程的各线程可以共享进程所拥有的系统资源，如果把进程比作一个车间，那么线程就好比是车间里面的工人。不过对于某些独占性资源存在锁机制，处理不当可能会产生“死锁”。</p>
</li>
<li><p>协程<br>协程是一种用户态的轻量级线程，又称微线程，英文名Coroutine，协程的调度完全由用户控制。人们通常将协程和子程序（函数）比较着理解。 子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。</p>
</li>
</ul>
<p><strong>与传统的系统级线程和进程相比，协程的最大优势在于其”轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过1万的。这也是协程也叫轻量级线程的原因。</strong></p>
<blockquote>
<p>协程的特点在于是一个线程执行，与多线程相比，其优势体现在：协程的执行效率极高。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
</blockquote>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><h3 id="什么是Goroutine"><a href="#什么是Goroutine" class="headerlink" title="什么是Goroutine"></a>什么是Goroutine</h3><p>go中使用Goroutine来实现并发concurrently。</p>
<p>Goroutine是Go语言特有的名词。区别于进程Process，线程Thread，协程Coroutine，因为Go语言的创造者们觉得和他们是有所区别的，所以专门创造了Goroutine。</p>
<p>Goroutine是与其他函数或方法同时运行的函数或方法。Goroutines可以被认为是轻量级的线程。与线程相比，创建Goroutine的成本很小，它就是一段代码，一个函数入口。以及在堆上为其分配的一个堆栈（初始大小为4K，会随着程序的执行自动增长删除）。因此它非常廉价，Go应用程序可以并发运行数千个Goroutines。</p>
<blockquote>
<p>Goroutines在线程上的优势。</p>
<ol>
<li>与线程相比，Goroutines非常便宜。它们只是堆栈大小的几个kb，堆栈可以根据应用程序的需要增长和收缩，而在线程的情况下，堆栈大小必须指定并且是固定的</li>
<li>Goroutines被多路复用到较少的OS线程。在一个程序中可能只有一个线程与数千个Goroutines。如果线程中的任何Goroutine都表示等待用户输入，则会创建另一个OS线程，剩下的Goroutines被转移到新的OS线程。所有这些都由运行时进行处理，我们作为程序员从这些复杂的细节中抽象出来，并得到了一个与并发工作相关的干净的API。</li>
<li>当使用Goroutines访问共享内存时，通过设计的通道可以防止竞态条件发生。通道可以被认为是Goroutines通信的管道。</li>
</ol>
</blockquote>
<h3 id="主goroutine"><a href="#主goroutine" class="headerlink" title="主goroutine"></a>主goroutine</h3><p>封装main函数的goroutine称为主goroutine。</p>
<p>主goroutine所做的事情并不是执行main函数那么简单。它首先要做的是：设定每一个goroutine所能申请的栈空间的最大尺寸。在32位的计算机系统中此最大尺寸为250MB，而在64位的计算机系统中此尺寸为1GB。如果有某个goroutine的栈空间尺寸大于这个限制，那么运行时系统就会引发一个栈溢出(stack overflow)的运行时恐慌。随后，这个go程序的运行也会终止。</p>
<p>此后，主goroutine会进行一系列的初始化工作，涉及的工作内容大致如下：</p>
<ol>
<li><p>创建一个特殊的defer语句，用于在主goroutine退出时做必要的善后处理。因为主goroutine也可能非正常的结束</p>
</li>
<li><p>启动专用于在后台清扫内存垃圾的goroutine，并设置GC可用的标识</p>
</li>
<li><p>执行mian包中的init函数</p>
</li>
<li><p>执行main函数</p>
<p>执行完main函数后，它还会检查主goroutine是否引发了运行时恐慌，并进行必要的处理。最后主goroutine会结束自己以及当前进程的运行。</p>
</li>
</ol>
<h3 id="如何使用Goroutines"><a href="#如何使用Goroutines" class="headerlink" title="如何使用Goroutines"></a>如何使用Goroutines</h3><p>在函数或方法调用前面加上关键字go，您将会同时运行一个新的Goroutine。</p>
<p>实例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    fmt.Println(<span class="string">&quot;main function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：可能会值输出<code>main function</code>。</p>
<p>由于主线程和新的goroutine是并发执行的，它们在时间上是相互独立的，因此主线程在打印”main function”之后，很可能立即结束，而新的goroutine可能没有足够的时间来执行<code>fmt.Println(&quot;Hello world goroutine&quot;)</code>语句，从而导致该语句没有被执行和打印。</p>
<p>我们开始的Goroutine怎么样了?我们需要了解Goroutine的规则</p>
<ol>
<li>当新的Goroutine开始时，Goroutine调用立即返回。与函数不同，go不等待Goroutine执行结束。当Goroutine调用，并且Goroutine的任何返回值被忽略之后，go立即执行到下一行代码。</li>
<li>main的Goroutine应该为其他的Goroutines执行。如果main的Goroutine终止了，程序将被终止，而其他Goroutine将不会运行。</li>
</ol>
<p>修改以上代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们已经调用了时间包的Sleep方法，它会在执行过程中睡觉。在这种情况下，main的goroutine被用来睡觉1秒。现在调用go hello()有足够的时间在main Goroutine终止之前执行。这个程序首先打印Hello world goroutine，等待1秒，然后打印<code>main function</code>。</p>
<h3 id="启动多个Goroutines"><a href="#启动多个Goroutines" class="headerlink" title="启动多个Goroutines"></a>启动多个Goroutines</h3><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numbers</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">250</span> * time.Millisecond)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alphabets</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;e&#x27;</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">400</span> * time.Millisecond)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> numbers()</span><br><span class="line">    <span class="keyword">go</span> alphabets()</span><br><span class="line">    time.Sleep(<span class="number">3000</span> * time.Millisecond)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main terminated&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 a 2 3 b 4 c 5 d e main terminated  </span><br></pre></td></tr></table></figure>

<p>时间轴分析：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/dxc.png"></p>
<h1 id="Go语言的并发模型"><a href="#Go语言的并发模型" class="headerlink" title="Go语言的并发模型"></a>Go语言的并发模型</h1><p>Go 语言相比Java等一个很大的优势就是可以方便地编写并发程序。Go 语言内置了 goroutine 机制，使用goroutine可以快速地开发并发程序， 更好的利用多核处理器资源。接下来我们来了解一下Go语言的并发原理。</p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>在现代操作系统中，线程是处理器调度和分配的基本单位，进程则作为资源拥有的基本单位。每个进程是由私有的虚拟地址空间、代码、数据和其它各种系统资源组成。线程是进程内部的一个执行单元。 每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。 用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。</p>
<p>我们先从线程讲起，无论语言层面何种并发模型，到了操作系统层面，一定是以线程的形态存在的。而操作系统根据资源访问权限的不同，体系架构可分为用户空间和内核空间；内核空间主要操作访问CPU资源、I&#x2F;O资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源，用户空间呢就是上层应用程序的固定活动空间，用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“Shell脚本”来调用内核空间提供的资源。</p>
<p>我们现在的计算机语言，可以狭义的认为是一种“软件”，它们中所谓的“线程”，往往是用户态的线程，和操作系统本身内核态的线程（简称KSE），还是有区别的。</p>
<p>Go并发编程模型在底层是由操作系统所提供的线程库支撑的，因此还是得从线程实现模型说起。</p>
<p>线程可以视为进程中的控制流。一个进程至少会包含一个线程，因为其中至少会有一个控制流持续运行。因而，一个进程的第一个线程会随着这个进程的启动而创建，这个线程称为该进程的主线程。当然，一个进程也可以包含多个线程。这些线程都是由当前进程中已存在的线程创建出来的，创建的方法就是调用系统调用，更确切地说是调用<br>pthread create函数。拥有多个线程的进程可以并发执行多个任务，并且即使某个或某些任务被阻塞，也不会影响其他任务正常执行，这可以大大改善程序的响应时间和吞吐量。另一方面，线程不可能独立于进程存在。它的生命周期不可能逾越其所属进程的生命周期。</p>
<p>线程的实现模型主要有3个，分别是:用户级线程模型、内核级线程模型和两级线程模型。它们之间最大的差异就在于线程与内核调度实体( Kernel Scheduling Entity,简称KSE)之间的对应关系上。顾名思义，内核调度实体就是可以被内核的调度器调度的对象。在很多文献和书中，它也称为内核级线程，是操作系统内核的最小调度单元。</p>
<h3 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h3><p>用户线程与KSE是1对1关系(1:1)。大部分编程语言的线程库(如linux的pthread，Java的java.lang.Thread，C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个不同的KSE静态关联，因此其调度完全由OS调度器来做。这种方式实现简单，直接借助OS提供的线程能力，并且不同用户线程之间一般也不会相互影响。但其创建，销毁以及多个线程之间的上下文切换等操作都是直接由OS层面亲自来做，在需要使用大量线程的场景下对OS的性能影响会很大。每个线程由内核调度器独立的调度，所以如果一个线程阻塞则不影响其他的线程。</p>
<p>优点：在多核处理器的硬件的支持下，内核空间线程模型支持了真正的并行，当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。</p>
<p>缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</p>
<h3 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h3><p>用户线程与KSE是多对1关系(M:1)，这种线程的创建，销毁以及多个线程之间的协调等操作都是由用户自己实现的线程库来负责，对OS内核透明，一个进程中所有创建的线程都与同一个KSE在运行时动态关联。现在有许多语言实现的 <strong>协程</strong> 基本上都属于这种方式。这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的数量与上下文切换所花费的代价也会小得多。但该模型有个致命的缺点，如果我们在某个用户线程上调用阻塞式系统调用(如用阻塞方式read网络IO)，那么一旦KSE因阻塞被内核调度出CPU的话，剩下的所有对应的用户线程全都会变为阻塞状态（整个进程挂起）。<br>所以这些语言的<strong>协程库</strong>会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。</p>
<p>优点： 这种模型的好处是线程上下文切换都发生在用户空间，避免的模态切换（mode switch），从而对于性能有积极的影响。</p>
<p>缺点：所有的线程基于一个内核调度实体即内核线程，这意味着只有一个处理器可以被利用，在多处理器环境下这是不能够被接受的，本质上，用户线程只解决了并发问题，但是没有解决并行问题。如果线程因为 I&#x2F;O 操作陷入了内核态，内核态线程阻塞等待 I&#x2F;O 数据，则所有的线程都将会被阻塞，用户空间也可以使用非阻塞而 I&#x2F;O，但是不能避免性能及复杂度问题。</p>
<h3 id="两级线程模型"><a href="#两级线程模型" class="headerlink" title="两级线程模型"></a>两级线程模型</h3><p>用户线程与KSE是多对多关系(M:N)，这种实现综合了前两种模型的优点，为一个进程中创建多个KSE，并且线程可以与不同的KSE在运行时进行动态关联，当某个KSE由于其上工作的线程的阻塞操作被内核调度出CPU时，当前与其关联的其余用户线程可以重新与其他KSE建立关联关系。当然这种动态关联机制的实现很复杂，也需要用户自己去实现，这算是它的一个缺点吧。Go语言中的并发就是使用的这种实现方式，Go为了实现该模型自己实现了一个运行时调度器来负责Go中的”线程”与KSE的动态关联。此模型有时也被称为 <strong>混合型线程模型</strong>，<strong>即用户调度器实现用户线程到KSE的“调度”，内核调度器实现KSE到CPU上的调度</strong>。</p>
<h2 id="Go并发调度-G-P-M模型"><a href="#Go并发调度-G-P-M模型" class="headerlink" title="Go并发调度: G-P-M模型"></a>Go并发调度: G-P-M模型</h2><p>在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。goroutine机制实现了M : N的线程模型，goroutine机制是协程（coroutine）的一种实现，golang内置的调度器，可以让多核CPU中每个CPU执行一个协程。</p>
<h3 id="调度器是如何工作的"><a href="#调度器是如何工作的" class="headerlink" title="调度器是如何工作的"></a>调度器是如何工作的</h3><p>有了上面的认识，我们可以开始真正的介绍Go的并发机制了，先用一段代码展示一下在Go语言中新建一个“线程”(Go语言中称为Goroutine)的样子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用go关键字加上一个函数（这里用了匿名函数）</span></span><br><span class="line"><span class="comment">// 调用就做到了在一个新的“线程”并发执行任务</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="comment">// do something in one new goroutine</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>理解goroutine机制的原理，关键是理解Go语言scheduler的实现。</p>
<p>Go语言中支撑整个scheduler实现的主要有4个重要结构，分别是M、G、P、Sched， 前三个定义在runtime.h中，Sched定义在proc.c中。</p>
<ul>
<li>Sched结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。</li>
<li>M结构是Machine，系统线程，它由操作系统管理的，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。</li>
<li>P结构是Processor，处理器，它的主要用途就是用来执行goroutine的，它维护了一个goroutine队列，即runqueue。Processor是让我们从N:1调度到M:N调度的重要部分。</li>
<li>G是goroutine实现的核心结构，它包含了栈，指令指针，以及其他对调度goroutine很重要的信息，例如其阻塞的channel。</li>
</ul>
<blockquote>
<p>Processor的数量是在启动时被设置为环境变量GOMAXPROCS的值，或者通过运行时调用函数GOMAXPROCS()进行设置。Processor数量固定意味着任意时刻只有GOMAXPROCS个线程在运行go代码。</p>
</blockquote>
<p>我们分别用三角形，矩形和圆形表示Machine Processor和Goroutine。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/moxing4.jpg" alt="moxing4"></p>
<p>在单核处理器的场景下，所有goroutine运行在同一个M系统线程中，每一个M系统线程维护一个Processor，任何时刻，一个Processor中只有一个goroutine，其他goroutine在runqueue中等待。一个goroutine运行完自己的时间片后，让出上下文，回到runqueue中。 多核处理器的场景下，为了运行goroutines，每个M系统线程会持有一个Processor。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/moxing5.jpg" alt="moxing5"></p>
<p>在正常情况下，scheduler会按照上面的流程进行调度，但是线程会发生阻塞等情况，看一下goroutine对线程阻塞等的处理。</p>
<h3 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h3><p>当正在运行的goroutine阻塞的时候，例如进行系统调用，会再创建一个系统线程（M1），当前的M线程放弃了它的Processor，P转到新的线程中去运行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/moxing6.jpg" alt="moxing6"></p>
<h3 id="runqueue执行完成"><a href="#runqueue执行完成" class="headerlink" title="runqueue执行完成"></a>runqueue执行完成</h3><p>当其中一个Processor的runqueue为空，没有goroutine可以调度。它会从另外一个上下文偷取一半的goroutine。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/moxing7.jpg" alt="moxing7"></p>
<blockquote>
<p>其图中的G，P和M都是Go语言运行时系统（其中包括内存分配器，并发调度器，垃圾收集器等组件，可以想象为Java中的JVM）抽象出来概念和数据结构对象：<br>G：Goroutine的简称，上面用go关键字加函数调用的代码就是创建了一个G对象，是对一个要并发执行的任务的封装，也可以称作用户态线程。属于用户级资源，对OS透明，具备轻量级，可以大量创建，上下文切换成本低等特点。<br>M：Machine的简称，在linux平台上是用clone系统调用创建的，其与用linux pthread库创建出来的线程本质上是一样的，都是利用系统调用创建出来的OS线程实体。M的作用就是执行G中包装的并发任务。<strong>Go运行时系统中的调度器的主要职责就是将G公平合理的安排到多个M上去执行</strong>。其属于OS资源，可创建的数量上也受限了OS，通常情况下G的数量都多于活跃的M的。<br>P：Processor的简称，逻辑处理器，主要作用是管理G对象（每个P都有一个G队列），并为G在M上的运行提供本地化资源。</p>
</blockquote>
<p>从两级线程模型来看，似乎并不需要P的参与，有G和M就可以了，那为什么要加入P这个东东呢？<br>其实Go语言运行时系统早期(Go1.0)的实现中并没有P的概念，Go中的调度器直接将G分配到合适的M上运行。但这样带来了很多问题，例如，不同的G在不同的M上并发运行时可能都需向系统申请资源（如堆内存），由于资源是全局的，将会由于资源竞争造成很多系统性能损耗，为了解决类似的问题，后面的Go（Go1.1）运行时系统加入了P，让P去管理G对象，M要想运行G必须先与一个P绑定，然后才能运行该P管理的G。这样带来的好处是，我们可以在P对象中预先申请一些系统资源（本地资源），G需要的时候先向自己的本地P申请（无需锁保护），如果不够用或没有再向全局申请，而且从全局拿的时候会多拿一部分，以供后面高效的使用。就像现在我们去政府办事情一样，先去本地政府看能搞定不，如果搞不定再去中央，从而提供办事效率。<br>而且由于P解耦了G和M对象，这样即使M由于被其上正在运行的G阻塞住，其余与该M关联的G也可以随着P一起迁移到别的活跃的M上继续运行，从而让G总能及时找到M并运行自己，从而提高系统的并发能力。<br>Go运行时系统通过构造G-P-M对象模型实现了一套用户态的并发调度系统，可以自己管理和调度自己的并发任务，所以可以说Go语言<strong>原生支持并发</strong>。<strong>自己实现的调度器负责将并发任务分配到不同的内核线程上运行，然后内核调度器接管内核线程在CPU上的执行与调度。</strong></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Go运行时完整的调度系统是很复杂，很难用一篇文章描述的清楚，这里只能从宏观上介绍一下，让大家有个整体的认识。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Goroutine1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> task2()</span><br><span class="line">    <span class="keyword">go</span> task3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如我们有一个G(Goroutine1)已经通过P被安排到了一个M上正在执行，在Goroutine1执行的过程中我们又创建两个G，这两个G会被马上放入与Goroutine1相同的P的本地G任务队列中，排队等待与该P绑定的M的执行，这是最基本的结构，很好理解。 关键问题是:</p>
<p><strong>a.如何在一个多核心系统上尽量合理分配G到多个M上运行，充分利用多核，提高并发能力呢？</strong><br>如果我们在一个Goroutine中通过<strong>go</strong>关键字创建了大量G，这些G虽然暂时会被放在同一个队列, 但如果这时还有空闲P（系统内P的数量默认等于系统cpu核心数），Go运行时系统始终能保证至少有一个（通常也只有一个）活跃的M与空闲P绑定去各种G队列去寻找可运行的G任务，该种M称为<strong>自旋的M</strong>。一般寻找顺序为：自己绑定的P的队列，全局队列，然后其他P队列。如果自己P队列找到就拿出来开始运行，否则去全局队列看看，由于全局队列需要锁保护，如果里面有很多任务，会转移一批到本地P队列中，避免每次都去竞争锁。如果全局队列还是没有，就要开始玩狠的了，直接从其他P队列偷任务了（偷一半任务回来）。这样就保证了在还有可运行的G任务的情况下，总有与CPU核心数相等的M+P组合 在执行G任务或在执行G的路上(寻找G任务)。</p>
<p><strong>b. 如果某个M在执行G的过程中被G中的系统调用阻塞了，怎么办？</strong><br>在这种情况下，这个M将会被内核调度器调度出CPU并处于阻塞状态，与该M关联的其他G就没有办法继续执行了，但Go运行时系统的一个监控线程(sysmon线程)能探测到这样的M，并把与该M绑定的P剥离，寻找其他空闲或新建M接管该P，然后继续运行其中的G，大致过程如下图所示。然后等到该M从阻塞状态恢复，需要重新找一个空闲P来继续执行原来的G，如果这时系统正好没有空闲的P，就把原来的G放到全局队列当中，等待其他M+P组合发掘并执行。</p>
<p><strong>c. 如果某一个G在M运行时间过长，有没有办法做抢占式调度，让该M上的其他G获得一定的运行时间，以保证调度系统的公平性?</strong><br>我们知道linux的内核调度器主要是基于时间片和优先级做调度的。对于相同优先级的线程，内核调度器会尽量保证每个线程都能获得一定的执行时间。为了防止有些线程”饿死”的情况，内核调度器会发起抢占式调度将长期运行的线程中断并让出CPU资源，让其他线程获得执行机会。当然在Go的运行时调度器中也有类似的抢占机制，但并不能保证抢占能成功，因为Go运行时系统并没有内核调度器的中断能力，它只能通过向运行时间过长的G中设置抢占flag的方法温柔的让运行的G自己主动让出M的执行权。<br>说到这里就不得不提一下Goroutine在运行过程中可以动态扩展自己线程栈的能力，可以从初始的2KB大小扩展到最大1G（64bit系统上），因此在每次调用函数之前需要先计算该函数调用需要的栈空间大小，然后按需扩展（超过最大值将导致运行时异常）。Go抢占式调度的机制就是利用在判断要不要扩栈的时候顺便查看以下自己的抢占flag，决定是否继续执行，还是让出自己。<br>运行时系统的监控线程会计时并设置抢占flag到运行时间过长的G，然后G在有函数调用的时候会检查该抢占flag，如果已设置就将自己放入全局队列，这样该M上关联的其他G就有机会执行了。但如果正在执行的G是个很耗时的操作且没有任何函数调用(如只是for循环中的计算操作)，即使抢占flag已经被设置，该G还是将一直霸占着当前M直到执行完自己的任务。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		一个goroutine打印数字，另外一个goroutine打印字母，观察运行结果。。</span></span><br><span class="line"><span class="comment">		并发的程序的运行结果，每次都不一定相同。</span></span><br><span class="line"><span class="comment">		不同计算机设备执行，效果也不相同。</span></span><br><span class="line"><span class="comment">		go语言的并发：go关键字</span></span><br><span class="line"><span class="comment">			系统自动创建并启动主goroutine，执行对应的main()</span></span><br><span class="line"><span class="comment">			用于自己创建并启动子goroutine，执行对应的函数</span></span><br><span class="line"><span class="comment">			go 函数()//go关键创建并启动goroutine，然后执行对应的函数()，该函数执行结束，子goroutine也随之结束。</span></span><br><span class="line"><span class="comment">				子goroutine中执行的函数，往往没有返回值。</span></span><br><span class="line"><span class="comment">				如果有也会被舍弃。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.先创建并启动子goroutine，执行printNum()</span></span><br><span class="line">	<span class="keyword">go</span> printNum()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.main中打印字母</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;\t主goroutine中打印字母：A %d\n&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;main...over...&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;子goroutine中打印数字：%d\n&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	主goroutine中打印字母：A 1</span><br><span class="line">子goroutine中打印数字：1</span><br><span class="line">子goroutine中打印数字：2</span><br><span class="line">子goroutine中打印数字：3</span><br><span class="line">子goroutine中打印数字：4</span><br><span class="line">子goroutine中打印数字：5</span><br><span class="line">子goroutine中打印数字：6</span><br><span class="line">子goroutine中打印数字：7</span><br><span class="line">	主goroutine中打印字母：A 2</span><br><span class="line">	主goroutine中打印字母：A 3</span><br><span class="line">	主goroutine中打印字母：A 4</span><br><span class="line">	主goroutine中打印字母：A 5</span><br><span class="line">	主goroutine中打印字母：A 6</span><br><span class="line">	主goroutine中打印字母：A 7</span><br><span class="line">	主goroutine中打印字母：A 8</span><br><span class="line">子goroutine中打印数字：8</span><br><span class="line">子goroutine中打印数字：9</span><br><span class="line">	主goroutine中打印字母：A 9</span><br><span class="line">子goroutine中打印数字：10</span><br><span class="line">	主goroutine中打印字母：A 10</span><br><span class="line">main...over...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>变量与常量</title>
    <url>/2023/06/01/Go/4/</url>
    <content><![CDATA[<h1 id="基本语法——变量var"><a href="#基本语法——变量var" class="headerlink" title="基本语法——变量var"></a>基本语法——变量var</h1><h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p>变量是为存储特定类型的值而提供给内存位置的名称。在go中声明变量有多种语法。</p>
<p>所以变量的本质就是一小块内存，用于存储数据，在程序运行过程中数值可以改变</p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>var名称类型是声明单个变量的语法。</p>
<blockquote>
<p>以字母或下划线开头，由一个或多个字母、数字、下划线组成</p>
</blockquote>
<p>声明一个变量</p>
<p>第一种，指定变量类型，声明后若不赋值，使用<em><strong>默认值</strong></em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span></span><br><span class="line">name = value</span><br></pre></td></tr></table></figure>

<p>第二种，根据值自行判定变量类型(类型推断Type inference)</p>
<p>如果一个变量有一个初始值，Go将自动能够使用初始值来推断该变量的类型。因此，如果变量具有初始值，则可以省略变量声明中的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = value</span><br></pre></td></tr></table></figure>

<p>第三种，省略var, 注意 :&#x3D;左侧的变量不应该是已经声明过的(多个变量同时声明时，至少保证一个是新变量)，否则会导致编译错误(简短声明)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := value</span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">c : = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式它只能被用在函数体内，而不可以用于全局变量的声明与赋值</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">string</span> = <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World false</span><br></pre></td></tr></table></figure>

<h4 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h4><p>第一种，以逗号分隔，声明与赋值分开，若不赋值，存在默认值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1, name2, name3 <span class="keyword">type</span></span><br><span class="line">name1, name2, name3 = v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>第二种，直接赋值，下面的变量类型可以是不同的类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1, name2, name3 = v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>第三种，集合类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    name1 type1</span><br><span class="line">    name2 type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a :&#x3D; 20 就是不被允许的，编译器会提示错误 no new variables on left side of :&#x3D;，但是 a &#x3D; 20 是可以的，因为这是给相同的变量赋予一个新的值。</p>
<p>如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试编译这段代码将得到错误 a declared and not used</p>
<p>此外，单纯地给 a 赋值也是不够的，这个值必须被使用</p>
<p>在同一个作用域中，已存在同名的变量，则之后的声明初始化，则退化为赋值操作。但这个前提是，最少要有一个新的变量被定义，且在同一作用域，例如，下面的y就是新定义的变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">140</span></span><br><span class="line">	fmt.Println(&amp;x)</span><br><span class="line">	x, y := <span class="number">200</span>, <span class="string">&quot;abc&quot;</span></span><br><span class="line">	fmt.Println(&amp;x, x)</span><br><span class="line">	fmt.Print(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xc04200a2b0</span><br><span class="line">0xc04200a2b0 200</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<h1 id="基本语法——常量constant"><a href="#基本语法——常量constant" class="headerlink" title="基本语法——常量constant"></a>基本语法——常量constant</h1><h2 id="常量的使用"><a href="#常量的使用" class="headerlink" title="常量的使用"></a>常量的使用</h2><h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式类型定义： </span></span><br><span class="line"><span class="keyword">const</span> b <span class="type">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment">//隐式类型定义：</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">const</span> LENGTH <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">const</span> WIDTH <span class="type">int</span> = <span class="number">5</span>   </span><br><span class="line">   <span class="keyword">var</span> area <span class="type">int</span></span><br><span class="line">   <span class="keyword">const</span> a, b, c = <span class="number">1</span>, <span class="literal">false</span>, <span class="string">&quot;str&quot;</span> <span class="comment">//多重赋值</span></span><br><span class="line"></span><br><span class="line">   area = LENGTH * WIDTH</span><br><span class="line">   fmt.Printf(<span class="string">&quot;面积为 : %d&quot;</span>, area)</span><br><span class="line">   <span class="built_in">println</span>()</span><br><span class="line">   <span class="built_in">println</span>(a, b, c)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面积为 : 50</span><br><span class="line">1 false str</span><br></pre></td></tr></table></figure>

<p>常量可以作为枚举，常量组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>常量组中如不指定类型和初始化值，则与上一行非空常量右值相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		x <span class="type">uint16</span> = <span class="number">16</span></span><br><span class="line">		y</span><br><span class="line">		s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">		z</span><br><span class="line">	)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, y, y)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, z, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint16,16</span><br><span class="line">string,abc</span><br></pre></td></tr></table></figure>

<p>常量的注意事项：</p>
<ul>
<li><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型</p>
</li>
<li><p><em><strong>不曾使用的常量，在编译的时候，是不会报错的</strong></em></p>
</li>
<li><p>显示指定类型的时候，必须确保常量左右值类型一致，需要时可做显示类型转换。这与变量就不一样了，变量是可以是不同的类型值</p>
</li>
</ul>
<h3 id="iota关键字"><a href="#iota关键字" class="headerlink" title="iota关键字"></a>iota关键字</h3><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量</p>
<p>iota 可以被用作枚举值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a&#x3D;0, b&#x3D;1, c&#x3D;2 可以简写为如下形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>iota 用法</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 ha ha 100 100 7 8</span><br></pre></td></tr></table></figure>

<p>如果中断iota自增，则必须显式恢复。且后续自增值按行序递增</p>
<p>自增默认是int类型，可以自行进行显示指定类型</p>
<p>数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址</p>
<h1 id="变量与常量的示例"><a href="#变量与常量的示例" class="headerlink" title="变量与常量的示例"></a>变量与常量的示例</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="string">&quot;initial&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b, c <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> e <span class="type">float64</span></span><br><span class="line"></span><br><span class="line">	f := <span class="type">float32</span>(e)</span><br><span class="line"></span><br><span class="line">	g := a + <span class="string">&quot;foo&quot;</span></span><br><span class="line">	fmt.Println(a, b, c, d, e, f) <span class="comment">// initial 1 2 true 0 0</span></span><br><span class="line">	fmt.Println(g)                <span class="comment">// initialapple</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> s <span class="type">string</span> = <span class="string">&quot;constant&quot;</span></span><br><span class="line">	<span class="keyword">const</span> h = <span class="number">500000000</span></span><br><span class="line">	<span class="keyword">const</span> i = <span class="number">3e20</span> / h</span><br><span class="line">	fmt.Println(s, h, i, math.Sin(h), math.Sin(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">initial 1 2 true 0 0</span><br><span class="line">initialfoo</span><br><span class="line">constant 500000000 6e+11 -0.28470407323754404 0.7591864109375384</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>条件语句与循环语句</title>
    <url>/2023/06/02/Go/6/</url>
    <content><![CDATA[<h1 id="程序的流程结构"><a href="#程序的流程结构" class="headerlink" title="程序的流程结构"></a>程序的流程结构</h1><p>程序的流程控制结构一共有三种：顺序结构，选择结构，循环结构。</p>
<p>顺序结构：从上向下，逐行执行。</p>
<p>选择结构：条件满足，某些代码才会执行。0-1次</p>
<p>​	分支语句：if，switch，select</p>
<p>循环结构：条件满足，某些代码会被反复的执行多次。0-N次</p>
<p>​	循环语句：for</p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="If语句"><a href="#If语句" class="headerlink" title="If语句"></a>If语句</h2><p>语法格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式<span class="number">1</span> &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式1为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 布尔表达式<span class="number">2</span>&#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式1为 false ,布尔表达式2为true时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">/* 在上面两个布尔表达式都为false时，执行*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用 if 语句判断布尔表达式 */</span></span><br><span class="line">   <span class="keyword">if</span> a &lt; <span class="number">20</span> &#123;</span><br><span class="line">       <span class="comment">/* 如果条件为 true 则执行以下语句 */</span></span><br><span class="line">       fmt.Printf(<span class="string">&quot;a 小于 20\n&quot;</span> )</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;a 的值为 : %d\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果其中包含一个可选的语句组件(在评估条件之前执行)，则还有一个变体。它的语法是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> statement; condition &#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="number">7</span>%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;7 is even&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;7 is odd&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="number">8</span>%<span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;8 is divisible by 4&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> num := <span class="number">9</span>; num &lt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(num, <span class="string">&quot;is negative&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">		fmt.Println(num, <span class="string">&quot;has 1 digit&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(num, <span class="string">&quot;has multiple digits&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，num的定义在if里，那么只能够在该if..else语句块中使用，否则编译器会报错的。</p>
</blockquote>
<h2 id="switch语句：“开关”"><a href="#switch语句：“开关”" class="headerlink" title="switch语句：“开关”"></a>switch语句：“开关”</h2><p>switch是一个条件语句，它计算表达式并将其与可能匹配的列表进行比较，并根据匹配执行代码块。它可以被认为是一种惯用的方式来写多个if else子句。</p>
<p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。<br>switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也<em><strong>不需要再加break</strong></em>。</p>
<p><em><strong>而如果switch没有表达式，它会匹配true</strong></em></p>
<p><em>Go里面switch默认相当于每个case最后带有break</em>，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。</p>
<p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。<br>可以<strong>同时测试多个可能符合条件的值，使用逗号分割它们</strong>，例如：case val1, val2, val3。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/* 定义局部变量 */</span></span><br><span class="line">	<span class="keyword">var</span> grade = <span class="string">&quot;B&quot;</span></span><br><span class="line">	<span class="keyword">var</span> marks = <span class="number">90</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> marks &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">90</span>:</span><br><span class="line">		grade = <span class="string">&quot;A&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">		grade = <span class="string">&quot;B&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>:</span><br><span class="line">		grade = <span class="string">&quot;C&quot;</span> <span class="comment">//case 后可以由多个数值</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		grade = <span class="string">&quot;D&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> grade == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;优秀!\n&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> grade == <span class="string">&quot;B&quot;</span>, grade == <span class="string">&quot;C&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;良好\n&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> grade == <span class="string">&quot;D&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;及格\n&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> grade == <span class="string">&quot;F&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;不及格\n&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;差\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;你的等级是 %s\n&quot;</span>, grade)</span><br><span class="line">    </span><br><span class="line">    t := time.Now()</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;It&#x27;s before noon&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;It&#x27;s after noon&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优秀!</span><br><span class="line">你的等级是 A</span><br><span class="line">It&#x27;s before noon</span><br></pre></td></tr></table></figure>



<h3 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h3><p>如需贯通后续的case，就添加fallthrough</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> x := <span class="number">5</span>; x &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(x)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		x += <span class="number">10</span></span><br><span class="line">		fmt.Println(x)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		x += <span class="number">20</span></span><br><span class="line">		fmt.Println(x)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br><span class="line">35</span><br></pre></td></tr></table></figure>

<hr>
<p>解释：</p>
<p>根据switch语句的逻辑，首先会执行default分支，但是由于我们没有在default分支中写入任何代码，所以会直接跳过。在case 5分支的最后，我们使用了fallthrough关键字。fallthrough关键字的作用是强制执行下一个case分支的代码，而不进行条件判断。</p>
<p>在<code>switch</code>语句中，<code>default</code>用于处理没有匹配到任何<code>case</code>的情况。当<code>switch</code>表达式的值与所有的<code>case</code>都不匹配时，程序会执行<code>default</code>分支中的代码。</p>
<p><code>default</code>分支是可选的，也就是说可以选择是否在<code>switch</code>语句中包含它。如果没有<code>default</code>分支，而且没有任何一个<code>case</code>匹配到<code>switch</code>表达式的值，那么<code>switch</code>语句将不会执行任何代码。</p>
<p><code>default</code>分支通常被用作最后一个分支，用于处理不常见或者意外的情况。它可以用来提供一个默认的处理逻辑，或者给用户一个错误提示。</p>
<p>以下是一个示例，展示了<code>default</code>的使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> num &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;小数&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;中数&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;大数&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;未知数&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，如果<code>num</code>的值不属于1到9之间的任何一个数，那么就会执行<code>default</code>分支，并输出”未知数”。<code>default</code>分支可以用来处理一些边缘情况或者未预料到的情况，确保程序的健壮性。</p>
<hr>
<p><em>case中的表达式是可选的，可以省略。如果该表达式被省略，则被认为是switch true，并且每个case表达式都被计算为true，并执行相应的代码块</em>。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    num := <span class="number">75</span></span><br><span class="line">    <span class="keyword">switch</span> &#123; <span class="comment">// expression is omitted</span></span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">50</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;num is greater than 0 and less than 50&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">51</span> &amp;&amp; num &lt;= <span class="number">100</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;num is greater than 51 and less than 100&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">101</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;num is greater than 100&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num is greater than 51 and less than 100</span><br></pre></td></tr></table></figure>

<blockquote>
<p>switch的注意事项</p>
<ol>
<li>case后的常量值不能重复</li>
<li>case后可以有多个常量值</li>
<li>fallthrough应该是某个case的最后一行。如果它出现在中间的某个地方，编译器就会抛出错误。</li>
</ol>
</blockquote>
<h3 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h3><p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">   <span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">nil</span>:	  </span><br><span class="line">         fmt.Printf(<span class="string">&quot; x 的类型 :%T&quot;</span>,i)                </span><br><span class="line">      <span class="keyword">case</span> <span class="type">int</span>:	  </span><br><span class="line">         fmt.Printf(<span class="string">&quot;x 是 int 型&quot;</span>)                       </span><br><span class="line">      <span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;x 是 float64 型&quot;</span>)           </span><br><span class="line">      <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">float64</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;x 是 func(int) 型&quot;</span>)                      </span><br><span class="line">      <span class="keyword">case</span> <span class="type">bool</span>, <span class="type">string</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;x 是 bool 或 string 型&quot;</span> )       </span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;未知型&quot;</span>)     </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x 的类型 :&lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>在这段代码中，变量<code>x</code>的类型被声明为<code>interface&#123;&#125;</code>，它是一个空接口。空接口可以表示任意类型的值，包括<code>nil</code>。当我们使用类型断言<code>x.(type)</code>来获取<code>x</code>的具体类型时，如果<code>x</code>的值是<code>nil</code>，那么<code>case nil</code>分支会匹配成功。这里需要注意的是，<code>nil</code>是一个特殊的值，表示一个指针类型或接口类型的零值，表示该指针或接口不指向任何具体的对象。在这种情况下，我们可以将其视为一种特殊的类型。因此，<code>case nil</code>分支被用来处理<code>x</code>为<code>nil</code>的情况。</p>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>循环语句表示条件满足，可以反复的执行某段代码。</p>
<p>for是唯一的循环语句。(Go没有while循环)</p>
<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>语法结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for init; condition; post &#123; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>初始化语句只执行一次。在初始化循环之后，将检查该条件。如果条件计算为true，那么{}中的循环体将被执行，然后是post语句。post语句将在循环的每次成功迭代之后执行。在执行post语句之后，该条件将被重新检查。如果它是正确的，循环将继续执行，否则循环终止。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot; %d&quot;</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在for循环中声明的变量仅在循环范围内可用。因此，i不能在外部访问循环。</p>
</blockquote>
<p><strong>所有的三个组成部分，即初始化、条件和post都是可选的。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>效果与while相似</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>效果与for(;;) 一样</p>
<p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for key, value := range oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">9</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   numbers := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* for 循环 */</span></span><br><span class="line">   <span class="keyword">for</span> a := <span class="number">0</span>; a &lt; <span class="number">5</span>; a++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> a &lt; b &#123;</span><br><span class="line">      a++</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i,x:= <span class="keyword">range</span> numbers &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i,x)</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a 的值为: 0</span><br><span class="line">a 的值为: 1</span><br><span class="line">a 的值为: 2</span><br><span class="line">a 的值为: 3</span><br><span class="line">a 的值为: 4</span><br><span class="line">a 的值为: 1</span><br><span class="line">a 的值为: 2</span><br><span class="line">a 的值为: 3</span><br><span class="line">a 的值为: 4</span><br><span class="line">a 的值为: 5</span><br><span class="line">a 的值为: 6</span><br><span class="line">a 的值为: 7</span><br><span class="line">a 的值为: 8</span><br><span class="line">a 的值为: 9</span><br><span class="line">第 0 位 x 的值 = 1</span><br><span class="line">第 1 位 x 的值 = 2</span><br><span class="line">第 2 位 x 的值 = 3</span><br><span class="line">第 3 位 x 的值 = 5</span><br><span class="line">第 4 位 x 的值 = 0</span><br><span class="line">第 5 位 x 的值 = 0</span><br></pre></td></tr></table></figure>



<h3 id="多层for循环"><a href="#多层for循环" class="headerlink" title="多层for循环"></a>多层for循环</h3><p>for循环中又有循环嵌套，就表示多层循环了。</p>
<h2 id="跳出循环的语句"><a href="#跳出循环的语句" class="headerlink" title="跳出循环的语句"></a>跳出循环的语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>break：跳出循环体。break语句用于在结束其正常执行之前突然终止for循环</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">//loop is terminated if i &gt; 5</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\nline after for loop&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 </span><br><span class="line">line after for loop</span><br></pre></td></tr></table></figure>

<h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>continue：跳出一次循环。continue语句用于跳过for循环的当前迭代。在continue语句后面的for循环中的所有代码将不会在当前迭代中执行。循环将继续到下一个迭代。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3 5 7 9 </span><br></pre></td></tr></table></figure>

<h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>goto：可以无条件地转移到过程中指定的行。</p>
<p>语法结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">label: statement;</span><br></pre></td></tr></table></figure>

<p>​												<a href="https://smms.app/image/ZUna3jv2o9h5xgN" target="_blank"><img src="https://s2.loli.net/2023/06/02/ZUna3jv2o9h5xgN.jpg" ></a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/* 定义局部变量 */</span></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 循环 */</span></span><br><span class="line">LOOP:</span><br><span class="line">	<span class="keyword">for</span> a &lt; <span class="number">20</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> a == <span class="number">15</span> &#123;</span><br><span class="line">			<span class="comment">/* 跳过迭代 */</span></span><br><span class="line">			a = a + <span class="number">1</span></span><br><span class="line">			<span class="keyword">goto</span> LOOP</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;a的值为 : %d\n&quot;</span>, a)</span><br><span class="line">		a++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a的值为 : 10</span><br><span class="line">a的值为 : 11</span><br><span class="line">a的值为 : 12</span><br><span class="line">a的值为 : 13</span><br><span class="line">a的值为 : 14</span><br><span class="line">a的值为 : 16</span><br><span class="line">a的值为 : 17</span><br><span class="line">a的值为 : 18</span><br><span class="line">a的值为 : 19</span><br></pre></td></tr></table></figure>

<p>统一错误处理<br>多处错误处理存在代码重复时是非常棘手的，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	err := firstCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    err = secondCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br></pre></td></tr></table></figure>

<h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num1 := rand.Int()</span><br><span class="line">	fmt.Println(num1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		num := rand.Intn(<span class="number">10</span>)</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;</span><br><span class="line">	rand.Seed(<span class="number">1000</span>)</span><br><span class="line">	num2 := rand.Intn(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;---&gt;&quot;</span>, num2)</span><br><span class="line"></span><br><span class="line">	t1 := time.Now()</span><br><span class="line">	fmt.Println(t1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, t1)</span><br><span class="line"></span><br><span class="line">	timeStamp1 := t1.Unix()</span><br><span class="line">	fmt.Println(timeStamp1)</span><br><span class="line"></span><br><span class="line">	timestamp2 := t1.UnixNano()</span><br><span class="line">	fmt.Println(timestamp2)</span><br><span class="line"></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;---&gt;&quot;</span>, rand.Intn(<span class="number">100</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	num3 := rand.Intn(<span class="number">46</span>) + <span class="number">3</span></span><br><span class="line">	fmt.Println(num3)</span><br><span class="line">	num4 := rand.Intn(<span class="number">62</span>) + <span class="number">15</span></span><br><span class="line">	fmt.Println(num4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2359980755445512729</span><br><span class="line">6</span><br><span class="line">0</span><br><span class="line">9</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">---&gt; 5</span><br><span class="line">2023-06-02 12:00:50.6796224 +0800 CST m=+0.001542201</span><br><span class="line">time.Time</span><br><span class="line">1685678450</span><br><span class="line">1685678450679622400</span><br><span class="line">---&gt; 74</span><br><span class="line">---&gt; 79</span><br><span class="line">---&gt; 18</span><br><span class="line">---&gt; 21</span><br><span class="line">---&gt; 68</span><br><span class="line">---&gt; 41</span><br><span class="line">---&gt; 33</span><br><span class="line">---&gt; 31</span><br><span class="line">---&gt; 26</span><br><span class="line">---&gt; 37</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>在随机数生成中，种子（seed）是用于初始化随机数生成器的值。种子决定了随机数序列的起始点。在某种程度上，相同种子会生成相同的随机数序列。</p>
<p>在上述代码中，<code>rand.Seed()</code>方法用于设置随机数生成器的种子。如果没有显式地设置种子，Go语言的<code>math/rand</code>包默认使用一个固定的种子，这意味着每次程序运行时都会生成相同的随机数序列。这在某些情况下可能不是我们所期望的。</p>
<p>通过调用<code>rand.Seed()</code>方法并传入一个不同的种子值，我们可以改变随机数生成器的起始点，从而产生不同的随机数序列。通常情况下，我们会使用当前时间的纳秒级时间戳作为种子，以确保每次运行程序时都能生成不同的随机数序列。</p>
<p>在代码中，<code>rand.Seed(1000)</code>将种子设置为固定值1000，因此后续生成的随机数序列将始终相同。而<code>rand.Seed(time.Now().UnixNano())</code>使用当前时间的纳秒级时间戳作为种子，可以产生不同的随机数序列。</p>
<p>但是<em><strong>自从Go 1.2 0以来,rand.Seed就已经被弃用了</strong></em>！</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>beego框架开发文档</title>
    <url>/2023/07/20/Go/30/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架，主要设计灵感来源于 tornado、sinatra 和 flask 这三个框架，但是结合了 Go 本身的一些特性（interface、struct 嵌入等）而设计的一个框架。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>beego 的整体设计架构如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/architecture.png"></p>
<p>beego 是基于八大独立的模块构建的，是一个高度解耦的框架。当初设计 beego 的时候就是考虑功能模块化，用户即使不使用 beego 的 HTTP 逻辑，也依旧可以使用这些独立模块，例如：你可以使用 cache 模块来做你的缓存逻辑；使用日志模块来记录你的操作信息；使用 config 模块来解析你各种格式的文件。所以 beego 不仅可以用于 HTTP 类的应用开发，在你的 socket 游戏开发中也是很有用的模块，这也是 beego 如此受欢迎的一个原因。大家如果玩过乐高的话，应该知道很多高级的东西都是一块一块的积木搭建出来的，而设计 beego 的时候，这些模块就是积木，高级机器人就是 beego。</p>
<h2 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a>执行逻辑</h2><p>既然 beego 是基于这些模块构建的，那么它的执行逻辑是怎么样的呢？beego 是一个典型的 MVC 架构，它的执行逻辑如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/flow.png"></p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>一般的 beego 项目的目录如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── conf</span><br><span class="line">│   └── app.conf</span><br><span class="line">├── controllers</span><br><span class="line">│   ├── admin</span><br><span class="line">│   └── default.go</span><br><span class="line">├── main.go</span><br><span class="line">├── models</span><br><span class="line">│   └── models.go</span><br><span class="line">├── static</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── ico</span><br><span class="line">│   ├── img</span><br><span class="line">│   └── js</span><br><span class="line">└── views</span><br><span class="line">    ├── admin</span><br><span class="line">    └── index.tpl</span><br></pre></td></tr></table></figure>

<p>从上面的目录结构我们可以看出来 M（models 目录）、V（views 目录）和 C（controllers 目录）的结构， <code>main.go</code> 是入口文件。</p>
<h1 id="安装与升级"><a href="#安装与升级" class="headerlink" title="安装与升级"></a>安装与升级</h1><h2 id="beego安装"><a href="#beego安装" class="headerlink" title="beego安装"></a>beego安装</h2><p>beego 的安装是典型的 Go 安装包的形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/beego/beego/v2@latest</span><br></pre></td></tr></table></figure>

<h2 id="beego-升级"><a href="#beego-升级" class="headerlink" title="beego 升级"></a>beego 升级</h2><p>beego 升级分为 go 方式升级和源码下载升级：</p>
<ul>
<li><p>Go 升级,通过该方式用户可以升级 beego 框架，强烈推荐该方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/beego/beego/v2</span><br></pre></td></tr></table></figure>
</li>
<li><p>源码下载升级，用户访问 <code>https://github.com/beego/beego</code> ,下载源码，然后覆盖到 <code>$GOPATH/src/github.com/beego/beego</code> 目录，然后通过本地执行安装就可以升级了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install 	github.com/beego/beego/v2</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="bee-工具"><a href="#bee-工具" class="headerlink" title="bee 工具"></a>bee 工具</h2><p>bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署。</p>
<h3 id="bee-工具的安装"><a href="#bee-工具的安装" class="headerlink" title="bee 工具的安装"></a>bee 工具的安装</h3><p>您可以通过如下的方式安装 bee 工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go 1.16 以前的版本</span></span><br><span class="line">go get -u github.com/beego/bee/v2</span><br><span class="line"></span><br><span class="line"><span class="comment"># go 1.16及以后的版本</span></span><br><span class="line">go install github.com/beego/bee/v2@latest</span><br></pre></td></tr></table></figure>

<p>安装完之后，<code>bee</code> 可执行文件默认存放在 <code>$GOPATH/bin</code> 里面，所以您需要把 <code>$GOPATH/bin</code> 添加到您的环境变量中，才可以进行下一步。</p>
<h3 id="bee-工具命令详解"><a href="#bee-工具命令详解" class="headerlink" title="bee 工具命令详解"></a>bee 工具命令详解</h3><p>我们在命令行输入 <code>bee</code>，可以看到如下的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version     Prints the current Bee version</span><br><span class="line">migrate     Runs database migrations</span><br><span class="line">api         Creates a Beego API application</span><br><span class="line">bale        Transforms non-Go files to Go <span class="built_in">source</span> files</span><br><span class="line">fix         Fixes your application by making it compatible with newer versions of Beego</span><br><span class="line">pro         Source code generator</span><br><span class="line">dev         Commands <span class="built_in">which</span> used to <span class="built_in">help</span> to develop beego and bee</span><br><span class="line">dlv         Start a debugging session using Delve</span><br><span class="line">dockerize   Generates a Dockerfile and docker-compose.yaml <span class="keyword">for</span> your Beego application</span><br><span class="line">generate    Source code generator</span><br><span class="line">hprose      Creates an RPC application based on Hprose and Beego frameworks</span><br><span class="line">new         Creates a Beego application</span><br><span class="line">pack        Compresses a Beego application into a single file</span><br><span class="line">rs          Run customized scripts</span><br><span class="line">run         Run the application by starting a <span class="built_in">local</span> development server</span><br><span class="line">server      serving static content over HTTP on port</span><br><span class="line">update      Update Bee</span><br></pre></td></tr></table></figure>

<h4 id="new命令"><a href="#new命令" class="headerlink" title="new命令"></a><code>new</code>命令</h4><p><code>new</code> 命令是新建一个 Web 项目，我们在命令行下执行 <code>bee new &lt;项目名&gt;</code> 就可以创建一个新的项目。但是注意该命令必须在 <code>$GOPATH/src</code> 下执行。最后会在 <code>$GOPATH/src</code> 相应目录下生成如下目录结构的项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bee new myproject</span><br><span class="line">[INFO] Creating application...</span><br><span class="line">/gopath/src/myproject/</span><br><span class="line">/gopath/src/myproject/conf/</span><br><span class="line">/gopath/src/myproject/controllers/</span><br><span class="line">/gopath/src/myproject/models/</span><br><span class="line">/gopath/src/myproject/static/</span><br><span class="line">/gopath/src/myproject/static/js/</span><br><span class="line">/gopath/src/myproject/static/css/</span><br><span class="line">/gopath/src/myproject/static/img/</span><br><span class="line">/gopath/src/myproject/views/</span><br><span class="line">/gopath/src/myproject/conf/app.conf</span><br><span class="line">/gopath/src/myproject/controllers/default.go</span><br><span class="line">/gopath/src/myproject/views/index.tpl</span><br><span class="line">/gopath/src/myproject/main.go</span><br><span class="line">13-11-25 09:50:39 [SUCC] New application successfully created!</span><br><span class="line">myproject</span><br><span class="line">├── conf</span><br><span class="line">│   └── app.conf</span><br><span class="line">├── controllers</span><br><span class="line">│   └── default.go</span><br><span class="line">├── main.go</span><br><span class="line">├── models</span><br><span class="line">├── routers</span><br><span class="line">│   └── router.go</span><br><span class="line">├── static</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── img</span><br><span class="line">│   └── js</span><br><span class="line">├── tests</span><br><span class="line">│   └── default_test.go</span><br><span class="line">└── views</span><br><span class="line">    └── index.tpl</span><br><span class="line"></span><br><span class="line">8 directories, 4 files</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是官方文档的描述，但是我亲测可以在任意路径使用<code>bee new &lt;项目名&gt;</code>命令，不一定要在<code>$GOPATH/src</code> 。</p>
</blockquote>
<h4 id="api-命令"><a href="#api-命令" class="headerlink" title="api 命令"></a><code>api</code> 命令</h4><p>上面的 <code>new</code> 命令是用来新建 Web 项目，不过很多用户使用 beego 来开发 API 应用。所以这个 <code>api</code> 命令就是用来创建 API 应用的，执行命令之后如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bee api apiproject</span><br><span class="line">create app folder: /gopath/src/apiproject</span><br><span class="line">create conf: /gopath/src/apiproject/conf</span><br><span class="line">create controllers: /gopath/src/apiproject/controllers</span><br><span class="line">create models: /gopath/src/apiproject/models</span><br><span class="line">create tests: /gopath/src/apiproject/tests</span><br><span class="line">create conf app.conf: /gopath/src/apiproject/conf/app.conf</span><br><span class="line">create controllers default.go: /gopath/src/apiproject/controllers/default.go</span><br><span class="line">create tests default.go: /gopath/src/apiproject/tests/default_test.go</span><br><span class="line">create models object.go: /gopath/src/apiproject/models/object.go</span><br><span class="line">create main.go: /gopath/src/apiproject/main.go</span><br></pre></td></tr></table></figure>

<p>这个项目的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiproject</span><br><span class="line">├── conf</span><br><span class="line">│   └── app.conf</span><br><span class="line">├── controllers</span><br><span class="line">│   └── object.go</span><br><span class="line">│   └── user.go</span><br><span class="line">├── docs</span><br><span class="line">│   └── doc.go</span><br><span class="line">├── main.go</span><br><span class="line">├── models</span><br><span class="line">│   └── object.go</span><br><span class="line">│   └── user.go</span><br><span class="line">├── routers</span><br><span class="line">│   └── router.go</span><br><span class="line">└── tests</span><br><span class="line">    └── default_test.go</span><br></pre></td></tr></table></figure>

<p>从上面的目录我们可以看到和 Web 项目相比，少了 static 和 views 目录，多了一个 test 模块，用来做单元测试的。同时，该命令还支持一些自定义参数自动连接数据库创建相关 model 和 controller:<br><code>bee api [appname] [-tables=&quot;&quot;] [-driver=mysql] [-conn=&quot;root:&lt;password&gt;@tcp(127.0.0.1:3306)/test&quot;]</code><br>如果 conn 参数为空则创建一个示例项目，否则将基于链接信息链接数据库创建项目。</p>
<blockquote>
<p>同样笔者亲测该命令也不一定要在<code>$GOPATH/src</code>运行</p>
</blockquote>
<h4 id="run-命令"><a href="#run-命令" class="headerlink" title="run 命令"></a><code>run</code> 命令</h4><p>我们在开发 Go 项目的时候最大的问题是经常需要自己手动去编译再运行，<code>bee run</code> 命令是监控 beego 的项目，通过 <a href="https://github.com/howeyc/fsnotify">fsnotify</a>监控文件系统。但是注意该命令必须在 <code>$GOPATH/src/appname</code> 下执行。<br>这样我们在开发过程中就可以实时的看到项目修改之后的效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bee run</span><br><span class="line">13-11-25 09:53:04 [INFO] Uses <span class="string">&#x27;myproject&#x27;</span> as <span class="string">&#x27;appname&#x27;</span></span><br><span class="line">13-11-25 09:53:04 [INFO] Initializing watcher...</span><br><span class="line">13-11-25 09:53:04 [TRAC] Directory(/gopath/src/myproject/controllers)</span><br><span class="line">13-11-25 09:53:04 [TRAC] Directory(/gopath/src/myproject/models)</span><br><span class="line">13-11-25 09:53:04 [TRAC] Directory(/gopath/src/myproject)</span><br><span class="line">13-11-25 09:53:04 [INFO] Start building...</span><br><span class="line">13-11-25 09:53:16 [SUCC] Build was successful</span><br><span class="line">13-11-25 09:53:16 [INFO] Restarting myproject ...</span><br><span class="line">13-11-25 09:53:16 [INFO] ./myproject is running...</span><br></pre></td></tr></table></figure>

<p>我们打开浏览器就可以看到效果 <code>http://localhost:8080/</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/beerun.png"></p>
<p>如果我们修改了 <code>Controller</code> 下面的 <code>default.go</code> 文件，我们就可以看到命令行输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13-11-25 10:11:20 [EVEN] &quot;/gopath/src/myproject/controllers/default.go&quot;: DELETE|MODIFY</span><br><span class="line">13-11-25 10:11:20 [INFO] Start building...</span><br><span class="line">13-11-25 10:11:20 [SKIP] &quot;/gopath/src/myproject/controllers/default.go&quot;: CREATE</span><br><span class="line">13-11-25 10:11:23 [SKIP] &quot;/gopath/src/myproject/controllers/default.go&quot;: MODIFY</span><br><span class="line">13-11-25 10:11:23 [SUCC] Build was successful</span><br><span class="line">13-11-25 10:11:23 [INFO] Restarting myproject ...</span><br><span class="line">13-11-25 10:11:23 [INFO] ./myproject is running...</span><br></pre></td></tr></table></figure>

<p>刷新浏览器我们看到新的修改内容已经输出。</p>
<h4 id="pack-命令"><a href="#pack-命令" class="headerlink" title="pack 命令"></a><code>pack</code> 命令</h4><p><code>pack</code> 目录用来发布应用的时候打包，会把项目打包成 zip 包，这样我们部署的时候直接把打包之后的项目上传，解压就可以部署了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bee pack</span><br><span class="line">app path: /gopath/src/apiproject</span><br><span class="line">GOOS darwin GOARCH amd64</span><br><span class="line">build apiproject</span><br><span class="line">build success</span><br><span class="line">exclude prefix:</span><br><span class="line">exclude suffix: .go:.DS_Store:.tmp</span><br><span class="line">file write to `/gopath/src/apiproject/apiproject.tar.gz`</span><br></pre></td></tr></table></figure>

<p>我们可以看到目录下有如下的压缩文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rwxr-xr-x  1 astaxie  staff  8995376 11 25 22:46 apiproject</span><br><span class="line">-rw-r--r--  1 astaxie  staff  2240288 11 25 22:58 apiproject.tar.gz</span><br><span class="line">drwxr-xr-x  3 astaxie  staff      102 11 25 22:31 conf</span><br><span class="line">drwxr-xr-x  3 astaxie  staff      102 11 25 22:31 controllers</span><br><span class="line">-rw-r--r--  1 astaxie  staff      509 11 25 22:31 main.go</span><br><span class="line">drwxr-xr-x  3 astaxie  staff      102 11 25 22:31 models</span><br><span class="line">drwxr-xr-x  3 astaxie  staff      102 11 25 22:31 tests</span><br></pre></td></tr></table></figure>

<h4 id="version-命令"><a href="#version-命令" class="headerlink" title="version 命令"></a><code>version</code> 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bee version</span><br><span class="line">______</span><br><span class="line">| ___ \</span><br><span class="line">| |_/ /  ___   ___</span><br><span class="line">| ___ \ / _ \ / _ \</span><br><span class="line">| |_/ /|  __/|  __/</span><br><span class="line">\____/  \___| \___| v2.0.4</span><br><span class="line"></span><br><span class="line">├── GoVersion : go1.20.4</span><br><span class="line">├── GOOS      : windows</span><br><span class="line">├── GOARCH    : amd64</span><br><span class="line">├── NumCPU    : 16</span><br><span class="line">├── GOPATH    : C:\Users\19393\sdk\go1.20.4\go_workspace</span><br><span class="line">├── GOROOT    : C:/Users/19393/sdk/go1.20.4</span><br><span class="line">├── Compiler  : gc</span><br><span class="line">└── Date      : Friday, 21 Jul 2023</span><br></pre></td></tr></table></figure>

<h4 id="generate-命令"><a href="#generate-命令" class="headerlink" title="generate 命令"></a><code>generate</code> 命令</h4><p>这个命令是用来自动化的生成代码的，包含了从数据库一键生成 model，还包含了 scaffold 的，通过这个命令，让大家开发代码不再慢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bee generate scaffold [scaffoldname] [-fields=&quot;&quot;] [-driver=mysql] [-conn=&quot;root:@tcp(127.0.0.1:3306)/test&quot;]</span><br><span class="line">    The generate scaffold command will do a number of things for you.</span><br><span class="line">    -fields: a list of table fields. Format: field:type, ...</span><br><span class="line">    -driver: [mysql | postgres | sqlite], the default is mysql</span><br><span class="line">    -conn:   the connection string used by the driver, the default is root:@tcp(127.0.0.1:3306)/test</span><br><span class="line">    example: bee generate scaffold post -fields=&quot;title:string,body:text&quot;</span><br><span class="line"></span><br><span class="line">bee generate model [modelname] [-fields=&quot;&quot;]</span><br><span class="line">    generate RESTful model based on fields</span><br><span class="line">    -fields: a list of table fields. Format: field:type, ...</span><br><span class="line"></span><br><span class="line">bee generate controller [controllerfile]</span><br><span class="line">    generate RESTful controllers</span><br><span class="line"></span><br><span class="line">bee generate view [viewpath]</span><br><span class="line">    generate CRUD view in viewpath</span><br><span class="line"></span><br><span class="line">bee generate migration [migrationfile] [-fields=&quot;&quot;]</span><br><span class="line">    generate migration file for making database schema update</span><br><span class="line">    -fields: a list of table fields. Format: field:type, ...</span><br><span class="line"></span><br><span class="line">bee generate docs</span><br><span class="line">    generate swagger doc file</span><br><span class="line">    </span><br><span class="line">bee generate routers [-ctrlDir=/path/to/controller/directory] [-routersFile=/path/to/routers/file.go] [-routersPkg=myPackage]</span><br><span class="line">    -ctrlDir: the directory contains controllers definition. Bee scans this directory and its subdirectory to generate routers info</span><br><span class="line">    -routersFile: output file. All generated routers info will be output into this file. </span><br><span class="line">              If file not found, Bee create new one, or Bee truncates it.</span><br><span class="line">              The default value is &quot;routers/commentRouters.go&quot;</span><br><span class="line">    -routersPkg: package declaration.The default value is &quot;routers&quot;. </span><br><span class="line">              When you pass routersFile parameter, you&#x27;d better pass this parameter</span><br><span class="line"></span><br><span class="line">bee generate test [routerfile]</span><br><span class="line">    generate testcase</span><br><span class="line"></span><br><span class="line">bee generate appcode [-tables=&quot;&quot;] [-driver=mysql] [-conn=&quot;root:@tcp(127.0.0.1:3306)/test&quot;] [-level=3]</span><br><span class="line">    generate appcode based on an existing database</span><br><span class="line">    -tables: a list of table names separated by &#x27;,&#x27;, default is empty, indicating all tables</span><br><span class="line">    -driver: [mysql | postgres | sqlite], the default is mysql</span><br><span class="line">    -conn:   the connection string used by the driver.</span><br><span class="line">             default for mysql:    root:@tcp(127.0.0.1:3306)/test</span><br><span class="line">             default for postgres: postgres://postgres:postgres@127.0.0.1:5432/postgres</span><br><span class="line">    -level:  [1 | 2 | 3], 1 = models; 2 = models,controllers; 3 = models,controllers,router</span><br></pre></td></tr></table></figure>

<h4 id="migrate-命令"><a href="#migrate-命令" class="headerlink" title="migrate 命令"></a><code>migrate</code> 命令</h4><p>这个命令是应用的数据库迁移命令，主要是用来每次应用升级，降级的SQL管理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bee migrate [-driver=mysql] [-conn=&quot;root:@tcp(127.0.0.1:3306)/test&quot;]</span><br><span class="line">    run all outstanding migrations</span><br><span class="line">    -driver: [mysql | postgresql | sqlite], the default is mysql</span><br><span class="line">    -conn:   the connection string used by the driver, the default is root:@tcp(127.0.0.1:3306)/test</span><br><span class="line"></span><br><span class="line">bee migrate rollback [-driver=mysql] [-conn=&quot;root:@tcp(127.0.0.1:3306)/test&quot;]</span><br><span class="line">    rollback the last migration operation</span><br><span class="line">    -driver: [mysql | postgresql | sqlite], the default is mysql</span><br><span class="line">    -conn:   the connection string used by the driver, the default is root:@tcp(127.0.0.1:3306)/test</span><br><span class="line"></span><br><span class="line">bee migrate reset [-driver=mysql] [-conn=&quot;root:@tcp(127.0.0.1:3306)/test&quot;]</span><br><span class="line">    rollback all migrations</span><br><span class="line">    -driver: [mysql | postgresql | sqlite], the default is mysql</span><br><span class="line">    -conn:   the connection string used by the driver, the default is root:@tcp(127.0.0.1:3306)/test</span><br><span class="line"></span><br><span class="line">bee migrate refresh [-driver=mysql] [-conn=&quot;root:@tcp(127.0.0.1:3306)/test&quot;]</span><br><span class="line">    rollback all migrations and run them all again</span><br><span class="line">    -driver: [mysql | postgresql | sqlite], the default is mysql</span><br><span class="line">    -conn:   the connection string used by the driver, the default is root:@tcp(127.0.0.1:3306)/test</span><br></pre></td></tr></table></figure>

<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>beego 是一个能够进行快速开发应用的框架，快速入门将带领你快速的建立一个 beego 的项目，然后运行起来。接着修改代码，让我们了解整个 MVC 的运行机制。那么让我们开始创建项目吧！</p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>beego 的项目基本都是通过 <code>bee</code> 命令来创建的，所以在创建项目之前确保你已经安装了 bee 工具和 beego。</p>
<p>现在一切就绪我们就可以开始创建项目了，打开终端，进入 <code>$GOPATH/src</code> 所在的目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  src  bee new quickstart</span><br><span class="line">[INFO] Creating application...</span><br><span class="line">/gopath/src/quickstart/</span><br><span class="line">/gopath/src/quickstart/conf/</span><br><span class="line">/gopath/src/quickstart/controllers/</span><br><span class="line">/gopath/src/quickstart/models/</span><br><span class="line">/gopath/src/quickstart/routers/</span><br><span class="line">/gopath/src/quickstart/tests/</span><br><span class="line">/gopath/src/quickstart/static/</span><br><span class="line">/gopath/src/quickstart/static/js/</span><br><span class="line">/gopath/src/quickstart/static/css/</span><br><span class="line">/gopath/src/quickstart/static/img/</span><br><span class="line">/gopath/src/quickstart/views/</span><br><span class="line">/gopath/src/quickstart/conf/app.conf</span><br><span class="line">/gopath/src/quickstart/controllers/default.go</span><br><span class="line">/gopath/src/quickstart/views/index.tpl</span><br><span class="line">/gopath/src/quickstart/routers/router.go</span><br><span class="line">/gopath/src/quickstart/tests/default_test.go</span><br><span class="line">/gopath/src/quickstart/main.go</span><br><span class="line">2014/11/06 18:17:09 [SUCC] New application successfully created!</span><br></pre></td></tr></table></figure>

<p>通过一个简单的命令就创建了一个 beego 项目。他的目录结构如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quickstart</span><br><span class="line">|-- conf</span><br><span class="line">|   `-- app.conf</span><br><span class="line">|-- controllers</span><br><span class="line">|   `-- default.go</span><br><span class="line">|-- main.go</span><br><span class="line">|-- models</span><br><span class="line">|-- routers</span><br><span class="line">|   `-- router.go</span><br><span class="line">|-- static</span><br><span class="line">|   |-- css</span><br><span class="line">|   |-- img</span><br><span class="line">|   `-- js</span><br><span class="line">|-- tests</span><br><span class="line">|   `-- default_test.go</span><br><span class="line">`-- views</span><br><span class="line">    `-- index.tpl</span><br></pre></td></tr></table></figure>

<p>从目录结构中我们也可以看出来这是一个典型的 MVC 架构的应用，<code>main.go</code> 是入口文件。</p>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>beego 项目创建之后，我们还需要初始化<code>go.mod</code>文件。进入目录之后，使用<code>go mod init</code>初始化模块依赖。</p>
<p>接着我们就开始运行项目，首先进入创建的项目，我们使用 <code>bee run</code> 来运行该项目，这样就可以做到热编译的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  src  cd quickstart</span><br><span class="line">➜  quickstart  bee run</span><br><span class="line">2014/11/06 18:18:34 [INFO] Uses &#x27;quickstart&#x27; as &#x27;appname&#x27;</span><br><span class="line">2014/11/06 18:18:34 [INFO] Initializing watcher...</span><br><span class="line">2014/11/06 18:18:34 [TRAC] Directory(/gopath/src/quickstart/controllers)</span><br><span class="line">2014/11/06 18:18:34 [TRAC] Directory(/gopath/src/quickstart)</span><br><span class="line">2014/11/06 18:18:34 [TRAC] Directory(/gopath/src/quickstart/routers)</span><br><span class="line">2014/11/06 18:18:34 [TRAC] Directory(/gopath/src/quickstart/tests)</span><br><span class="line">2014/11/06 18:18:34 [INFO] Start building...</span><br><span class="line">2014/11/06 18:18:35 [SUCC] Build was successful</span><br><span class="line">2014/11/06 18:18:35 [INFO] Restarting quickstart ...</span><br><span class="line">2014/11/06 18:18:35 [INFO] ./quickstart is running...</span><br><span class="line">2014/11/06 18:18:35 [app.go:96] [I] http server Running on :8080</span><br></pre></td></tr></table></figure>

<p>这样我们的应用已经在 <code>8080</code> 端口(beego 的默认端口)跑起来了.你是不是觉得很神奇，为什么没有 nginx 和 apache 居然可以自己干这个事情？是的，Go 其实已经做了网络层的东西，beego 只是封装了一下，所以可以做到不需要 nginx 和 apache。让我们打开浏览器看看效果吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/beerun.png"></p>
<h2 id="路由设置"><a href="#路由设置" class="headerlink" title="路由设置"></a>路由设置</h2><p>前面我们已经创建了 beego 项目，而且我们也看到它已经运行起来了，那么是如何运行起来的呢？让我们从入口文件先分析起来吧：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;quickstart/routers&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	web.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到 main 函数是入口函数，但是我们知道 Go 的执行过程是如下图所示的方式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/init.png"></p>
<p>这里我们就看到了我们引入了一个包 <code>_ &quot;quickstart/routers&quot;</code>,这个包只引入执行了里面的 init 函数，那么让我们看看这个里面做了什么事情：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;quickstart/controllers&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    web.Router(<span class="string">&quot;/&quot;</span>, &amp;controllers.MainController&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由包里面我们看到执行了路由注册 <code>web.Router</code>, 这个函数的功能是映射 URL 到 controller，第一个参数是 URL (用户请求的地址)，这里我们注册的是 <code>/</code>，也就是我们访问的不带任何参数的 URL，第二个参数是对应的 Controller，也就是我们即将把请求分发到那个控制器来执行相应的逻辑，我们可以执行类似的方式注册如下路由：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Router(<span class="string">&quot;/user&quot;</span>, &amp;controllers.UserController&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>这样用户就可以通过访问 <code>/user</code> 去执行 <code>UserController</code> 的逻辑。这就是我们所谓的路由。</p>
<p>一旦 run 起来之后，我们的服务就监听在两个端口了，一个服务端口 8080 作为对外服务，另一个 8088 端口实行对内监控。</p>
<h2 id="controller-逻辑"><a href="#controller-逻辑" class="headerlink" title="controller 逻辑"></a>controller 逻辑</h2><p>前面我们了解了如何把用户的请求分发到控制器，这小节我们就介绍大家如何来写控制器，首先我们还是从源码分析入手：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MainController <span class="keyword">struct</span> &#123;</span><br><span class="line">        web.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MainController)</span></span> Get() &#123;</span><br><span class="line">        this.Data[<span class="string">&quot;Website&quot;</span>] = <span class="string">&quot;beego.vip&quot;</span></span><br><span class="line">        this.Data[<span class="string">&quot;Email&quot;</span>] = <span class="string">&quot;astaxie@gmail.com&quot;</span></span><br><span class="line">        this.TplName = <span class="string">&quot;index.tpl&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码显示首先我们声明了一个控制器 <code>MainController</code>，这个控制器里面组合了 <code>web.Controller</code>，这就是 Go 的组合方式，也就是 <code>MainController</code> 自动拥有了所有 <code>web.Controller</code> 的方法。</p>
<p>而 <code>web.Controller</code> 拥有很多方法，其中包括 <code>Init</code>、<code>Prepare</code>、<code>Post</code>、<code>Get</code>、<code>Delete</code>、<code>Head</code> 等方法。我们可以通过重写的方式来实现这些方法，而我们上面的代码就是重写了 <code>Get</code> 方法。</p>
<p>我们先前介绍过 beego 是一个 RESTful 的框架，所以我们的请求默认是执行对应 <code>req.Method</code> 的方法。例如浏览器的是 <code>GET</code> 请求，那么默认就会执行 <code>MainController</code> 下的 <code>Get</code> 方法。这样我们上面的 Get 方法就会被执行到，这样就进入了我们的逻辑处理。（用户可以改变这个行为，通过注册自定义的函数名。)</p>
<p>里面的代码是需要执行的逻辑，这里只是简单的输出数据，我们可以通过各种方式获取数据，然后赋值到 <code>this.Data</code> 中，这是一个用来存储输出数据的 map，可以赋值任意类型的值，这里我们只是简单举例输出两个字符串。</p>
<p>最后一个就是需要去渲染的模板，<code>this.TplName</code> 就是需要渲染的模板，这里指定了 <code>index.tpl</code>，如果用户不设置该参数，那么默认会去到模板目录的 <code>Controller/&lt;方法名&gt;.tpl</code> 查找，例如上面的方法会去 <code>maincontroller/get.tpl</code> ***(文件、文件夹必须小写)***。</p>
<p>用户设置了模板之后系统会自动的调用 <code>Render</code> 函数（这个函数是在 <code>web.Controller</code> 中实现的），所以无需用户自己来调用渲染。</p>
<p>当然也可以不使用模版，直接用 <code>this.Ctx.WriteString</code> 输出字符串，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (this *MainController) Get() &#123;</span><br><span class="line">        this.Ctx.WriteString(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此我们的控制器分析基本完成了，接下来让我们看看如何来编写 model。</p>
<h2 id="model-逻辑"><a href="#model-逻辑" class="headerlink" title="model 逻辑"></a>model 逻辑</h2><p>我们知道 Web 应用中我们用的最多的就是数据库操作，而 model 层一般用来做这些操作，我们的 <code>bee new</code> 例子不存在 Model 的演示，但是 <code>bee api</code> 应用中存在 model 的应用。说的简单一点，如果您的应用足够简单，那么 Controller 可以处理一切的逻辑，如果您的逻辑里面存在着可以复用的东西，那么就抽取出来变成一个模块。因此 Model 就是逐步抽象的过程，一般我们会在 Model 里面处理一些数据读取，如下是一个日志分析应用中的代码片段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	NotPV []<span class="type">string</span> = []<span class="type">string</span>&#123;<span class="string">&quot;css&quot;</span>, <span class="string">&quot;js&quot;</span>, <span class="string">&quot;class&quot;</span>, <span class="string">&quot;gif&quot;</span>, <span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;jpeg&quot;</span>, <span class="string">&quot;png&quot;</span>, <span class="string">&quot;bmp&quot;</span>, <span class="string">&quot;ico&quot;</span>, <span class="string">&quot;rss&quot;</span>, <span class="string">&quot;xml&quot;</span>, <span class="string">&quot;swf&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> big = <span class="number">0xFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LogPV</span><span class="params">(urls <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	ext := filepath.Ext(urls)</span><br><span class="line">	<span class="keyword">if</span> ext == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> NotPV &#123;</span><br><span class="line">		<span class="keyword">if</span> v == strings.ToLower(ext) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以如果您的应用足够简单，那么就不需要 Model 了；如果你的模块开始多了，需要复用，需要逻辑分离了，那么 Model 是必不可少的。接下来我们将分析如何编写 View 层的东西。</p>
<h2 id="View-编写"><a href="#View-编写" class="headerlink" title="View 编写"></a>View 编写</h2><p>在前面编写 Controller 的时候，我们在 Get 里面写过这样的语句 <code>this.TplName = &quot;index.tpl&quot;</code>，设置显示的模板文件，默认支持 <code>tpl</code> 和 <code>html</code> 的后缀名，如果想设置其他后缀你可以调用 <code>beego.AddTemplateExt</code> 接口设置，那么模板如何来显示相应的数据呢？beego 采用了 Go 语言默认的模板引擎，所以和 Go 的模板语法一样，Go 模板的详细使用方法在我<a href="https://blog.csdn.net/m0_63230155/article/details/131732504?spm=1001.2014.3001.5502">这篇文章</a>有讲解。</p>
<p>我们看看快速入门里面的代码（去掉了 css 样式）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Beego&lt;/title&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;header class=<span class="string">&quot;hero-unit&quot;</span> style=<span class="string">&quot;background-color:#A9F16C&quot;</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">                &lt;div class=<span class="string">&quot;row&quot;</span>&gt;</span><br><span class="line">                    &lt;div class=<span class="string">&quot;hero-text&quot;</span>&gt;</span><br><span class="line">                        &lt;h1&gt;Welcome to Beego!&lt;/h1&gt;</span><br><span class="line">                        &lt;p class=<span class="string">&quot;description&quot;</span>&gt;</span><br><span class="line">                            Beego is a simple &amp; powerful Go web framework which is inspired by tornado and sinatra.</span><br><span class="line">                            &lt;br /&gt;</span><br><span class="line">                            Official website: &lt;a href=<span class="string">&quot;http://&#123;&#123;.Website&#125;&#125;&quot;</span>&gt;&#123;&#123;.Website&#125;&#125;&lt;/a&gt;</span><br><span class="line">                            &lt;br /&gt;</span><br><span class="line">                            Contact me: &#123;&#123;.Email&#125;&#125;</span><br><span class="line">                        &lt;/p&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>我们在 Controller 里面把数据赋值给了 data（map 类型），然后我们在模板中就直接通过 key 访问 <code>.Website</code> 和 <code>.Email</code> 。这样就做到了数据的输出。接下来我们讲解如何让静态文件输出。</p>
<h2 id="静态文件处理"><a href="#静态文件处理" class="headerlink" title="静态文件处理"></a>静态文件处理</h2><p>前面我们介绍了如何输出静态页面，但是我们的网页往往包含了很多的静态文件，包括图片、JS、CSS 等，刚才创建的应用里面就创建了如下目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── static</span><br><span class="line">	│   ├── css</span><br><span class="line">	│   ├── img</span><br><span class="line">	│   └── js</span><br></pre></td></tr></table></figure>

<p>beego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在<code>/main.go</code>文件中<code>web.Run()</code>之前加入）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">StaticDir[<span class="string">&quot;/static&quot;</span>] = <span class="string">&quot;static&quot;</span></span><br></pre></td></tr></table></figure>

<p>用户可以设置多个静态文件处理目录，例如你有多个文件下载目录 download1、download2，你可以这样映射（在 <code>/main.go</code> 文件中 <code>web.Run()</code> 之前加入）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.SetStaticPath(<span class="string">&quot;/down1&quot;</span>, <span class="string">&quot;download1&quot;</span>)</span><br><span class="line">web.SetStaticPath(<span class="string">&quot;/down2&quot;</span>, <span class="string">&quot;download2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样用户访问 URL <code>http://localhost:8080/down1/123.txt</code> 则会请求 download1 目录下的 123.txt 文件。</p>
<h1 id="beego-的-MVC-架构"><a href="#beego-的-MVC-架构" class="headerlink" title="beego 的 MVC 架构"></a>beego 的 MVC 架构</h1><p>beego 是一个典型的 MVC 框架，它的整个执行逻辑如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/detail.png"></p>
<p>通过文字来描述如下：</p>
<ol>
<li>在监听的端口接收数据，默认监听在 8080 端口。</li>
<li>用户请求到达 8080 端口之后进入 beego 的处理逻辑。</li>
<li>初始化 Context 对象，根据请求判断是否为 WebSocket 请求，如果是的话设置 Input，同时判断请求的方法是否在标准请求方法中（GET、POST、PUT、DELETE、PATCH、OPTIONS、HEAD），防止用户的恶意伪造请求攻击造成不必要的影响。</li>
<li>执行 BeforeRouter 过滤器，当然在 beego 里面有开关设置。如果用户设置了过滤器，那么该开关打开，这样可以提高在没有开启过滤器的情况下提高执行效率。如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。</li>
<li>开始执行静态文件的处理，查看用户的请求 URL 是否和注册在静态文件处理 StaticDir 中的 prefix 是否匹配。如果匹配的话，采用 <code>http</code> 包中默认的 ServeFile 来处理静态文件。</li>
<li>如果不是静态文件开始初始化 session 模块(如果开启 session 的话)，这个里面大家需要注意，如果你的 BeforeRouter 过滤器用到了 session 就会报错，你应该把它加入到 AfterStatic 过滤器中。</li>
<li>开始执行 AfterStatic 过滤器，如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。</li>
<li>执行过过滤器之后，开始从固定的路由规则中查找和请求 URL 相匹配的对象。这个匹配是全匹配规则，即如果用户请求的 URL 是 <code>/hello/world</code>，那么固定规则中 <code>/hello</code> 是不会匹配的，只有完全匹配才算匹配。如果匹配的话就进入逻辑执行，如果不匹配进入下一环节的正则匹配。</li>
<li>正则匹配是进行正则的全匹配，这个正则是按照用户添加 beego 路由顺序来进行匹配的，也就是说，如果你在添加路由的时候你的顺序影响你的匹配。和固定匹配一样，如果匹配的话就进行逻辑执行，如果不匹配进入 Auto 匹配。</li>
<li>如果用户注册了 AutoRouter，那么会通过 <code>controller/method</code> 这样的方式去查找对应的 Controller 和他内置的方法，如果找到就开始执行逻辑，如果找不到就跳转到监控判断。</li>
<li>如果找到 Controller 的话，那么就开始执行逻辑，首先执行 BeforeExec 过滤器，如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。</li>
<li>Controller 开始执行 Init 函数，初始化基本的一些信息，这个函数一般都是 beego.Controller 的初始化，不建议用户继承的时候修改该函数。</li>
<li>是否开启了 XSRF，开启的话就调用 Controller 的 XsrfToken，然后如果是 POST 请求就调用 CheckXsrfCookie 方法。</li>
<li>继续执行 Controller 的 Prepare 函数，这个函数一般是预留给用户的，用来做 Controller 里面的一些参数初始化之类的工作。如果在初始化中 responseWriter 有输出，那么就直接进入 Finish 函数逻辑。</li>
<li>如果没有输出的话，那么根据用户注册的方法执行相应的逻辑，如果用户没有注册，那么就调用 http.Method 对应的方法（Get&#x2F;Post 等）。执行相应的逻辑，例如数据读取，数据赋值，模板显示之类的，或者直接输出 JSON 或者 XML。</li>
<li>如果 responseWriter 没有输出，那么就调用 Render 函数进行模板输出。</li>
<li>执行 Controller 的 Finish 函数，这个函数是预留给用户用来重写的，用于释放一些资源。释放在 Init 中初始化的信息数据。</li>
<li>执行 AfterExec 过滤器，如果有输出的话就跳转到监控判断逻辑。</li>
<li>执行 Controller 的 Destructor，用于释放 Init 中初始化的一些数据。</li>
<li>如果这一路执行下来都没有找到路由，那么会调用 404 显示找不到该页面。</li>
<li>最后所有的逻辑都汇聚到了监控判断，如果用户开启了监控模块（默认是开启一个 8088 端口用于进程内监控），这样就会把访问的请求链接扔给监控程序去记录当前访问的 QPS，对应的链接访问的执行时间，请求链接等。</li>
</ol>
<h1 id="controller-设计"><a href="#controller-设计" class="headerlink" title="controller 设计"></a>controller 设计</h1><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p>beego 目前支持 INI、XML、JSON、YAML 格式的配置文件解析，但是默认采用了 INI 格式解析，用户可以通过简单的配置就可以获得很大的灵活性。</p>
<h3 id="默认配置解析"><a href="#默认配置解析" class="headerlink" title="默认配置解析"></a>默认配置解析</h3><p>beego 默认会解析当前应用下的 <code>conf/app.conf</code> 文件。</p>
<p>通过这个文件你可以初始化很多 beego 的默认参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">appname = beepkg</span><br><span class="line">httpaddr = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">httpport = <span class="number">9090</span></span><br><span class="line">runmode =<span class="string">&quot;dev&quot;</span></span><br><span class="line">autorender = <span class="literal">false</span></span><br><span class="line">recoverpanic = <span class="literal">false</span></span><br><span class="line">viewspath = <span class="string">&quot;myview&quot;</span></span><br></pre></td></tr></table></figure>

<p>它们都维护在结构体 <code>beego/server/web#Config</code> 。</p>
<p>BConfig 就是 beego 里面的默认的配置，也是结构体 <code>beego/server/web#Config</code> 的实例。</p>
<p>你也可以直接通过<code>web.BConfig.AppName=&quot;beepkg&quot;</code>这样来修改，和上面的配置效果一样，只是一个在代码里面写死了，而配置文件就会显得更加灵活。</p>
<p>你也可以在配置文件中配置应用需要用的一些配置信息，例如下面所示的数据库信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mysqluser = <span class="string">&quot;root&quot;</span></span><br><span class="line">mysqlpass = <span class="string">&quot;rootpass&quot;</span></span><br><span class="line">mysqlurls = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">mysqldb   = <span class="string">&quot;beego&quot;</span></span><br></pre></td></tr></table></figure>

<p>那么你就可以通过如下的方式获取设置的配置信息:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.AppConfig.String(<span class="string">&quot;mysqluser&quot;</span>)</span><br><span class="line">web.AppConfig.String(<span class="string">&quot;mysqlpass&quot;</span>)</span><br><span class="line">web.AppConfig.String(<span class="string">&quot;mysqlurls&quot;</span>)</span><br><span class="line">web.AppConfig.String(<span class="string">&quot;mysqldb&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="不同级别的配置"><a href="#不同级别的配置" class="headerlink" title="不同级别的配置"></a>不同级别的配置</h3><p>在配置文件里面支持 section，可以有不同的 Runmode 的配置，默认优先读取 runmode 下的配置信息，例如下面的配置文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">appname = beepkg</span><br><span class="line">httpaddr = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">httpport = <span class="number">9090</span></span><br><span class="line">runmode =<span class="string">&quot;dev&quot;</span></span><br><span class="line">autorender = <span class="literal">false</span></span><br><span class="line">recoverpanic = <span class="literal">false</span></span><br><span class="line">viewspath = <span class="string">&quot;myview&quot;</span></span><br><span class="line"></span><br><span class="line">[dev]</span><br><span class="line">httpport = <span class="number">8080</span></span><br><span class="line">[prod]</span><br><span class="line">httpport = <span class="number">8088</span></span><br><span class="line">[test]</span><br><span class="line">httpport = <span class="number">8888</span></span><br></pre></td></tr></table></figure>

<p>上面的配置文件就是在不同的 runmode 下解析不同的配置，例如在 dev 模式下，httpport 是 8080，在 prod 模式下是 8088，在 test 模式下是 8888。其他配置文件同理。解析的时候优先解析 runmode 下的配置，然后解析默认的配置。</p>
<h3 id="多个配置文件"><a href="#多个配置文件" class="headerlink" title="多个配置文件"></a>多个配置文件</h3><p>INI 格式配置支持 <code>include</code> 方式，引用多个配置文件，例如下面的两个配置文件效果同上：</p>
<p>app.conf</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">appname = beepkg</span><br><span class="line">httpaddr = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">httpport = <span class="number">9090</span></span><br><span class="line"></span><br><span class="line">include <span class="string">&quot;app2.conf&quot;</span></span><br></pre></td></tr></table></figure>

<p>app2.conf</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runmode =<span class="string">&quot;dev&quot;</span></span><br><span class="line">autorender = <span class="literal">false</span></span><br><span class="line">recoverpanic = <span class="literal">false</span></span><br><span class="line">viewspath = <span class="string">&quot;myview&quot;</span></span><br><span class="line"></span><br><span class="line">[dev]</span><br><span class="line">httpport = <span class="number">8080</span></span><br><span class="line">[prod]</span><br><span class="line">httpport = <span class="number">8088</span></span><br><span class="line">[test]</span><br><span class="line">httpport = <span class="number">8888</span></span><br></pre></td></tr></table></figure>

<p>关于系统的默认参数，参考官方文档：<a href="https://git-books.github.io/books/beego/?p=mvc/controller/config.md">https://git-books.github.io/books/beego/?p=mvc/controller/config.md</a></p>
<h2 id="路由设置-1"><a href="#路由设置-1" class="headerlink" title="路由设置"></a>路由设置</h2><h3 id="基础路由"><a href="#基础路由" class="headerlink" title="基础路由"></a>基础路由</h3><p>从 beego 1.2 版本开始支持了基本的 RESTful 函数式路由,应用中的大多数路由都会定义在 <code>routers/router.go</code> 文件中。最简单的 beego 路由由 URI 和闭包函数组成。</p>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Get(<span class="string">&quot;/&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(ctx *context.Context)</span></span>&#123;</span><br><span class="line">     ctx.Output.Body([]<span class="type">byte</span>(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Post(<span class="string">&quot;/alice&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(ctx *context.Context)</span></span>&#123;</span><br><span class="line">     ctx.Output.Body([]<span class="type">byte</span>(<span class="string">&quot;bob&quot;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="响应任何-HTTP-的路由"><a href="#响应任何-HTTP-的路由" class="headerlink" title="响应任何 HTTP 的路由"></a>响应任何 HTTP 的路由</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Any(<span class="string">&quot;/foo&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(ctx *context.Context)</span></span>&#123;</span><br><span class="line">     ctx.Output.Body([]<span class="type">byte</span>(<span class="string">&quot;bar&quot;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="支持的基础函数"><a href="#支持的基础函数" class="headerlink" title="支持的基础函数"></a>支持的基础函数</h4><ul>
<li>web.Get(router, web.HandleFunc)</li>
<li>web.Post(router, web.HandleFunc)</li>
<li>web.Put(router, web.HandleFunc)</li>
<li>web.Patch(router, web.HandleFunc)</li>
<li>web.Head(router, web.HandleFunc)</li>
<li>web.Options(router, web.HandleFunc)</li>
<li>web.Delete(router, web.HandleFunc)</li>
<li>web.Any(router, web.HandleFunc)</li>
</ul>
<h3 id="固定路由"><a href="#固定路由" class="headerlink" title="固定路由"></a>固定路由</h3><p>固定路由也就是全匹配的路由，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Router(<span class="string">&quot;/&quot;</span>, &amp;controllers.MainController&#123;&#125;)</span><br><span class="line">web.Router(<span class="string">&quot;/admin&quot;</span>, &amp;admin.UserController&#123;&#125;)</span><br><span class="line">web.Router(<span class="string">&quot;/admin/index&quot;</span>, &amp;admin.ArticleController&#123;&#125;)</span><br><span class="line">web.Router(<span class="string">&quot;/admin/addpkg&quot;</span>, &amp;admin.AddController&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>如上所示的路由就是我们最常用的路由方式，一个固定的路由，一个控制器，然后根据用户请求方法不同请求控制器中对应的方法，典型的 RESTful 方式。</p>
<h3 id="正则路由"><a href="#正则路由" class="headerlink" title="正则路由"></a>正则路由</h3><p>为了用户更加方便的路由设置，beego 参考了 sinatra 的路由实现，支持多种方式的路由：</p>
<ul>
<li><p>web.Router(“&#x2F;api&#x2F;?:id”, &amp;controllers.RController{})</p>
<p>默认匹配 &#x2F;&#x2F;例如对于URL”&#x2F;api&#x2F;123”可以匹配成功，此时变量”:id”值为”123”，URL”&#x2F;api&#x2F;“可正常匹配</p>
</li>
<li><p>web.Router(“&#x2F;api&#x2F;:id”, &amp;controllers.RController{})</p>
<p>默认匹配 &#x2F;&#x2F;例如对于URL”&#x2F;api&#x2F;123”可以匹配成功，此时变量”:id”值为”123”，但URL”&#x2F;api&#x2F;“匹配失败</p>
</li>
<li><p>web.Router(“&#x2F;api&#x2F;:id([0-9]+)”, &amp;controllers.RController{})</p>
<p>自定义正则匹配 &#x2F;&#x2F;例如对于URL”&#x2F;api&#x2F;123”可以匹配成功，此时变量”:id”值为”123”</p>
</li>
<li><p>web.Router(“&#x2F;user&#x2F;:username([\w]+)”, &amp;controllers.RController{})</p>
<p>正则字符串匹配 &#x2F;&#x2F;例如对于URL”&#x2F;user&#x2F;astaxie”可以匹配成功，此时变量”:username”值为”astaxie”</p>
</li>
<li><p>web.Router(“&#x2F;download&#x2F;<em>.</em>“, &amp;controllers.RController{})</p>
<p>*匹配方式 &#x2F;&#x2F;例如对于URL”&#x2F;download&#x2F;file&#x2F;api.xml”可以匹配成功，此时变量”:path”值为”file&#x2F;api”， “:ext”值为”xml”</p>
</li>
<li><p>web.Router(“&#x2F;download&#x2F;ceshi&#x2F;*”, &amp;controllers.RController{})</p>
<p>*全匹配方式 &#x2F;&#x2F;例如对于URL”&#x2F;download&#x2F;ceshi&#x2F;file&#x2F;api.json”可以匹配成功，此时变量”:splat”值为”file&#x2F;api.json”</p>
</li>
<li><p>web.Router(“&#x2F;:id:int”, &amp;controllers.RController{})</p>
<p>int 类型设置方式，匹配 :id为int 类型，框架帮你实现了正则 ([0-9]+)</p>
</li>
<li><p>web.Router(“&#x2F;:hi:string”, &amp;controllers.RController{})</p>
<p>string 类型设置方式，匹配 :hi 为 string 类型。框架帮你实现了正则 ([\w]+)</p>
</li>
<li><p>web.Router(“&#x2F;cms_:id([0-9]+).html”, &amp;controllers.CmsController{})</p>
<p>带有前缀的自定义正则 &#x2F;&#x2F;匹配 :id 为正则类型。匹配 cms_123.html 这样的 url :id &#x3D; 123</p>
</li>
</ul>
<p>可以在 Controller 中通过如下方式获取上面的变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">this.Ctx.Input.Param(<span class="string">&quot;:id&quot;</span>)</span><br><span class="line">this.Ctx.Input.Param(<span class="string">&quot;:username&quot;</span>)</span><br><span class="line">this.Ctx.Input.Param(<span class="string">&quot;:splat&quot;</span>)</span><br><span class="line">this.Ctx.Input.Param(<span class="string">&quot;:path&quot;</span>)</span><br><span class="line">this.Ctx.Input.Param(<span class="string">&quot;:ext&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="自定义方法及-RESTful-规则"><a href="#自定义方法及-RESTful-规则" class="headerlink" title="自定义方法及 RESTful 规则"></a>自定义方法及 RESTful 规则</h3><p>上面列举的是默认的请求方法名（请求的 method 和函数名一致，例如 <code>GET</code> 请求执行 <code>Get</code> 函数，<code>POST</code> 请求执行 <code>Post</code> 函数），如果用户期望自定义函数名，那么可以使用如下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Router(<span class="string">&quot;/&quot;</span>,&amp;IndexController&#123;&#125;,<span class="string">&quot;*:Index&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用第三个参数，第三个参数就是用来设置对应 method 到函数名，定义如下</p>
<ul>
<li><code>*</code>表示任意的 method 都执行该函数</li>
<li>使用 httpmethod:funcname 格式来展示</li>
<li>多个不同的格式使用 <code>;</code> 分割</li>
<li>多个 method 对应同一个 funcname，method 之间通过 <code>,</code> 来分割</li>
</ul>
<p>以下是一个 RESTful 的设计示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Router(<span class="string">&quot;/api/food&quot;</span>,&amp;RestController&#123;&#125;,<span class="string">&quot;get:ListFood&quot;</span>)</span><br><span class="line">web.Router(<span class="string">&quot;/api/food&quot;</span>,&amp;RestController&#123;&#125;,<span class="string">&quot;post:CreateFood&quot;</span>)</span><br><span class="line">web.Router(<span class="string">&quot;/api/food&quot;</span>,&amp;RestController&#123;&#125;,<span class="string">&quot;put:UpdateFood&quot;</span>)</span><br><span class="line">web.Router(<span class="string">&quot;/api/food&quot;</span>,&amp;RestController&#123;&#125;,<span class="string">&quot;delete:DeleteFood&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以下是多个 HTTP Method 指向同一个函数的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Router(<span class="string">&quot;/api&quot;</span>,&amp;RestController&#123;&#125;,<span class="string">&quot;get,post:ApiFunc&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以下是不同的 method 对应不同的函数，通过 ; 进行分割的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Router(<span class="string">&quot;/api/food&quot;</span>,&amp;RestController&#123;&#125;,<span class="string">&quot;get:ListFood;post:CreateFood;put:UpdateFood;delete:DeleteFood&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>可用的 HTTP Method：</p>
<ul>
<li>*: 包含以下所有的函数</li>
<li>get: GET 请求</li>
<li>post: POST 请求</li>
<li>put: PUT 请求</li>
<li>delete: DELETE 请求</li>
<li>patch: PATCH 请求</li>
<li>options: OPTIONS 请求</li>
<li>head: HEAD 请求</li>
</ul>
<p>如果同时存在 * 和对应的 HTTP Method，那么优先执行 HTTP Method 的方法，例如同时注册了如下所示的路由：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Router(<span class="string">&quot;/simple&quot;</span>,&amp;SimpleController&#123;&#125;,<span class="string">&quot;*:AllFunc;post:PostFunc&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>那么执行 <code>POST</code> 请求的时候，执行 <code>PostFunc</code> 而不执行 <code>AllFunc</code>。</p>
<blockquote>
<blockquote>
<blockquote>
<p>自定义函数的路由默认不支持 RESTful 的方法，也就是如果你设置了 <code>web.Router(&quot;/api&quot;,&amp;RestController&#123;&#125;,&quot;post:ApiFunc&quot;)</code> 这样的路由，如果请求的方法是 <code>POST</code>，那么不会默认去执行 <code>Post</code> 函数。</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="自动匹配"><a href="#自动匹配" class="headerlink" title="自动匹配"></a>自动匹配</h3><p>用户首先需要把需要路由的控制器注册到自动路由中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.AutoRouter(&amp;controllers.ObjectController&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>那么 beego 就会通过反射获取该结构体中所有的实现方法，你就可以通过如下的方式访问到对应的方法中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/object/login   调用 ObjectController 中的 Login 方法</span><br><span class="line">/object/logout  调用 ObjectController 中的 Logout 方法</span><br></pre></td></tr></table></figure>

<p>除了前缀两个 <code>/:controller/:method</code> 的匹配之外，剩下的 url beego 会帮你自动化解析为参数，保存在 <code>this.Ctx.Input.Params</code> 当中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/object/blog/<span class="number">2013</span>/<span class="number">09</span>/<span class="number">12</span>  调用 ObjectController 中的 Blog 方法，参数如下：<span class="keyword">map</span>[<span class="number">0</span>:<span class="number">2013</span> <span class="number">1</span>:<span class="number">09</span> <span class="number">2</span>:<span class="number">12</span>]</span><br></pre></td></tr></table></figure>

<p>方法名在内部是保存了用户设置的，例如 Login，url 匹配的时候都会转化为小写，所以，<code>/object/LOGIN</code> 这样的 <code>url</code> 也一样可以路由到用户定义的 <code>Login</code> 方法中。</p>
<p>现在已经可以通过自动识别出来下面类似的所有 url，都会把请求分发到 <code>controller</code> 的 <code>simple</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/controller/simple</span><br><span class="line">/controller/simple.html</span><br><span class="line">/controller/simple.json</span><br><span class="line">/controller/simple.xml</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>this.Ctx.Input.Param(&quot;:ext&quot;)</code> 获取后缀名。</p>
<h3 id="注解路由"><a href="#注解路由" class="headerlink" title="注解路由"></a>注解路由</h3><p>从2.0开始，我们使用配置<code>CommentRouterPath</code>来配置注解路由的扫描路径。在<code>dev</code>环境下，我们将自动扫描该配置指向的目录及其子目录，生成路由文件。</p>
<p>生成之后，用户需要显示 Include 相应的 controller。注意， controller 的 method 方法上面须有 router 注释（&#x2F;&#x2F; @router），详细的使用请看下面的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMS API</span></span><br><span class="line"><span class="keyword">type</span> CMSController <span class="keyword">struct</span> &#123;</span><br><span class="line">	web.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CMSController)</span></span> URLMapping() &#123;</span><br><span class="line">	c.Mapping(<span class="string">&quot;StaticBlock&quot;</span>, c.StaticBlock)</span><br><span class="line">	c.Mapping(<span class="string">&quot;AllBlock&quot;</span>, c.AllBlock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @router /staticblock/:key [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CMSController)</span></span> StaticBlock() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @router /all/:key [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CMSController)</span></span> AllBlock() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在 <code>router.go</code> 中通过如下方式注册路由：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Include(&amp;CMSController&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>web 自动会进行源码分析，注意只会在 dev 模式下进行生成，生成的路由放在 “&#x2F;routers&#x2F;commentsRouter.go” 文件中。</p>
<p>这样上面的路由就支持了如下的路由：</p>
<ul>
<li>GET &#x2F;staticblock&#x2F;:key</li>
<li>GET &#x2F;all&#x2F;:key</li>
</ul>
<p>其实效果和自己通过 Router 函数注册是一样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Router(<span class="string">&quot;/staticblock/:key&quot;</span>, &amp;CMSController&#123;&#125;, <span class="string">&quot;get:StaticBlock&quot;</span>)</span><br><span class="line">web.Router(<span class="string">&quot;/all/:key&quot;</span>, &amp;CMSController&#123;&#125;, <span class="string">&quot;get:AllBlock&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>同时大家注意到新版本里面增加了 URLMapping 这个函数，这是新增加的函数，用户如果没有进行注册，那么就会通过反射来执行对应的函数，如果注册了就会通过 interface 来进行执行函数，性能上面会提升很多。</p>
<h3 id="方法表达式路由"><a href="#方法表达式路由" class="headerlink" title="方法表达式路由"></a>方法表达式路由</h3><p>方法表达式路由与上面的RESTful基本相似，区别是无需在传入http method和controller方法（如：<code>&quot;get:StaticBlock&quot;</code>）。<br>只需要通过golang的method expression进行传入方法表达式。如果方法是receiver是非指针，则直接使用 <code>包名.Controller.Method</code> 方法 传入，<br>如果receiver是指针，则使用 <code>(*包名.Controller).Method</code> 进行传参。假如在同包下，包名可进行省略。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BaseController <span class="keyword">struct</span> &#123;</span><br><span class="line">	web.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b BaseController)</span></span> Ping() &#123;</span><br><span class="line">	b.Data[<span class="string">&quot;json&quot;</span>] = <span class="string">&quot;pong&quot;</span></span><br><span class="line">	b.ServeJSON()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BaseController)</span></span> PingPointer() &#123;</span><br><span class="line">	b.Data[<span class="string">&quot;json&quot;</span>] = <span class="string">&quot;pong_pointer&quot;</span></span><br><span class="line">	b.ServeJSON()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	web.CtrlGet(<span class="string">&quot;/ping&quot;</span>, BaseController.Ping)</span><br><span class="line">	web.CtrlGet(<span class="string">&quot;/ping_pointer&quot;</span>, (*BaseController).PingPointer)</span><br><span class="line">	web.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共有以下几种函数：</p>
<ul>
<li>web.CtrlGet(router, pkg.controller.method)</li>
<li>web.CtrlPost(router, pkg.controller.method)</li>
<li>web.CtrlPut(router, pkg.controller.method)</li>
<li>web.CtrlPatch(router, pkg.controller.method)</li>
<li>web.CtrlHead(router, pkg.controller.method)</li>
<li>web.CtrlOptions(router, pkg.controller.method)</li>
<li>web.CtrlDelete(router, pkg.controller.method)</li>
<li>web.CtrlAny(router, pkg.controller.method)</li>
</ul>
<h2 id="控制器函数"><a href="#控制器函数" class="headerlink" title="控制器函数"></a>控制器函数</h2><h3 id="控制器介绍"><a href="#控制器介绍" class="headerlink" title="控制器介绍"></a>控制器介绍</h3><p>基于 beego 的 Controller 设计，只需要匿名组合 <code>beego.Controller</code> 就可以了，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> your_package</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> xxxController <span class="keyword">struct</span> &#123;</span><br><span class="line">	    web.Controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="控制器方法"><a href="#控制器方法" class="headerlink" title="控制器方法"></a>控制器方法</h3><p><code>web.Controller</code> 实现了接口 <code>web.ControllerInterface</code>，<code>web.ControllerInterface</code> 定义了如下函数：</p>
<ul>
<li><p>Init(ctx *context.Context, controllerName, actionName string, app interface{})</p>
<p>这个函数主要初始化了 Context、相应的 Controller 名称，模板名，初始化模板参数的容器 Data，app 即为当前执行的 Controller 的 reflecttype，这个 app 可以用来执行子类的方法。</p>
</li>
<li><p>Prepare()</p>
<p>这个函数主要是为了用户扩展用的，这个函数会在下面定义的这些 Method 方法之前执行，用户可以重写这个函数实现类似用户验证之类。</p>
</li>
<li><p>Get()</p>
<p>如果用户请求的 HTTP Method 是 GET，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Get 请求。</p>
</li>
<li><p>Post()</p>
<p>如果用户请求的 HTTP Method 是 POST，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Post 请求。</p>
</li>
<li><p>Delete()</p>
<p>如果用户请求的 HTTP Method 是 DELETE，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Delete 请求。</p>
</li>
<li><p>Put()</p>
<p>如果用户请求的 HTTP Method 是 PUT，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Put 请求.</p>
</li>
<li><p>Head()</p>
<p>如果用户请求的 HTTP Method 是 HEAD，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Head 请求。</p>
</li>
<li><p>Patch()</p>
<p>如果用户请求的 HTTP Method 是 PATCH，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Patch 请求.</p>
</li>
<li><p>Options()</p>
<p>如果用户请求的HTTP Method是OPTIONS，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Options 请求。</p>
</li>
<li><p>Finish()</p>
<p>这个函数是在执行完相应的 HTTP Method 方法之后执行的，默认是空，用户可以在子 struct 中重写这个函数，执行例如数据库关闭，清理数据之类的工作。</p>
</li>
<li><p>Render() error</p>
<p>这个函数主要用来实现渲染模板，如果 beego.AutoRender 为 true 的情况下才会执行。</p>
</li>
<li><p>Redirect(url string, code int)</p>
<p>重定向。<code>url</code>是目的地址。</p>
</li>
</ul>
<h3 id="子类扩展"><a href="#子类扩展" class="headerlink" title="子类扩展"></a>子类扩展</h3><p>通过子 struct 的方法重写，用户就可以实现自己的逻辑，接下来我们看一个实际的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AddController <span class="keyword">struct</span> &#123;</span><br><span class="line">    web.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddController)</span></span> Prepare() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddController)</span></span> Get() &#123;</span><br><span class="line">    this.Data[<span class="string">&quot;content&quot;</span>] = <span class="string">&quot;value&quot;</span></span><br><span class="line">    this.Layout = <span class="string">&quot;admin/layout.html&quot;</span></span><br><span class="line">    this.TplName = <span class="string">&quot;admin/add.tpl&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddController)</span></span> Post() &#123;</span><br><span class="line">    pkgname := this.GetString(<span class="string">&quot;pkgname&quot;</span>)</span><br><span class="line">    content := this.GetString(<span class="string">&quot;content&quot;</span>)</span><br><span class="line">    pk := models.GetCruPkg(pkgname)</span><br><span class="line">    <span class="keyword">if</span> pk.Id == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> pp models.PkgEntity</span><br><span class="line">        pp.Pid = <span class="number">0</span></span><br><span class="line">        pp.Pathname = pkgname</span><br><span class="line">        pp.Intro = pkgname</span><br><span class="line">        models.InsertPkg(pp)</span><br><span class="line">        pk = models.GetCruPkg(pkgname)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> at models.Article</span><br><span class="line">    at.Pkgid = pk.Id</span><br><span class="line">    at.Content = content</span><br><span class="line">    models.InsertArticle(at)</span><br><span class="line">    this.Ctx.Redirect(<span class="number">302</span>, <span class="string">&quot;/admin/index&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出来，通过重写方法可以实现对应 method 的逻辑，实现 RESTFul 结构的逻辑处理。</p>
<h3 id="提前终止运行"><a href="#提前终止运行" class="headerlink" title="提前终止运行"></a>提前终止运行</h3><p>我们应用中经常会遇到这样的情况，在 Prepare 阶段进行判断，如果用户认证不通过，就输出一段信息，然后直接中止进程，之后的 Post、Get 之类的不再执行，那么如何终止呢？可以使用 <code>StopRun</code> 来终止执行逻辑，可以在任意的地方执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RController <span class="keyword">struct</span> &#123;</span><br><span class="line">    beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RController)</span></span> Prepare() &#123;</span><br><span class="line">    this.Data[<span class="string">&quot;json&quot;</span>] = <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;astaxie&quot;</span>&#125;</span><br><span class="line">    this.ServeJSON()</span><br><span class="line">    this.StopRun()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<blockquote>
<p>调用 StopRun 之后，如果你还定义了 Finish 函数就不会再执行，如果需要释放资源，那么请自己在调用 StopRun 之前手工调用 Finish 函数。</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="XSRF-过滤"><a href="#XSRF-过滤" class="headerlink" title="XSRF 过滤"></a>XSRF 过滤</h2><h3 id="跨站请求伪造"><a href="#跨站请求伪造" class="headerlink" title="跨站请求伪造"></a>跨站请求伪造</h3><p><a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">跨站请求伪造(Cross-site request forgery)</a>， 简称为 XSRF，是 Web 应用中常见的一个安全问题。前面的链接也详细讲述了 XSRF 攻击的实现方式。</p>
<p>当前防范 XSRF 的一种通用的方法，是对每一个用户都记录一个无法预知的 cookie 数据，然后要求所有提交的请求（POST&#x2F;PUT&#x2F;DELETE）中都必须带有这个 cookie 数据。如果此数据不匹配 ，那么这个请求就可能是被伪造的。</p>
<p>beego 有内建的 XSRF 的防范机制，要使用此机制，你需要在应用配置文件中加上 <code>enablexsrf</code> 设定：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">enablexsrf = <span class="literal">true</span></span><br><span class="line">xsrfkey = <span class="number">61</span>oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o</span><br><span class="line">xsrfexpire = <span class="number">3600</span></span><br></pre></td></tr></table></figure>

<p>或者直接在 main 入口处这样设置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.EnableXSRF = <span class="literal">true</span></span><br><span class="line">web.XSRFKEY = <span class="string">&quot;61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o&quot;</span></span><br><span class="line">web.XSRFExpire = <span class="number">3600</span>  <span class="comment">//过期时间，默认1小时</span></span><br></pre></td></tr></table></figure>

<p>如果开启了 XSRF，那么 beego 的 Web 应用将对所有用户设置一个 <code>_xsrf</code> 的 cookie 值（默认过期 1 小时），如果 <code>POST PUT DELET</code> 请求中没有这个 cookie 值，那么这个请求会被直接拒绝。如果你开启了这个机制，那么在所有被提交的表单中，你都需要加上一个域来提供这个值。你可以通过在模板中使用 专门的函数 <code>XSRFFormHTML()</code> 来做到这一点：</p>
<p>过期时间上面我们设置了全局的过期时间 <code>web.XSRFExpire</code>，但是有些时候我们也可以在控制器中修改这个过期时间，专门针对某一类处理逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *HomeController)</span></span> Get()&#123;</span><br><span class="line">	this.XSRFExpire = <span class="number">7200</span></span><br><span class="line">	this.Data[<span class="string">&quot;xsrfdata&quot;</span>]=template.HTML(this.XSRFFormHTML())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="支持controller-级别的屏蔽"><a href="#支持controller-级别的屏蔽" class="headerlink" title="支持controller 级别的屏蔽"></a>支持controller 级别的屏蔽</h3><p>XSRF 之前是全局设置的一个参数,如果设置了那么所有的 API 请求都会进行验证,但是有些时候API 逻辑是不需要进行验证的,因此现在支持在controller 级别设置屏蔽:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AdminController <span class="keyword">struct</span>&#123;</span><br><span class="line">	web.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AdminController)</span></span> Prepare() &#123;</span><br><span class="line">	a.EnableXSRF = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请求数据处理"><a href="#请求数据处理" class="headerlink" title="请求数据处理"></a>请求数据处理</h2><h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><p>我们经常需要获取用户传递的数据，包括 Get、POST 等方式的请求，beego 里面会自动解析这些数据，你可以通过如下方式获取数据：</p>
<ul>
<li>GetString(key string) string</li>
<li>GetStrings(key string) []string</li>
<li>GetInt(key string) (int64, error)</li>
<li>GetBool(key string) (bool, error)</li>
<li>GetFloat(key string) (float64, error)</li>
</ul>
<p>使用例子如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MainController)</span></span> Post() &#123;</span><br><span class="line">	jsoninfo := this.GetString(<span class="string">&quot;jsoninfo&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> jsoninfo == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		this.Ctx.WriteString(<span class="string">&quot;jsoninfo is empty&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你需要的数据可能是其他类型的，例如是 int 类型而不是 int64，那么你需要这样处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MainController)</span></span> Post() &#123;</span><br><span class="line">	id := this.Input().Get(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">	intid, err := strconv.Atoi(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多其他的 request 的信息，用户可以通过 <code>this.Ctx.Request</code> 获取信息。</p>
<h3 id="直接解析到-struct"><a href="#直接解析到-struct" class="headerlink" title="直接解析到 struct"></a>直接解析到 struct</h3><p>如果要把表单里的内容赋值到一个 struct 里，除了用上面的方法一个一个获取再赋值外，beego 提供了通过另外一个更便捷的方式，就是通过 struct 的字段名或 tag 与表单字段对应直接解析到 struct。</p>
<p>定义 struct：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="type">int</span>         <span class="string">`form:&quot;-&quot;`</span></span><br><span class="line">	Name  <span class="keyword">interface</span>&#123;&#125; <span class="string">`form:&quot;username&quot;`</span></span><br><span class="line">	Age   <span class="type">int</span>         <span class="string">`form:&quot;age&quot;`</span></span><br><span class="line">	Email <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">	名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">	年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">	邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;Email&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Controller 里解析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MainController)</span></span> Post() &#123;</span><br><span class="line">	u := user&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err := this.ParseForm(&amp;u); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//handle error</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>StructTag form 的定义和 <a href="https://git-books.github.io/books/beego/view/view.md">renderform方法</a> 共用一个标签</li>
<li>定义 struct 时，字段名后如果有 form 这个 tag，则会以把 form 表单里的 name 和 tag 的名称一样的字段赋值给这个字段，否则就会把 form 表单里与字段名一样的表单内容赋值给这个字段。如上面例子中，会把表单中的 username 和 age 分别赋值给 user 里的 Name 和 Age 字段，而 Email 里的内容则会赋给 Email 这个字段。</li>
<li>调用 Controller ParseForm 这个方法的时候，传入的参数必须为一个 struct 的指针，否则对 struct 的赋值不会成功并返回 <code>xx must be a struct pointer</code> 的错误。</li>
<li>如果要忽略一个字段，有两种办法，一是：字段名小写开头，二是：<code>form</code> 标签的值设置为 <code>-</code></li>
</ul>
<h3 id="获取-Request-Body-里的内容"><a href="#获取-Request-Body-里的内容" class="headerlink" title="获取 Request Body 里的内容"></a>获取 Request Body 里的内容</h3><p>在 API 的开发中，我们经常会用到 <code>JSON</code> 或 <code>XML</code> 来作为数据交互的格式，如何在 beego 中获取 Request Body 里的 JSON 或 XML 的数据呢？</p>
<ol>
<li>在配置文件里设置 <code>copyrequestbody = true</code></li>
<li>在 Controller 中</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ObjectController)</span></span> Post() &#123;</span><br><span class="line">	<span class="keyword">var</span> ob models.Object</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> err = json.Unmarshal(this.Ctx.Input.RequestBody, &amp;ob); err == <span class="literal">nil</span> &#123;</span><br><span class="line">	    objectid := models.AddOne(ob)</span><br><span class="line">	    this.Data[<span class="string">&quot;json&quot;</span>] = <span class="string">&quot;&#123;\&quot;ObjectId\&quot;:\&quot;&quot;</span> + objectid + <span class="string">&quot;\&quot;&#125;&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    this.Data[<span class="string">&quot;json&quot;</span>] = err.Error()</span><br><span class="line">	&#125;</span><br><span class="line">	this.ServeJSON()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>在 beego 中你可以很容易的处理文件上传，就是别忘记在你的 form 表单中增加这个属性 <code>enctype=&quot;multipart/form-data&quot;</code>，否则你的浏览器不会传输你的上传文件。</p>
<p>文件上传之后一般是放在系统的内存里面，如果文件的 size 大于设置的缓存内存大小，那么就放在临时文件中，默认的缓存内存是 64M，你可以通过如下来调整这个缓存内存大小:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.MaxMemory = <span class="number">1</span>&lt;&lt;<span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>或者在配置文件中通过如下设置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">maxmemory = <span class="number">1</span>&lt;&lt;<span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>与此同时，beego 提供了另外一个参数，<code>MaxUploadSize</code>来限制最大上传文件大小——如果你一次长传多个文件，那么它限制的就是这些所有文件合并在一起的大小。</p>
<p>默认情况下，<code>MaxMemory</code>应该设置得比<code>MaxUploadSize</code>小，这种情况下两个参数合并在一起的效果则是：</p>
<ol>
<li>如果文件大小小于<code>MaxMemory</code>，则直接在内存中处理；</li>
<li>如果文件大小介于<code>MaxMemory</code>和<code>MaxUploadSize</code>之间，那么比<code>MaxMemory</code>大的部分将会放在临时目录；</li>
<li>文件大小超出<code>MaxUploadSize</code>，直接拒绝请求，返回响应码 413</li>
</ol>
<p>Beego 提供了两个很方便的方法来处理文件上传：</p>
<ul>
<li><p>GetFile(key string) (multipart.File, *multipart.FileHeader, error)</p>
<p>该方法主要用于用户读取表单中的文件名 <code>the_file</code>，然后返回相应的信息，用户根据这些变量来处理文件上传：过滤、保存文件等。</p>
</li>
<li><p>SaveToFile(fromfile, tofile string) error</p>
<p>该方法是在 GetFile 的基础上实现了快速保存的功能<br>fromfile 是提交时候的 html 表单中的 name</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadname&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>保存的代码例子如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *FormController)</span></span> Post() &#123;</span><br><span class="line">	f, h, err := c.GetFile(<span class="string">&quot;uploadname&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;getfile err &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	c.SaveToFile(<span class="string">&quot;uploadname&quot;</span>, <span class="string">&quot;static/upload/&quot;</span> + h.Filename) <span class="comment">// 保存位置在 static/upload, 没有文件夹要先创建</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>支持从用户请求中直接数据 bind 到指定的对象,例如请求地址如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">123</span>&amp;isok=<span class="literal">true</span>&amp;ft=<span class="number">1.2</span>&amp;ol[<span class="number">0</span>]=<span class="number">1</span>&amp;ol[<span class="number">1</span>]=<span class="number">2</span>&amp;ul[]=str&amp;ul[]=array&amp;user.Name=astaxie</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id <span class="type">int</span></span><br><span class="line">this.Ctx.Input.Bind(&amp;id, <span class="string">&quot;id&quot;</span>)  <span class="comment">//id ==123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isok <span class="type">bool</span></span><br><span class="line">this.Ctx.Input.Bind(&amp;isok, <span class="string">&quot;isok&quot;</span>)  <span class="comment">//isok ==true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ft <span class="type">float64</span></span><br><span class="line">this.Ctx.Input.Bind(&amp;ft, <span class="string">&quot;ft&quot;</span>)  <span class="comment">//ft ==1.2</span></span><br><span class="line"></span><br><span class="line">ol := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">this.Ctx.Input.Bind(&amp;ol, <span class="string">&quot;ol&quot;</span>)  <span class="comment">//ol ==[1 2]</span></span><br><span class="line"></span><br><span class="line">ul := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">this.Ctx.Input.Bind(&amp;ul, <span class="string">&quot;ul&quot;</span>)  <span class="comment">//ul ==[str array]</span></span><br><span class="line"></span><br><span class="line">user <span class="keyword">struct</span>&#123;Name&#125;</span><br><span class="line">this.Ctx.Input.Bind(&amp;user, <span class="string">&quot;user&quot;</span>)  <span class="comment">//user ==&#123;Name:&quot;astaxie&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="session-控制"><a href="#session-控制" class="headerlink" title="session 控制"></a>session 控制</h2><p>beego 内置了 session 模块，使用 session 相当方便，只要在 main 入口函数中设置如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.BConfig.WebConfig.Session.SessionOn = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>或者通过配置文件配置如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sessionon = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>通过这种方式就可以开启 session，如何使用 session，请看下面的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MainController)</span></span> Get() &#123;</span><br><span class="line">	v := this.GetSession(<span class="string">&quot;asta&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">		this.SetSession(<span class="string">&quot;asta&quot;</span>, <span class="type">int</span>(<span class="number">1</span>))</span><br><span class="line">		this.Data[<span class="string">&quot;num&quot;</span>] = <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		this.SetSession(<span class="string">&quot;asta&quot;</span>, v.(<span class="type">int</span>)+<span class="number">1</span>)</span><br><span class="line">		this.Data[<span class="string">&quot;num&quot;</span>] = v.(<span class="type">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	this.TplName = <span class="string">&quot;index.tpl&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>session 有几个方便的方法：</p>
<ul>
<li>SetSession(name string, value interface{})</li>
<li>GetSession(name string) interface{}</li>
<li>DelSession(name string)</li>
<li>SessionRegenerateID()</li>
<li>DestroySession()</li>
</ul>
<p>session 操作主要有设置 session、获取 session、删除 session。</p>
<p>当然你可以通过下面的方式自己控制这些逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sess:=this.StartSession()</span><br><span class="line"><span class="keyword">defer</span> sess.SessionRelease()</span><br></pre></td></tr></table></figure>

<p>sess 对象具有如下方法：</p>
<ul>
<li>sess.Set()</li>
<li>sess.Get()</li>
<li>sess.Delete()</li>
<li>sess.SessionID()</li>
<li>sess.Flush()</li>
</ul>
<p>但是我还是建议大家采用 SetSession、GetSession、DelSession 三个方法来操作，避免自己在操作的过程中资源没释放的问题。</p>
<p>关于 Session 模块使用中的一些参数设置：</p>
<ul>
<li><p>web.BConfig.WebConfig.Session.SessionOn</p>
<p>设置是否开启 Session，默认是 false，配置文件对应的参数名：sessionon。</p>
</li>
<li><p>web.BConfig.WebConfig.Session.SessionName</p>
<p>设置 cookies 的名字，Session 默认是保存在用户的浏览器 cookies 里面的，默认名是 beegosessionID，配置文件对应的参数名是：sessionname。</p>
</li>
<li><p>web.BConfig.WebConfig.Session.SessionGCMaxLifetime</p>
<p>设置 Session 过期的时间，默认值是 3600 秒，配置文件对应的参数：sessiongcmaxlifetime。</p>
</li>
<li><p>web.BConfig.WebConfig.Session.SessionHashFunc</p>
<p>默认值为 sha1，采用 sha1 加密算法生产 sessionid</p>
</li>
<li><p>web.BConfig.WebConfig.Session.SessionCookieLifeTime</p>
<p>设置 cookie 的过期时间，cookie 是用来存储保存在客户端的数据。</p>
</li>
</ul>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>beego 支持自定义过滤中间件，例如安全验证，强制跳转等。</p>
<p>过滤器函数如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.InsertFilter(pattern <span class="type">string</span>, pos <span class="type">int</span>, filter FilterFunc, opts ...FilterOpt)</span><br></pre></td></tr></table></figure>

<p>InsertFilter 函数的三个必填参数，一个可选参数</p>
<ul>
<li>pattern 路由规则，可以根据一定的规则进行路由，如果你全匹配可以用 <code>*</code></li>
<li>position 执行 Filter 的地方，五个固定参数如下，分别表示不同的执行过程<ul>
<li>BeforeStatic 静态地址之前<ul>
<li>BeforeRouter 寻找路由之前</li>
<li>BeforeExec 找到路由之后，开始执行相应的 Controller 之前</li>
<li>AfterExec 执行完 Controller 逻辑之后执行的过滤器</li>
<li>FinishRouter 执行完逻辑之后执行的过滤器</li>
</ul>
</li>
</ul>
</li>
<li>filter filter 函数 type FilterFunc func(*context.Context)</li>
<li>opts</li>
</ul>
<p>如下例子所示，验证用户是否已经登录，应用于全部的请求：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> FilterUser = <span class="function"><span class="keyword">func</span><span class="params">(ctx *context.Context)</span></span> &#123;</span><br><span class="line">    _, ok := ctx.Input.Session(<span class="string">&quot;uid&quot;</span>).(<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; ctx.Request.RequestURI != <span class="string">&quot;/login&quot;</span> &#123;</span><br><span class="line">        ctx.Redirect(<span class="number">302</span>, <span class="string">&quot;/login&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">web.InsertFilter(<span class="string">&quot;/*&quot;</span>, web.BeforeRouter, FilterUser)</span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<blockquote>
<p>这里需要特别注意使用 session 的 Filter 必须在 BeforeStatic 之后才能获取，因为 session 没有在这之前初始化。</p>
</blockquote>
</blockquote>
</blockquote>
<p>还可以通过正则路由进行过滤，如果匹配参数就执行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> FilterUser = <span class="function"><span class="keyword">func</span><span class="params">(ctx *context.Context)</span></span> &#123;</span><br><span class="line">    _, ok := ctx.Input.Session(<span class="string">&quot;uid&quot;</span>).(<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        ctx.Redirect(<span class="number">302</span>, <span class="string">&quot;/login&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">web.InsertFilter(<span class="string">&quot;/user/:id([0-9]+)&quot;</span>, web.BeforeRouter, FilterUser)</span><br></pre></td></tr></table></figure>

<h2 id="flash-数据"><a href="#flash-数据" class="headerlink" title="flash 数据"></a>flash 数据</h2><p>这个 flash 与 Adobe&#x2F;Macromedia Flash 没有任何关系。它主要用于在两个逻辑间传递临时数据，flash 中存放的所有数据会在紧接着的下一个逻辑中调用后清除。一般用于传递提示和错误消息。它适合 <a href="http://en.wikipedia.org/wiki/Post/Redirect/Get">Post&#x2F;Redirect&#x2F;Get</a> 模式。下面看使用的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示设置信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MainController)</span></span> Get() &#123;</span><br><span class="line">	flash:=web.ReadFromRequest(&amp;c.Controller)</span><br><span class="line">	<span class="keyword">if</span> n,ok:=flash.Data[<span class="string">&quot;notice&quot;</span>];ok&#123;</span><br><span class="line">		<span class="comment">// 显示设置成功</span></span><br><span class="line">		c.TplName = <span class="string">&quot;set_success.html&quot;</span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> n,ok=flash.Data[<span class="string">&quot;error&quot;</span>];ok&#123;</span><br><span class="line">		<span class="comment">// 显示错误</span></span><br><span class="line">		c.TplName = <span class="string">&quot;set_error.html&quot;</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 不然默认显示设置页面</span></span><br><span class="line">		c.Data[<span class="string">&quot;list&quot;</span>]=GetInfo()</span><br><span class="line">		c.TplName = <span class="string">&quot;setting_list.html&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理设置信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MainController)</span></span> Post() &#123;</span><br><span class="line">	flash:=web.NewFlash()</span><br><span class="line">	setting:=Settings&#123;&#125;</span><br><span class="line">	valid := Validation&#123;&#125;</span><br><span class="line">	c.ParseForm(&amp;setting)</span><br><span class="line">	<span class="keyword">if</span> b, err := valid.Valid(setting);err!=<span class="literal">nil</span> &#123;</span><br><span class="line">		flash.Error(<span class="string">&quot;Settings invalid!&quot;</span>)</span><br><span class="line">		flash.Store(&amp;c.Controller)</span><br><span class="line">		c.Redirect(<span class="string">&quot;/setting&quot;</span>,<span class="number">302</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> b!=<span class="literal">nil</span>&#123;</span><br><span class="line">		flash.Error(<span class="string">&quot;validation err!&quot;</span>)</span><br><span class="line">		flash.Store(&amp;c.Controller)</span><br><span class="line">		c.Redirect(<span class="string">&quot;/setting&quot;</span>,<span class="number">302</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	saveSetting(setting)</span><br><span class="line">	flash.Notice(<span class="string">&quot;Settings saved!&quot;</span>)</span><br><span class="line">	flash.Store(&amp;c.Controller)</span><br><span class="line">	c.Redirect(<span class="string">&quot;/setting&quot;</span>,<span class="number">302</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码执行的大概逻辑是这样的：</p>
<ol>
<li>Get 方法执行，因为没有 flash 数据，所以显示设置页面。</li>
<li>用户设置信息之后点击递交，执行 Post，然后初始化一个 flash，通过验证，验证出错或者验证不通过设置 flash 的错误，如果通过了就保存设置，然后设置 flash 成功设置的信息。</li>
<li>设置完成后跳转到 Get 请求。</li>
<li>Get 请求获取到了 Flash 信息，然后执行相应的逻辑，如果出错显示出错的页面，如果成功显示成功的页面。</li>
</ol>
<p>默认情况下 <code>ReadFromRequest</code> 函数已经实现了读取的数据赋值给 flash，所以在你的模板里面你可以这样读取数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;&#123;.flash.<span class="type">error</span>&#125;&#125;</span><br><span class="line">&#123;&#123;.flash.warning&#125;&#125;</span><br><span class="line">&#123;&#123;.flash.notice&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>flash 对象有三个级别的设置：</p>
<ul>
<li>Notice 提示信息</li>
<li>Warning 警告信息</li>
<li>Error 错误信息</li>
</ul>
<h2 id="URL-构建"><a href="#URL-构建" class="headerlink" title="URL 构建"></a>URL 构建</h2><p>如果可以匹配 URL ，那么 beego 也可以生成 URL 吗？当然可以。 UrlFor() 函数就是用于构建指定函数的 URL 的。它把对应控制器和函数名结合的字符串作为第一个参数，其余参数对应 URL 中的变量。未知变量将添加到 URL 中作为查询参数。 例如：</p>
<p>下面定义了一个相应的控制器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TestController <span class="keyword">struct</span> &#123;</span><br><span class="line">	web.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TestController)</span></span> Get() &#123;</span><br><span class="line">	this.Data[<span class="string">&quot;Username&quot;</span>] = <span class="string">&quot;astaxie&quot;</span></span><br><span class="line">	this.Ctx.Output.Body([]<span class="type">byte</span>(<span class="string">&quot;ok&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TestController)</span></span> List() &#123;</span><br><span class="line">	this.Ctx.Output.Body([]<span class="type">byte</span>(<span class="string">&quot;i am list&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TestController)</span></span> Params() &#123;</span><br><span class="line">	this.Ctx.Output.Body([]<span class="type">byte</span>(this.Ctx.Input.Params()[<span class="string">&quot;0&quot;</span>] + this.Ctx.Input.Params()[<span class="string">&quot;1&quot;</span>] + this.Ctx.Input.Params()[<span class="string">&quot;2&quot;</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TestController)</span></span> Myext() &#123;</span><br><span class="line">	this.Ctx.Output.Body([]<span class="type">byte</span>(this.Ctx.Input.Param(<span class="string">&quot;:ext&quot;</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TestController)</span></span> GetUrl() &#123;</span><br><span class="line">	this.Ctx.Output.Body([]<span class="type">byte</span>(this.UrlFor(<span class="string">&quot;.Myext&quot;</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我们注册的路由：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.Router(<span class="string">&quot;/api/list&quot;</span>, &amp;TestController&#123;&#125;, <span class="string">&quot;*:List&quot;</span>)</span><br><span class="line">web.Router(<span class="string">&quot;/person/:last/:first&quot;</span>, &amp;TestController&#123;&#125;)</span><br><span class="line">web.AutoRouter(&amp;TestController&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>那么通过方式可以获取相应的URL地址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.URLFor(<span class="string">&quot;TestController.List&quot;</span>)</span><br><span class="line"><span class="comment">// 输出 /api/list</span></span><br><span class="line"></span><br><span class="line">web.URLFor(<span class="string">&quot;TestController.Get&quot;</span>, <span class="string">&quot;:last&quot;</span>, <span class="string">&quot;xie&quot;</span>, <span class="string">&quot;:first&quot;</span>, <span class="string">&quot;asta&quot;</span>)</span><br><span class="line"><span class="comment">// 输出 /person/xie/asta</span></span><br><span class="line"></span><br><span class="line">web.URLFor(<span class="string">&quot;TestController.Myext&quot;</span>)</span><br><span class="line"><span class="comment">// 输出 /Test/Myext</span></span><br><span class="line"></span><br><span class="line">web.URLFor(<span class="string">&quot;TestController.GetUrl&quot;</span>)</span><br><span class="line"><span class="comment">// 输出 /Test/GetUrl</span></span><br></pre></td></tr></table></figure>

<h3 id="模板中如何使用"><a href="#模板中如何使用" class="headerlink" title="模板中如何使用"></a>模板中如何使用</h3><p>默认情况下，beego 已经注册了 urlfor 函数，用户可以通过如下的代码进行调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;&#123;urlfor <span class="string">&quot;TestController.List&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不在把 URL 写死在模板中，反而要动态构建？有两个很好的理由：</p>
<ol>
<li>反向解析通常比硬编码 URL 更直观。同时，更重要的是你可以只在一个地方改变 URL ，而不用到处乱找。</li>
<li>URL 创建会为你处理特殊字符的转义和 Unicode 数据，不用你操心。</li>
</ol>
<h2 id="多种格式数据输出"><a href="#多种格式数据输出" class="headerlink" title="多种格式数据输出"></a>多种格式数据输出</h2><p>beego 当初设计的时候就考虑了 API 功能的设计，而我们在设计 API 的时候经常是输出 JSON 或者 XML 数据，那么 beego 提供了这样的方式直接输出：</p>
<p>注意 struct 属性应该 为 exported Identifier<br>首字母应该大写</p>
<ul>
<li><p>JSON 数据直接输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddController)</span></span> Get() &#123;</span><br><span class="line">	mystruct := &#123; ... &#125;</span><br><span class="line">	this.Data[<span class="string">&quot;json&quot;</span>] = &amp;mystruct</span><br><span class="line">	this.ServeJSON()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 ServeJSON 之后，会设置 <code>content-type</code> 为 <code>application/json</code>，然后同时把数据进行 JSON 序列化输出。</p>
</li>
<li><p>XML 数据直接输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddController)</span></span> Get() &#123;</span><br><span class="line">	mystruct := &#123; ... &#125;</span><br><span class="line">	this.Data[<span class="string">&quot;xml&quot;</span>]=&amp;mystruct</span><br><span class="line">	this.ServeXML()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 ServeXML 之后，会设置 <code>content-type</code> 为 <code>application/xml</code>，同时数据会进行 XML 序列化输出。</p>
</li>
<li><p>jsonp 调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddController)</span></span> Get() &#123;</span><br><span class="line">	mystruct := &#123; ... &#125;</span><br><span class="line">	this.Data[<span class="string">&quot;jsonp&quot;</span>] = &amp;mystruct</span><br><span class="line">	this.ServeJSONP()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 ServeJSONP 之后，会设置 <code>content-type</code> 为 <code>application/javascript</code>，然后同时把数据进行 JSON 序列化，然后根据请求的 callback 参数设置 jsonp 输出。</p>
</li>
</ul>
<p>开发模式下序列化后输出的是格式化易阅读的 JSON 或 XML 字符串；在生产模式下序列化后输出的是压缩的字符串。</p>
<h2 id="表单数据验证"><a href="#表单数据验证" class="headerlink" title="表单数据验证"></a>表单数据验证</h2><h3 id="安装及测试"><a href="#安装及测试" class="headerlink" title="安装及测试"></a>安装及测试</h3><p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get github.com/beego/beego/v2/core/validation</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go test github.com/beego/beego/v2/core/validation</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>直接使用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/beego/beego/v2/core/validation&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="string">&quot;man&quot;</span>, <span class="number">40</span>&#125;</span><br><span class="line">    valid := validation.Validation&#123;&#125;</span><br><span class="line">    valid.Required(u.Name, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">    valid.MaxSize(u.Name, <span class="number">15</span>, <span class="string">&quot;nameMax&quot;</span>)</span><br><span class="line">    valid.Range(u.Age, <span class="number">0</span>, <span class="number">18</span>, <span class="string">&quot;age&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> valid.HasErrors() &#123;</span><br><span class="line">        <span class="comment">// 如果有错误信息，证明验证没通过</span></span><br><span class="line">        <span class="comment">// 打印错误信息</span></span><br><span class="line">        <span class="keyword">for</span> _, err := <span class="keyword">range</span> valid.Errors &#123;</span><br><span class="line">            log.Println(err.Key, err.Message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// or use like this</span></span><br><span class="line">    <span class="keyword">if</span> v := valid.Max(u.Age, <span class="number">140</span>, <span class="string">&quot;age&quot;</span>); !v.Ok &#123;</span><br><span class="line">        log.Println(v.Error.Key, v.Error.Message)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定制错误信息</span></span><br><span class="line">    minAge := <span class="number">18</span></span><br><span class="line">    valid.Min(u.Age, minAge, <span class="string">&quot;age&quot;</span>).Message(<span class="string">&quot;少儿不宜！&quot;</span>)</span><br><span class="line">    <span class="comment">// 错误信息格式化</span></span><br><span class="line">    valid.Min(u.Age, minAge, <span class="string">&quot;age&quot;</span>).Message(<span class="string">&quot;%d不禁&quot;</span>, minAge)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 StructTag 使用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/beego/beego/v2/core/validation&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证函数写在 &quot;valid&quot; tag 的标签里</span></span><br><span class="line"><span class="comment">// 各个函数之间用分号 &quot;;&quot; 分隔，分号后面可以有空格</span></span><br><span class="line"><span class="comment">// 参数用括号 &quot;()&quot; 括起来，多个参数之间用逗号 &quot;,&quot; 分开，逗号后面可以有空格</span></span><br><span class="line"><span class="comment">// 正则函数(Match)的匹配模式用两斜杠 &quot;/&quot; 括起来</span></span><br><span class="line"><span class="comment">// 各个函数的结果的 key 值为字段名.验证函数名</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id     <span class="type">int</span></span><br><span class="line">    Name   <span class="type">string</span> <span class="string">`valid:&quot;Required;Match(/^Bee.*/)&quot;`</span> <span class="comment">// Name 不能为空并且以 Bee 开头</span></span><br><span class="line">    Age    <span class="type">int</span>    <span class="string">`valid:&quot;Range(1, 140)&quot;`</span> <span class="comment">// 1 &lt;= Age &lt;= 140，超出此范围即为不合法</span></span><br><span class="line">    Email  <span class="type">string</span> <span class="string">`valid:&quot;Email; MaxSize(100)&quot;`</span> <span class="comment">// Email 字段需要符合邮箱格式，并且最大长度不能大于 100 个字符</span></span><br><span class="line">    Mobile <span class="type">string</span> <span class="string">`valid:&quot;Mobile&quot;`</span> <span class="comment">// Mobile 必须为正确的手机号</span></span><br><span class="line">    IP     <span class="type">string</span> <span class="string">`valid:&quot;IP&quot;`</span> <span class="comment">// IP 必须为一个正确的 IPv4 地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你的 struct 实现了接口 validation.ValidFormer</span></span><br><span class="line"><span class="comment">// 当 StructTag 中的测试都成功时，将会执行 Valid 函数进行自定义验证</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> Valid(v *validation.Validation) &#123;</span><br><span class="line">    <span class="keyword">if</span> strings.Index(u.Name, <span class="string">&quot;admin&quot;</span>) != <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 SetError 设置 Name 的错误信息，HasErrors 将会返回 true</span></span><br><span class="line">        v.SetError(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;名称里不能含有 admin&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    valid := validation.Validation&#123;&#125;</span><br><span class="line">    u := user&#123;Name: <span class="string">&quot;Beego&quot;</span>, Age: <span class="number">2</span>, Email: <span class="string">&quot;dev@web.me&quot;</span>&#125;</span><br><span class="line">    b, err := valid.Valid(&amp;u)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !b &#123;</span><br><span class="line">        <span class="comment">// validation does not pass</span></span><br><span class="line">        <span class="comment">// blabla...</span></span><br><span class="line">        <span class="keyword">for</span> _, err := <span class="keyword">range</span> valid.Errors &#123;</span><br><span class="line">            log.Println(err.Key, err.Message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StructTag 可用的验证函数：</p>
<ul>
<li><code>Required</code> 不为空，即各个类型要求不为其零值</li>
<li><code>Min(min int)</code> 最小值，有效类型：<code>int</code>，其他类型都将不能通过验证</li>
<li><code>Max(max int)</code> 最大值，有效类型：<code>int</code>，其他类型都将不能通过验证</li>
<li><code>Range(min, max int)</code> 数值的范围，有效类型：<code>int</code>，他类型都将不能通过验证</li>
<li><code>MinSize(min int)</code> 最小长度，有效类型：<code>string slice</code>，其他类型都将不能通过验证</li>
<li><code>MaxSize(max int)</code> 最大长度，有效类型：<code>string slice</code>，其他类型都将不能通过验证</li>
<li><code>Length(length int)</code> 指定长度，有效类型：<code>string slice</code>，其他类型都将不能通过验证</li>
<li><code>Alpha</code> alpha字符，有效类型：<code>string</code>，其他类型都将不能通过验证</li>
<li><code>Numeric</code> 数字，有效类型：<code>string</code>，其他类型都将不能通过验证</li>
<li><code>AlphaNumeric</code> alpha 字符或数字，有效类型：<code>string</code>，其他类型都将不能通过验证</li>
<li><code>Match(pattern string)</code> 正则匹配，有效类型：<code>string</code>，其他类型都将被转成字符串再匹配(fmt.Sprintf(“%v”, obj).Match)</li>
<li><code>AlphaDash</code> alpha 字符或数字或横杠 <code>-_</code>，有效类型：<code>string</code>，其他类型都将不能通过验证</li>
<li><code>Email</code> 邮箱格式，有效类型：<code>string</code>，其他类型都将不能通过验证</li>
<li><code>IP</code> IP 格式，目前只支持 IPv4 格式验证，有效类型：<code>string</code>，其他类型都将不能通过验证</li>
<li><code>Base64</code> base64 编码，有效类型：<code>string</code>，其他类型都将不能通过验证</li>
<li><code>Mobile</code> 手机号，有效类型：<code>string</code>，其他类型都将不能通过验证</li>
<li><code>Tel</code> 固定电话号，有效类型：<code>string</code>，其他类型都将不能通过验证</li>
<li><code>Phone</code> 手机号或固定电话号，有效类型：<code>string</code>，其他类型都将不能通过验证</li>
<li><code>ZipCode</code> 邮政编码，有效类型：<code>string</code>，其他类型都将不能通过验证</li>
</ul>
<h3 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h3><p>我们允许自己注册验证逻辑。使用方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">AddCustomFunc(name <span class="type">string</span>, f CustomFunc) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>我们在做 Web 开发的时候，经常需要页面跳转和错误处理，beego 这方面也进行了考虑，通过 <code>Redirect</code> 方法来进行跳转：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddController)</span></span> Get() &#123;</span><br><span class="line">	this.Redirect(<span class="string">&quot;/&quot;</span>, <span class="number">302</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何中止此次请求并抛出异常，beego 可以在控制器中这样操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MainController)</span></span> Get() &#123;</span><br><span class="line">	this.Abort(<span class="string">&quot;401&quot;</span>)</span><br><span class="line">	v := this.GetSession(<span class="string">&quot;asta&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">		this.SetSession(<span class="string">&quot;asta&quot;</span>, <span class="type">int</span>(<span class="number">1</span>))</span><br><span class="line">		this.Data[<span class="string">&quot;Email&quot;</span>] = <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		this.SetSession(<span class="string">&quot;asta&quot;</span>, v.(<span class="type">int</span>)+<span class="number">1</span>)</span><br><span class="line">		this.Data[<span class="string">&quot;Email&quot;</span>] = v.(<span class="type">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	this.TplName = <span class="string">&quot;index.tpl&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样 <code>this.Abort(&quot;401&quot;)</code> 之后的代码不会再执行，而且会默认显示给用户如下页面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/401.png"></p>
<p>web 框架默认支持 401、403、404、500、503 这几种错误的处理。用户可以自定义相应的错误处理，例如下面重新定义 404 页面：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">page_not_found</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">	t,_:= template.New(<span class="string">&quot;404.html&quot;</span>).ParseFiles(web.BConfig.WebConfig.ViewsPath+<span class="string">&quot;/404.html&quot;</span>)</span><br><span class="line">	data :=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	data[<span class="string">&quot;content&quot;</span>] = <span class="string">&quot;page not found&quot;</span></span><br><span class="line">	t.Execute(rw, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	web.ErrorHandler(<span class="string">&quot;404&quot;</span>,page_not_found)</span><br><span class="line">	web.Router(<span class="string">&quot;/&quot;</span>, &amp;controllers.MainController&#123;&#125;)</span><br><span class="line">	web.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过自定义错误页面 <code>404.html</code> 来处理 404 错误。</p>
<p>beego 更加人性化的还有一个设计就是支持用户自定义字符串错误类型处理函数，例如下面的代码，用户注册了一个数据库出错的处理页面：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dbError</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">	t,_:= template.New(<span class="string">&quot;dberror.html&quot;</span>).ParseFiles(web.BConfig.WebConfig.ViewsPath+<span class="string">&quot;/dberror.html&quot;</span>)</span><br><span class="line">	data :=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	data[<span class="string">&quot;content&quot;</span>] = <span class="string">&quot;database is now down&quot;</span></span><br><span class="line">	t.Execute(rw, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	web.ErrorHandler(<span class="string">&quot;dbError&quot;</span>,dbError)</span><br><span class="line">	web.Router(<span class="string">&quot;/&quot;</span>, &amp;controllers.MainController&#123;&#125;)</span><br><span class="line">	web.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦在入口注册该错误处理代码，那么你可以在任何你的逻辑中遇到数据库错误调用 <code>this.Abort(&quot;dbError&quot;)</code> 来进行异常页面处理。</p>
<h3 id="Controller-定义-Error"><a href="#Controller-定义-Error" class="headerlink" title="Controller 定义 Error"></a>Controller 定义 Error</h3><p>从 1.4.3 版本开始，支持 Controller 方式定义 Error 错误处理函数，这样就可以充分利用系统自带的模板处理，以及 context 等方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ErrorController <span class="keyword">struct</span> &#123;</span><br><span class="line">	web.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ErrorController)</span></span> Error404() &#123;</span><br><span class="line">	c.Data[<span class="string">&quot;content&quot;</span>] = <span class="string">&quot;page not found&quot;</span></span><br><span class="line">	c.TplName = <span class="string">&quot;404.tpl&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ErrorController)</span></span> Error501() &#123;</span><br><span class="line">	c.Data[<span class="string">&quot;content&quot;</span>] = <span class="string">&quot;server error&quot;</span></span><br><span class="line">	c.TplName = <span class="string">&quot;501.tpl&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ErrorController)</span></span> ErrorDb() &#123;</span><br><span class="line">	c.Data[<span class="string">&quot;content&quot;</span>] = <span class="string">&quot;database is now down&quot;</span></span><br><span class="line">	c.TplName = <span class="string">&quot;dberror.tpl&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的例子我们可以看到，所有的函数都是有一定规律的，都是 <code>Error</code> 开头，后面的名字就是我们调用 <code>Abort</code> 的名字，例如 <code>Error404</code> 函数其实调用对应的就是 <code>Abort(&quot;404&quot;)</code></p>
<p>我们就只要在 <code>web.Run</code> 之前采用 <code>web.ErrorController</code> 注册这个错误处理函数就可以了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;btest/routers&quot;</span></span><br><span class="line">	<span class="string">&quot;btest/controllers&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	web.ErrorController(&amp;controllers.ErrorController&#123;&#125;)</span><br><span class="line">	web.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="model设计"><a href="#model设计" class="headerlink" title="model设计"></a>model设计</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>beego ORM 是一个强大的 Go 语言 ORM 框架。她的灵感主要来自 Django ORM 和 SQLAlchemy。</p>
<p>目前该框架仍处于开发阶段，可能发生任何导致不兼容的改动。</p>
<p><strong>已支持数据库驱动：</strong></p>
<ul>
<li>MySQL：<a href="https://github.com/go-sql-driver/mysql">github.com&#x2F;go-sql-driver&#x2F;mysql</a></li>
<li>PostgreSQL：<a href="https://github.com/lib/pq">github.com&#x2F;lib&#x2F;pq</a></li>
<li>Sqlite3：<a href="https://github.com/mattn/go-sqlite3">github.com&#x2F;mattn&#x2F;go-sqlite3</a></li>
</ul>
<p><strong>ORM 特性：</strong></p>
<ul>
<li>支持 Go 的所有类型存储</li>
<li>轻松上手，采用简单的 CRUD 风格</li>
<li>自动 Join 关联表</li>
<li>跨数据库兼容查询</li>
<li>允许直接使用 SQL 查询／映射</li>
<li>严格完整的测试保证 ORM 的稳定与健壮</li>
</ul>
<p><strong>安装 ORM：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get github.com/beego/beego/v2/client/orm</span><br></pre></td></tr></table></figure>

<h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/beego/beego/v2/client/orm&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span> <span class="comment">// import your used driver</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Model Struct</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span> <span class="string">`orm:&quot;size(100)&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// set default database</span></span><br><span class="line">	orm.RegisterDataBase(<span class="string">&quot;default&quot;</span>, <span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;username:password@tcp(127.0.0.1:3306)/db_name?charset=utf8&amp;loc=Local&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// register model</span></span><br><span class="line">	orm.RegisterModel(<span class="built_in">new</span>(User))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create table</span></span><br><span class="line">	orm.RunSyncdb(<span class="string">&quot;default&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	o := orm.NewOrm()</span><br><span class="line"></span><br><span class="line">	user := User&#123;Name: <span class="string">&quot;slene&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert</span></span><br><span class="line">	id, err := o.Insert(&amp;user)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ID: %d, ERR: %v\n&quot;</span>, id, err)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// update</span></span><br><span class="line">	user.Name = <span class="string">&quot;astaxie&quot;</span></span><br><span class="line">	num, err := o.Update(&amp;user)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;NUM: %d, ERR: %v\n&quot;</span>, num, err)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read one</span></span><br><span class="line">	u := User&#123;Id: user.Id&#125;</span><br><span class="line">	err = o.Read(&amp;u)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ERR: %v\n&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// delete</span></span><br><span class="line">	num, err = o.Delete(&amp;u)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;NUM: %d, ERR: %v\n&quot;</span>, num, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="type">int</span>    <span class="string">`orm:&quot;auto&quot;`</span></span><br><span class="line">	Title <span class="type">string</span> <span class="string">`orm:&quot;size(100)&quot;`</span></span><br><span class="line">	User  *User  <span class="string">`orm:&quot;rel(fk)&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> posts []*Post</span><br><span class="line">qs := o.QueryTable(<span class="string">&quot;post&quot;</span>)</span><br><span class="line">num, err := qs.Filter(<span class="string">&quot;User__Name&quot;</span>, <span class="string">&quot;slene&quot;</span>).All(&amp;posts)</span><br></pre></td></tr></table></figure>

<h3 id="SQL-查询"><a href="#SQL-查询" class="headerlink" title="SQL 查询"></a>SQL 查询</h3><p>当您无法使用 ORM 来达到您的需求时，也可以直接使用 SQL 来完成查询／映射操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maps []orm.Params</span><br><span class="line">num, err := o.Raw(<span class="string">&quot;SELECT * FROM user&quot;</span>).Values(&amp;maps)</span><br><span class="line"><span class="keyword">for</span> _,term := <span class="keyword">range</span> maps&#123;</span><br><span class="line">	fmt.Println(term[<span class="string">&quot;id&quot;</span>],<span class="string">&quot;:&quot;</span>,term[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ORM使用"><a href="#ORM使用" class="headerlink" title="ORM使用"></a>ORM使用</h2><p>我们建议在使用过程中，一个数据库应该只存在一个<code>ORM</code>对象。</p>
<p><code>models.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/beego/beego/v2/client/orm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id          <span class="type">int</span></span><br><span class="line">	Name        <span class="type">string</span></span><br><span class="line">	Profile     *Profile   <span class="string">`orm:&quot;rel(one)&quot;`</span> <span class="comment">// OneToOne relation</span></span><br><span class="line">	Post    	[]*Post <span class="string">`orm:&quot;reverse(many)&quot;`</span> <span class="comment">// 设置一对多的反向关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id          <span class="type">int</span></span><br><span class="line">	Age         <span class="type">int16</span></span><br><span class="line">	User        *User   <span class="string">`orm:&quot;reverse(one)&quot;`</span> <span class="comment">// 设置一对一反向关系(可选)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id    <span class="type">int</span></span><br><span class="line">    Title <span class="type">string</span></span><br><span class="line">    User  *User  <span class="string">`orm:&quot;rel(fk)&quot;`</span>	<span class="comment">//设置一对多关系</span></span><br><span class="line">    Tags  []*Tag <span class="string">`orm:&quot;rel(m2m)&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tag <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id    <span class="type">int</span></span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Posts []*Post <span class="string">`orm:&quot;reverse(many)&quot;`</span> <span class="comment">//设置多对多反向关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 需要在init中注册定义的model</span></span><br><span class="line">	orm.RegisterModel(<span class="built_in">new</span>(User), <span class="built_in">new</span>(Post), <span class="built_in">new</span>(Profile), <span class="built_in">new</span>(Tag))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/beego/beego/v2/client/orm&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	orm.RegisterDriver(<span class="string">&quot;mysql&quot;</span>, orm.DRMySQL)</span><br><span class="line"></span><br><span class="line">	orm.RegisterDataBase(<span class="string">&quot;default&quot;</span>, <span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:root@/orm_test?charset=utf8&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用 default，你可以指定为其他数据库</span></span><br><span class="line">	o := orm.NewOrm()</span><br><span class="line"></span><br><span class="line">	profile := <span class="built_in">new</span>(Profile)</span><br><span class="line">	profile.Age = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">	user := <span class="built_in">new</span>(User)</span><br><span class="line">	user.Profile = profile</span><br><span class="line">	user.Name = <span class="string">&quot;slene&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(o.Insert(profile))</span><br><span class="line">	fmt.Println(o.Insert(user))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RegisterDriver"><a href="#RegisterDriver" class="headerlink" title="RegisterDriver"></a>RegisterDriver</h3><p>默认数据库类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">orm.DRMySQL</span><br><span class="line">orm.DRSqlite</span><br><span class="line">orm.DRPostgres</span><br><span class="line">orm.DRTiDB</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt; 1.6</span></span><br><span class="line">orm.DR_MySQL</span><br><span class="line">orm.DR_Sqlite</span><br><span class="line">orm.DR_Postgres</span><br><span class="line"><span class="comment">// 参数1   driverName</span></span><br><span class="line"><span class="comment">// 参数2   数据库类型</span></span><br><span class="line"><span class="comment">// 这个用来设置 driverName 对应的数据库类型</span></span><br><span class="line"><span class="comment">// mysql / sqlite3 / postgres / tidb 这几种是默认已经注册过的，所以可以无需设置</span></span><br><span class="line">orm.RegisterDriver(<span class="string">&quot;mysql&quot;</span>, orm.DRMySQL)</span><br></pre></td></tr></table></figure>

<h3 id="RegisterDataBase"><a href="#RegisterDataBase" class="headerlink" title="RegisterDataBase"></a>RegisterDataBase</h3><p>ORM 必须注册一个别名为 <code>default</code> 的数据库，作为默认使用。</p>
<p>ORM 使用 golang 自己的连接池</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1        数据库的别名，用来在 ORM 中切换数据库使用</span></span><br><span class="line"><span class="comment">// 参数2        driverName</span></span><br><span class="line"><span class="comment">// 参数3        对应的链接字符串</span></span><br><span class="line">orm.RegisterDataBase(<span class="string">&quot;default&quot;</span>, <span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:root@/orm_test?charset=utf8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数4(可选)  设置最大空闲连接</span></span><br><span class="line"><span class="comment">// 参数5(可选)  设置最大数据库连接 (go &gt;= 1.2)</span></span><br><span class="line">maxIdle := <span class="number">30</span></span><br><span class="line">maxConn := <span class="number">30</span></span><br><span class="line">orm.RegisterDataBase(<span class="string">&quot;default&quot;</span>, <span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:root@/orm_test?charset=utf8&quot;</span>, orm.MaxIdleConnections(maxIdle), orm.MaxOpenConnections(maxConn))</span><br></pre></td></tr></table></figure>

<h3 id="RegisterModel"><a href="#RegisterModel" class="headerlink" title="RegisterModel"></a>RegisterModel</h3><p>将你定义的 Model 进行注册，最佳设计是有单独的 models.go 文件，在他的 init 函数中进行注册。</p>
<p>迷你版 models.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/beego/beego/v2/client/orm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	orm.RegisterModel(<span class="built_in">new</span>(User))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RegisterModel 也可以同时注册多个 model</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">orm.RegisterModel(<span class="built_in">new</span>(User), <span class="built_in">new</span>(Profile), <span class="built_in">new</span>(Post))</span><br></pre></td></tr></table></figure>

<h3 id="RegisterModelWithPrefix"><a href="#RegisterModelWithPrefix" class="headerlink" title="RegisterModelWithPrefix"></a>RegisterModelWithPrefix</h3><p>使用表名前缀</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">orm.RegisterModelWithPrefix(<span class="string">&quot;prefix_&quot;</span>, <span class="built_in">new</span>(User))</span><br></pre></td></tr></table></figure>

<p>创建后的表名为 prefix_user</p>
<h3 id="QueryTable"><a href="#QueryTable" class="headerlink" title="QueryTable"></a>QueryTable</h3><p>传入表名，或者 Model 对象，返回一个 <a href="https://git-books.github.io/books/beego/query.md">QuerySeter</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line"><span class="keyword">var</span> qs orm.QuerySeter</span><br><span class="line">qs = o.QueryTable(<span class="string">&quot;user&quot;</span>)</span><br><span class="line"><span class="comment">// 如果表没有定义过，会立刻 panic</span></span><br></pre></td></tr></table></figure>

<h3 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h3><p>使用 sql 语句直接进行操作</p>
<p>Raw 函数，返回一个 <a href="https://git-books.github.io/books/beego/rawsql.md">RawSeter</a> 用以对设置的 sql 语句和参数进行操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line"><span class="keyword">var</span> r orm.RawSeter</span><br><span class="line">r = o.Raw(<span class="string">&quot;UPDATE user SET name = ? WHERE name = ?&quot;</span>, <span class="string">&quot;testing&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h2><p>如果已知主键的值，那么可以使用这些方法进行 CRUD 操作</p>
<p>对 object 操作的四个方法 Read &#x2F; Insert &#x2F; Update &#x2F; Delete</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">user.Name = <span class="string">&quot;slene&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(o.Insert(user))</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;Your&quot;</span></span><br><span class="line">fmt.Println(o.Update(user))</span><br><span class="line">fmt.Println(o.Read(user))</span><br><span class="line">fmt.Println(o.Delete(user))</span><br></pre></td></tr></table></figure>

<h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line">user := User&#123;Id: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">err := o.Read(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == orm.ErrNoRows &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;查询不到&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == orm.ErrMissPK &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;找不到主键&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(user.Id, user.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Read 默认通过查询主键赋值，可以使用指定的字段进行查询：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;slene&quot;</span>&#125;</span><br><span class="line">err = o.Read(&amp;user, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="ReadOrCreate"><a href="#ReadOrCreate" class="headerlink" title="ReadOrCreate"></a>ReadOrCreate</h3><p>尝试从数据库读取，不存在的话就创建一个。</p>
<p>它的实现机制，和具体的数据库有关。例如在 MYSQL 中，是使用</p>
<p>默认必须传入一个参数作为条件字段，同时也支持多个参数多个条件字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line">user := User&#123;Name: <span class="string">&quot;slene&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 三个返回参数依次为：是否新创建的，对象 Id 值，错误</span></span><br><span class="line"><span class="keyword">if</span> created, id, err := o.ReadOrCreate(&amp;user, <span class="string">&quot;Name&quot;</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> created &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;New Insert an object. Id:&quot;</span>, id)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Get an object. Id:&quot;</span>, id)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>第一个返回值为自增健 Id 的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">user.Name = <span class="string">&quot;slene&quot;</span></span><br><span class="line">user.IsActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">id, err := o.Insert(&amp;user)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建后会自动对 auto 的 field 赋值</p>
<h3 id="InsertMulti"><a href="#InsertMulti" class="headerlink" title="InsertMulti"></a>InsertMulti</h3><p>同时插入多个对象</p>
<p>类似sql语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> (name, age) <span class="keyword">values</span>(&quot;slene&quot;, <span class="number">28</span>),(&quot;astaxie&quot;, <span class="number">30</span>),(&quot;unknown&quot;, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>第一个参数 bulk 为并列插入的数量，第二个为对象的slice</p>
<p>返回值为成功插入的数量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">users := []User&#123;</span><br><span class="line">	&#123;Name: <span class="string">&quot;slene&quot;</span>&#125;,</span><br><span class="line">	&#123;Name: <span class="string">&quot;astaxie&quot;</span>&#125;,</span><br><span class="line">	&#123;Name: <span class="string">&quot;unknown&quot;</span>&#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">successNums, err := o.InsertMulti(<span class="number">100</span>, users)</span><br></pre></td></tr></table></figure>

<p>bulk 为 1 时，将会顺序插入 slice 中的数据</p>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>第一个返回值为影响的行数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line">user := User&#123;Id: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">if</span> o.Read(&amp;user) == <span class="literal">nil</span> &#123;</span><br><span class="line">	user.Name = <span class="string">&quot;MyName&quot;</span></span><br><span class="line">	<span class="keyword">if</span> num, err := o.Update(&amp;user); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Update 默认更新所有的字段，可以更新指定的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只更新 Name</span></span><br><span class="line">o.Update(&amp;user, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line"><span class="comment">// 指定多个字段</span></span><br><span class="line"><span class="comment">// o.Update(&amp;user, &quot;Field1&quot;, &quot;Field2&quot;, ...)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>根据复杂条件更新字段值参见 <a href="https://git-books.github.io/books/beego/query.md#update">Update</a></p>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>第一个返回值为影响的行数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line"><span class="keyword">if</span> num, err := o.Delete(&amp;User&#123;Id: <span class="number">1</span>&#125;); err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Delete 操作会对反向关系进行操作，此例中 Post 拥有一个到 User 的外键。删除 User 的时候。如果 on_delete 设置为默认的级联操作，将删除对应的 Post</p>
<p><strong>Changed in 1.0.3</strong> 删除以后不会删除 auto field 的值</p>
<h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><p>ORM 以 <strong>QuerySeter</strong> 来组织查询，每个返回 <strong>QuerySeter</strong> 的方法都会获得一个新的 <strong>QuerySeter</strong> 对象。</p>
<p>基本使用方法:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 QuerySeter 对象，user 为表名</span></span><br><span class="line">qs := o.QueryTable(<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接使用 Model 结构体作为表名</span></span><br><span class="line">qs = o.QueryTable(&amp;User)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接使用对象作为表名</span></span><br><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">qs = o.QueryTable(user) <span class="comment">// 返回 QuerySeter</span></span><br></pre></td></tr></table></figure>

<h3 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h3><p>QuerySeter 中用于描述字段和 sql 操作符，使用简单的 expr 查询方法</p>
<p>字段组合的前后顺序依照表的关系，比如 User 表拥有 Profile 的外键，那么对 User 表查询对应的 Profile.Age 为条件，则使用 <code>Profile__Age</code> 注意，字段的分隔符号使用双下划线 <code>__</code>，除了描述字段， expr 的尾部可以增加操作符以执行对应的 sql 操作。比如 <code>Profile__Age__gt</code> 代表 Profile.Age &gt; 18 的条件查询。</p>
<p>注释后面将描述对应的 sql 语句，仅仅是描述 expr 的类似结果，并不代表实际生成的语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>) <span class="comment">// WHERE id = 1</span></span><br><span class="line">qs.Filter(<span class="string">&quot;profile__age&quot;</span>, <span class="number">18</span>) <span class="comment">// WHERE profile.age = 18</span></span><br><span class="line">qs.Filter(<span class="string">&quot;Profile__Age&quot;</span>, <span class="number">18</span>) <span class="comment">// 使用字段名和 Field 名都是允许的</span></span><br><span class="line">qs.Filter(<span class="string">&quot;profile__age__gt&quot;</span>, <span class="number">18</span>) <span class="comment">// WHERE profile.age &gt; 18</span></span><br><span class="line">qs.Filter(<span class="string">&quot;profile__age__gte&quot;</span>, <span class="number">18</span>) <span class="comment">// WHERE profile.age &gt;= 18</span></span><br><span class="line">qs.Filter(<span class="string">&quot;profile__age__in&quot;</span>, <span class="number">18</span>, <span class="number">20</span>) <span class="comment">// WHERE profile.age IN (18, 20)</span></span><br><span class="line"></span><br><span class="line">qs.Filter(<span class="string">&quot;profile__age__in&quot;</span>, <span class="number">18</span>, <span class="number">20</span>).Exclude(<span class="string">&quot;profile__lt&quot;</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// WHERE profile.age IN (18, 20) AND NOT profile_id &lt; 1000</span></span><br></pre></td></tr></table></figure>

<h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><p>当前支持的操作符号：</p>
<ul>
<li><a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#exact">exact</a> &#x2F; <a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#iexact">iexact</a> 等于</li>
<li><a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#contains">contains</a> &#x2F; <a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#icontains">icontains</a> 包含</li>
<li>[gt &#x2F; gte](#gt &#x2F; gte) 大于 &#x2F; 大于等于</li>
<li>[lt &#x2F; lte](#lt &#x2F; lte) 小于 &#x2F; 小于等于</li>
<li><a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#startswith">startswith</a> &#x2F; <a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#istartswith">istartswith</a> 以…起始</li>
<li><a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#endswith">endswith</a> &#x2F; <a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#iendswith">iendswith</a> 以…结束</li>
<li><a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#in">in</a></li>
<li><a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#isnull">isnull</a></li>
</ul>
<p>后面以 <code>i</code> 开头的表示：大小写不敏感</p>
<h3 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h3><p>Filter &#x2F; Exclude &#x2F; Condition expr 的默认值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;slene&quot;</span>) <span class="comment">// WHERE name = &#x27;slene&#x27;</span></span><br><span class="line">qs.Filter(<span class="string">&quot;name__exact&quot;</span>, <span class="string">&quot;slene&quot;</span>) <span class="comment">// WHERE name = &#x27;slene&#x27;</span></span><br><span class="line"><span class="comment">// 使用 = 匹配，大小写是否敏感取决于数据表使用的 collation</span></span><br><span class="line">qs.Filter(<span class="string">&quot;profile_id&quot;</span>, <span class="literal">nil</span>) <span class="comment">// WHERE profile_id IS NULL</span></span><br></pre></td></tr></table></figure>

<h3 id="iexact"><a href="#iexact" class="headerlink" title="iexact"></a>iexact</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__iexact&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br><span class="line"><span class="comment">// WHERE name LIKE &#x27;slene&#x27;</span></span><br><span class="line"><span class="comment">// 大小写不敏感，匹配任意 &#x27;Slene&#x27; &#x27;sLENE&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__contains&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br><span class="line"><span class="comment">// WHERE name LIKE BINARY &#x27;%slene%&#x27;</span></span><br><span class="line"><span class="comment">// 大小写敏感, 匹配包含 slene 的字符</span></span><br></pre></td></tr></table></figure>

<h3 id="icontains"><a href="#icontains" class="headerlink" title="icontains"></a>icontains</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__icontains&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br><span class="line"><span class="comment">// WHERE name LIKE &#x27;%slene%&#x27;</span></span><br><span class="line"><span class="comment">// 大小写不敏感, 匹配任意 &#x27;im Slene&#x27;, &#x27;im sLENE&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;age__in&quot;</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// WHERE age IN (17, 18, 19, 20)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ids:=[]<span class="type">int</span>&#123;<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>&#125;</span><br><span class="line">qs.Filter(<span class="string">&quot;age__in&quot;</span>, ids)</span><br><span class="line"><span class="comment">// WHERE age IN (17, 18, 19, 20)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上效果</span></span><br></pre></td></tr></table></figure>

<h3 id="gt-gte"><a href="#gt-gte" class="headerlink" title="gt &#x2F; gte"></a>gt &#x2F; gte</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;profile__age__gt&quot;</span>, <span class="number">17</span>)</span><br><span class="line"><span class="comment">// WHERE profile.age &gt; 17</span></span><br><span class="line"></span><br><span class="line">qs.Filter(<span class="string">&quot;profile__age__gte&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment">// WHERE profile.age &gt;= 18</span></span><br></pre></td></tr></table></figure>

<h3 id="lt-lte"><a href="#lt-lte" class="headerlink" title="lt &#x2F; lte"></a>lt &#x2F; lte</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;profile__age__lt&quot;</span>, <span class="number">17</span>)</span><br><span class="line"><span class="comment">// WHERE profile.age &lt; 17</span></span><br><span class="line"></span><br><span class="line">qs.Filter(<span class="string">&quot;profile__age__lte&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment">// WHERE profile.age &lt;= 18</span></span><br></pre></td></tr></table></figure>

<h3 id="startswith"><a href="#startswith" class="headerlink" title="startswith"></a>startswith</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__startswith&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br><span class="line"><span class="comment">// WHERE name LIKE BINARY &#x27;slene%&#x27;</span></span><br><span class="line"><span class="comment">// 大小写敏感, 匹配以 &#x27;slene&#x27; 起始的字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="istartswith"><a href="#istartswith" class="headerlink" title="istartswith"></a>istartswith</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__istartswith&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br><span class="line"><span class="comment">// WHERE name LIKE &#x27;slene%&#x27;</span></span><br><span class="line"><span class="comment">// 大小写不敏感, 匹配任意以 &#x27;slene&#x27;, &#x27;Slene&#x27; 起始的字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="endswith"><a href="#endswith" class="headerlink" title="endswith"></a>endswith</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__endswith&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br><span class="line"><span class="comment">// WHERE name LIKE BINARY &#x27;%slene&#x27;</span></span><br><span class="line"><span class="comment">// 大小写敏感, 匹配以 &#x27;slene&#x27; 结束的字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="iendswith"><a href="#iendswith" class="headerlink" title="iendswith"></a>iendswith</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;name__iendswithi&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br><span class="line"><span class="comment">// WHERE name LIKE &#x27;%slene&#x27;</span></span><br><span class="line"><span class="comment">// 大小写不敏感, 匹配任意以 &#x27;slene&#x27;, &#x27;Slene&#x27; 结束的字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="isnull"><a href="#isnull" class="headerlink" title="isnull"></a>isnull</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;profile__isnull&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">qs.Filter(<span class="string">&quot;profile_id__isnull&quot;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// WHERE profile_id IS NULL</span></span><br><span class="line"></span><br><span class="line">qs.Filter(<span class="string">&quot;profile__isnull&quot;</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// WHERE profile_id IS NOT NULL</span></span><br></pre></td></tr></table></figure>

<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>用来过滤查询结果，起到 <strong>包含条件</strong> 的作用</p>
<p>多个 Filter 之间使用 <code>AND</code> 连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Filter(<span class="string">&quot;profile__isnull&quot;</span>, <span class="literal">true</span>).Filter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br><span class="line"><span class="comment">// WHERE profile_id IS NULL AND name = &#x27;slene&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h3><p>用来过滤查询结果，起到 <strong>排除条件</strong> 的作用</p>
<p>使用 <code>NOT</code> 排除条件</p>
<p>多个 Exclude 之间使用 <code>AND</code> 连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Exclude(<span class="string">&quot;profile__isnull&quot;</span>, <span class="literal">true</span>).Filter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br><span class="line"><span class="comment">// WHERE NOT profile_id IS NULL AND name = &#x27;slene&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="SetCond"><a href="#SetCond" class="headerlink" title="SetCond"></a>SetCond</h3><p>自定义条件表达式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cond := orm.NewCondition()</span><br><span class="line">cond1 := cond.And(<span class="string">&quot;profile__isnull&quot;</span>, <span class="literal">false</span>).AndNot(<span class="string">&quot;status__in&quot;</span>, <span class="number">1</span>).Or(<span class="string">&quot;profile__age__gt&quot;</span>, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">qs := orm.QueryTable(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">qs = qs.SetCond(cond1)</span><br><span class="line"><span class="comment">// WHERE ... AND ... AND NOT ... OR ...</span></span><br><span class="line"></span><br><span class="line">cond2 := cond.AndCond(cond1).OrCond(cond.And(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;slene&quot;</span>))</span><br><span class="line">qs = qs.SetCond(cond2).Count()</span><br><span class="line"><span class="comment">// WHERE (... AND ... AND NOT ... OR ...) OR ( ... )</span></span><br></pre></td></tr></table></figure>

<h3 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h3><p>限制最大返回数据行数，第二个参数可以设置 <code>Offset</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultRowsLimit = <span class="number">1000</span> <span class="comment">// ORM 默认的 limit 值为 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下 select 查询的最大行数为 1000</span></span><br><span class="line"><span class="comment">// LIMIT 1000</span></span><br><span class="line"></span><br><span class="line">qs.Limit(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// LIMIT 10</span></span><br><span class="line"></span><br><span class="line">qs.Limit(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// LIMIT 10 OFFSET 20 注意跟 SQL 反过来的</span></span><br><span class="line"></span><br><span class="line">qs.Limit(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// no limit</span></span><br><span class="line"></span><br><span class="line">qs.Limit(<span class="number">-1</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment">// LIMIT 18446744073709551615 OFFSET 100</span></span><br><span class="line"><span class="comment">// 18446744073709551615 是 1&lt;&lt;64 - 1 用来指定无 limit 限制 但有 offset 偏移的情况</span></span><br></pre></td></tr></table></figure>

<h3 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h3><p>设置 偏移行数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Offset(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// LIMIT 1000 OFFSET 20</span></span><br></pre></td></tr></table></figure>

<h3 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.GroupBy(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;age&quot;</span>)</span><br><span class="line"><span class="comment">// GROUP BY id,age</span></span><br></pre></td></tr></table></figure>

<h3 id="OrderBy"><a href="#OrderBy" class="headerlink" title="OrderBy"></a>OrderBy</h3><p>参数使用 <strong>expr</strong></p>
<p>在 expr 前使用减号 <code>-</code> 表示 <code>DESC</code> 的排列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.OrderBy(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;-profile__age&quot;</span>)</span><br><span class="line"><span class="comment">// ORDER BY id ASC, profile.age DESC</span></span><br><span class="line"></span><br><span class="line">qs.OrderBy(<span class="string">&quot;-profile__age&quot;</span>, <span class="string">&quot;profile&quot;</span>)</span><br><span class="line"><span class="comment">// ORDER BY profile.age DESC, profile_id ASC</span></span><br></pre></td></tr></table></figure>

<h3 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h3><p>对应 sql 的 <code>distinct</code> 语句, 返回指定字段不重复的值.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">qs.Distinct()</span><br><span class="line"><span class="comment">// SELECT DISTINCT</span></span><br></pre></td></tr></table></figure>

<h3 id="RelatedSel"><a href="#RelatedSel" class="headerlink" title="RelatedSel"></a>RelatedSel</h3><p>关系查询，参数使用 <strong>expr</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultRelsDepth = <span class="number">5</span> <span class="comment">// 默认情况下直接调用 RelatedSel 将进行最大 5 层的关系查询</span></span><br><span class="line"></span><br><span class="line">qs := o.QueryTable(<span class="string">&quot;post&quot;</span>)</span><br><span class="line"></span><br><span class="line">qs.RelatedSel()</span><br><span class="line"><span class="comment">// INNER JOIN user ... LEFT OUTER JOIN profile ...</span></span><br><span class="line"></span><br><span class="line">qs.RelatedSel(<span class="string">&quot;user&quot;</span>)</span><br><span class="line"><span class="comment">// INNER JOIN user ...</span></span><br><span class="line"><span class="comment">// 设置 expr 只对设置的字段进行关系查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对设置 null 属性的 Field 将使用 LEFT OUTER JOIN</span></span><br></pre></td></tr></table></figure>

<h3 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h3><p>依据当前的查询条件，返回结果行数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cnt, err := o.QueryTable(<span class="string">&quot;user&quot;</span>).Count() <span class="comment">// SELECT COUNT(*) FROM USER</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Count Num: %s, %s&quot;</span>, cnt, err)</span><br></pre></td></tr></table></figure>

<h3 id="Exist"><a href="#Exist" class="headerlink" title="Exist"></a>Exist</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">exist := o.QueryTable(<span class="string">&quot;user&quot;</span>).Filter(<span class="string">&quot;UserName&quot;</span>, <span class="string">&quot;Name&quot;</span>).Exist()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Is Exist: %s&quot;</span>, exist)</span><br></pre></td></tr></table></figure>

<h3 id="Update-1"><a href="#Update-1" class="headerlink" title="Update"></a>Update</h3><p>依据当前查询条件，进行批量更新操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num, err := o.QueryTable(<span class="string">&quot;user&quot;</span>).Filter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;slene&quot;</span>).Update(orm.Params&#123;</span><br><span class="line">	<span class="string">&quot;name&quot;</span>: <span class="string">&quot;astaxie&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Affected Num: %s, %s&quot;</span>, num, err)</span><br><span class="line"><span class="comment">// SET name = &quot;astaixe&quot; WHERE name = &quot;slene&quot;</span></span><br></pre></td></tr></table></figure>

<p>原子操作增加字段值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 user struct 里有一个 nums int 字段</span></span><br><span class="line">num, err := o.QueryTable(<span class="string">&quot;user&quot;</span>).Update(orm.Params&#123;</span><br><span class="line">	<span class="string">&quot;nums&quot;</span>: orm.ColValue(orm.ColAdd, <span class="number">100</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// SET nums = nums + 100</span></span><br></pre></td></tr></table></figure>

<p>orm.ColValue 支持以下操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ColAdd      <span class="comment">// 加</span></span><br><span class="line">ColMinus    <span class="comment">// 减</span></span><br><span class="line">ColMultiply <span class="comment">// 乘</span></span><br><span class="line">ColExcept   <span class="comment">// 除</span></span><br></pre></td></tr></table></figure>

<h3 id="Delete-1"><a href="#Delete-1" class="headerlink" title="Delete"></a>Delete</h3><p>依据当前查询条件，进行批量删除操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num, err := o.QueryTable(<span class="string">&quot;user&quot;</span>).Filter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;slene&quot;</span>).Delete()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Affected Num: %s, %s&quot;</span>, num, err)</span><br><span class="line"><span class="comment">// DELETE FROM user WHERE name = &quot;slene&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="PrepareInsert"><a href="#PrepareInsert" class="headerlink" title="PrepareInsert"></a>PrepareInsert</h3><p>用于一次 prepare 多次 insert 插入，以提高批量插入的速度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users []*User</span><br><span class="line">...</span><br><span class="line">qs := o.QueryTable(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">i, _ := qs.PrepareInsert()</span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">	id, err := i.Insert(user)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PREPARE INSERT INTO user (`name`, ...) VALUES (?, ...)</span></span><br><span class="line"><span class="comment">// EXECUTE INSERT INTO user (`name`, ...) VALUES (&quot;slene&quot;, ...)</span></span><br><span class="line"><span class="comment">// EXECUTE ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">i.Close() <span class="comment">// 别忘记关闭 statement</span></span><br></pre></td></tr></table></figure>

<h3 id="All"><a href="#All" class="headerlink" title="All"></a>All</h3><p>返回对应的结果集对象</p>
<p>All 的参数支持 *[]Type 和 *[]*Type 两种形式的 slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users []*User</span><br><span class="line">num, err := o.QueryTable(<span class="string">&quot;user&quot;</span>).Filter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;slene&quot;</span>).All(&amp;users)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Returned Rows Num: %s, %s&quot;</span>, num, err)</span><br></pre></td></tr></table></figure>

<p>All &#x2F; Values &#x2F; ValuesList &#x2F; ValuesFlat 受到 <a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#limit">Limit</a> 的限制，默认最大行数为 1000</p>
<p>可以指定返回的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id      <span class="type">int</span></span><br><span class="line">	Title   <span class="type">string</span></span><br><span class="line">	Content <span class="type">string</span></span><br><span class="line">	Status  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只返回 Id 和 Title</span></span><br><span class="line"><span class="keyword">var</span> posts []Post</span><br><span class="line">o.QueryTable(<span class="string">&quot;post&quot;</span>).Filter(<span class="string">&quot;Status&quot;</span>, <span class="number">1</span>).All(&amp;posts, <span class="string">&quot;Id&quot;</span>, <span class="string">&quot;Title&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对象的其他字段值将会是对应类型的默认值</p>
<h3 id="One"><a href="#One" class="headerlink" title="One"></a>One</h3><p>尝试返回单条记录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">err := o.QueryTable(<span class="string">&quot;user&quot;</span>).Filter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;slene&quot;</span>).One(&amp;user)</span><br><span class="line"><span class="keyword">if</span> err == orm.ErrMultiRows &#123;</span><br><span class="line">	<span class="comment">// 多条的时候报错</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Returned Multi Rows Not One&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err == orm.ErrNoRows &#123;</span><br><span class="line">	<span class="comment">// 没有找到记录</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Not row found&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以指定返回的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只返回 Id 和 Title</span></span><br><span class="line"><span class="keyword">var</span> post Post</span><br><span class="line">o.QueryTable(<span class="string">&quot;post&quot;</span>).Filter(<span class="string">&quot;Content__istartswith&quot;</span>, <span class="string">&quot;prefix string&quot;</span>).One(&amp;post, <span class="string">&quot;Id&quot;</span>, <span class="string">&quot;Title&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对象的其他字段值将会是对应类型的默认值</p>
<h3 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h3><p>返回结果集的 key &#x3D;&gt; value 值</p>
<p>key 为Model里的Field name, value的值是interface{}类型,例如，如果你要将value赋值给struct中的某字段，需要根据结构体对应字段类型使用<a href="https://golang.org/ref/spec#Type_assertions">断言</a>获取真实值。举例:<code>Name : m[&quot;Name&quot;].(string)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maps []orm.Params</span><br><span class="line">num, err := o.QueryTable(<span class="string">&quot;user&quot;</span>).Values(&amp;maps)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Result Nums: %d\n&quot;</span>, num)</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> maps &#123;</span><br><span class="line">		fmt.Println(m[<span class="string">&quot;Id&quot;</span>], m[<span class="string">&quot;Name&quot;</span>])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回指定的 Field 数据</p>
<p><strong>TODO</strong>: 暂不支持级联查询 <strong>RelatedSel</strong> 直接返回 Values</p>
<p>但可以直接指定 expr 级联返回需要的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maps []orm.Params</span><br><span class="line">num, err := o.QueryTable(<span class="string">&quot;user&quot;</span>).Values(&amp;maps, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;profile&quot;</span>, <span class="string">&quot;profile__age&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Result Nums: %d\n&quot;</span>, num)</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> maps &#123;</span><br><span class="line">		fmt.Println(m[<span class="string">&quot;Id&quot;</span>], m[<span class="string">&quot;Name&quot;</span>], m[<span class="string">&quot;Profile&quot;</span>], m[<span class="string">&quot;Profile__Age&quot;</span>])</span><br><span class="line">		<span class="comment">// map 中的数据都是展开的，没有复杂的嵌套</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ValuesList"><a href="#ValuesList" class="headerlink" title="ValuesList"></a>ValuesList</h3><p>顾名思义，返回的结果集以slice存储</p>
<p>结果的排列与 Model 中定义的 Field 顺序一致</p>
<p>返回的每个元素值以 string 保存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lists []orm.ParamsList</span><br><span class="line">num, err := o.QueryTable(<span class="string">&quot;user&quot;</span>).ValuesList(&amp;lists)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Result Nums: %d\n&quot;</span>, num)</span><br><span class="line">	<span class="keyword">for</span> _, row := <span class="keyword">range</span> lists &#123;</span><br><span class="line">		fmt.Println(row)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以指定 expr 返回指定的 Field</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lists []orm.ParamsList</span><br><span class="line">num, err := o.QueryTable(<span class="string">&quot;user&quot;</span>).ValuesList(&amp;lists, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;profile__age&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Result Nums: %d\n&quot;</span>, num)</span><br><span class="line">	<span class="keyword">for</span> _, row := <span class="keyword">range</span> lists &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Name: %s, Age: %s\m&quot;</span>, row[<span class="number">0</span>], row[<span class="number">1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ValuesFlat"><a href="#ValuesFlat" class="headerlink" title="ValuesFlat"></a>ValuesFlat</h3><p>只返回特定的 Field 值，将结果集展开到单个 slice 里</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list orm.ParamsList</span><br><span class="line">num, err := o.QueryTable(<span class="string">&quot;user&quot;</span>).ValuesFlat(&amp;list, <span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Result Nums: %d\n&quot;</span>, num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;All User Names: %s&quot;</span>, strings.Join(list, <span class="string">&quot;, &quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关系查询"><a href="#关系查询" class="headerlink" title="关系查询"></a>关系查询</h3><h4 id="User-和-Profile-是-OneToOne-的关系"><a href="#User-和-Profile-是-OneToOne-的关系" class="headerlink" title="User 和 Profile 是 OneToOne 的关系"></a>User 和 Profile 是 OneToOne 的关系</h4><p>已经取得了 User 对象，查询 Profile：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := &amp;User&#123;Id: <span class="number">1</span>&#125;</span><br><span class="line">o.Read(user)</span><br><span class="line"><span class="keyword">if</span> user.Profile != <span class="literal">nil</span> &#123;</span><br><span class="line">	o.Read(user.Profile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接关联查询：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := &amp;User&#123;&#125;</span><br><span class="line">o.QueryTable(<span class="string">&quot;user&quot;</span>).Filter(<span class="string">&quot;Id&quot;</span>, <span class="number">1</span>).RelatedSel().One(user)</span><br><span class="line"><span class="comment">// 自动查询到 Profile</span></span><br><span class="line">fmt.Println(user.Profile)</span><br><span class="line"><span class="comment">// 因为在 Profile 里定义了反向关系的 User，所以 Profile 里的 User 也是自动赋值过的，可以直接取用。</span></span><br><span class="line">fmt.Println(user.Profile.User)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [SELECT T0.`id`, T0.`name`, T0.`profile_id`, T1.`id`, T1.`age` FROM `user` T0 INNER JOIN `profile` T1 ON T1.`id` = T0.`profile_id` WHERE T0.`id` = ? LIMIT 1000] - `1`</span></span><br></pre></td></tr></table></figure>

<p>通过 User 反向查询 Profile：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> profile Profile</span><br><span class="line">err := o.QueryTable(<span class="string">&quot;profile&quot;</span>).Filter(<span class="string">&quot;User__Id&quot;</span>, <span class="number">1</span>).One(&amp;profile)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(profile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Post-和-User-是-ManyToOne-关系，也就是-ForeignKey-为-User"><a href="#Post-和-User-是-ManyToOne-关系，也就是-ForeignKey-为-User" class="headerlink" title="Post 和 User 是 ManyToOne 关系，也就是 ForeignKey 为 User"></a>Post 和 User 是 ManyToOne 关系，也就是 ForeignKey 为 User</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="type">int</span></span><br><span class="line">	Title <span class="type">string</span></span><br><span class="line">	User  *User  <span class="string">`orm:&quot;rel(fk)&quot;`</span></span><br><span class="line">	Tags  []*Tag <span class="string">`orm:&quot;rel(m2m)&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> posts []*Post</span><br><span class="line">num, err := o.QueryTable(<span class="string">&quot;post&quot;</span>).Filter(<span class="string">&quot;User&quot;</span>, <span class="number">1</span>).RelatedSel().All(&amp;posts)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d posts read\n&quot;</span>, num)</span><br><span class="line">	<span class="keyword">for</span> _, post := <span class="keyword">range</span> posts &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Id: %d, UserName: %d, Title: %s\n&quot;</span>, post.Id, post.User.UserName, post.Title)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [SELECT T0.`id`, T0.`title`, T0.`user_id`, T1.`id`, T1.`name`, T1.`profile_id`, T2.`id`, T2.`age` FROM `post` T0 INNER JOIN `user` T1 ON T1.`id` = T0.`user_id` INNER JOIN `profile` T2 ON T2.`id` = T1.`profile_id` WHERE T0.`user_id` = ? LIMIT 1000] - `1`</span></span><br></pre></td></tr></table></figure>

<p>根据 Post.Title 查询对应的 User：</p>
<p>RegisterModel 时，ORM 也会自动建立 User 中 Post 的反向关系，所以可以直接进行查询</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">err := o.QueryTable(<span class="string">&quot;user&quot;</span>).Filter(<span class="string">&quot;Post__Title&quot;</span>, <span class="string">&quot;The Title&quot;</span>).Limit(<span class="number">1</span>).One(&amp;user)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Post-和-Tag-是-ManyToMany-关系"><a href="#Post-和-Tag-是-ManyToMany-关系" class="headerlink" title="Post 和 Tag 是 ManyToMany 关系"></a>Post 和 Tag 是 ManyToMany 关系</h4><p>设置 rel(m2m) 以后，ORM 会自动创建中间表</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="type">int</span></span><br><span class="line">	Title <span class="type">string</span></span><br><span class="line">	User  *User  <span class="string">`orm:&quot;rel(fk)&quot;`</span></span><br><span class="line">	Tags  []*Tag <span class="string">`orm:&quot;rel(m2m)&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Tag <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="type">int</span></span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Posts []*Post <span class="string">`orm:&quot;reverse(many)&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一条 Post 纪录可能对应不同的 Tag 纪录,一条 Tag 纪录可能对应不同的 Post 纪录，所以 Post 和 Tag 属于多对多关系,通过 tag name 查询哪些 post 使用了这个 tag</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> posts []*Post</span><br><span class="line">num, err := dORM.QueryTable(<span class="string">&quot;post&quot;</span>).Filter(<span class="string">&quot;Tags__Tag__Name&quot;</span>, <span class="string">&quot;golang&quot;</span>).All(&amp;posts)</span><br></pre></td></tr></table></figure>

<p>通过 post title 查询这个 post 有哪些 tag</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tags []*Tag</span><br><span class="line">num, err := dORM.QueryTable(<span class="string">&quot;tag&quot;</span>).Filter(<span class="string">&quot;Posts__Post__Title&quot;</span>, <span class="string">&quot;Introduce Beego ORM&quot;</span>).All(&amp;tags)</span><br></pre></td></tr></table></figure>

<h3 id="载入关系字段"><a href="#载入关系字段" class="headerlink" title="载入关系字段"></a>载入关系字段</h3><p>LoadRelated 用于载入模型的关系字段，包括所有的 rel&#x2F;reverse - one&#x2F;many 关系</p>
<p>ManyToMany 关系字段载入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 载入相应的 Tags</span></span><br><span class="line">post := Post&#123;Id: <span class="number">1</span>&#125;</span><br><span class="line">err := o.Read(&amp;post)</span><br><span class="line">num, err := o.LoadRelated(&amp;post, <span class="string">&quot;Tags&quot;</span>)</span><br><span class="line"><span class="comment">// 载入相应的 Posts</span></span><br><span class="line">tag := Tag&#123;Id: <span class="number">1</span>&#125;</span><br><span class="line">err := o.Read(&amp;tag)</span><br><span class="line">num, err := o.LoadRelated(&amp;tag, <span class="string">&quot;Posts&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>User 是 Post 的 ForeignKey，对应的 ReverseMany 关系字段载入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="type">int</span></span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Posts []*Post <span class="string">`orm:&quot;reverse(many)&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user := User&#123;Id: <span class="number">1</span>&#125;</span><br><span class="line">err := dORM.Read(&amp;user)</span><br><span class="line">num, err := dORM.LoadRelated(&amp;user, <span class="string">&quot;Posts&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, post := <span class="keyword">range</span> user.Posts &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多对多关系操作"><a href="#多对多关系操作" class="headerlink" title="多对多关系操作"></a>多对多关系操作</h3><ul>
<li>type QueryM2Mer interface {<ul>
<li><a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#querym2mer-add">Add(…interface{}) (int64, error)</a></li>
<li><a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#querym2mer-remove">Remove(…interface{}) (int64, error)</a></li>
<li><a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#querym2mer-exist">Exist(interface{}) bool</a></li>
<li><a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#querym2mer-clear">Clear() (int64, error)</a></li>
<li><a href="https://git-books.github.io/books/beego/?p=mvc/model/query.md#querym2mer-count">Count() (int64, error)</a></li>
</ul>
</li>
<li>}</li>
</ul>
<p>创建一个 QueryM2Mer 对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line">post := Post&#123;Id: <span class="number">1</span>&#125;</span><br><span class="line">m2m := o.QueryM2M(&amp;post, <span class="string">&quot;Tags&quot;</span>)</span><br><span class="line"><span class="comment">// 第一个参数的对象，主键必须有值</span></span><br><span class="line"><span class="comment">// 第二个参数为对象需要操作的 M2M 字段</span></span><br><span class="line"><span class="comment">// QueryM2Mer 的 api 将作用于 Id 为 1 的 Post</span></span><br></pre></td></tr></table></figure>

<h4 id="QueryM2Mer-Add"><a href="#QueryM2Mer-Add" class="headerlink" title="QueryM2Mer Add"></a>QueryM2Mer Add</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tag := &amp;Tag&#123;Name: <span class="string">&quot;golang&quot;</span>&#125;</span><br><span class="line">o.Insert(tag)</span><br><span class="line"></span><br><span class="line">num, err := m2m.Add(tag)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Added nums: &quot;</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Add 支持多种类型 Tag *Tag []*Tag []Tag []interface{}</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tags []*Tag</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 读取 tags 以后</span></span><br><span class="line">...</span><br><span class="line">num, err := m2m.Add(tags)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Added nums: &quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以多个作为参数传入</span></span><br><span class="line"><span class="comment">// m2m.Add(tag1, tag2, tag3)</span></span><br></pre></td></tr></table></figure>

<h4 id="QueryM2Mer-Remove"><a href="#QueryM2Mer-Remove" class="headerlink" title="QueryM2Mer Remove"></a>QueryM2Mer Remove</h4><p>从M2M关系中删除 tag</p>
<p>Remove 支持多种类型 Tag *Tag []*Tag []Tag []interface{}</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tags []*Tag</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 读取 tags 以后</span></span><br><span class="line">...</span><br><span class="line">num, err := m2m.Remove(tags)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Removed nums: &quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以多个作为参数传入</span></span><br><span class="line"><span class="comment">// m2m.Remove(tag1, tag2, tag3)</span></span><br></pre></td></tr></table></figure>

<h4 id="QueryM2Mer-Exist"><a href="#QueryM2Mer-Exist" class="headerlink" title="QueryM2Mer Exist"></a>QueryM2Mer Exist</h4><p>判断 Tag 是否存在于 M2M 关系中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> m2m.Exist(&amp;Tag&#123;Id: <span class="number">2</span>&#125;) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Tag Exist&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="QueryM2Mer-Clear"><a href="#QueryM2Mer-Clear" class="headerlink" title="QueryM2Mer Clear"></a>QueryM2Mer Clear</h4><p>清除所有 M2M 关系</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums, err := m2m.Clear()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Removed Tag Nums: &quot;</span>, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="QueryM2Mer-Count"><a href="#QueryM2Mer-Count" class="headerlink" title="QueryM2Mer Count"></a>QueryM2Mer Count</h4><p>计算 Tag 的数量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums, err := m2m.Count()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Total Nums: &quot;</span>, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原生-SQL-查询"><a href="#原生-SQL-查询" class="headerlink" title="原生 SQL 查询"></a>原生 SQL 查询</h2><ul>
<li>使用 Raw SQL 查询，无需使用 ORM 表定义</li>
<li>多数据库，都可直接使用占位符号 <code>?</code>，自动转换</li>
<li>查询时的参数，支持使用 Model Struct 和 Slice, Array</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line">ids := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r RawSter</span><br><span class="line">r = o.Raw(<span class="string">&quot;SELECT name FROM user WHERE id IN (?, ?, ?)&quot;</span>, ids)</span><br></pre></td></tr></table></figure>

<p>创建一个 <strong>RawSeter</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := orm.NewOrm()</span><br><span class="line"><span class="keyword">var</span> r RawSeter</span><br><span class="line">r = o.Raw(<span class="string">&quot;UPDATE user SET name = ? WHERE name = ?&quot;</span>, <span class="string">&quot;testing&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h3><p>执行 sql 语句，返回 <a href="http://gowalker.org/database/sql#Result">sql.Result</a> 对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">res, err := o.Raw(<span class="string">&quot;UPDATE user SET name = ?&quot;</span>, <span class="string">&quot;your&quot;</span>).Exec()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	num, _ := res.RowsAffected()</span><br><span class="line">	fmt.Println(<span class="string">&quot;mysql row affected nums: &quot;</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QueryRow"><a href="#QueryRow" class="headerlink" title="QueryRow"></a>QueryRow</h3><p>QueryRow 和 QueryRows 提供高级 sql mapper 功能</p>
<p>支持 struct</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id       <span class="type">int</span></span><br><span class="line">	UserName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">err := o.Raw(<span class="string">&quot;SELECT id, user_name FROM user WHERE id = ?&quot;</span>, <span class="number">1</span>).QueryRow(&amp;user)</span><br></pre></td></tr></table></figure>

<h3 id="QueryRows"><a href="#QueryRows" class="headerlink" title="QueryRows"></a>QueryRows</h3><p>QueryRows 支持的对象还有 map 规则是和 QueryRow 一样的，但都是 slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id       <span class="type">int</span></span><br><span class="line">	UserName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line">num, err := o.Raw(<span class="string">&quot;SELECT id, user_name FROM user WHERE id = ?&quot;</span>, <span class="number">1</span>).QueryRows(&amp;users)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;user nums: &quot;</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SetArgs"><a href="#SetArgs" class="headerlink" title="SetArgs"></a>SetArgs</h3><p>改变 Raw(sql, args…) 中的 args 参数，返回一个新的 RawSeter</p>
<p>用于单条 sql 语句，重复利用，替换参数然后执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">res, err := r.SetArgs(<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>).Exec()</span><br><span class="line">res, err := r.SetArgs(<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>).Exec()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="Values-ValuesList-ValuesFlat"><a href="#Values-ValuesList-ValuesFlat" class="headerlink" title="Values &#x2F; ValuesList &#x2F; ValuesFlat"></a>Values &#x2F; ValuesList &#x2F; ValuesFlat</h3><p>Raw SQL 查询获得的结果集 Value 为 <code>string</code> 类型，NULL 字段的值为空 &#96;&#96;</p>
<h3 id="Values-1"><a href="#Values-1" class="headerlink" title="Values"></a>Values</h3><p>返回结果集的 key &#x3D;&gt; value 值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maps []orm.Params</span><br><span class="line">num, err := o.Raw(<span class="string">&quot;SELECT user_name FROM user WHERE status = ?&quot;</span>, <span class="number">1</span>).Values(&amp;maps)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; num &gt; <span class="number">0</span> &#123;</span><br><span class="line">	fmt.Println(maps[<span class="number">0</span>][<span class="string">&quot;user_name&quot;</span>]) <span class="comment">// slene</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ValuesList-1"><a href="#ValuesList-1" class="headerlink" title="ValuesList"></a>ValuesList</h3><p>返回结果集 slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lists []orm.ParamsList</span><br><span class="line">num, err := o.Raw(<span class="string">&quot;SELECT user_name FROM user WHERE status = ?&quot;</span>, <span class="number">1</span>).ValuesList(&amp;lists)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; num &gt; <span class="number">0</span> &#123;</span><br><span class="line">	fmt.Println(lists[<span class="number">0</span>][<span class="number">0</span>]) <span class="comment">// slene</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ValuesFlat-1"><a href="#ValuesFlat-1" class="headerlink" title="ValuesFlat"></a>ValuesFlat</h3><p>返回单一字段的平铺 slice 数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list orm.ParamsList</span><br><span class="line">num, err := o.Raw(<span class="string">&quot;SELECT id FROM user WHERE id &lt; ?&quot;</span>, <span class="number">10</span>).ValuesFlat(&amp;list)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; num &gt; <span class="number">0</span> &#123;</span><br><span class="line">	fmt.Println(list) <span class="comment">// []&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RowsToMap"><a href="#RowsToMap" class="headerlink" title="RowsToMap"></a>RowsToMap</h3><p>SQL 查询结果是这样</p>
<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">total</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left">found</td>
<td align="left">200</td>
</tr>
</tbody></table>
<p>查询结果匹配到 map 里</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">res := <span class="built_in">make</span>(orm.Params)</span><br><span class="line">nums, err := o.Raw(<span class="string">&quot;SELECT name, value FROM options_table&quot;</span>).RowsToMap(&amp;res, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line"><span class="comment">// res is a map[string]interface&#123;&#125;&#123;</span></span><br><span class="line"><span class="comment">//	&quot;total&quot;: 100,</span></span><br><span class="line"><span class="comment">//	&quot;found&quot;: 200,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="RowsToStruct"><a href="#RowsToStruct" class="headerlink" title="RowsToStruct"></a>RowsToStruct</h3><p>SQL 查询结果是这样</p>
<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">total</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left">found</td>
<td align="left">200</td>
</tr>
</tbody></table>
<p>查询结果匹配到 struct 里</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">	Total <span class="type">int</span></span><br><span class="line">	Found <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res := <span class="built_in">new</span>(Options)</span><br><span class="line">nums, err := o.Raw(<span class="string">&quot;SELECT name, value FROM options_table&quot;</span>).RowsToStruct(res, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">fmt.Println(res.Total) <span class="comment">// 100</span></span><br><span class="line">fmt.Println(res.Found) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>匹配支持的名称转换为 snake -&gt; camel, eg: SELECT user_name … 需要你的 struct 中定义有 UserName</p>
</blockquote>
<h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p>用于一次 prepare 多次 exec，以提高批量执行的速度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p, err := o.Raw(<span class="string">&quot;UPDATE user SET name = ? WHERE name = ?&quot;</span>).Prepare()</span><br><span class="line">res, err := p.Exec(<span class="string">&quot;testing&quot;</span>, <span class="string">&quot;slene&quot;</span>)</span><br><span class="line">res, err  = p.Exec(<span class="string">&quot;testing&quot;</span>, <span class="string">&quot;astaxie&quot;</span>)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">p.Close() <span class="comment">// 别忘记关闭 statement</span></span><br></pre></td></tr></table></figure>

<h2 id="构造查询"><a href="#构造查询" class="headerlink" title="构造查询"></a>构造查询</h2><p><strong>QueryBuilder</strong> 提供了一个简便，流畅的 SQL 查询构造器。在不影响代码可读性的前提下用来快速的建立 SQL 语句。</p>
<p><strong>QueryBuilder</strong> 在功能上与 ORM 重合， 但是各有利弊。ORM 更适用于简单的 CRUD 操作，而 QueryBuilder 则更适用于复杂的查询，例如查询中包含子查询和多重联结。</p>
<p>使用方法:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 包装了下面的查询结果</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 QueryBuilder 对象. 需要指定数据库驱动参数。</span></span><br><span class="line"><span class="comment">// 第二个返回值是错误对象，在这里略过</span></span><br><span class="line">qb, _ := orm.NewQueryBuilder(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建查询对象</span></span><br><span class="line">qb.Select(<span class="string">&quot;user.name&quot;</span>,</span><br><span class="line">	<span class="string">&quot;profile.age&quot;</span>).</span><br><span class="line">	From(<span class="string">&quot;user&quot;</span>).</span><br><span class="line">	InnerJoin(<span class="string">&quot;profile&quot;</span>).On(<span class="string">&quot;user.id_user = profile.fk_user&quot;</span>).</span><br><span class="line">	Where(<span class="string">&quot;age &gt; ?&quot;</span>).</span><br><span class="line">	OrderBy(<span class="string">&quot;name&quot;</span>).Desc().</span><br><span class="line">	Limit(<span class="number">10</span>).Offset(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 SQL 语句</span></span><br><span class="line">sql := qb.String()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 SQL 语句</span></span><br><span class="line">o := orm.NewOrm()</span><br><span class="line">o.Raw(sql, <span class="number">20</span>).QueryRows(&amp;users)</span><br></pre></td></tr></table></figure>

<h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h2><p>复杂的模型定义不是必须的，此功能用作数据库数据转换和<a href="https://git-books.github.io/books/beego/cmd.md#%E8%87%AA%E5%8A%A8%E5%BB%BA%E8%A1%A8">自动建表</a></p>
<p>默认的表名规则，使用驼峰转蛇形：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AuthUser -&gt; auth_user</span><br><span class="line">Auth_User -&gt; auth__user</span><br><span class="line">DB_AuthUser -&gt; d_b__auth_user</span><br></pre></td></tr></table></figure>

<p>除了开头的大写字母以外，遇到大写会增加 <code>_</code>，原名称中的下划线保留。</p>
<h3 id="自定义表名"><a href="#自定义表名" class="headerlink" title="自定义表名"></a>自定义表名</h3><p>实现接口<code>TableNameI</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;auth_user&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<a href="https://git-books.github.io/books/beego/orm.md#registermodelwithprefix">前缀设置</a>为 <code>prefix_</code> 那么表名为：prefix_auth_user</p>
<h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">orm:<span class="string">&quot;null;rel(fk)&quot;</span></span><br></pre></td></tr></table></figure>

<p>多个设置间使用 <code>;</code> 分隔，设置的值如果是多个，使用 <code>,</code> 分隔。</p>
<h4 id="忽略字段"><a href="#忽略字段" class="headerlink" title="忽略字段"></a>忽略字段</h4><p>设置 <code>-</code> 即可忽略 struct 中的字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">	AnyField <span class="type">string</span> <span class="string">`orm:&quot;-&quot;`</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>当 Field 类型为 int, int32, int64, uint, uint32, uint64 时，可以设置字段为自增健</p>
<ul>
<li>当模型定义里没有主键时，符合上述类型且名称为 <code>Id</code> 的 Field 将被视为自增健。</li>
</ul>
<p>鉴于 go 目前的设计，即使使用了 uint64，但你也不能存储到他的最大值。依然会作为 int64 处理。</p>
<h4 id="pk"><a href="#pk" class="headerlink" title="pk"></a>pk</h4><p>设置为主键，适用于自定义其他类型为主键</p>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>数据库表默认为 <code>NOT NULL</code>，设置 null 代表 <code>ALLOW NULL</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Name <span class="type">string</span> <span class="string">`orm:&quot;null&quot;`</span></span><br></pre></td></tr></table></figure>

<h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>为单个字段增加索引</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Name <span class="type">string</span> <span class="string">`orm:&quot;index&quot;`</span></span><br></pre></td></tr></table></figure>

<h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><p>为单个字段增加 unique 键</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Name <span class="type">string</span> <span class="string">`orm:&quot;unique&quot;`</span></span><br></pre></td></tr></table></figure>

<h4 id="column"><a href="#column" class="headerlink" title="column"></a>column</h4><p>为字段设置 db 字段的名称</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Name <span class="type">string</span> <span class="string">`orm:&quot;column(user_name)&quot;`</span></span><br></pre></td></tr></table></figure>

<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><p>string 类型字段默认为 varchar(255)</p>
<p>设置 size 以后，db type 将使用 varchar(size)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Title <span class="type">string</span> <span class="string">`orm:&quot;size(60)&quot;`</span></span><br></pre></td></tr></table></figure>

<h4 id="digits-decimals"><a href="#digits-decimals" class="headerlink" title="digits &#x2F; decimals"></a>digits &#x2F; decimals</h4><p>设置 float32, float64 类型的浮点精度</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Money <span class="type">float64</span> <span class="string">`orm:&quot;digits(12);decimals(4)&quot;`</span></span><br></pre></td></tr></table></figure>

<p>总长度 12 小数点后 4 位 eg: <code>99999999.9999</code></p>
<h4 id="auto-now-auto-now-add"><a href="#auto-now-auto-now-add" class="headerlink" title="auto_now &#x2F; auto_now_add"></a>auto_now &#x2F; auto_now_add</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Created time.Time <span class="string">`orm:&quot;auto_now_add;type(datetime)&quot;`</span></span><br><span class="line">Updated time.Time <span class="string">`orm:&quot;auto_now;type(datetime)&quot;`</span></span><br></pre></td></tr></table></figure>

<ul>
<li>auto_now 每次 model 保存时都会对时间自动更新</li>
<li>auto_now_add 第一次保存时才设置时间</li>
</ul>
<p>对于批量的 update 此设置是不生效的</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>设置为 date 时，time.Time 字段的对应 db 类型使用 date</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Created time.Time <span class="string">`orm:&quot;auto_now_add;type(date)&quot;`</span></span><br></pre></td></tr></table></figure>

<p>设置为 datetime 时，time.Time 字段的对应 db 类型使用 datetime</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Created time.Time <span class="string">`orm:&quot;auto_now_add;type(datetime)&quot;`</span></span><br></pre></td></tr></table></figure>

<h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><p>在 v2.x 里面，我们提供了默认值的Filter:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/beego/beego/v2/client/orm/filter/bean&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/beego/beego/v2/client/orm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefaultValueTestEntity <span class="keyword">struct</span> &#123;</span><br><span class="line">Id            <span class="type">int</span></span><br><span class="line">Age           <span class="type">int</span> <span class="string">`default:&quot;12&quot;`</span></span><br><span class="line">AgeInOldStyle <span class="type">int</span> <span class="string">`orm:&quot;default(13);bee()&quot;`</span></span><br><span class="line">AgeIgnore     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">XXX</span><span class="params">()</span></span> &#123;</span><br><span class="line">    builder := bean.NewDefaultValueFilterChainBuilder(<span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">    orm.AddGlobalFilterChain(builder.FilterChain)</span><br><span class="line">    o := orm.NewOrm()</span><br><span class="line">    _, _ = o.Insert(&amp;User&#123;</span><br><span class="line">        ID: <span class="number">1</span>,</span><br><span class="line">        Name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一个很重要的认识，是认为显式设置值才是更加优雅的实践，所以我们将默认值的功能做成了一种可选的<code>filter</code>实现。</p>
<h4 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h4><p>为字段添加注释</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	Status <span class="type">int</span> <span class="string">`orm:&quot;default(1);description(这是状态字段)&quot;`</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: 注释中禁止包含引号</p>
<h4 id="Precision"><a href="#Precision" class="headerlink" title="Precision"></a>Precision</h4><p>为<code>datetime</code>字段设置精度值位数，不同DB支持最大精度值位数也不一致。</p>
<p>type User struct {<br>…<br>Created time.Time <code>orm:&quot;type(datetime);precision(4)&quot;</code><br>…<br>}</p>
<h3 id="表关系设置"><a href="#表关系设置" class="headerlink" title="表关系设置"></a>表关系设置</h3><h4 id="rel-reverse"><a href="#rel-reverse" class="headerlink" title="rel &#x2F; reverse"></a>rel &#x2F; reverse</h4><p><strong>RelOneToOne</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	Profile *Profile <span class="string">`orm:&quot;null;rel(one);on_delete(set_null)&quot;`</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的反向关系 <strong>RelReverseOne</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	User *User <span class="string">`orm:&quot;reverse(one)&quot;`</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RelForeignKey</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	User *User <span class="string">`orm:&quot;rel(fk)&quot;`</span> <span class="comment">// RelForeignKey relation</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的反向关系 <strong>RelReverseMany</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	Posts []*Post <span class="string">`orm:&quot;reverse(many)&quot;`</span> <span class="comment">// fk 的反向关系</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RelManyToMany</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	Tags []*Tag <span class="string">`orm:&quot;rel(m2m)&quot;`</span> <span class="comment">// ManyToMany relation</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的反向关系 <strong>RelReverseMany</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Tag <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	Posts []*Post <span class="string">`orm:&quot;reverse(many)&quot;`</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="rel-table-rel-through"><a href="#rel-table-rel-through" class="headerlink" title="rel_table &#x2F; rel_through"></a>rel_table &#x2F; rel_through</h4><p>此设置针对 <code>orm:&quot;rel(m2m)&quot;</code> 的关系字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rel_table       设置自动生成的 m2m 关系表的名称</span><br><span class="line">rel_through     如果要在 m2m 关系中使用自定义的 m2m 关系表</span><br><span class="line">                通过这个设置其名称，格式为 pkg.path.ModelName</span><br><span class="line">                eg: app.models.PostTagRel</span><br><span class="line">                PostTagRel 表需要有到 Post 和 Tag 的关系</span><br></pre></td></tr></table></figure>

<p>当设置 rel_table 时会忽略 rel_through</p>
<p>设置方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">orm:<span class="string">&quot;rel(m2m);rel_table(the_table_name)&quot;</span></span><br><span class="line">orm:<span class="string">&quot;rel(m2m);rel_through(pkg.path.ModelName)&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="on-delete"><a href="#on-delete" class="headerlink" title="on_delete"></a>on_delete</h4><p>设置对应的 rel 关系删除时，如何处理关系字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cascade        级联删除(默认值)</span><br><span class="line">set_null       设置为 NULL，需要设置 null = <span class="literal">true</span></span><br><span class="line">set_default    设置为默认值，需要设置 <span class="keyword">default</span> 值</span><br><span class="line">do_nothing     什么也不做，忽略</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	Profile *Profile <span class="string">`orm:&quot;null;rel(one);on_delete(set_null)&quot;`</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	User *User <span class="string">`orm:&quot;reverse(one)&quot;`</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 Profile 时将设置 User.Profile 的数据库字段为 NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="关于-on-delete-的相关例子"><a href="#关于-on-delete-的相关例子" class="headerlink" title="关于 on_delete 的相关例子"></a>关于 on_delete 的相关例子</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int</span></span><br><span class="line">    Title <span class="type">string</span></span><br><span class="line">    User *User <span class="string">`orm:&quot;rel(fk)&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 Post -&gt; User 是 ManyToOne 的关系，也就是外键。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o.Filter(<span class="string">&quot;Id&quot;</span>, <span class="number">1</span>).Delete()</span><br></pre></td></tr></table></figure>

<p>这个时候即会删除 Id 为 1 的 User 也会删除其发布的 Post</p>
<p>不想删除的话，需要设置 set_null</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int</span></span><br><span class="line">    Title <span class="type">string</span></span><br><span class="line">    User *User <span class="string">`orm:&quot;rel(fk);null;on_delete(set_null)&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那这个时候，删除 User 只会把对应的 Post.user_id 设置为 NULL</p>
<p>当然有时候为了高性能的需要，多存点数据无所谓啊，造成批量删除才是问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int</span></span><br><span class="line">    Title <span class="type">string</span></span><br><span class="line">    User *User <span class="string">`orm:&quot;rel(fk);null;on_delete(do_nothing)&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么只要删除的时候，不操作 Post 就可以了。</p>
<h3 id="模型字段与数据库类型的对应"><a href="#模型字段与数据库类型的对应" class="headerlink" title="模型字段与数据库类型的对应"></a>模型字段与数据库类型的对应</h3><p>在此列出 ORM 推荐的对应数据库类型，自动建表功能也会以此为标准。</p>
<p>默认所有的字段都是 <strong>NOT NULL</strong></p>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><table>
<thead>
<tr>
<th align="left">go</th>
<th align="left">mysql</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int, int32 - 设置 auto 或者名称为 <code>Id</code> 时</td>
<td align="left">integer AUTO_INCREMENT</td>
</tr>
<tr>
<td align="left">int64 - 设置 auto 或者名称为 <code>Id</code> 时</td>
<td align="left">bigint AUTO_INCREMENT</td>
</tr>
<tr>
<td align="left">uint, uint32 - 设置 auto 或者名称为 <code>Id</code> 时</td>
<td align="left">integer unsigned AUTO_INCREMENT</td>
</tr>
<tr>
<td align="left">uint64 - 设置 auto 或者名称为 <code>Id</code> 时</td>
<td align="left">bigint unsigned AUTO_INCREMENT</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left">bool</td>
</tr>
<tr>
<td align="left">string - 默认为 size 255</td>
<td align="left">varchar(size)</td>
</tr>
<tr>
<td align="left">string - 设置 type(char) 时</td>
<td align="left">char(size)</td>
</tr>
<tr>
<td align="left">string - 设置 type(text) 时</td>
<td align="left">longtext</td>
</tr>
<tr>
<td align="left">time.Time - 设置 type 为 date 时</td>
<td align="left">date</td>
</tr>
<tr>
<td align="left">time.Time</td>
<td align="left">datetime</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">tinyint unsigned</td>
</tr>
<tr>
<td align="left">rune</td>
<td align="left">integer</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">integer</td>
</tr>
<tr>
<td align="left">int8</td>
<td align="left">tinyint</td>
</tr>
<tr>
<td align="left">int16</td>
<td align="left">smallint</td>
</tr>
<tr>
<td align="left">int32</td>
<td align="left">integer</td>
</tr>
<tr>
<td align="left">int64</td>
<td align="left">bigint</td>
</tr>
<tr>
<td align="left">uint</td>
<td align="left">integer unsigned</td>
</tr>
<tr>
<td align="left">uint8</td>
<td align="left">tinyint unsigned</td>
</tr>
<tr>
<td align="left">uint16</td>
<td align="left">smallint unsigned</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">integer unsigned</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">bigint unsigned</td>
</tr>
<tr>
<td align="left">float32</td>
<td align="left">double precision</td>
</tr>
<tr>
<td align="left">float64</td>
<td align="left">double precision</td>
</tr>
<tr>
<td align="left">float64 - 设置 digits, decimals 时</td>
<td align="left">numeric(digits, decimals)</td>
</tr>
</tbody></table>
<h3 id="关系型字段"><a href="#关系型字段" class="headerlink" title="关系型字段"></a>关系型字段</h3><p>其字段类型取决于对应的主键。</p>
<ul>
<li>RelForeignKey</li>
<li>RelOneToOne</li>
<li>RelManyToMany</li>
<li>RelReverseOne</li>
<li>RelReverseMany</li>
</ul>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>注册模型与数据库以后，调用 RunCommand 执行 orm 命令。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// orm.RegisterModel...</span></span><br><span class="line">	<span class="comment">// orm.RegisterDataBase...</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	orm.RunCommand()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> build main.<span class="keyword">go</span></span><br><span class="line">./main orm</span><br><span class="line"># 直接执行可以显示帮助</span><br><span class="line"># 如果你的程序可以支持的话，直接运行 <span class="keyword">go</span> run main.<span class="keyword">go</span> orm 也是一样的效果</span><br></pre></td></tr></table></figure>

<h3 id="自动建表"><a href="#自动建表" class="headerlink" title="自动建表"></a>自动建表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./main orm syncdb -h</span><br><span class="line">Usage of orm <span class="built_in">command</span>: syncdb:</span><br><span class="line">  -db=<span class="string">&quot;default&quot;</span>: DataBase <span class="built_in">alias</span> name</span><br><span class="line">  -force=<span class="literal">false</span>: drop tables before create</span><br><span class="line">  -v=<span class="literal">false</span>: verbose info</span><br></pre></td></tr></table></figure>

<p>使用 <code>-force=1</code> 可以 drop table 后再建表</p>
<p>使用 <code>-v</code> 可以查看执行的 sql 语句</p>
<hr>
<p>在程序中直接调用自动建表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据库别名</span></span><br><span class="line">name := <span class="string">&quot;default&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// drop table 后再建表</span></span><br><span class="line">force := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印执行过程</span></span><br><span class="line">verbose := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到错误立即返回</span></span><br><span class="line">err := orm.RunSyncdb(name, force, verbose)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动建表功能在非 force 模式下，是会自动创建新增加的字段的。也会创建新增加的索引。</p>
<p>对于改动过的旧字段，旧索引，需要用户自行进行处理。</p>
<h3 id="打印建表SQL"><a href="#打印建表SQL" class="headerlink" title="打印建表SQL"></a>打印建表SQL</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./main orm sqlall -h</span><br><span class="line">Usage of orm <span class="built_in">command</span>: syncdb:</span><br><span class="line">  -db=<span class="string">&quot;default&quot;</span>: DataBase <span class="built_in">alias</span> name</span><br></pre></td></tr></table></figure>

<p>默认使用别名为 default 的数据库。</p>
<h1 id="view设计"><a href="#view设计" class="headerlink" title="view设计"></a>view设计</h1><h2 id="模板语法指南"><a href="#模板语法指南" class="headerlink" title="模板语法指南"></a>模板语法指南</h2><p>本文讲述 beego 中使用的模板语法，与 go 模板语法基本相同。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>go 统一使用了 <code>&#123;&#123;` 和 `&#125;&#125;</code> 作为左右标签，没有其他的标签符号。如果您想要修改为其它符号，可以参考 <a href="http://beego.vip/docs/mvc/view/view.md#%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE">模板标签</a>。</p>
<p>使用 <code>.</code> 来访问当前位置的上下文</p>
<p>使用 <code>$</code> 来引用当前模板根级的上下文</p>
<p>使用 <code>$var</code> 来访问创建的变量</p>
<p>[more]</p>
<p><strong>模板中支持的 go 语言符号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&quot;string&quot;&#125;&#125; // 一般 string</span><br><span class="line">&#123;&#123;`raw string`&#125;&#125; // 原始 string</span><br><span class="line">&#123;&#123;&#x27;c&#x27;&#125;&#125; // byte</span><br><span class="line">&#123;&#123;print nil&#125;&#125; // nil 也被支持</span><br></pre></td></tr></table></figure>

<p><strong>模板中的 pipeline</strong></p>
<p>可以是上下文的变量输出，也可以是函数通过管道传递的返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;. | FuncA | FuncB | FuncC&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>当 pipeline 的值等于:</p>
<ul>
<li>false 或 0</li>
<li>nil 的指针或 interface</li>
<li>长度为 0 的 array, slice, map, string</li>
</ul>
<p>那么这个 pipeline 被认为是空</p>
<h4 id="if-…-else-…-end"><a href="#if-…-else-…-end" class="headerlink" title="if … else … end"></a>if … else … end</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;if pipeline&#125;&#125;&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>if 判断时，pipeline 为空时，相当于判断为 False</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.Data[&quot;IsLogin&quot;] = true</span><br><span class="line">this.Data[&quot;IsHome&quot;] = true</span><br><span class="line">this.Data[&quot;IsAbout&quot;] = true</span><br></pre></td></tr></table></figure>

<p>支持嵌套的循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;if .IsHome&#125;&#125;</span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">	&#123;&#123;if .IsAbout&#125;&#125;&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用 else if 进行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;if .IsHome&#125;&#125;</span><br><span class="line">&#123;&#123;else if .IsAbout&#125;&#125;</span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="range-…-end"><a href="#range-…-end" class="headerlink" title="range … end"></a>range … end</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;range pipeline&#125;&#125;&#123;&#123;.&#125;&#125;&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>pipeline 支持的类型为 array, slice, map, channel</p>
<p>range 循环内部的 <code>.</code> 改变为以上类型的子元素</p>
<p>对应的值长度为 0 时，range 不会执行，<code>.</code> 不会改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pages := []struct &#123;</span><br><span class="line">	Num int</span><br><span class="line">&#125;&#123;&#123;10&#125;, &#123;20&#125;, &#123;30&#125;&#125;</span><br><span class="line"></span><br><span class="line">this.Data[&quot;Total&quot;] = 100</span><br><span class="line">this.Data[&quot;Pages&quot;] = pages</span><br></pre></td></tr></table></figure>

<p>使用 <code>.Num</code> 输出子元素的 Num 属性，使用 <code>$.</code> 引用模板中的根级上下文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;range .Pages&#125;&#125;</span><br><span class="line">	&#123;&#123;.Num&#125;&#125; of &#123;&#123;$.Total&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>使用创建的变量，在这里和 go 中的 range 用法是相同的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;range $index, $elem := .Pages&#125;&#125;</span><br><span class="line">	&#123;&#123;$index&#125;&#125; - &#123;&#123;$elem.Num&#125;&#125; - &#123;&#123;.Num&#125;&#125; of &#123;&#123;$.Total&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>range 也支持 else</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;range .Pages&#125;&#125;</span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">	&#123;&#123;/* 当 .Pages 为空 或者 长度为 0 时会执行这里 */&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="with-…-end"><a href="#with-…-end" class="headerlink" title="with … end"></a>with … end</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;with pipeline&#125;&#125;&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>with 用于重定向 pipeline</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;with .Field.NestField.SubField&#125;&#125;</span><br><span class="line">	&#123;&#123;.Var&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>也可以对变量赋值操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;with $value := &quot;My name is %s&quot;&#125;&#125;</span><br><span class="line">	&#123;&#123;printf . &quot;slene&quot;&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>with 也支持 else</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;with pipeline&#125;&#125;</span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">	&#123;&#123;/* 当 pipeline 为空时会执行这里 */&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="define"><a href="#define" class="headerlink" title="define"></a>define</h4><p>define 可以用来定义自模板，可用于模块定义和模板嵌套</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;define &quot;loop&quot;&#125;&#125;</span><br><span class="line">	&lt;li&gt;&#123;&#123;.Name&#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>使用 template 调用模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">	&#123;&#123;range .Items&#125;&#125;</span><br><span class="line">		&#123;&#123;template &quot;loop&quot; .&#125;&#125;</span><br><span class="line">	&#123;&#123;end&#125;&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h4 id="template"><a href="#template" class="headerlink" title="template"></a>template</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;template &quot;模板名&quot; pipeline&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>将对应的上下文 pipeline 传给模板，才可以在模板中调用</p>
<p><strong>Beego 中支持直接载入文件模板</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;template &quot;path/to/head.html&quot; .&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>Beego 会依据你设置的模板路径读取 head.html</p>
<p>在模板中可以接着载入其他模板，对于模板的分模块处理很有用处</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>允许多行文本注释，不允许嵌套</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;/* comment content</span><br><span class="line">support new line */&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><p>变量可以使用符号 <code>|</code> 在函数间传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;.Con | markdown | addlinks&#125;&#125;</span><br><span class="line">&#123;&#123;.Name | printf &quot;%s&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>使用括号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;printf &quot;nums is %s %d&quot; (printf &quot;%d %d&quot; 1 2) 3&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;and .X .Y .Z&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>and 会逐一判断每个参数，将返回第一个为空的参数，否则就返回最后一个非空参数</p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;call .Field.Func .Arg1 .Arg2&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>call 可以调用函数，并传入参数</p>
<p>调用的函数需要返回 1 个值 或者 2 个值，返回两个值时，第二个值用于返回 error 类型的错误。返回的错误不等于 nil 时，执行将终止。</p>
<h4 id="index-1"><a href="#index-1" class="headerlink" title="index"></a>index</h4><p>index 支持 map, slice, array, string，读取指定类型对应下标的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.Data[&quot;Maps&quot;] = map[string]string&#123;&quot;name&quot;: &quot;Beego&quot;&#125;</span><br><span class="line">&#123;&#123;index .Maps &quot;name&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="len"><a href="#len" class="headerlink" title="len"></a>len</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;printf &quot;The content length is %d&quot; (.Content|len)&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>返回对应类型的长度，支持类型：map, slice, array, string, chan</p>
<h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4><p>not 返回输入参数的否定值，if true then false else true</p>
<h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;or .X .Y .Z&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>or 会逐一判断每个参数，将返回第一个非空的参数，否则就返回最后一个参数</p>
<h4 id="print"><a href="#print" class="headerlink" title="print"></a>print</h4><p>对应 fmt.Sprint</p>
<h4 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h4><p>对应 fmt.Sprintf</p>
<h4 id="println"><a href="#println" class="headerlink" title="println"></a>println</h4><p>对应 fmt.Sprintln</p>
<h4 id="urlquery"><a href="#urlquery" class="headerlink" title="urlquery"></a>urlquery</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;urlquery &quot;http://beego.vip&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>将返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http%3A%2F%2Fbeego.vip</span><br></pre></td></tr></table></figure>

<h4 id="eq-ne-lt-le-gt-ge"><a href="#eq-ne-lt-le-gt-ge" class="headerlink" title="eq &#x2F; ne &#x2F; lt &#x2F; le &#x2F; gt &#x2F; ge"></a>eq &#x2F; ne &#x2F; lt &#x2F; le &#x2F; gt &#x2F; ge</h4><p>这类函数一般配合在 if 中使用</p>
<p><code>eq</code>: arg1 &#x3D;&#x3D; arg2<br><code>ne</code>: arg1 !&#x3D; arg2<br><code>lt</code>: arg1 &lt; arg2<br><code>le</code>: arg1 &lt;&#x3D; arg2<br><code>gt</code>: arg1 &gt; arg2<br><code>ge</code>: arg1 &gt;&#x3D; arg2</p>
<p>eq 和其他函数不一样的地方是，支持多个参数，和下面的逻辑判断相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arg1==arg2 || arg1==arg3 || arg1==arg4 ...</span><br></pre></td></tr></table></figure>

<p>与 if 一起使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;if eq true .Var1 .Var2 .Var3&#125;&#125;&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123;if lt 100 200&#125;&#125;&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板处理"><a href="#模板处理" class="headerlink" title="模板处理"></a>模板处理</h2><p>beego 的模板处理引擎采用的是 Go 内置的 <code>html/template</code> 包进行处理，而且 beego 的模板处理逻辑是采用了缓存编译方式，也就是所有的模板会在 beego 应用启动的时候全部编译然后缓存在 map 里面。</p>
<h3 id="模板目录"><a href="#模板目录" class="headerlink" title="模板目录"></a>模板目录</h3><p>beego 中默认的模板目录是 <code>views</code>，用户可以把模板文件放到该目录下，beego 会自动在该目录下的所有模板文件进行解析并缓存，开发模式下每次都会重新解析，不做缓存。当然，用户也可以通过如下的方式改变模板的目录（只能指定一个目录为模板目录）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">beego.ViewsPath = <span class="string">&quot;myviewpath&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="自动渲染"><a href="#自动渲染" class="headerlink" title="自动渲染"></a>自动渲染</h3><p>用户无需手动的调用渲染输出模板，beego 会自动的在调用完相应的 method 方法之后调用 Render 函数，当然如果您的应用是不需要模板输出的，那么可以在配置文件或者在 <code>main.go</code> 中设置关闭自动渲染。</p>
<p>配置文件配置如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">autorender = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>main.go 文件中设置如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.AutoRender = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="模板标签"><a href="#模板标签" class="headerlink" title="模板标签"></a>模板标签</h3><p>Go 语言的默认模板采用了 <code>&#123;&#123;` 和 `&#125;&#125;</code> 作为左右标签，但是我们有时候在开发中可能界面是采用了 AngularJS 开发，他的模板也是这个标签，故而引起了冲突。在 beego 中你可以通过配置文件或者直接设置配置变量修改：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.TemplateLeft = <span class="string">&quot;&lt;&lt;&lt;&quot;</span></span><br><span class="line">web.TemplateRight = <span class="string">&quot;&gt;&gt;&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="模板数据"><a href="#模板数据" class="headerlink" title="模板数据"></a>模板数据</h3><p>模板中的数据是通过在 Controller 中 <code>this.Data</code> 获取的，所以如果你想在模板中获取内容 <code>&#123;&#123;.Content&#125;&#125;</code> ,那么你需要在 Controller 中如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.Data[&quot;Content&quot;] = &quot;value&quot;</span><br></pre></td></tr></table></figure>

<p>如何使用各种类型的数据渲染：</p>
<ol>
<li>结构体数据渲染</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">结构体：</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line"></span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">Gender <span class="type">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">赋值：</span><br><span class="line">c.Data[<span class="string">&quot;student&quot;</span>] = Student&#123;Name:<span class="string">&quot;知了&quot;</span>,Age:<span class="number">18</span>,Gender:<span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">前端使用：</span><br><span class="line">学生姓名：&#123;&#123;.student.Name&#125;&#125;</span><br><span class="line">学生年龄：&#123;&#123;.student.Age&#125;&#125;</span><br><span class="line">学生性别:&#123;&#123;.student.Gender&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：结构体中的字段要在其他地方使用，比如首字母大写</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数组数据渲染</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lista := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">c.Data[<span class="string">&quot;arr&quot;</span>] = lista</span><br><span class="line"></span><br><span class="line">前端：</span><br><span class="line"></span><br><span class="line">第一种：</span><br><span class="line">&#123;&#123;<span class="keyword">range</span> $i,$v := .arr&#125;&#125;</span><br><span class="line">&#123;&#123;$i&#125;&#125;</span><br><span class="line">&#123;&#123;$v&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">&#123;&#123;<span class="keyword">range</span> .arr&#125;&#125;</span><br><span class="line">&#123;&#123;.&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>结构体数组渲染</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">结构体：</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">Gender <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">赋值：</span><br><span class="line">arr_struct := [<span class="number">3</span>]student&#123;&#123;Name:<span class="string">&quot;hl&quot;</span>,Age:<span class="number">18</span>,Gender:<span class="string">&quot;男&quot;</span>&#125;,&#123;Name:<span class="string">&quot;hallen&quot;</span>,Age:<span class="number">19</span>,Gender:<span class="string">&quot;男&quot;</span>&#125;,&#123;Name:<span class="string">&quot;hallen1&quot;</span>,Age:<span class="number">191</span>,Gender:<span class="string">&quot;男&quot;</span>&#125;&#125;</span><br><span class="line">c.Data[<span class="string">&quot;arr_struct&quot;</span>] = arr_struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">前端获取：先循环数组，在获取结构体变量，注意是大写</span><br><span class="line">&#123;&#123;<span class="keyword">range</span> $v := .arr_struct&#125;&#125;</span><br><span class="line">&#123;&#123;$v.Name&#125;&#125;</span><br><span class="line">&#123;&#123;$v.Age&#125;&#125;</span><br><span class="line">&#123;&#123;$v.Gender&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;<span class="keyword">range</span> .books&#125;&#125;</span><br><span class="line">&#123;&#123;.Name&#125;&#125;</span><br><span class="line">&#123;&#123;.Author&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>map数据渲染</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//teacher :=map[string]string&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;18&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">teacher :=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">teacher[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;老王&quot;</span></span><br><span class="line"></span><br><span class="line">teacher[<span class="string">&quot;age&quot;</span>]=<span class="string">&quot;30&quot;</span></span><br><span class="line"></span><br><span class="line">c.Data[<span class="string">&quot;teacher&quot;</span>] = teacher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">前端：</span><br><span class="line"></span><br><span class="line">取出key对应的值</span><br><span class="line">&#123;&#123;.teacher.name&#125;&#125;</span><br><span class="line">&#123;&#123;.teacher.age&#125;&#125;</span><br><span class="line"></span><br><span class="line">取出所有的key和value：</span><br><span class="line">&#123;&#123;<span class="keyword">range</span> $k,$v := .teacher&#125;&#125;</span><br><span class="line">&#123;&#123;$k&#125;&#125;</span><br><span class="line">&#123;&#123;$v&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>结构体和map组合渲染</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">结构体：</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">Gender <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">赋值：</span><br><span class="line">mapa := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]student)</span><br><span class="line">mapa[<span class="number">101</span>] = student&#123;Name:<span class="string">&quot;张三1&quot;</span>,Age:<span class="number">181</span>,Gender:<span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line">mapa[<span class="number">102</span>] = student&#123;Name:<span class="string">&quot;张三2&quot;</span>,Age:<span class="number">182</span>,Gender:<span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line">mapa[<span class="number">103</span>] = student&#123;Name:<span class="string">&quot;张三3&quot;</span>,Age:<span class="number">183</span>,Gender:<span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line">c.Data[<span class="string">&quot;hero_map&quot;</span>] = mapa</span><br><span class="line"></span><br><span class="line">前端获取：先循环<span class="keyword">map</span>，在获取结构体变量，注意是大写</span><br><span class="line">&#123;&#123;<span class="keyword">range</span> $v :=.hero_map&#125;&#125;</span><br><span class="line">&#123;&#123;$v.Name&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>切片数据渲染</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">listb := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">c.Data[<span class="string">&quot;list_b&quot;</span>] = listb</span><br><span class="line"></span><br><span class="line">前端：只有一个值的时候默认是切片的元素，而不是角标</span><br><span class="line">&#123;&#123;<span class="keyword">range</span> $v := .list_b&#125;&#125;</span><br><span class="line">&#123;&#123;$v&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板名称"><a href="#模板名称" class="headerlink" title="模板名称"></a>模板名称</h3><p>beego 采用了 Go 语言内置的模板引擎，所有模板的语法和 Go 的一模一样，至于如何写模板文件，详细的请参考 <a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/07.4.md">模板教程</a>。</p>
<p>用户通过在 Controller 的对应方法中设置相应的模板名称，beego 会自动的在 viewpath 目录下查询该文件并渲染，例如下面的设置，beego 会在 admin 下面找 add.tpl 文件进行渲染：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.TplName = &quot;admin/add.tpl&quot;</span><br></pre></td></tr></table></figure>

<p>我们看到上面的模板后缀名是 tpl，beego 默认情况下支持 tpl 和 html 后缀名的模板文件，如果你的后缀名不是这两种，请进行如下设置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.AddTemplateExt(<span class="string">&quot;你文件的后缀名&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当你设置了自动渲染，然后在你的 Controller 中没有设置任何的 TplName，那么 beego 会自动设置你的模板文件如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.TplName = strings.ToLower(c.controllerName) + <span class="string">&quot;/&quot;</span> + strings.ToLower(c.actionName) + <span class="string">&quot;.&quot;</span> + c.TplExt</span><br></pre></td></tr></table></figure>

<p>也就是你对应的 Controller 名字+请求方法名.模板后缀，也就是如果你的 Controller 名是 <code>AddController</code>，请求方法是 <code>POST</code>，默认的文件后缀是 <code>tpl</code>，那么就会默认请求 <code>/viewpath/AddController/post.tpl</code> 文件。</p>
<h3 id="Layout-设计"><a href="#Layout-设计" class="headerlink" title="Layout 设计"></a>Layout 设计</h3><p>beego 支持 layout 设计，例如你在管理系统中，整个管理界面是固定的，只会变化中间的部分，那么你可以通过如下的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.Layout = &quot;admin/layout.html&quot;</span><br><span class="line">this.TplName = &quot;admin/add.tpl&quot;</span><br></pre></td></tr></table></figure>

<p>在 layout.html 中你必须设置如下的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;.LayoutContent&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>beego 就会首先解析 TplName 指定的文件，获取内容赋值给 LayoutContent，然后最后渲染 layout.html 文件。</p>
<p>目前采用首先把目录下所有的文件进行缓存，所以用户还可以通过类似这样的方式实现 layout：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;template &quot;header.html&quot; .&#125;&#125;</span><br><span class="line">Logic code</span><br><span class="line">&#123;&#123;template &quot;footer.html&quot; .&#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<blockquote>
<p>特别注意后面的<code>.</code>,这是传递当前参数到子模板</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="LayoutSection"><a href="#LayoutSection" class="headerlink" title="LayoutSection"></a>LayoutSection</h3><p>对于一个复杂的 <code>LayoutContent</code>，其中可能包括有javascript脚本、CSS 引用等，根据惯例，通常 css 会放到 Head 元素中，javascript 脚本需要放到 body 元素的末尾，而其它内容则根据需要放在合适的位置。在 <code>Layout</code> 页中仅有一个 <code>LayoutContent</code> 是不够的。所以在 <code>Controller</code> 中增加了一个 <code>LayoutSections</code>属性，可以允许 <code>Layout</code> 页中设置多个 <code>section</code>，然后每个 <code>section</code> 可以分别包含各自的子模板页。</p>
<p>layout_blog.tpl:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Lin Li<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap-theme.min.css&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;.HtmlHead&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;.LayoutContent&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;&#123;.SideBar&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://code.jquery.com/jquery-2.0.3.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    &#123;&#123;.Scripts&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>html_head.tpl:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">     <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">     &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>scripts.tpl：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(document).ready(function() &#123;</span><br><span class="line">        // bla bla bla</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>逻辑处理如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BlogsController <span class="keyword">struct</span> &#123;</span><br><span class="line">  web.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *BlogsController)</span></span> Get() &#123;</span><br><span class="line">	this.Layout = <span class="string">&quot;layout_blog.tpl&quot;</span></span><br><span class="line">	this.TplName = <span class="string">&quot;blogs/index.tpl&quot;</span></span><br><span class="line">	this.LayoutSections = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	this.LayoutSections[<span class="string">&quot;HtmlHead&quot;</span>] = <span class="string">&quot;blogs/html_head.tpl&quot;</span></span><br><span class="line">	this.LayoutSections[<span class="string">&quot;Scripts&quot;</span>] = <span class="string">&quot;blogs/scripts.tpl&quot;</span></span><br><span class="line">	this.LayoutSections[<span class="string">&quot;Sidebar&quot;</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="renderform-使用"><a href="#renderform-使用" class="headerlink" title="renderform 使用"></a>renderform 使用</h3><p>定义 struct:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="type">int</span>         <span class="string">`form:&quot;-&quot;`</span></span><br><span class="line">	Name  <span class="keyword">interface</span>&#123;&#125; <span class="string">`form:&quot;username&quot;`</span></span><br><span class="line">	Age   <span class="type">int</span>         <span class="string">`form:&quot;age,text,年龄：&quot;`</span></span><br><span class="line">	Sex   <span class="type">string</span></span><br><span class="line">	Intro <span class="type">string</span> <span class="string">`form:&quot;,textarea&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>StructTag 的定义用的标签用为 <code>form</code>，和 <a href="https://git-books.github.io/books/beego/controller/params.md#%E7%9B%B4%E6%8E%A5%E8%A7%A3%E6%9E%90%E5%88%B0-struct">ParseForm 方法</a> 共用一个标签，标签后面有三个可选参数，用 <code>,</code> 分割。第一个参数为表单中类型的 <code>name</code> 的值，如果为空，则以 <code>struct field name</code> 为值。第二个参数为表单组件的类型，如果为空，则为 <code>text</code>。表单组件的标签默认为 <code>struct field name</code> 的值，否则为第三个值。</li>
<li>如果 <code>form</code> 标签只有一个值，则为表单中类型 <code>name</code> 的值，除了最后一个值可以忽略外，其他位置的必须要有 <code>,</code> 号分割，如：<code>form:&quot;,,姓名：&quot;</code></li>
<li>如果要忽略一个字段，有两种办法，一是：字段名小写开头，二是：<code>form</code> 标签的值设置为 <code>-</code></li>
<li>现在的代码版本只能实现固定的格式，用 br 标签实现换行，无法实现 css 和 class 等代码的插入。所以，要实现 form 的高级排版，不能使用 renderform 的方法，而需要手动处理每一个字段。</li>
</ul>
<p>controller：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddController)</span></span> Get() &#123;</span><br><span class="line">	this.Data[<span class="string">&quot;Form&quot;</span>] = &amp;User&#123;&#125;</span><br><span class="line">	this.TplName = <span class="string">&quot;index.tpl&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Form 的参数必须是一个 struct 的指针。</p>
<p>template:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&#123;&#123;.Form | renderform&#125;&#125;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>上面的代码生成的表单为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">Sex: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;Sex&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">Intro: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;Intro&quot;</span> <span class="attr">type</span>=<span class="string">&quot;textarea&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h2><p>beego 支持用户定义模板函数，但是必须在 <code>web.Run()</code> 调用之前，设置如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(in <span class="type">string</span>)</span></span>(out <span class="type">string</span>)&#123;</span><br><span class="line">    out = in + <span class="string">&quot;world&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">web.AddFuncMap(<span class="string">&quot;hi&quot;</span>,hello)</span><br></pre></td></tr></table></figure>

<p>定义之后你就可以在模板中这样使用了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;.Content | hi&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>目前 beego 内置的模板函数如下所示：</p>
<ul>
<li><p>dateformat</p>
<p>实现了时间的格式化，返回字符串，使用方法 <code>&#123;&#123;dateformat .Time "2006-01-02T15:04:05Z07:00"&#125;&#125;</code>。</p>
</li>
<li><p>date</p>
<p>实现了类似 PHP 的 date 函数，可以很方便的根据字符串返回时间，使用方法 <code>&#123;&#123;date .T "Y-m-d H:i:s"&#125;&#125;</code>。</p>
</li>
<li><p>compare</p>
<p>实现了比较两个对象的比较，如果相同返回 true，否者 false，使用方法 <code>&#123;&#123;compare .A .B&#125;&#125;</code>。</p>
</li>
<li><p>substr</p>
<p>实现了字符串的截取，支持中文截取的完美截取，使用方法<code> &#123;&#123;substr .Str 0 30&#125;&#125;</code>。</p>
</li>
<li><p>html2str</p>
<p>实现了把 html 转化为字符串，剔除一些 script、css 之类的元素，返回纯文本信息，使用方法 <code>&#123;&#123;html2str .Htmlinfo&#125;&#125;</code>。</p>
</li>
<li><p>str2html</p>
<p>实现了把相应的字符串当作 HTML 来输出，不转义，使用方法 <code>&#123;&#123;str2html .Strhtml&#125;&#125;</code>。</p>
</li>
<li><p>htmlquote</p>
<p>实现了基本的 html 字符转义，使用方法<code> &#123;&#123;htmlquote .quote&#125;&#125;</code>。</p>
</li>
<li><p>htmlunquote</p>
<p>实现了基本的反转移字符，使用方法 <code>&#123;&#123;htmlunquote .unquote&#125;&#125;</code>。</p>
</li>
<li><p>renderform</p>
<p>根据 StructTag 直接生成对应的表单，使用方法 <code>&#123;&#123;&struct | renderform&#125;&#125;</code>。</p>
</li>
<li><p>assets_js</p>
<p>为 js 文件生成一个 <code>&lt;script&gt;</code> 标签. 使用方法 <code>&#123;&#123;assets_js src&#125;&#125;</code></p>
</li>
<li><p>assets_css</p>
<p>为 css 文件生成一个 <code>&lt;link&gt;</code> 标签. 使用方法 <code>&#123;&#123;assets_css src&#125;&#125;</code></p>
</li>
<li><p>config</p>
<p>获取 AppConfig 的值. 使用方法 {<code>&#123;config configType configKey defaultValue&#125;&#125;</code>. 可选的 configType 有 String, Bool, Int, Int64, Float, DIY</p>
</li>
<li><p>map_get</p>
<p>获取 <code>map</code> 的值</p>
<p>用法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// In controller</span><br><span class="line">Data[&quot;m&quot;] = map[string]interface&#123;&#125; &#123;</span><br><span class="line">    &quot;a&quot;: 1,</span><br><span class="line">    &quot;1&quot;: map[string]float64&#123;</span><br><span class="line">        &quot;c&quot;: 4,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">// In view</span><br><span class="line">&#123;&#123; map_get .m &quot;a&quot; &#125;&#125; // return 1</span><br><span class="line">&#123;&#123; map_get .m 1 &quot;c&quot; &#125;&#125; // return 4</span><br></pre></td></tr></table></figure>
</li>
<li><p>urlfor</p>
<p>获取控制器方法的 URL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;urlfor &quot;TestController.List&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="静态文件处理-1"><a href="#静态文件处理-1" class="headerlink" title="静态文件处理"></a>静态文件处理</h2><p>Go 语言内部其实已经提供了 <code>http.ServeFile</code>，通过这个函数可以实现静态文件的服务。beego 针对这个功能进行了一层封装，通过下面的方式进行静态文件注册：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.SetStaticPath(<span class="string">&quot;/static&quot;</span>,<span class="string">&quot;public&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数是路径，url 路径信息</li>
<li>第二个参数是静态文件目录（相对应用所在的目录）</li>
</ul>
<p>beego 支持多个目录的静态文件注册，用户可以注册如下的静态文件目录：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web.SetStaticPath(<span class="string">&quot;/images&quot;</span>,<span class="string">&quot;images&quot;</span>)</span><br><span class="line">web.SetStaticPath(<span class="string">&quot;/css&quot;</span>,<span class="string">&quot;css&quot;</span>)</span><br><span class="line">web.SetStaticPath(<span class="string">&quot;/js&quot;</span>,<span class="string">&quot;js&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>设置了如上的静态目录之后，用户访问 <code>/images/login/login.png</code>，那么就会访问应用对应的目录下面的 <code>images/login/login.png</code> 文件。如果是访问 <code>/static/img/logo.png</code>，那么就访问 <code>public/img/logo.png</code>文件。</p>
<p>默认情况下 beego 会判断目录下文件是否存在，不存在直接返回 404 页面，如果请求的是 <code>index.html</code>，那么由于 <code>http.ServeFile</code> 默认是会跳转的，不提供该页面的显示。因此 beego 可以设置 <code>web.BConfig.WebConfig.DirectoryIndex=true</code> 这样来使得显示 <code>index.html</code> 页面。而且开启该功能之后，用户访问目录就会显示该目录下所有的文件列表。</p>
]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型与输入输出</title>
    <url>/2023/06/02/Go/5/</url>
    <content><![CDATA[<h1 id="基本语法——数据类型"><a href="#基本语法——数据类型" class="headerlink" title="基本语法——数据类型"></a>基本语法——数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>以下是go中可用的基本数据类型</p>
<p><a href="https://smms.app/image/mkKRra8JejXWM4V" target="_blank"><img src="https://s2.loli.net/2023/06/02/mkKRra8JejXWM4V.jpg" ></a></p>
<h3 id="布尔型bool"><a href="#布尔型bool" class="headerlink" title="布尔型bool"></a>布尔型bool</h3><p>布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool &#x3D; true</p>
<h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><p><strong>1、</strong>整数型</p>
<ul>
<li><p>int8<br>有符号 8 位整型 (-128 到 127)<br>长度：8bit</p>
</li>
<li><p>int16<br>有符号 16 位整型 (-32768 到 32767)</p>
</li>
<li><p>int32<br>有符号 32 位整型 (-2147483648 到 2147483647)</p>
</li>
<li><p>int64<br>有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</p>
</li>
<li><p>uint8<br>无符号 8 位整型 (0 到 255)<br>8位都用于表示数值：</p>
</li>
<li><p>uint16<br>无符号 16 位整型 (0 到 65535)</p>
</li>
<li><p>uint32<br>无符号 32 位整型 (0 到 4294967295)</p>
</li>
<li><p>uint64<br>无符号 64 位整型 (0 到 18446744073709551615)</p>
</li>
</ul>
<blockquote>
<p>int和uint:根据底层平台，表示32或64位整数。除非需要使用特定大小的整数，否则通常应该使用int来表示整数。<br>大小:32位系统32位，64位系统64位。<br>范围:-2147483648到2147483647的32位系统和-9223372036854775808到9223372036854775807的64位系统。</p>
</blockquote>
<p><strong>2、浮点型</strong></p>
<ul>
<li><p>float32</p>
<p>IEEE-754 32位浮点型数</p>
</li>
<li><p>float64</p>
<p>IEEE-754 64位浮点型数</p>
</li>
<li><p>complex64</p>
<p>32 位实数和虚数</p>
</li>
<li><p>complex128</p>
<p>64 位实数和虚数</p>
</li>
</ul>
<p><strong>3、其他</strong></p>
<ul>
<li><p>byte</p>
<p>类似 uint8</p>
</li>
<li><p>rune</p>
<p>类似 int32</p>
</li>
<li><p>uint</p>
<p>32 或 64 位</p>
</li>
<li><p>int</p>
<p>与 uint 一样大小</p>
</li>
<li><p>uintptr</p>
<p>无符号整型，用于存放一个指针</p>
</li>
</ul>
<h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><p>字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line">str = <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="数据类型转换：Type-Convert"><a href="#数据类型转换：Type-Convert" class="headerlink" title="数据类型转换：Type Convert"></a>数据类型转换：Type Convert</h3><p>语法格式：Type(Value)</p>
<p>常数：在有需要的时候，会自动转型</p>
<p>变量：需要手动转型	T(V)</p>
<p>注意点：兼容类型可以转换</p>
<h2 id="复合类型-派生类型"><a href="#复合类型-派生类型" class="headerlink" title="复合类型(派生类型)"></a>复合类型(派生类型)</h2><p>1、指针类型（Pointer）<br>2、数组类型<br>3、结构化类型(struct)<br>4、Channel 类型<br>5、函数类型<br>6、切片类型<br>7、接口类型（interface）<br>8、Map 类型</p>
<h1 id="键盘输入和打印输出"><a href="#键盘输入和打印输出" class="headerlink" title="键盘输入和打印输出"></a>键盘输入和打印输出</h1><h2 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h2><h3 id="fmt包"><a href="#fmt包" class="headerlink" title="fmt包"></a>fmt包</h3><p>fmt包实现了类似C语言printf和scanf的格式化I&#x2F;O。格式化verb（’verb’）源自C语言但更简单。</p>
<p>详见官网fmt的API：<a href="https://golang.google.cn/pkg/fmt/">https://golang.google.cn/pkg/fmt/</a></p>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="常用打印函数"><a href="#常用打印函数" class="headerlink" title="常用打印函数"></a>常用打印函数</h3><p><strong>打印：</strong></p>
<p><a href="https://golang.google.cn/pkg/fmt/#Print">func Print(a …interface{}) (n int, err error)</a></p>
<p><strong>格式化打印：</strong></p>
<p><a href="https://golang.google.cn/pkg/fmt/#Printf">func Printf(format string, a …interface{}) (n int, err error)</a></p>
<p><strong>打印后换行</strong></p>
<p><a href="https://golang.google.cn/pkg/fmt/#Println">func Println(a …interface{}) (n int, err error)</a></p>
<p>格式化打印中的常用占位符：</p>
<blockquote>
<p>格式化打印占位符：<br>            %v,原样输出<br>            %T，打印类型<br>            %t,bool类型<br>            %s，字符串<br>            %f，浮点<br>            %d，10进制的整数<br>            %b，2进制的整数<br>            %o，8进制<br>            %x，%X，16进制<br>                %x：0-9，a-f<br>                %X：0-9，A-F<br>            %c，打印字符<br>            %p，打印地址</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">100</span>           <span class="comment">//int</span></span><br><span class="line">	b := <span class="number">3.14</span>          <span class="comment">//float64</span></span><br><span class="line">	c := <span class="literal">true</span>          <span class="comment">// bool</span></span><br><span class="line">	d := <span class="string">&quot;Hello World&quot;</span> <span class="comment">//string</span></span><br><span class="line">	e := <span class="string">`Ruby`</span>        <span class="comment">//string</span></span><br><span class="line">	f := <span class="string">&#x27;A&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%b\n&quot;</span>, a, a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%f\n&quot;</span>, b, b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%t\n&quot;</span>, c, c)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%s\n&quot;</span>, d, d)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%s\n&quot;</span>, e, e)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%d,%c\n&quot;</span>, f, f, f)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, c)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, d)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, e)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, f)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int,1100100</span><br><span class="line">float64,3.140000</span><br><span class="line">bool,true</span><br><span class="line">string,Hello World</span><br><span class="line">string,Ruby</span><br><span class="line">int32,65,A</span><br><span class="line">-----------------------</span><br><span class="line">100</span><br><span class="line">3.14</span><br><span class="line">true</span><br><span class="line">Hello World</span><br><span class="line">Ruby</span><br><span class="line">65</span><br></pre></td></tr></table></figure>



<h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><h3 id="fmt包读取键盘输入"><a href="#fmt包读取键盘输入" class="headerlink" title="fmt包读取键盘输入"></a>fmt包读取键盘输入</h3><p>常用方法：</p>
<ul>
<li><a href="https://golang.google.cn/pkg/fmt/#Scan">func Scan(a …interface{}) (n int, err error)</a></li>
</ul>
<p>​		Scan 从标准输入扫描文本，读取由 <strong>空白符</strong> 分隔的值分别保存到本函数的参数中。（换行符也被视为空白符）</p>
<ul>
<li><p><a href="https://golang.google.cn/pkg/fmt/#Scanf">func Scanf(format string, a …interface{}) (n int, err error)</a></p>
<p>Scanf从标准输入扫描文本，按照 format 参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。</p>
</li>
<li><p><a href="https://golang.google.cn/pkg/fmt/#Scanln">func Scanln(a …interface{}) (n int, err error)</a></p>
<p>Scanln类似Scan，它在遇到换行时停止扫描。最后一个数据后面必须有换行或者到达结束位置。</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> y <span class="type">float64</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入一个整数，一个浮点类型：&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;x,&amp;y)<span class="comment">//读取键盘的输入，通过操作地址，赋值给x和y   阻塞式</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;x的数值：%d，y的数值：%f\n&quot;</span>,x,y)</span><br><span class="line"></span><br><span class="line">	fmt.Scanf(<span class="string">&quot;%d,%f&quot;</span>,&amp;x,&amp;y)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;x:%d,y:%f\n&quot;</span>,x,y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入一个整数，一个浮点类型：</span><br><span class="line">100 3.14</span><br><span class="line">x的数值：100，y的数值：3.140000</span><br><span class="line">100,5.20</span><br><span class="line">x:100,y:5.200000</span><br></pre></td></tr></table></figure>

<h3 id="bufio包读取"><a href="#bufio包读取" class="headerlink" title="bufio包读取"></a>bufio包读取</h3><p><a href="https://golang.google.cn/pkg/bufio/">https://golang.google.cn/pkg/bufio/</a></p>
<p>bufio包中都是IO操作的方法：</p>
<p>先创建Reader对象,然后就可以各种读取了。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入一个字符串：&quot;</span>)</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	s1, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;读到的数据：&quot;</span>, s1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入一个字符串：</span><br><span class="line">hello wxy</span><br><span class="line">读到的数据： hello wxy</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>reader := bufio.NewReader(os.Stdin)</code>：这行代码创建了一个用于读取用户输入的读取器。<code>bufio.NewReader</code> 函数接受一个参数 <code>os.Stdin</code>，它表示标准输入（通常是键盘输入）。<code>reader</code> 是一个读取器对象，我们可以使用它来读取用户输入的字符串。</li>
<li><code>s1, _ := reader.ReadString(&#39;\n&#39;)</code>：这行代码使用读取器 <code>reader</code> 从标准输入读取字符串，直到遇到换行符 (<code>&#39;\n&#39;</code>) 为止。它将读取的字符串赋值给变量 <code>s1</code>。注意，这里使用了 <code>_</code>（下划线）来忽略函数的第二个返回值（表示可能的错误），因为我们不关心错误处理。</li>
</ul>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>数组&amp;切片&amp;集合&amp;字符串</title>
    <url>/2023/06/03/Go/7/</url>
    <content><![CDATA[<h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h1><h2 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h2><p>Go 语言提供了数组类型的数据结构。<br>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。</p>
<p>数组元素可以通过索引（位置）来读取（或者修改），索引从0开始，第一个元素索引为 0，第二个索引为 1，以此类推。数组的下标取值范围是从0开始，到长度减1。</p>
<p>数组一旦定义后，大小不能更改。</p>
<h2 id="数组的语法"><a href="#数组的语法" class="headerlink" title="数组的语法"></a>数组的语法</h2><p><strong>声明和初始化数组</strong></p>
<p>需要指明数组的大小和存储的数据类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>] <span class="type">float32</span></span><br><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>初始化数组中 {} 中的元素个数不能大于 [] 中的数字。<br>如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance = []<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span></span><br></pre></td></tr></table></figure>

<p>数组的其他创建方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">4</span>] <span class="type">float32</span> <span class="comment">// 等价于：var arr2 = [4]float32&#123;&#125;</span></span><br><span class="line">fmt.Println(a) <span class="comment">// [0 0 0 0]</span></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">5</span>] <span class="type">string</span>&#123;<span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;王二狗&quot;</span>, <span class="string">&quot;rose&quot;</span>&#125;</span><br><span class="line">fmt.Println(b) <span class="comment">// [ruby 王二狗 rose  ]</span></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">5</span>] <span class="type">int</span>&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125; <span class="comment">// byte</span></span><br><span class="line">fmt.Println(c) <span class="comment">// [65 66 67 68 69]</span></span><br><span class="line">d := [...] <span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">// 根据元素的个数，设置数组的大小</span></span><br><span class="line">fmt.Println(d)<span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">e := [<span class="number">5</span>] <span class="type">int</span>&#123;<span class="number">4</span>: <span class="number">100</span>&#125; <span class="comment">// [0 0 0 0 100]</span></span><br><span class="line">fmt.Println(e)</span><br><span class="line">f := [...] <span class="type">int</span>&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">1</span>, <span class="number">9</span>: <span class="number">1</span>&#125; <span class="comment">// [1 0 0 0 1 0 0 0 0 1]</span></span><br><span class="line">fmt.Println(f)</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p><code>0: 1</code> 表示将索引为 0 的位置的元素初始化为 1，<code>4: 1</code> 表示将索引为 4 的位置的元素初始化为 1，<code>9: 1</code> 表示将索引为 9 的位置的元素初始化为 1。其余位置的元素将使用默认值进行初始化，对于整数数组，默认值为 0。</p>
<p><strong>访问数组元素</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">float32</span> salary = balance[<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> n [<span class="number">10</span>]<span class="type">int</span> <span class="comment">/* n 是一个长度为 10 的数组 */</span></span><br><span class="line">   <span class="keyword">var</span> i,j <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 为数组 n 初始化元素 */</span>         </span><br><span class="line">   <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      n[i] = i + <span class="number">100</span> <span class="comment">/* 设置元素为 i + 100 */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 输出每个数组元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Element[%d] = %d\n&quot;</span>, j, n[j] )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Element[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">Element[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">Element[<span class="number">2</span>] = <span class="number">102</span></span><br><span class="line">Element[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line">Element[<span class="number">4</span>] = <span class="number">104</span></span><br><span class="line">Element[<span class="number">5</span>] = <span class="number">105</span></span><br><span class="line">Element[<span class="number">6</span>] = <span class="number">106</span></span><br><span class="line">Element[<span class="number">7</span>] = <span class="number">107</span></span><br><span class="line">Element[<span class="number">8</span>] = <span class="number">108</span></span><br><span class="line">Element[<span class="number">9</span>] = <span class="number">109</span></span><br></pre></td></tr></table></figure>

<p><strong>数组的长度</strong></p>
<p>通过将数组作为参数传递给len函数，可以获得数组的长度。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="type">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;length of a is&quot;</span>,<span class="built_in">len</span>(a))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">length of a is 4</span><br></pre></td></tr></table></figure>

<p>您甚至可以忽略声明中数组的长度并将其替换为…让编译器为你找到长度。这是在下面的程序中完成的。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="type">int</span>&#123;<span class="number">12</span>, <span class="number">78</span>, <span class="number">50</span>&#125; <span class="comment">// ... makes the compiler determine the length</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[12 78 50]</span><br></pre></td></tr></table></figure>

<p>遍历数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="type">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123; <span class="comment">//looping from 0 to the length of the array</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d th element of a is %.2f\n&quot;</span>, i, a[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 th element of a is 67.70</span><br><span class="line">1 th element of a is 89.80</span><br><span class="line">2 th element of a is 21.00</span><br><span class="line">3 th element of a is 78.00</span><br></pre></td></tr></table></figure>

<p>使用range遍历数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="type">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    sum := <span class="type">float64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;<span class="comment">//range returns both the index and value</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d the element of a is %.2f\n&quot;</span>, i, v)</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;\nsum of all elements of a&quot;</span>,sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 the element of a is 67.70</span><br><span class="line">1 the element of a is 89.80</span><br><span class="line">2 the element of a is 21.00</span><br><span class="line">3 the element of a is 78.00</span><br><span class="line"></span><br><span class="line">sum of all elements of a 256.5</span><br></pre></td></tr></table></figure>

<p>如果您只需要值并希望忽略索引，那么可以通过使用_ blank标识符替换索引来实现这一点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123; <span class="comment">//ignores index  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go 语言支持多维数组，以下为常用的多维数组声明语法方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threedim [<span class="number">5</span>][<span class="number">10</span>][<span class="number">4</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>三维数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span>&#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;   <span class="comment">/*  第三行索引为 2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">			twoD[i][j] = i + j</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;2d: &quot;</span>, twoD)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2d:  [[0 1 2] [1 2 3]]</span><br></pre></td></tr></table></figure>

<h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h2><p>Go中的数组是值类型，而不是引用类型。这意味着当它们被分配给一个新变量时，将把原始数组的副本分配给新变量。如果对新变量进行了更改，则不会在原始数组中反映。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="type">string</span>&#123;<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;China&quot;</span>, <span class="string">&quot;India&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;France&quot;</span>&#125;</span><br><span class="line">    b := a <span class="comment">// a copy of a is assigned to b</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&quot;Singapore&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a is &quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;b is &quot;</span>, b) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a is [USA China India Germany France]  </span><br><span class="line">b is [Singapore China India Germany France] </span><br></pre></td></tr></table></figure>

<p>数组的大小是类型的一部分。因此[5]int和[25]int是不同的类型。因此，数组不能被调整大小。不要担心这个限制，因为切片的存在是为了解决这个问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">78</span>, <span class="number">8</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    b = a <span class="comment">//not possible since [3]int and [5]int are distinct types</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片(Slice)"></a>切片(Slice)</h1><h2 id="什么是切片"><a href="#什么是切片" class="headerlink" title="什么是切片"></a>什么是切片</h2><p><em><strong>Go 语言切片是对数组的抽象</strong></em>。<br>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大<br>切片是一种方便、灵活且强大的包装器。切片本身没有任何数据。它们只是对现有数组的引用。<br>切片与数组相比，不需要设定长度，在[]中不用设定值，相对来说比较自由<br>从概念上面来说slice像一个结构体，这个结构体包含了三个元素： </p>
<blockquote>
<ol>
<li>指针，指向数组中slice指定的开始位置</li>
<li>长度，即slice的长度</li>
<li>最大长度，也就是slice开始位置到数组的最后位置的长度</li>
</ol>
</blockquote>
<h2 id="切片的语法"><a href="#切片的语法" class="headerlink" title="切片的语法"></a>切片的语法</h2><p><strong>定义切片</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>切片不需要说明长度。<br>或使用make()函数来创建切片:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">//也可以简写为</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s :=[] <span class="type">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:endIndex] </span><br></pre></td></tr></table></figure>

<p>将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片（<strong>前闭后开</strong>），长度为endIndex-startIndex</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:] </span><br></pre></td></tr></table></figure>

<p>缺省endIndex时将表示一直到arr的最后一个元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[:endIndex] </span><br></pre></td></tr></table></figure>

<p>缺省startIndex时将表示从arr的第一个元素开始</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="type">int</span> = a[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//creates a slice from a[1] to a[3]</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改切片"><a href="#修改切片" class="headerlink" title="修改切片"></a>修改切片</h2><p>slice没有自己的任何数据。它只是底层数组的一个表示。对slice所做的任何修改都将反映在底层数组中。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    darr := [...]<span class="type">int</span>&#123;<span class="number">57</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">82</span>, <span class="number">100</span>, <span class="number">78</span>, <span class="number">67</span>, <span class="number">69</span>, <span class="number">59</span>&#125;</span><br><span class="line">    dslice := darr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;array before&quot;</span>,darr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dslice &#123;</span><br><span class="line">        dslice[i]++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;array after&quot;</span>,darr) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，<code>range</code> 遍历 <code>dslice</code> 时返回的是索引，而不是值。切片是对数组的引用，因此<em><strong>修改切片的值也会影响到原始数组</strong></em>。</p>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array before [57 89 90 82 100 78 67 69 59]  </span><br><span class="line">array after [57 89 91 83 101 78 67 69 59]  </span><br></pre></td></tr></table></figure>

<p>当多个片共享相同的底层数组时，每个元素所做的更改将在数组中反映出来。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    numa := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">78</span>, <span class="number">79</span> ,<span class="number">80</span>&#125;</span><br><span class="line">    nums1 := numa[:] <span class="comment">//creates a slice which contains all elements of the array</span></span><br><span class="line">    nums2 := numa[:]</span><br><span class="line">    fmt.Println(<span class="string">&quot;array before change 1&quot;</span>,numa)</span><br><span class="line">    nums1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;array after modification to slice nums1&quot;</span>, numa)</span><br><span class="line">    nums2[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;array after modification to slice nums2&quot;</span>, numa)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array before change 1 [78 79 80]  </span><br><span class="line">array after modification to slice nums1 [100 79 80]  </span><br><span class="line">array after modification to slice nums2 [100 101 80]  </span><br></pre></td></tr></table></figure>

<h2 id="len-和-cap"><a href="#len-和-cap" class="headerlink" title="len() 和 cap()"></a>len() 和 cap()</h2><p>切片的长度是切片中元素的数量。切片的容量是从创建切片的索引开始的底层数组中元素的数量。</p>
<p>切片是可索引的，并且可以由 len() 方法获取长度<br>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>make([]int, 3, 5)</code> 创建了一个切片 <code>numbers</code>，长度为 3，容量为 5。<code>make</code> 函数用于创建切片、映射和通道，并指定它们的长度和容量。</p>
<p>运行结果:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">3</span> <span class="built_in">cap</span>=<span class="number">5</span> slice=[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>空切片</strong></p>
<p>一个切片在未初始化之前默认为 nil，长度为 0</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">len=0 cap=0 slice=[]</span><br><span class="line">切片是空的</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;   </span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers ==&quot;</span>, numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[1:4] ==&quot;</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[:3] ==&quot;</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[4:] ==&quot;</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">9</span> <span class="built_in">cap</span>=<span class="number">9</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line">numbers == [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line">numbers[<span class="number">1</span>:<span class="number">4</span>] == [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">numbers[:<span class="number">3</span>] == [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">numbers[<span class="number">4</span>:] == [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">5</span> slice=[]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">9</span> slice=[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">3</span> <span class="built_in">cap</span>=<span class="number">7</span> slice=[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>切片的容量（<code>cap</code>）是指切片的底层数组中从切片的起始位置到数组末尾的元素数量。在这个例子中，切片 <code>numbers</code> 的容量与底层数组的容量相同，都是 9。这是因为我们没有指定切片的容量，Go语言会默认将切片的容量设置为底层数组中剩余的元素数量。<code>number2</code> 的容量是从切片的起始位置到底层数组的末尾，即剩余的元素数量。<code>number2</code> 的容量是 9，与底层数组的容量相同。<code>number3</code> 的容量是 7，因为从索引 2 开始，底层数组中还有 7 个元素。</p>
<h2 id="append-和-copy"><a href="#append-和-copy" class="headerlink" title="append() 和 copy()"></a>append() 和 copy()</h2><p>append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice<br>copy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数</p>
<p>append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩余空间（即(cap-len) &#x3D;&#x3D; 0）时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响</p>
<p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">len=0 cap=0 slice=[]</span><br><span class="line">len=1 cap=1 slice=[0]</span><br><span class="line">len=2 cap=2 slice=[0 1]</span><br><span class="line">len=5 cap=6 slice=[0 1 2 3 4]</span><br><span class="line">len=5 cap=12 slice=[0 1 2 3 4]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>numbers容量为6是因为在分配底层数组时，系统会根据策略进行内存分配，通常是分配比所需容量稍微多一点的容量。所以，在这个例子中，底层数组的容量被分配为了6。</p>
<p>numbers1与numbers两者不存在联系，numbers发生变化时，numbers1是不会随着变化的。也就是说copy方法是不会建立两个切片的联系的</p>
</blockquote>
<h1 id="集合-Map"><a href="#集合-Map" class="headerlink" title="集合(Map)"></a>集合(Map)</h1><h2 id="什么是Map"><a href="#什么是Map" class="headerlink" title="什么是Map"></a>什么是Map</h2><p>map是Go中的内置类型，它将一个值与一个键关联起来。可以使用相应的键检索值。</p>
<p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值<br>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的，也是引用类型</p>
<p>使用map过程中需要注意的几点： </p>
<ul>
<li>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取</li>
<li>map的长度是不固定的，也就是和slice一样，也是一种引用类型</li>
<li>内置的len函数同样适用于map，返回map拥有的key的数量 </li>
<li>map的key可以是所有可比较的类型，如布尔型、整数型、浮点型、复杂型、字符串型……也可以键。</li>
</ul>
<h2 id="Map的使用"><a href="#Map的使用" class="headerlink" title="Map的使用"></a>Map的使用</h2><h3 id="使用make-创建map"><a href="#使用make-创建map" class="headerlink" title="使用make()创建map"></a>使用make()创建map</h3><p>可以使用内建函数 make 也可以使用 map 关键字来定义 Map:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable = <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rating := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span> &#123;<span class="string">&quot;C&quot;</span>:<span class="number">5</span>, <span class="string">&quot;Go&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;Python&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;C++&quot;</span>:<span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">   <span class="comment">/* 创建集合 */</span></span><br><span class="line">   countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* map 插入 key-value 对，各个国家对应的首都 */</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;France&quot;</span>] = <span class="string">&quot;Paris&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Italy&quot;</span>] = <span class="string">&quot;Rome&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Japan&quot;</span>] = <span class="string">&quot;Tokyo&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;India&quot;</span>] = <span class="string">&quot;New Delhi&quot;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 使用 key 输出 map 值 */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 查看元素在集合中是否存在 */</span></span><br><span class="line">   captial, ok := countryCapitalMap[<span class="string">&quot;United States&quot;</span>]</span><br><span class="line">   <span class="comment">/* 如果 ok 是 true, 则存在，否则不存在 */</span></span><br><span class="line">   <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is&quot;</span>, captial)  </span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is not present&quot;</span>) </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k, v) <span class="comment">// b 8; a A</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;key&quot;</span>, k) <span class="comment">// key a; key b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Capital of France is Paris</span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br><span class="line">Capital of United States is not present</span><br><span class="line">a A</span><br><span class="line">b B</span><br><span class="line">key a</span><br><span class="line">key b</span><br></pre></td></tr></table></figure>

<h3 id="delete-函数"><a href="#delete-函数" class="headerlink" title="delete() 函数"></a>delete() 函数</h3><p>delete(map, key) 函数用于删除集合的元素, 参数为 map 和其对应的 key。删除函数不返回任何值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">   <span class="comment">/* 创建 map */</span></span><br><span class="line">   countryCapitalMap := <span class="keyword">map</span>[<span class="type">string</span>] <span class="type">string</span> &#123;<span class="string">&quot;France&quot;</span>:<span class="string">&quot;Paris&quot;</span>,<span class="string">&quot;Italy&quot;</span>:<span class="string">&quot;Rome&quot;</span>,<span class="string">&quot;Japan&quot;</span>:<span class="string">&quot;Tokyo&quot;</span>,<span class="string">&quot;India&quot;</span>:<span class="string">&quot;New Delhi&quot;</span>&#125;</span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">&quot;原始 map&quot;</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 删除元素 */</span></span><br><span class="line">   <span class="built_in">delete</span>(countryCapitalMap,<span class="string">&quot;France&quot;</span>);</span><br><span class="line">   fmt.Println(<span class="string">&quot;Entry for France is deleted&quot;</span>)  </span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">&quot;删除元素后 map&quot;</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始 map</span><br><span class="line">Capital of France is Paris</span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br><span class="line">Entry for France is deleted</span><br><span class="line">删除元素后 map</span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br></pre></td></tr></table></figure>

<h3 id="ok-idiom"><a href="#ok-idiom" class="headerlink" title="ok-idiom"></a>ok-idiom</h3><p>我们可以通过key获取map中对应的value值。语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[key] </span><br></pre></td></tr></table></figure>

<p>但是当key如果不存在的时候，我们会得到该value值类型的默认值，比如string类型得到空字符串，int类型得到0。但是程序不会报错。</p>
<p>所以我们可以使用ok-idiom获取值，可知道key&#x2F;value是否存在</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key] </span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">	x, ok := m[<span class="string">&quot;b&quot;</span>]</span><br><span class="line">	fmt.Println(x, ok)</span><br><span class="line">	x, ok = m[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">	fmt.Println(x, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br><span class="line"><span class="number">1</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="map的长度"><a href="#map的长度" class="headerlink" title="map的长度"></a>map的长度</h3><p>使用len函数可以确定map的长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="keyword">map</span>)  <span class="comment">// 可以得到map的长度</span></span><br></pre></td></tr></table></figure>

<h3 id="map是引用类型"><a href="#map是引用类型" class="headerlink" title="map是引用类型"></a>map是引用类型</h3><p>与切片相似，映射是引用类型。当将映射分配给一个新变量时，它们都指向相同的内部数据结构。因此，一个的变化会反映另一个。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    personSalary := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="string">&quot;steve&quot;</span>: <span class="number">12000</span>,</span><br><span class="line">        <span class="string">&quot;jamie&quot;</span>: <span class="number">15000</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    personSalary[<span class="string">&quot;mike&quot;</span>] = <span class="number">9000</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Original person salary&quot;</span>, personSalary)</span><br><span class="line">    newPersonSalary := personSalary</span><br><span class="line">    newPersonSalary[<span class="string">&quot;mike&quot;</span>] = <span class="number">18000</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Person salary changed&quot;</span>, personSalary)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Original person salary map[steve:12000 jamie:15000 mike:9000]  </span><br><span class="line">Person salary changed map[steve:12000 jamie:15000 mike:18000] </span><br></pre></td></tr></table></figure>

<blockquote>
<p>map不能使用&#x3D;&#x3D;操作符进行比较。&#x3D;&#x3D;只能用来检查map是否为空。否则会报错：invalid operation: map1 &#x3D;&#x3D; map2 (map can only be comparedto nil)</p>
</blockquote>
<h1 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h1><h2 id="什么是string"><a href="#什么是string" class="headerlink" title="什么是string"></a>什么是string</h2><p>Go中的字符串是一个字节的切片。可以通过将其内容封装在“”中来创建字符串。Go中的字符串是Unicode兼容的，并且是UTF-8编码的。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    name := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string的使用"><a href="#string的使用" class="headerlink" title="string的使用"></a>string的使用</h2><p>访问字符串中的单个字节</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, s[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%c &quot;</span>, s[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>%c：相应Unicode码点所表示的字符</p>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">72 101 108 108 111 32 87 111 114 108 100 </span><br><span class="line">H e l l o   W o r l d </span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC与gRPC详解</title>
    <url>/2023/08/04/Go/32/</url>
    <content><![CDATA[<h1 id="RPC原理与Go-RPC"><a href="#RPC原理与Go-RPC" class="headerlink" title="RPC原理与Go RPC"></a>RPC原理与Go RPC</h1><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>RPC（Remote Procedure Call），即远程过程调用。它允许像调用本地服务一样调用远程服务。</p>
<p>RPC是一种服务器-客户端（Client&#x2F;Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。</p>
<p>首先与RPC（远程过程调用）相对应的是本地调用。</p>
<h3 id="本地调用"><a href="#本地调用" class="headerlink" title="本地调用"></a>本地调用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	z := x + y</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用本地函数add</span></span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	b := <span class="number">20</span></span><br><span class="line">	ret := add(a, b)</span><br><span class="line">	fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述程序编译成二进制文件——<code>app1</code>后运行，会输出结果30。</p>
<p>在<code>app1</code>程序中本地调用<code>add</code>函数的执行流程，可以理解为以下四个步骤。</p>
<ol>
<li>将a和b的值压栈</li>
<li>通过函数指针找到add函数，进入函数取出栈中的值10和20，将其赋予x和y</li>
<li>计算x*y，并将结果存在z</li>
<li>将z的值压栈，然后从 add函数返回</li>
<li>从栈中取出z返回值，并赋值给ret</li>
</ol>
<h3 id="RPC调用"><a href="#RPC调用" class="headerlink" title="RPC调用"></a>RPC调用</h3><p>本地过程调用发生在同一进程中——定义<code>add</code>函数的代码和调用<code>add</code>函数的代码共享同一个内存空间，所以调用能够正常执行。</p>
<p>但是我们无法直接在另一个程序——<code>app2中调用</code>add&#96;函数，因为它们是两个程序——内存空间是相互隔离的。（app1和app2可能部署在同一台服务器上也可能部署在互联网的不同服务器上。）</p>
<p>RPC就是为了解决类似远程、跨内存空间、的函数&#x2F;方法调用的。要实现RPC就需要解决以下三个问题。</p>
<ol>
<li>如何确定要执行的函数？ 在本地调用中，函数主体通过函数指针函数指定，然后调用 add 函数，编译器通过函数指针函数自动确定 add 函数在内存中的位置。但是在 RPC 中，调用不能通过函数指针完成，因为它们的内存地址可能完全不同。因此，调用方和被调用方都需要维护一个{ function &lt;-&gt; ID }映射表，以确保调用正确的函数。</li>
<li>如何表达参数？ 本地过程调用中传递的参数是通过堆栈内存结构实现的，但 RPC 不能直接使用内存传递参数，因此参数或返回值需要在传输期间序列化并转换成字节流，反之亦然。</li>
<li>如何进行网络传输？ 函数的调用方和被调用方通常是通过网络连接的，也就是说，function ID 和序列化字节流需要通过网络传输，因此，只要能够完成传输，调用方和被调用方就不受某个网络协议的限制。例如，一些 RPC 框架使用 TCP 协议，一些使用 HTTP。</li>
</ol>
<p>以往实现跨服务调用的时候，我们会采用RESTful API的方式，被调用方会对外提供一个HTTP接口，调用方按要求发起HTTP请求并接收API接口返回的响应数据。下面的示例是将<code>add</code>函数包装成一个RESTful API。</p>
<h3 id="HTTP调用RESTful-API"><a href="#HTTP调用RESTful-API" class="headerlink" title="HTTP调用RESTful API"></a>HTTP调用RESTful API</h3><p>首先，我们编写一个基于HTTP的server服务，它将接收其他程序发来的HTTP请求，执行特定的程序并将结果返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> addParam <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="type">int</span> <span class="string">`json:&quot;x&quot;`</span></span><br><span class="line">	Y <span class="type">int</span> <span class="string">`json:&quot;y&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> addResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code <span class="type">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">	Data <span class="type">int</span> <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check for the HTTP method to be POST</span></span><br><span class="line">	<span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;Method not allowed&quot;</span>, http.StatusMethodNotAllowed)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parse the request body</span></span><br><span class="line">	<span class="keyword">var</span> param addParam</span><br><span class="line">	err := json.NewDecoder(r.Body).Decode(&amp;param)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;Invalid request body&quot;</span>, http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Perform the business logic</span></span><br><span class="line">	ret := add(param.X, param.Y)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return the response</span></span><br><span class="line">	resp := addResult&#123;Code: <span class="number">0</span>, Data: ret&#125;</span><br><span class="line">	w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">	err = json.NewEncoder(w).Encode(resp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;Error encoding response:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/add&quot;</span>, addHandler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们编写一个客户端来请求上述HTTP服务，传递x和y两个整数，等待返回结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Param <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="type">int</span> <span class="string">`json:&quot;x&quot;`</span></span><br><span class="line">	Y <span class="type">int</span> <span class="string">`json:&quot;y&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code <span class="type">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">	Data <span class="type">int</span> <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通过HTTP请求调用其他服务器上的add服务</span></span><br><span class="line">	url := <span class="string">&quot;http://127.0.0.1:9090/add&quot;</span></span><br><span class="line">	param := Param&#123;</span><br><span class="line">		X: <span class="number">10</span>,</span><br><span class="line">		Y: <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	paramBytes, err := json.Marshal(param)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error marshalling request body:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err := http.Post(url, <span class="string">&quot;application/json&quot;</span>, bytes.NewReader(paramBytes))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error making HTTP POST request:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	respBytes, err := io.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error reading response body:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> respData Result</span><br><span class="line">	err = json.Unmarshal(respBytes, &amp;respData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error unmarshalling response body:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(respData.Data) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式是我们目前比较常见的跨服务或跨语言之间基于RESTful API的服务调用模式。 既然使用API调用也能实现类似远程调用的目的，为什么还要用RPC呢？</p>
<p>使用 RPC 的目的是让我们调用远程方法像调用本地方法一样无差别。并且基于RESTful API通常是基于HTTP协议，传输数据采用JSON等文本协议，相较于RPC 直接使用TCP协议，传输数据多采用二进制协议来说，RPC通常相比RESTful API性能会更好。</p>
<p>RESTful API多用于前后端之间的数据传输，而目前微服务架构下各个微服务之间多采用RPC调用。</p>
<h2 id="net-rpc"><a href="#net-rpc" class="headerlink" title="net&#x2F;rpc"></a>net&#x2F;rpc</h2><h3 id="基础RPC示例"><a href="#基础RPC示例" class="headerlink" title="基础RPC示例"></a>基础RPC示例</h3><p>Go语言的 rpc 包提供对通过网络或其他 i&#x2F;o 连接导出的对象方法的访问，服务器注册一个对象，并把它作为服务对外可见（服务名称就是类型名称）。注册后，对象的导出方法将支持远程访问。服务器可以注册不同类型的多个对象(服务) ，但是不支持注册同一类型的多个对象。</p>
<p>在下面的代码中我们定义一个<code>ServiceA</code>类型，并为其定义了一个可导出的<code>Add</code>方法。并将<code>ServiceA</code>类型注册为一个服务，其Add方法就支持RPC调用了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rpc demo/service.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceA 自定义一个结构体类型</span></span><br><span class="line"><span class="keyword">type</span> ServiceA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 为ServiceA类型增加一个可导出的Add方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceA)</span></span> Add(args *Args, reply *<span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">	*reply = args.X + args.Y</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	service := <span class="built_in">new</span>(ServiceA)</span><br><span class="line">	rpc.Register(service) <span class="comment">// 注册RPC服务</span></span><br><span class="line">	rpc.HandleHTTP()      <span class="comment">// 基于HTTP协议</span></span><br><span class="line">	l, e := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line">	http.Serve(l, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，client 端便能看到一个拥有“Add”方法的“ServiceA”服务，想要调用这个服务需要使用下面的代码先连接到server端再执行远程调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rpc demo/client.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClientArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立HTTP连接</span></span><br><span class="line">	client, err := rpc.DialHTTP(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同步调用</span></span><br><span class="line">	args := &amp;ClientArgs&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ServiceA.Add error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ServiceA.Add: %d+%d=%d\n&quot;</span>, args.X, args.Y, reply)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步调用</span></span><br><span class="line">	<span class="keyword">var</span> reply2 <span class="type">int</span></span><br><span class="line">	divCall := client.Go(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply2, <span class="literal">nil</span>)</span><br><span class="line">	replyCall := &lt;-divCall.Done <span class="comment">// 接收调用结果</span></span><br><span class="line">	fmt.Println(replyCall.Error)</span><br><span class="line">	fmt.Println(reply2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a. 同步调用：</p>
<ul>
<li><code>client.Call(&quot;ServiceA.Add&quot;, args, &amp;reply)</code>: 该行代码表示使用<code>client</code>连接对象对名为”ServiceA.Add”的远程方法进行同步调用，传递了<code>args</code>作为参数，并将结果存储在<code>reply</code>中。</li>
<li>如果调用出现错误，则通过<code>log.Fatal</code>输出错误信息。</li>
</ul>
<p>b. 异步调用：</p>
<ul>
<li><code>client.Go(&quot;ServiceA.Add&quot;, args, &amp;reply2, nil)</code>: 该行代码表示使用<code>client</code>连接对象对名为”ServiceA.Add”的远程方法进行异步调用，传递了<code>args</code>作为参数，并将结果存储在<code>reply2</code>中。此处使用了Go方法，该方法会立即返回一个<code>rpc.Call</code>对象，它代表了异步调用的状态。</li>
<li><code>&lt;-divCall.Done</code>: 通过使用<code>&lt;-</code>操作符，我们等待异步调用完成，这里<code>divCall.Done</code>是一个通道，它会在异步调用结束时收到一个通知。</li>
<li><code>replyCall.Error</code>: 获取异步调用结果的错误信息（如果有的话）。</li>
<li><code>reply2</code>: 获取异步调用的返回值。</li>
</ul>
<p>执行上述两个程序，查看 RPC 调用的结果。</p>
<p>会看到如下输出结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ServiceA.Add: 10+20=30</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<h3 id="基于TCP协议的RPC"><a href="#基于TCP协议的RPC" class="headerlink" title="基于TCP协议的RPC"></a>基于TCP协议的RPC</h3><p>当然 rpc 包也支持直接使用 TCP 协议而不使用HTTP协议。</p>
<p>server 端代码修改如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rpc demo/service.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceA 自定义一个结构体类型</span></span><br><span class="line"><span class="keyword">type</span> ServiceA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 为ServiceA类型增加一个可导出的Add方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceA)</span></span> Add(args *Args, reply *<span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">	*reply = args.X + args.Y</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	service := <span class="built_in">new</span>(ServiceA)</span><br><span class="line">	rpc.Register(service) <span class="comment">// 注册RPC服务</span></span><br><span class="line">	l, e := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, _ := l.Accept()</span><br><span class="line">		rpc.ServeConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client 端代码修改如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rpc demo/client.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClientArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立TCP连接</span></span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同步调用</span></span><br><span class="line">	args := &amp;ClientArgs&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ServiceA.Add error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ServiceA.Add: %d+%d=%d\n&quot;</span>, args.X, args.Y, reply)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步调用</span></span><br><span class="line">	<span class="keyword">var</span> reply2 <span class="type">int</span></span><br><span class="line">	divCall := client.Go(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply2, <span class="literal">nil</span>)</span><br><span class="line">	replyCall := &lt;-divCall.Done <span class="comment">// 接收调用结果</span></span><br><span class="line">	fmt.Println(replyCall.Error)</span><br><span class="line">	fmt.Println(reply2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用JSON协议的RPC"><a href="#使用JSON协议的RPC" class="headerlink" title="使用JSON协议的RPC"></a>使用JSON协议的RPC</h3><p>rpc 包默认使用的是 gob 协议对传输数据进行序列化&#x2F;反序列化，比较有局限性。下面的代码将尝试使用 JSON 协议对传输数据进行序列化与反序列化。</p>
<p>server 端代码修改如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rpc demo/service.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceA 自定义一个结构体类型</span></span><br><span class="line"><span class="keyword">type</span> ServiceA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 为ServiceA类型增加一个可导出的Add方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceA)</span></span> Add(args *Args, reply *<span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">	*reply = args.X + args.Y</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	service := <span class="built_in">new</span>(ServiceA)</span><br><span class="line">	rpc.Register(service) <span class="comment">// 注册RPC服务</span></span><br><span class="line">	l, e := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, _ := l.Accept()</span><br><span class="line">		<span class="comment">// 使用JSON协议</span></span><br><span class="line">		rpc.ServeCodec(jsonrpc.NewServerCodec(conn))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client 端代码修改如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rpc demo/client.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClientArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立TCP连接</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用JSON协议</span></span><br><span class="line">	client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))</span><br><span class="line">	<span class="comment">// 同步调用</span></span><br><span class="line">	args := &amp;ClientArgs&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ServiceA.Add error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ServiceA.Add: %d+%d=%d\n&quot;</span>, args.X, args.Y, reply)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步调用</span></span><br><span class="line">	<span class="keyword">var</span> reply2 <span class="type">int</span></span><br><span class="line">	divCall := client.Go(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply2, <span class="literal">nil</span>)</span><br><span class="line">	replyCall := &lt;-divCall.Done <span class="comment">// 接收调用结果</span></span><br><span class="line">	fmt.Println(replyCall.Error)</span><br><span class="line">	fmt.Println(reply2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python调用RPC"><a href="#Python调用RPC" class="headerlink" title="Python调用RPC"></a>Python调用RPC</h3><p>下面的代码演示了如何使用 python client 远程调用上面 Go server中 serviceA的Add方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">request = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;params&quot;</span>: [&#123;<span class="string">&quot;x&quot;</span>:<span class="number">10</span>, <span class="string">&quot;y&quot;</span>:<span class="number">20</span>&#125;],  <span class="comment"># 参数要对应上Args结构体</span></span><br><span class="line">    <span class="string">&quot;method&quot;</span>: <span class="string">&quot;ServiceA.Add&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client = socket.create_connection((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9091</span>),<span class="number">5</span>)</span><br><span class="line">client.sendall(json.dumps(request).encode())</span><br><span class="line"></span><br><span class="line">rsp = client.recv(<span class="number">1024</span>)</span><br><span class="line">rsp = json.loads(rsp.decode())</span><br><span class="line"><span class="built_in">print</span>(rsp)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;id&#x27;: 0, &#x27;result&#x27;: 30, &#x27;error&#x27;: None&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h2><p>RPC 让远程调用就像本地调用一样，其调用过程可拆解为以下步骤。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230804131507445.png" alt="image-20230804131507445"></p>
<p>① 服务调用方（client）以本地调用方式调用服务；</p>
<p>② client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</p>
<p>③ client stub找到服务地址，并将消息发送到服务端；</p>
<p>④ server 端接收到消息；</p>
<p>⑤ server stub收到消息后进行解码；</p>
<p>⑥ server stub根据解码结果调用本地的服务；</p>
<p>⑦ 本地服务执行并将结果返回给server stub；</p>
<p>⑧ server stub将返回结果打包成能够进行网络传输的消息体；</p>
<p>⑨ 按地址将消息发送至调用方；</p>
<p>⑩ client 端接收到消息；</p>
<p>⑪ client stub收到消息并进行解码；</p>
<p>⑫ 调用方得到最终结果。</p>
<p>使用RPC框架的目标是只需要关心第1步和最后1步，中间的其他步骤统统封装起来，让使用者无需关心。例如社区中各式RPC框架（grpc、thrift等）就是为了让RPC调用更方便。</p>
<h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><h2 id="gRPC是什么"><a href="#gRPC是什么" class="headerlink" title="gRPC是什么"></a>gRPC是什么</h2><p><code>gRPC</code>是一种现代化开源的高性能RPC框架，能够运行于任意环境之中。最初由谷歌进行开发。它使用HTTP&#x2F;2作为传输协议。</p>
<p>在gRPC里，客户端可以像调用本地方法一样直接调用其他机器上的服务端应用程序的方法，帮助你更容易创建分布式应用程序和服务。与许多RPC系统一样，gRPC是基于定义一个服务，指定一个可以远程调用的带有参数和返回类型的的方法。在服务端程序中实现这个接口并且运行gRPC服务处理客户端调用。在客户端，有一个stub提供和服务端相同的方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/grpc.svg" alt="grpc"></p>
<h2 id="为什么要用gRPC"><a href="#为什么要用gRPC" class="headerlink" title="为什么要用gRPC"></a>为什么要用gRPC</h2><p>使用gRPC， 我们可以一次性的在一个<code>.proto</code>文件中定义服务并使用任何支持它的语言去实现客户端和服务端，反过来，它们可以应用在各种场景中，从Google的服务器到你自己的平板电脑—— gRPC帮你解决了不同语言及环境间通信的复杂性。使用<code>protocol buffers</code>还能获得其他好处，包括高效的序列化，简单的IDL以及容易进行接口更新。总之一句话，使用gRPC能让我们更容易编写跨语言的分布式代码。</p>
<blockquote>
<p>IDL（Interface description language）是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用C++写成，另一个组件用Go写成。</p>
</blockquote>
<h2 id="安装gRPC"><a href="#安装gRPC" class="headerlink" title="安装gRPC"></a>安装gRPC</h2><h3 id="安装gRPC-1"><a href="#安装gRPC-1" class="headerlink" title="安装gRPC"></a>安装gRPC</h3><p>在你的项目目录下执行以下命令，获取 gRPC 作为项目依赖。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get google.golang.org/grpc@latest</span><br></pre></td></tr></table></figure>

<h3 id="安装Protocol-Buffers-v3"><a href="#安装Protocol-Buffers-v3" class="headerlink" title="安装Protocol Buffers v3"></a>安装Protocol Buffers v3</h3><p>安装用于生成gRPC服务代码的协议编译器，最简单的方法是从下面的链接：<a href="https://github.com/protocolbuffers/protobuf/releases/">https://github.com/protocolbuffers/protobuf/releases/</a>下载适合你平台的预编译好的二进制文件（<code>protoc-&lt;version&gt;-&lt;platform&gt;.zip</code>）。</p>
<blockquote>
<p>适用Windows 64位<a href="https://github.com/protocolbuffers/protobuf/releases/download/v23.4/protoc-23.4-win64.zip">protoc-23.4-win64.zip</a></p>
</blockquote>
<p>其中：</p>
<ul>
<li>bin 目录下的 protoc 是可执行文件。</li>
<li>include 目录下的是 google 定义的<code>.proto</code>文件，我们<code>import &quot;google/protobuf/timestamp.proto&quot;</code>就是从此处导入。</li>
</ul>
<p>由于需要将下载得到的可执行文件<code>protoc</code>所在的 bin 目录加到我们电脑的环境变量中，于是我把它放到了<code>GOPATH/bin</code>里。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>因为本文我们是使用Go语言做开发，接下来执行下面的命令安装<code>protoc</code>的Go插件：</p>
<p>安装go语言插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br></pre></td></tr></table></figure>

<p>该插件会根据<code>.proto</code>文件生成一个后缀为<code>.pb.go</code>的文件，包含所有<code>.proto</code>文件中定义的类型及其序列化方法。</p>
<p>安装grpc插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure>

<p>该插件会生成一个后缀为<code>_grpc.pb.go</code>的文件，其中包含：</p>
<ul>
<li>一种接口类型(或存根) ，供客户端调用的服务方法。</li>
<li>服务器要实现的接口类型。</li>
</ul>
<p>上述命令会默认将插件安装到<code>GOPATH/bin</code>，为了<code>protoc</code>编译器能找到这些插件，请确保你的<code>GOPATH/bin</code>在环境变量中。</p>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>依次执行以下命令检查一下是否开发环境都准备完毕。</p>
<ol>
<li><p>确认 protoc 安装完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ protoc --version</span><br><span class="line">libprotoc 23.4</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认 protoc-gen-go 安装完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ protoc-gen-go --version</span><br><span class="line">protoc-gen-go.exe v1.28.1</span><br></pre></td></tr></table></figure>

<p>如果这里提示<code>protoc-gen-go</code>不是可执行的程序，请确保你的 GOPATH 下的 bin 目录在你电脑的环境变量中。</p>
</li>
<li><p>确认 protoc-gen-go-grpc 安装完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ protoc-gen-go-grpc --version</span><br><span class="line">protoc-gen-go-grpc 1.2.0</span><br></pre></td></tr></table></figure>

<p>如果这里提示<code>protoc-gen-go-grpc</code>不是可执行的程序，请确保你的 GOPATH 下的 bin 目录在你电脑的环境变量中。</p>
</li>
</ol>
<h2 id="gRPC的开发方式"><a href="#gRPC的开发方式" class="headerlink" title="gRPC的开发方式"></a>gRPC的开发方式</h2><p>把大象放进冰箱分几步？</p>
<ol>
<li>把冰箱门打开。</li>
<li>把大象放进去。</li>
<li>把冰箱门带上。</li>
</ol>
<p>gRPC开发同样分三步：</p>
<h3 id="编写-proto文件定义服务"><a href="#编写-proto文件定义服务" class="headerlink" title="编写.proto文件定义服务"></a>编写<code>.proto</code>文件定义服务</h3><p>像许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以通过参数和返回类型远程调用的方法。默认情况下，gRPC 使用 <a href="https://developers.google.com/protocol-buffers">protocol buffers</a>作为接口定义语言(IDL)来描述服务接口和有效负载消息的结构。可以根据需要使用其他的IDL代替。</p>
<p>例如，下面使用 protocol buffers 定义了一个<code>HelloService</code>服务。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">HelloService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> greeting = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResponse</span> &#123;</span><br><span class="line">  <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在gRPC中你可以定义四种类型的服务方法。</p>
<ul>
<li>普通 rpc，客户端向服务器发送一个请求，然后得到一个响应，就像普通的函数调用一样。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> SayHello(HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务器流式 rpc，其中客户端向服务器发送请求，并获得一个流来读取一系列消息。客户端从返回的流中读取，直到没有更多的消息。gRPC 保证在单个 RPC 调用中的消息是有序的。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> LotsOfReplies(HelloRequest) <span class="keyword">returns</span> (stream HelloResponse)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端流式 rpc，其中客户端写入一系列消息并将其发送到服务器，同样使用提供的流。一旦客户端完成了消息的写入，它就等待服务器读取消息并返回响应。同样，gRPC 保证在单个 RPC 调用中对消息进行排序。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> LotsOfGreetings(stream HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>双向流式 rpc，其中双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照自己喜欢的顺序读写: 例如，服务器可以等待接收所有客户端消息后再写响应，或者可以交替读取消息然后写入消息，或者其他读写组合。每个流中的消息是有序的。</li>
</ul>
<h3 id="生成指定语言的代码"><a href="#生成指定语言的代码" class="headerlink" title="生成指定语言的代码"></a>生成指定语言的代码</h3><p>在 <code>.proto</code> 文件中的定义好服务之后，gRPC 提供了生成客户端和服务器端代码的 protocol buffers 编译器插件。</p>
<p>我们使用这些插件可以根据需要生成<code>Java</code>、<code>Go</code>、<code>C++</code>、<code>Python</code>等语言的代码。我们通常会在客户端调用这些 API，并在服务器端实现相应的 API。</p>
<ul>
<li>在服务器端，服务器实现服务声明的方法，并运行一个 gRPC 服务器来处理客户端发来的调用请求。gRPC 底层会对传入的请求进行解码，执行被调用的服务方法，并对服务响应进行编码。</li>
<li>在客户端，客户端有一个称为存根（stub）的本地对象，它实现了与服务相同的方法。然后，客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的 protocol buffers 消息类型中—— gRPC 在向服务器发送请求并返回服务器的 protocol buffers 响应之后进行处理。</li>
</ul>
<h3 id="编写业务逻辑代码"><a href="#编写业务逻辑代码" class="headerlink" title="编写业务逻辑代码"></a>编写业务逻辑代码</h3><p>gRPC 帮我们解决了 RPC 中的服务调用、数据传输以及消息编解码，我们剩下的工作就是要编写业务逻辑代码。</p>
<p>在服务端编写业务代码实现具体的服务方法，在客户端按需调用这些方法。</p>
<h2 id="gRPC入门示例"><a href="#gRPC入门示例" class="headerlink" title="gRPC入门示例"></a>gRPC入门示例</h2><h3 id="编写proto代码"><a href="#编写proto代码" class="headerlink" title="编写proto代码"></a>编写proto代码</h3><p><code>Protocol Buffers</code>是一种与语言无关，平台无关的可扩展机制，用于序列化结构化数据。使用<code>Protocol Buffers</code>可以一次定义结构化的数据，然后可以使用特殊生成的源代码轻松地在各种数据流中使用各种语言编写和读取结构化数据。</p>
<p>关于<code>Protocol Buffers</code>的教程可以查看<a href="https://www.liwenzhou.com/posts/Go/Protobuf3-language-guide-zh/">Protocol Buffers V3中文指南</a>，本文后续内容默认读者熟悉<code>Protocol Buffers</code>。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 版本声明，使用Protocol Buffers v3版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;xx&quot;</span>;  <span class="comment">// 指定生成的Go代码在你项目中的导入路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pb; <span class="comment">// 包名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="comment">// SayHello 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResponse</span> &#123;</span><br><span class="line">    <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写Server端Go代码"><a href="#编写Server端Go代码" class="headerlink" title="编写Server端Go代码"></a>编写Server端Go代码</h3><p>我们新建一个<code>hello_server</code>项目，在项目根目录下执行<code>go mod init hello_server</code>。</p>
<p>再新建一个<code>pb</code>文件夹，将上面的 proto 文件保存为<code>hello.proto</code>，将<code>go_package</code>按如下方式修改。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;hello_server/pb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>此时，项目的目录结构为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello_server</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── pb</span><br><span class="line">    └── hello.proto</span><br></pre></td></tr></table></figure>

<p>在项目根目录下执行以下命令，根据<code>hello.proto</code>生成 go 源码文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative pb/hello.proto</span><br></pre></td></tr></table></figure>

<p>生成后的go源码文件会保存在pb文件夹下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello_server</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── pb</span><br><span class="line">    ├── hello.pb.go</span><br><span class="line">    ├── hello.proto</span><br><span class="line">    └── hello_grpc.pb.go</span><br></pre></td></tr></table></figure>

<p>将下面的内容添加到<code>hello_server/main.go</code>中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_server/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(_ context.Context, in *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloResponse&#123;Reply: <span class="string">&quot;Hello &quot;</span> + in.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听本地的8972端口</span></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8972&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()                  <span class="comment">// 创建gRPC服务器</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;) <span class="comment">// 在gRPC服务端注册服务</span></span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	err = s.Serve(lis)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并执行 <code>http_server</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build</span><br><span class="line">./server</span><br></pre></td></tr></table></figure>

<h3 id="编写Client端Go代码"><a href="#编写Client端Go代码" class="headerlink" title="编写Client端Go代码"></a>编写Client端Go代码</h3><p>我们新建一个<code>hello_client</code>项目，在项目根目录下执行<code>go mod init hello_client</code>。</p>
<p>再新建一个<code>pb</code>文件夹，将上面的 proto 文件保存为<code>hello.proto</code>，将<code>go_package</code>按如下方式修改。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;hello_client/pb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在项目根目录下执行以下命令，根据<code>hello.proto</code>在<code>http_client</code>项目下生成 go 源码文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative pb/hello.proto</span><br></pre></td></tr></table></figure>

<p>此时，项目的目录结构为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http_client</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── pb</span><br><span class="line">    ├── hello.pb.go</span><br><span class="line">    ├── hello.proto</span><br><span class="line">    └── hello_grpc.pb.go</span><br></pre></td></tr></table></figure>

<p>在<code>http_client/main.go</code>文件中按下面的代码调用<code>http_server</code>提供的 <code>SayHello</code> RPC服务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;hello_client/pb&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello_client</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultName = <span class="string">&quot;world&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	addr = flag.String(<span class="string">&quot;addr&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>, <span class="string">&quot;the address to connect to&quot;</span>)</span><br><span class="line">	name = flag.String(<span class="string">&quot;name&quot;</span>, defaultName, <span class="string">&quot;Name to greet&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 连接到server端，此处禁用安全传输</span></span><br><span class="line">	conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行RPC调用并打印收到的响应数据</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.GetReply())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后将<code>hello_client</code>编译并执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build</span><br><span class="line">./hello_client -name=wxy</span><br></pre></td></tr></table></figure>

<p>得到以下输出结果，说明RPC调用成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2023/08/04 14:11:19 Greeting: Hello wxy</span><br></pre></td></tr></table></figure>

<h3 id="gRPC跨语言调用"><a href="#gRPC跨语言调用" class="headerlink" title="gRPC跨语言调用"></a>gRPC跨语言调用</h3><p>接下来，我们演示一下如何使用gRPC实现跨语言的RPC调用。</p>
<p>我们使用<code>Python</code>语言编写<code>Client</code>，然后向上面使用<code>go</code>语言编写的<code>server</code>发送RPC请求。</p>
<p>python下安装 grpc：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install grpcio</span><br></pre></td></tr></table></figure>

<p>安装gRPC tools：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install grpcio-tools</span><br></pre></td></tr></table></figure>

<h3 id="生成Python代码"><a href="#生成Python代码" class="headerlink" title="生成Python代码"></a>生成Python代码</h3><p>新建一个<code>py_client</code>项目工程，将<code>hello.proto</code>文件保存到<code>py_client/pb/</code>目录下。 </p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 版本声明，使用Protocol Buffers v3版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;py_client/pb&quot;</span>;  <span class="comment">// 指定生成的Go代码在你项目中的导入路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pb; <span class="comment">// 包名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="comment">// SayHello 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResponse</span> &#123;</span><br><span class="line">    <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>py_client</code>目录下执行以下命令，生成python源码文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m grpc_tools.protoc -Ipb --python_out=. --grpc_python_out=. pb/hello.proto</span><br></pre></td></tr></table></figure>

<h3 id="编写Python版RPC客户端"><a href="#编写Python版RPC客户端" class="headerlink" title="编写Python版RPC客户端"></a>编写Python版RPC客户端</h3><p>将下面的代码保存到<code>py_client/client.py</code>文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> hello_pb2</span><br><span class="line"><span class="keyword">import</span> hello_pb2_grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="comment"># NOTE(gRPC Python Team): .close() is possible on a channel and should be</span></span><br><span class="line">    <span class="comment"># used in circumstances in which the with statement does not fit the needs</span></span><br><span class="line">    <span class="comment"># of the code.</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">&#x27;127.0.0.1:8972&#x27;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = hello_pb2_grpc.GreeterStub(channel)</span><br><span class="line">        resp = stub.SayHello(hello_pb2.HelloRequest(name=<span class="string">&#x27;q1mi&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span> + resp.reply)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<p>此时项目的目录结构图如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">py_client</span><br><span class="line">├── client.py</span><br><span class="line">├── hello_pb2.py</span><br><span class="line">├── hello_pb2_grpc.py</span><br><span class="line">└── pb</span><br><span class="line">    └── hello.proto</span><br></pre></td></tr></table></figure>

<h3 id="Python-RPC-调用"><a href="#Python-RPC-调用" class="headerlink" title="Python RPC 调用"></a>Python RPC 调用</h3><p>执行<code>client.py</code>调用go语言的<code>SayHello</code>RPC服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python client.py</span><br><span class="line">Greeter client received: Hello wxy</span><br></pre></td></tr></table></figure>

<p>这里我们就实现了，使用 Python 代码编写的client去调用Go语言版本的server了。</p>
<h2 id="gRPC流式示例"><a href="#gRPC流式示例" class="headerlink" title="gRPC流式示例"></a>gRPC流式示例</h2><p>在上面的示例中，客户端发起了一个RPC请求到服务端，服务端进行业务处理并返回响应给客户端，这是gRPC最基本的一种工作方式（Unary RPC）。除此之外，依托于HTTP2，gRPC还支持流式RPC（Streaming RPC）。</p>
<h3 id="服务端流式RPC"><a href="#服务端流式RPC" class="headerlink" title="服务端流式RPC"></a>服务端流式RPC</h3><p>客户端发出一个RPC请求，服务端与客户端之间建立一个单向的流，服务端可以向流中写入多个响应消息，最后主动关闭流；而客户端需要监听这个流，不断获取响应直到流关闭。应用场景举例：客户端向服务端发送一个股票代码，服务端就把该股票的实时数据源源不断的返回给客户端。</p>
<p>我们在此编写一个使用多种语言打招呼的方法，客户端发来一个用户名，服务端分多次返回打招呼的信息。</p>
<p>1.定义服务</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 版本声明，使用Protocol Buffers v3版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;hello_server/pb&quot;</span>;  <span class="comment">// 指定生成的Go代码在你项目中的导入路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pb; <span class="comment">// 包名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// 服务端返回流式数据</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> LotsOfReplies(HelloRequest) <span class="keyword">returns</span> (stream HelloResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResponse</span> &#123;</span><br><span class="line">  <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>.proto</code>文件后，需要重新使用 protocol buffers编译器生成<font  color="red">客户端和服务端</font>代码。</p>
<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative pb/hello.proto</span><br></pre></td></tr></table></figure>

<p>2.服务端需要实现 <code>LotsOfReplies</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_server/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LotsOfReplies 返回使用多种语言打招呼</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> LotsOfReplies(in *pb.HelloRequest, stream pb.Greeter_LotsOfRepliesServer) <span class="type">error</span> &#123;</span><br><span class="line">	words := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;你好&quot;</span>,</span><br><span class="line">		<span class="string">&quot;hello&quot;</span>,</span><br><span class="line">		<span class="string">&quot;こんにちは&quot;</span>,</span><br><span class="line">		<span class="string">&quot;안녕하세요&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">		data := &amp;pb.HelloResponse&#123;</span><br><span class="line">			Reply: word + in.GetName(),</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 使用Send方法返回多个数据</span></span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听本地的8972端口</span></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8972&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()                  <span class="comment">// 创建gRPC服务器</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;) <span class="comment">// 在gRPC服务端注册服务</span></span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	err = s.Serve(lis)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.客户端调用<code>LotsOfReplies</code> 并将收到的数据依次打印出来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;hello_client/pb&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello_client</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultName = <span class="string">&quot;world&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	addr = flag.String(<span class="string">&quot;addr&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>, <span class="string">&quot;the address to connect to&quot;</span>)</span><br><span class="line">	name = flag.String(<span class="string">&quot;name&quot;</span>, defaultName, <span class="string">&quot;Name to greet&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 连接到server端，此处禁用安全传输</span></span><br><span class="line">	conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// server端流式RPC</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	stream, err := c.LotsOfReplies(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;c.LotsOfReplies failed, err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 接收服务端返回的流式数据，当收到io.EOF或错误时退出</span></span><br><span class="line">		res, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;c.LotsOfReplies failed, err: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">&quot;got reply: %q\n&quot;</span>, res.GetReply())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后将<code>hello_client</code>编译并执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build</span><br><span class="line">./hello_client -name=wxy</span><br></pre></td></tr></table></figure>

<p>执行程序后会得到如下输出结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2023/08/04 15:08:38 got reply: <span class="string">&quot;你好wxy&quot;</span></span><br><span class="line">2023/08/04 15:08:38 got reply: <span class="string">&quot;hellowxy&quot;</span></span><br><span class="line">2023/08/04 15:08:38 got reply: <span class="string">&quot;こんにちはwxy&quot;</span></span><br><span class="line">2023/08/04 15:08:38 got reply: <span class="string">&quot;안녕하세요wxy&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="客户端流式RPC"><a href="#客户端流式RPC" class="headerlink" title="客户端流式RPC"></a>客户端流式RPC</h3><p>客户端传入多个请求对象，服务端返回一个响应结果。典型的应用场景举例：物联网终端向服务器上报数据、大数据流式计算等。</p>
<p>在这个示例中，我们编写一个多次发送人名，服务端统一返回一个打招呼消息的程序。</p>
<p>1.定义服务</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 版本声明，使用Protocol Buffers v3版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;hello_server/pb&quot;</span>;  <span class="comment">// 指定生成的Go代码在你项目中的导入路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pb; <span class="comment">// 包名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// 客户端发送流式数据</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> LotsOfGreetings(stream HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResponse</span> &#123;</span><br><span class="line">  <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>.proto</code>文件后，需要重新使用 protocol buffers编译器生成客户端和服务端代码。</p>
<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative pb/hello.proto</span><br></pre></td></tr></table></figure>

<p>2.服务端实现<code>LotsOfGreetings</code>方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_server/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LotsOfGreetings 接收流式数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> LotsOfGreetings(stream pb.Greeter_LotsOfGreetingsServer) <span class="type">error</span> &#123;</span><br><span class="line">	reply := <span class="string">&quot;你好：&quot;</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 接收客户端发来的流式数据</span></span><br><span class="line">		res, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="comment">// 最终统一回复</span></span><br><span class="line">			<span class="keyword">return</span> stream.SendAndClose(&amp;pb.HelloResponse&#123;</span><br><span class="line">				Reply: reply,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		reply += res.GetName()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听本地的8972端口</span></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8972&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()                  <span class="comment">// 创建gRPC服务器</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;) <span class="comment">// 在gRPC服务端注册服务</span></span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	err = s.Serve(lis)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>3.客户端调用<code>LotsOfGreetings</code>方法，向服务端发送流式请求数据，接收返回值并打印。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;hello_client/pb&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello_client</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultName = <span class="string">&quot;world&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	addr = flag.String(<span class="string">&quot;addr&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>, <span class="string">&quot;the address to connect to&quot;</span>)</span><br><span class="line">	name = flag.String(<span class="string">&quot;name&quot;</span>, defaultName, <span class="string">&quot;Name to greet&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 连接到server端，此处禁用安全传输</span></span><br><span class="line">	conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="comment">// 客户端流式RPC</span></span><br><span class="line">	stream, err := c.LotsOfGreetings(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;c.LotsOfGreetings failed, err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	names := []<span class="type">string</span>&#123;<span class="string">&quot;wxy&quot;</span>, <span class="string">&quot;Palp1tate&quot;</span>, <span class="string">&quot;沙河娜扎&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">		<span class="comment">// 发送流式数据</span></span><br><span class="line">		err := stream.Send(&amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;c.LotsOfGreetings stream.Send(%v) failed, err: %v&quot;</span>, name, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res, err := stream.CloseAndRecv()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;c.LotsOfGreetings failed: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;got reply: %v&quot;</span>, res.GetReply())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述函数将得到如下数据结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2023/08/04 15:11:59 got reply: 你好：wxyPalp1tate沙河娜扎</span><br></pre></td></tr></table></figure>

<h3 id="双向流式RPC"><a href="#双向流式RPC" class="headerlink" title="双向流式RPC"></a>双向流式RPC</h3><p>双向流式RPC即客户端和服务端均为流式的RPC，能发送多个请求对象也能接收到多个响应对象。典型应用示例：聊天应用等。</p>
<p>我们这里还是编写一个客户端和服务端进行人机对话的双向流式RPC示例。</p>
<p>1.定义服务</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向流式数据</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> BidiHello(stream HelloRequest) <span class="keyword">returns</span> (stream HelloResponse)</span>;</span><br></pre></td></tr></table></figure>

<p>修改<code>.proto</code>文件后，需要重新使用 protocol buffers编译器生成客户端和服务端代码。</p>
<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative pb/hello.proto</span><br></pre></td></tr></table></figure>

<p>2.服务端实现<code>BidiHello</code>方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_server/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BidiHello 双向流式打招呼</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> BidiHello(stream pb.Greeter_BidiHelloServer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 接收流式请求</span></span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		reply := magic(in.GetName()) <span class="comment">// 对收到的数据做些处理</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回流式响应</span></span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(&amp;pb.HelloResponse&#123;Reply: reply&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// magic 一段价值连城的“人工智能”代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">magic</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	s = strings.ReplaceAll(s, <span class="string">&quot;吗&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	s = strings.ReplaceAll(s, <span class="string">&quot;吧&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	s = strings.ReplaceAll(s, <span class="string">&quot;你&quot;</span>, <span class="string">&quot;我&quot;</span>)</span><br><span class="line">	s = strings.ReplaceAll(s, <span class="string">&quot;？&quot;</span>, <span class="string">&quot;!&quot;</span>)</span><br><span class="line">	s = strings.ReplaceAll(s, <span class="string">&quot;?&quot;</span>, <span class="string">&quot;!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听本地的8972端口</span></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8972&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()                  <span class="comment">// 创建gRPC服务器</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;) <span class="comment">// 在gRPC服务端注册服务</span></span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	err = s.Serve(lis)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.客户端调用<code>BidiHello</code>方法，一边从终端获取输入的请求数据发送至服务端，一边从服务端接收流式响应。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;hello_client/pb&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello_client</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultName = <span class="string">&quot;world&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	addr = flag.String(<span class="string">&quot;addr&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>, <span class="string">&quot;the address to connect to&quot;</span>)</span><br><span class="line">	name = flag.String(<span class="string">&quot;name&quot;</span>, defaultName, <span class="string">&quot;Name to greet&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 连接到server端，此处禁用安全传输</span></span><br><span class="line">	conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Minute)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="comment">// 双向流模式</span></span><br><span class="line">	stream, err := c.BidiHello(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;c.BidiHello failed, err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	waitc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 接收服务端返回的响应</span></span><br><span class="line">			in, err := stream.Recv()</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="comment">// read done.</span></span><br><span class="line">				<span class="built_in">close</span>(waitc)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatalf(<span class="string">&quot;c.BidiHello stream.Recv() failed, err: %v&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;AI：%s\n&quot;</span>, in.GetReply())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 从标准输入获取用户输入</span></span><br><span class="line">	reader := bufio.NewReader(os.Stdin) <span class="comment">// 从标准输入生成读对象</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		cmd, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读到换行</span></span><br><span class="line">		cmd = strings.TrimSpace(cmd)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(cmd) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> strings.ToUpper(cmd) == <span class="string">&quot;QUIT&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将获取到的数据发送至服务端</span></span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(&amp;pb.HelloRequest&#123;Name: cmd&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;c.BidiHello stream.Send(%v) failed: %v&quot;</span>, cmd, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stream.CloseSend()</span><br><span class="line">	&lt;-waitc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将服务端和客户端的代码都运行起来，就可以实现简单的对话程序了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/image-20230804152125944.png" alt="image-20230804152125944"></p>
<h2 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h2><p>元数据（<a href="https://pkg.go.dev/google.golang.org/grpc/metadata">metadata</a>）是指在处理RPC请求和响应过程中需要但又不属于具体业务（例如身份验证详细信息）的信息，采用键值对列表的形式，其中键是<code>string</code>类型，值通常是<code>[]string</code>类型，但也可以是二进制数据。gRPC中的 metadata 类似于我们在 HTTP headers中的键值对，元数据可以包含认证token、请求标识和监控标签等。</p>
<p>metadata中的键是大小写不敏感的，由字母、数字和特殊字符<code>-</code>、<code>_</code>、<code>.</code>组成并且不能以<code>grpc-</code>开头（gRPC保留自用），二进制值的键名必须以<code>-bin</code>结尾。</p>
<p>元数据对 gRPC 本身是不可见的，我们通常是在应用程序代码或中间件中处理元数据，我们不需要在<code>.proto</code>文件中指定元数据。</p>
<p>如何访问元数据取决于具体使用的编程语言。 在Go语言中我们是用<a href="https://pkg.go.dev/google.golang.org/grpc/metadata">google.golang.org&#x2F;grpc&#x2F;metadata</a>这个库来操作metadata。</p>
<p>metadata 类型定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MD <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>元数据可以像普通map一样读取。注意，这个 map 的值类型是<code>[]string</code>，因此用户可以使用一个键附加多个值。</p>
<h3 id="创建新的metadata"><a href="#创建新的metadata" class="headerlink" title="创建新的metadata"></a>创建新的metadata</h3><p>常用的创建MD的方法有以下两种。</p>
<p>第一种方法是使用函数 <code>New</code> 基于<code>map[string]string</code> 创建元数据:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">md := metadata.New(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;key1&quot;</span>: <span class="string">&quot;val1&quot;</span>, <span class="string">&quot;key2&quot;</span>: <span class="string">&quot;val2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>另一种方法是使用<code>Pairs</code>。具有相同键的值将合并到一个列表中:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">md := metadata.Pairs(</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1-2&quot;</span>, <span class="comment">// &quot;key1&quot;的值将会是 []string&#123;&quot;val1&quot;, &quot;val1-2&quot;&#125;</span></span><br><span class="line">    <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>注意: 所有的键将自动转换为小写，因此“ kEy1”和“ Key1”将是相同的键，它们的值将合并到相同的列表中。这种情况适用于 <code>New</code> 和 <code>Pair</code>。</p>
<h3 id="元数据中存储二进制数据"><a href="#元数据中存储二进制数据" class="headerlink" title="元数据中存储二进制数据"></a>元数据中存储二进制数据</h3><p>在元数据中，键始终是字符串。但是值可以是字符串或二进制数据。要在元数据中存储二进制数据值，只需在密钥中添加“-bin”后缀。在创建元数据时，将对带有“-bin”后缀键的值进行编码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">md := metadata.Pairs(</span><br><span class="line">    <span class="string">&quot;key&quot;</span>, <span class="string">&quot;string value&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key-bin&quot;</span>, <span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="number">96</span>, <span class="number">102</span>&#125;), <span class="comment">// 二进制数据在发送前会进行(base64) 编码</span></span><br><span class="line">                                        <span class="comment">// 收到后会进行解码</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="从请求上下文中获取元数据"><a href="#从请求上下文中获取元数据" class="headerlink" title="从请求上下文中获取元数据"></a>从请求上下文中获取元数据</h3><p>可以使用 <code>FromIncomingContext</code> 可以从RPC请求的上下文中获取元数据:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeRPC(ctx context.Context, in *pb.SomeRequest) (*pb.SomeResponse, err) &#123;</span><br><span class="line">    md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">    <span class="comment">// do something with metadata</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送和接收元数据-客户端"><a href="#发送和接收元数据-客户端" class="headerlink" title="发送和接收元数据-客户端"></a>发送和接收元数据-客户端</h3><h4 id="发送metadata"><a href="#发送metadata" class="headerlink" title="发送metadata"></a>发送metadata</h4><p>有两种方法可以将元数据发送到服务端。推荐的方法是使用 <code>AppendToOutgoingContext</code> 将 kv 对附加到context。无论context中是否已经有元数据都可以使用这个方法。如果先前没有元数据，则添加元数据; 如果context中已经存在元数据，则将 kv 对合并进去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建带有metadata的context</span></span><br><span class="line">ctx := metadata.AppendToOutgoingContext(ctx, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一些 metadata 到 context (e.g. in an interceptor)</span></span><br><span class="line">ctx := metadata.AppendToOutgoingContext(ctx, <span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起普通RPC请求</span></span><br><span class="line">response, err := client.SomeRPC(ctx, someRequest)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者发起流式RPC请求</span></span><br><span class="line">stream, err := client.SomeStreamingRPC(ctx)</span><br></pre></td></tr></table></figure>

<p>或者，可以使用 <code>NewOutgoingContext</code> 将元数据附加到context。但是，这将替换context中的任何已有的元数据，因此必须注意保留现有元数据(如果需要的话)。这个方法比使用 <code>AppendToOutgoingContext</code> 要慢。这方面的一个例子如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建带有metadata的context</span></span><br><span class="line">md := metadata.Pairs(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line">ctx := metadata.NewOutgoingContext(context.Background(), md)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一些metadata到context (e.g. in an interceptor)</span></span><br><span class="line">send, _ := metadata.FromOutgoingContext(ctx)</span><br><span class="line">newMD := metadata.Pairs(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line">ctx = metadata.NewOutgoingContext(ctx, metadata.Join(send, newMD))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起普通RPC请求</span></span><br><span class="line">response, err := client.SomeRPC(ctx, someRequest)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者发起流式RPC请求</span></span><br><span class="line">stream, err := client.SomeStreamingRPC(ctx)</span><br></pre></td></tr></table></figure>

<h4 id="接收metadata"><a href="#接收metadata" class="headerlink" title="接收metadata"></a>接收metadata</h4><p>客户端可以接收的元数据包括header和trailer。</p>
<blockquote>
<p>trailer可以用于服务器希望在处理请求后给客户端发送任何内容，例如在流式RPC中只有等所有结果都流到客户端后才能计算出负载信息，这时候就不能使用headers（header在数据之前，trailer在数据之后）。</p>
</blockquote>
<p>引申：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Trailer">HTTP trailer</a></p>
<h5 id="普通调用"><a href="#普通调用" class="headerlink" title="普通调用"></a>普通调用</h5><p>可以使用 <a href="https://godoc.org/google.golang.org/grpc#CallOption">CallOption</a> 中的 <a href="https://godoc.org/google.golang.org/grpc#Header">Header</a> 和 <a href="https://godoc.org/google.golang.org/grpc#Trailer">Trailer</a> 函数来获取普通RPC调用发送的header和trailer:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> header, trailer metadata.MD <span class="comment">// 声明存储header和trailer的变量</span></span><br><span class="line">r, err := client.SomeRPC(</span><br><span class="line">    ctx,</span><br><span class="line">    someRequest,</span><br><span class="line">    grpc.Header(&amp;header),    <span class="comment">// 将会接收header</span></span><br><span class="line">    grpc.Trailer(&amp;trailer),  <span class="comment">// 将会接收trailer</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// do something with header and trailer</span></span><br></pre></td></tr></table></figure>

<h5 id="流式调用"><a href="#流式调用" class="headerlink" title="流式调用"></a>流式调用</h5><p>流式调用包括：</p>
<ul>
<li>客户端流式</li>
<li>服务端流式</li>
<li>双向流式</li>
</ul>
<p>使用接口 <a href="https://godoc.org/google.golang.org/grpc#ClientStream">ClientStream</a> 中的 <code>Header</code> 和 <code>Trailer</code> 函数，可以从返回的流中接收 Header 和 Trailer:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stream, err := client.SomeStreamingRPC(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收 header</span></span><br><span class="line">header, err := stream.Header()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收 trailer</span></span><br><span class="line">trailer := stream.Trailer()</span><br></pre></td></tr></table></figure>

<h3 id="发送和接收元数据-服务器端"><a href="#发送和接收元数据-服务器端" class="headerlink" title="发送和接收元数据-服务器端"></a>发送和接收元数据-服务器端</h3><h4 id="接收metadata-1"><a href="#接收metadata-1" class="headerlink" title="接收metadata"></a>接收metadata</h4><p>要读取客户端发送的元数据，服务器需要从 RPC 上下文检索它。如果是普通RPC调用，则可以使用 RPC 处理程序的上下文。对于流调用，服务器需要从流中获取上下文。</p>
<h5 id="普通调用-1"><a href="#普通调用-1" class="headerlink" title="普通调用"></a>普通调用</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">    <span class="comment">// do something with metadata</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="流式调用-1"><a href="#流式调用-1" class="headerlink" title="流式调用"></a>流式调用</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) <span class="type">error</span> &#123;</span><br><span class="line">    md, ok := metadata.FromIncomingContext(stream.Context()) <span class="comment">// get context from stream</span></span><br><span class="line">    <span class="comment">// do something with metadata</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发送metadata-1"><a href="#发送metadata-1" class="headerlink" title="发送metadata"></a>发送metadata</h4><h5 id="普通调用-2"><a href="#普通调用-2" class="headerlink" title="普通调用"></a>普通调用</h5><p>在普通调用中，服务器可以调用 <a href="https://godoc.org/google.golang.org/grpc">grpc</a> 模块中的 <a href="https://godoc.org/google.golang.org/grpc#SendHeader">SendHeader</a> 和 <a href="https://godoc.org/google.golang.org/grpc#SetTrailer">SetTrailer</a> 函数向客户端发送header和trailer。这两个函数将context作为第一个参数。它应该是 RPC 处理程序的上下文或从中派生的上下文：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建和发送 header</span></span><br><span class="line">    header := metadata.Pairs(<span class="string">&quot;header-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    grpc.SendHeader(ctx, header)</span><br><span class="line">    <span class="comment">// 创建和发送 trailer</span></span><br><span class="line">    trailer := metadata.Pairs(<span class="string">&quot;trailer-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    grpc.SetTrailer(ctx, trailer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="流式调用-2"><a href="#流式调用-2" class="headerlink" title="流式调用"></a>流式调用</h5><p>对于流式调用，可以使用接口 <a href="https://godoc.org/google.golang.org/grpc#ServerStream">ServerStream</a> 中的 <code>SendHeader</code> 和 <code>SetTrailer</code> 函数发送header和trailer:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 创建和发送 header</span></span><br><span class="line">    header := metadata.Pairs(<span class="string">&quot;header-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    stream.SendHeader(header)</span><br><span class="line">    <span class="comment">// 创建和发送 trailer</span></span><br><span class="line">    trailer := metadata.Pairs(<span class="string">&quot;trailer-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    stream.SetTrailer(trailer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通RPC调用metadata示例"><a href="#普通RPC调用metadata示例" class="headerlink" title="普通RPC调用metadata示例"></a>普通RPC调用metadata示例</h3><h4 id="client端的metadata操作"><a href="#client端的metadata操作" class="headerlink" title="client端的metadata操作"></a>client端的metadata操作</h4><p>下面的代码片段演示了client端如何设置和获取metadata。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unaryCallWithMetadata 普通RPC调用客户端metadata操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unaryCallWithMetadata</span><span class="params">(c pb.GreeterClient, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;--- UnarySayHello client---&quot;</span>)</span><br><span class="line">	<span class="comment">// 创建metadata</span></span><br><span class="line">	md := metadata.Pairs(</span><br><span class="line">		<span class="string">&quot;token&quot;</span>, <span class="string">&quot;app-test-q1mi&quot;</span>,</span><br><span class="line">		<span class="string">&quot;request_id&quot;</span>, <span class="string">&quot;1234567&quot;</span>,</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// 基于metadata创建context.</span></span><br><span class="line">	ctx := metadata.NewOutgoingContext(context.Background(), md)</span><br><span class="line">	<span class="comment">// RPC调用</span></span><br><span class="line">	<span class="keyword">var</span> header, trailer metadata.MD</span><br><span class="line">	r, err := c.SayHello(</span><br><span class="line">		ctx,</span><br><span class="line">		&amp;pb.HelloRequest&#123;Name: name&#125;,</span><br><span class="line">		grpc.Header(&amp;header),   <span class="comment">// 接收服务端发来的header</span></span><br><span class="line">		grpc.Trailer(&amp;trailer), <span class="comment">// 接收服务端发来的trailer</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;failed to call SayHello: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从header中取location</span></span><br><span class="line">	<span class="keyword">if</span> t, ok := header[<span class="string">&quot;location&quot;</span>]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;location from header:\n&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> i, e := <span class="keyword">range</span> t &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot; %d. %s\n&quot;</span>, i, e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;location expected but doesn&#x27;t exist in header&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">// 获取响应结果</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;got response: %s\n&quot;</span>, r.Reply)</span><br><span class="line">	<span class="comment">// 从trailer中取timestamp</span></span><br><span class="line">	<span class="keyword">if</span> t, ok := trailer[<span class="string">&quot;timestamp&quot;</span>]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;timestamp from trailer:\n&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> i, e := <span class="keyword">range</span> t &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot; %d. %s\n&quot;</span>, i, e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;timestamp expected but doesn&#x27;t exist in trailer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="server端metadata操作"><a href="#server端metadata操作" class="headerlink" title="server端metadata操作"></a>server端metadata操作</h4><p>下面的代码片段演示了server端如何设置和获取metadata。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnarySayHello 普通RPC调用服务端metadata操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> UnarySayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 通过defer中设置trailer.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		trailer := metadata.Pairs(<span class="string">&quot;timestamp&quot;</span>, strconv.Itoa(<span class="type">int</span>(time.Now().Unix())))</span><br><span class="line">		grpc.SetTrailer(ctx, trailer)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从客户端请求上下文中读取metadata.</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.DataLoss, <span class="string">&quot;UnarySayHello: failed to get metadata&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t, ok := md[<span class="string">&quot;token&quot;</span>]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;token from metadata:\n&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(t) &lt; <span class="number">1</span> || t[<span class="number">0</span>] != <span class="string">&quot;app-test-q1mi&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Unauthenticated, <span class="string">&quot;认证失败&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建和发送header.</span></span><br><span class="line">	header := metadata.New(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;location&quot;</span>: <span class="string">&quot;BeiJing&quot;</span>&#125;)</span><br><span class="line">	grpc.SendHeader(ctx, header)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;request received: %v, say hello...\n&quot;</span>, in)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloResponse&#123;Reply: in.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流式RPC调用metadata示例"><a href="#流式RPC调用metadata示例" class="headerlink" title="流式RPC调用metadata示例"></a>流式RPC调用metadata示例</h3><p>这里以双向流式RPC为例演示客户端和服务端如何进行metadata操作。</p>
<h4 id="client端的metadata操作-1"><a href="#client端的metadata操作-1" class="headerlink" title="client端的metadata操作"></a>client端的metadata操作</h4><p>下面的代码片段演示了client端在服务端流式RPC模式下如何设置和获取metadata。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bidirectionalWithMetadata 流式RPC调用客户端metadata操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bidirectionalWithMetadata</span><span class="params">(c pb.GreeterClient, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建metadata和context.</span></span><br><span class="line">	md := metadata.Pairs(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;app-test-q1mi&quot;</span>)</span><br><span class="line">	ctx := metadata.NewOutgoingContext(context.Background(), md)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用带有metadata的context执行RPC调用.</span></span><br><span class="line">	stream, err := c.BidiHello(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to call BidiHello: %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 当header到达时读取header.</span></span><br><span class="line">		header, err := stream.Header()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;failed to get header from stream: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从返回响应的header中读取数据.</span></span><br><span class="line">		<span class="keyword">if</span> l, ok := header[<span class="string">&quot;location&quot;</span>]; ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;location from header:\n&quot;</span>)</span><br><span class="line">			<span class="keyword">for</span> i, e := <span class="keyword">range</span> l &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot; %d. %s\n&quot;</span>, i, e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;location expected but doesn&#x27;t exist in header&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送所有的请求数据到server.</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> err := stream.Send(&amp;pb.HelloRequest&#123;Name: name&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatalf(<span class="string">&quot;failed to send streaming: %v\n&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		stream.CloseSend()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取所有的响应.</span></span><br><span class="line">	<span class="keyword">var</span> rpcStatus <span class="type">error</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;got response:\n&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		r, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			rpcStatus = err</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot; - %s\n&quot;</span>, r.Reply)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rpcStatus != io.EOF &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;failed to finish server streaming: %v&quot;</span>, rpcStatus)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当RPC结束时读取trailer</span></span><br><span class="line">	trailer := stream.Trailer()</span><br><span class="line">	<span class="comment">// 从返回响应的trailer中读取metadata.</span></span><br><span class="line">	<span class="keyword">if</span> t, ok := trailer[<span class="string">&quot;timestamp&quot;</span>]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;timestamp from trailer:\n&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> i, e := <span class="keyword">range</span> t &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot; %d. %s\n&quot;</span>, i, e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;timestamp expected but doesn&#x27;t exist in trailer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="server端的metadata操作"><a href="#server端的metadata操作" class="headerlink" title="server端的metadata操作"></a>server端的metadata操作</h4><p>下面的代码片段演示了server端在服务端流式RPC模式下设置和操作metadata。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BidirectionalStreamingSayHello 流式RPC调用客户端metadata操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> BidirectionalStreamingSayHello(stream pb.Greeter_BidiHelloServer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 在defer中创建trailer记录函数的返回时间.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		trailer := metadata.Pairs(<span class="string">&quot;timestamp&quot;</span>, strconv.Itoa(<span class="type">int</span>(time.Now().Unix())))</span><br><span class="line">		stream.SetTrailer(trailer)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从client读取metadata.</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(stream.Context())</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> status.Errorf(codes.DataLoss, <span class="string">&quot;BidirectionalStreamingSayHello: failed to get metadata&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> t, ok := md[<span class="string">&quot;token&quot;</span>]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;token from metadata:\n&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> i, e := <span class="keyword">range</span> t &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot; %d. %s\n&quot;</span>, i, e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建和发送header.</span></span><br><span class="line">	header := metadata.New(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;location&quot;</span>: <span class="string">&quot;X2Q&quot;</span>&#125;)</span><br><span class="line">	stream.SendHeader(header)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取请求数据发送响应数据.</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;request received %v, sending reply\n&quot;</span>, in)</span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(&amp;pb.HelloResponse&#123;Reply: in.Name&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="gRPC-code"><a href="#gRPC-code" class="headerlink" title="gRPC code"></a>gRPC code</h3><p>类似于HTTP定义了一套响应状态码，gRPC也定义有一些状态码。Go语言中此状态码由<a href="https://pkg.go.dev/google.golang.org/grpc/codes">codes</a>定义，本质上是一个uint32。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Code <span class="type">uint32</span></span><br></pre></td></tr></table></figure>

<p>使用时需导入<code>google.golang.org/grpc/codes</code>包。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google.golang.org/grpc/codes&quot;</span></span><br></pre></td></tr></table></figure>

<p>目前已经定义的状态码有如下几种。</p>
<table>
<thead>
<tr>
<th align="center">Code</th>
<th align="center">值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OK</td>
<td align="center">0</td>
<td align="center">请求成功</td>
</tr>
<tr>
<td align="center">Canceled</td>
<td align="center">1</td>
<td align="center">操作已取消</td>
</tr>
<tr>
<td align="center">Unknown</td>
<td align="center">2</td>
<td align="center">未知错误。如果从另一个地址空间接收到的状态值属 于在该地址空间中未知的错误空间，则可以返回此错误的示例。 没有返回足够的错误信息的API引发的错误也可能会转换为此错误</td>
</tr>
<tr>
<td align="center">InvalidArgument</td>
<td align="center">3</td>
<td align="center">表示客户端指定的参数无效。 请注意，这与 FailedPrecondition 不同。 它表示无论系统状态如何都有问题的参数（例如，格式错误的文件名）。</td>
</tr>
<tr>
<td align="center">DeadlineExceeded</td>
<td align="center">4</td>
<td align="center">表示操作在完成之前已过期。对于改变系统状态的操作，即使操作成功完成，也可能会返回此错误。 例如，来自服务器的成功响应可能已延迟足够长的时间以使截止日期到期。</td>
</tr>
<tr>
<td align="center">NotFound</td>
<td align="center">5</td>
<td align="center">表示未找到某些请求的实体（例如，文件或目录）。</td>
</tr>
<tr>
<td align="center">AlreadyExists</td>
<td align="center">6</td>
<td align="center">创建实体的尝试失败，因为实体已经存在。</td>
</tr>
<tr>
<td align="center">PermissionDenied</td>
<td align="center">7</td>
<td align="center">表示调用者没有权限执行指定的操作。 它不能用于拒绝由耗尽某些资源引起的（使用 ResourceExhausted ）。 如果无法识别调用者，也不能使用它（使用 Unauthenticated ）。</td>
</tr>
<tr>
<td align="center">ResourceExhausted</td>
<td align="center">8</td>
<td align="center">表示某些资源已耗尽，可能是每个用户的配额，或者整个文件系统空间不足</td>
</tr>
<tr>
<td align="center">FailedPrecondition</td>
<td align="center">9</td>
<td align="center">指示操作被拒绝，因为系统未处于操作执行所需的状态。 例如，要删除的目录可能是非空的，rmdir 操作应用于非目录等。</td>
</tr>
<tr>
<td align="center">Aborted</td>
<td align="center">10</td>
<td align="center">表示操作被中止，通常是由于并发问题，如排序器检查失败、事务中止等。</td>
</tr>
<tr>
<td align="center">OutOfRange</td>
<td align="center">11</td>
<td align="center">表示尝试超出有效范围的操作。</td>
</tr>
<tr>
<td align="center">Unimplemented</td>
<td align="center">12</td>
<td align="center">表示此服务中未实施或不支持&#x2F;启用操作。</td>
</tr>
<tr>
<td align="center">Internal</td>
<td align="center">13</td>
<td align="center">意味着底层系统预期的一些不变量已被破坏。 如果你看到这个错误，则说明问题很严重。</td>
</tr>
<tr>
<td align="center">Unavailable</td>
<td align="center">14</td>
<td align="center">表示服务当前不可用。这很可能是暂时的情况，可以通过回退重试来纠正。 请注意，重试非幂等操作并不总是安全的。</td>
</tr>
<tr>
<td align="center">DataLoss</td>
<td align="center">15</td>
<td align="center">表示不可恢复的数据丢失或损坏</td>
</tr>
<tr>
<td align="center">Unauthenticated</td>
<td align="center">16</td>
<td align="center">表示请求没有用于操作的有效身份验证凭据</td>
</tr>
<tr>
<td align="center">_maxCode</td>
<td align="center">17</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="gRPC-Status"><a href="#gRPC-Status" class="headerlink" title="gRPC Status"></a>gRPC Status</h3><p>Go语言使用的gRPC Status 定义在<a href="https://pkg.go.dev/google.golang.org/grpc/status">google.golang.org&#x2F;grpc&#x2F;status</a>，使用时需导入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google.golang.org/grpc/status&quot;</span></span><br></pre></td></tr></table></figure>

<p>RPC服务的方法应该返回 <code>nil</code> 或来自<code>status.Status</code>类型的错误。客户端可以直接访问错误。</p>
<h4 id="创建错误"><a href="#创建错误" class="headerlink" title="创建错误"></a>创建错误</h4><p>当遇到错误时，gRPC服务的方法函数应该创建一个 <code>status.Status</code>。通常我们会使用 <code>status.New</code>函数并传入适当的<code>status.Code</code>和错误描述来生成一个<code>status.Status</code>。调用<code>status.Err</code>方法便能将一个<code>status.Status</code>转为<code>error</code>类型。也存在一个简单的<code>status.Error</code>方法直接生成<code>error</code>。下面是两种方式的比较。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建status.Status</span></span><br><span class="line">st := status.New(codes.NotFound, <span class="string">&quot;some description&quot;</span>)</span><br><span class="line">err := st.Err()  <span class="comment">// 转为error类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vs.</span></span><br><span class="line"></span><br><span class="line">err := status.Error(codes.NotFound, <span class="string">&quot;some description&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="为错误添加其他详细信息"><a href="#为错误添加其他详细信息" class="headerlink" title="为错误添加其他详细信息"></a>为错误添加其他详细信息</h4><p>在某些情况下，可能需要为服务器端的特定错误添加详细信息。<code>status.WithDetails</code>就是为此而存在的，它可以添加任意多个<code>proto.Message</code>，我们可以使用<code>google.golang.org/genproto/googleapis/rpc/errdetails</code>中的定义或自定义的错误详情。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">st := status.New(codes.ResourceExhausted, <span class="string">&quot;Request limit exceeded.&quot;</span>)</span><br><span class="line">ds, _ := st.WithDetails(</span><br><span class="line">	<span class="comment">// proto.Message</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ds.Err()</span><br></pre></td></tr></table></figure>

<p>然后，客户端可以通过首先将普通<code>error</code>类型转换回<code>status.Status</code>，然后使用<code>status.Details</code>来读取这些详细信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := status.Convert(err)</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> s.Details() &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>我们现在要为<code>hello</code>服务设置访问限制，每个<code>name</code>只能调用一次<code>SayHello</code>方法，超过此限制就返回一个请求超过限制的错误。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>使用map存储每个name的请求次数，超过1次则返回错误，并且记录错误详情。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_server/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/genproto/googleapis/rpc/errdetails&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/codes&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/status&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// grpc server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">	mu    sync.Mutex     <span class="comment">// count的并发锁</span></span><br><span class="line">	count <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="comment">// 记录每个name的请求次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello 是我们需要实现的方法</span></span><br><span class="line"><span class="comment">// 这个方法是我们对外提供的服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">	s.count[in.Name]++ <span class="comment">// 记录用户的请求次数</span></span><br><span class="line">	<span class="comment">// 超过1次就返回错误</span></span><br><span class="line">	<span class="keyword">if</span> s.count[in.Name] &gt; <span class="number">1</span> &#123;</span><br><span class="line">		st := status.New(codes.ResourceExhausted, <span class="string">&quot;Request limit exceeded.&quot;</span>)</span><br><span class="line">		ds, err := st.WithDetails(</span><br><span class="line">			&amp;errdetails.QuotaFailure&#123;</span><br><span class="line">				Violations: []*errdetails.QuotaFailure_Violation&#123;&#123;</span><br><span class="line">					Subject:     fmt.Sprintf(<span class="string">&quot;name:%s&quot;</span>, in.Name),</span><br><span class="line">					Description: <span class="string">&quot;限制每个name调用一次&quot;</span>,</span><br><span class="line">				&#125;&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, st.Err()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ds.Err()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 正常返回响应</span></span><br><span class="line">	reply := <span class="string">&quot;hello &quot;</span> + in.GetName()</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloResponse&#123;Reply: reply&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	l, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8972&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to listen, err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer() <span class="comment">// 创建grpc服务</span></span><br><span class="line">	<span class="comment">// 注册服务，注意初始化count</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;count: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;)</span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	err = s.Serve(l)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to serve,err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>当服务端返回错误时，尝试从错误中获取detail信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/status&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_client/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/genproto/googleapis/rpc/errdetails&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// grpc 客户端</span></span><br><span class="line"><span class="comment">// 调用server端的 SayHello 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = flag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;七米&quot;</span>, <span class="string">&quot;通过-name告诉server你是谁&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse() <span class="comment">// 解析命令行参数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接server</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;127.0.0.1:8972&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;grpc.Dial failed,err:%v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="comment">// 创建客户端</span></span><br><span class="line">	c := pb.NewGreeterClient(conn) <span class="comment">// 使用生成的Go代码</span></span><br><span class="line">	<span class="comment">// 调用RPC方法</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	resp, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		s := status.Convert(err)        <span class="comment">// 将err转为status</span></span><br><span class="line">		<span class="keyword">for</span> _, d := <span class="keyword">range</span> s.Details() &#123; <span class="comment">// 获取details</span></span><br><span class="line">			<span class="keyword">switch</span> info := d.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *errdetails.QuotaFailure:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;Quota failure: %s\n&quot;</span>, info)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;Unexpected type: %s\n&quot;</span>, info)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;c.SayHello failed, err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拿到了RPC响应</span></span><br><span class="line">	log.Printf(<span class="string">&quot;resp:%v\n&quot;</span>, resp.GetReply())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="加密或认证"><a href="#加密或认证" class="headerlink" title="加密或认证"></a>加密或认证</h2><h3 id="无加密认证"><a href="#无加密认证" class="headerlink" title="无加密认证"></a>无加密认证</h3><p>在上面的示例中，我们都没有为我们的 gRPC 配置加密或认证，属于不安全的连接（insecure connection）。</p>
<p>Client端：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn, _ := grpc.Dial(<span class="string">&quot;127.0.0.1:8972&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">client := pb.NewGreeterClient(conn)</span><br></pre></td></tr></table></figure>

<p>Server端：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := grpc.NewServer()</span><br><span class="line">lis, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>)</span><br><span class="line"><span class="comment">// error handling omitted</span></span><br><span class="line">s.Serve(lis)</span><br></pre></td></tr></table></figure>

<h3 id="使用服务器身份验证-SSL-TLS"><a href="#使用服务器身份验证-SSL-TLS" class="headerlink" title="使用服务器身份验证 SSL&#x2F;TLS"></a>使用服务器身份验证 SSL&#x2F;TLS</h3><p>gRPC 内置支持 SSL&#x2F;TLS，可以通过 SSL&#x2F;TLS 证书建立安全连接，对传输的数据进行加密处理。</p>
<p>这里我们演示如何使用自签名证书进行server端加密。</p>
<h4 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h4><h5 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h5><p>执行下面的命令生成私钥文件——<code>server.key</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl ecparam -genkey -name secp384r1 -out server.key</span><br></pre></td></tr></table></figure>

<p>这里生成的是ECC私钥，当然你也可以使用RSA。</p>
<h5 id="生成自签名的证书"><a href="#生成自签名的证书" class="headerlink" title="生成自签名的证书"></a>生成自签名的证书</h5><blockquote>
<p>Go1.15之后x509弃用Common Name改用SANs。</p>
</blockquote>
<p>当出现如下错误时，需要提供SANs信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">transport: authentication handshake failed: x509: certificate relies on legacy Common Name field, use SANs or temporarily <span class="built_in">enable</span> Common Name matching with GODEBUG=x509ignoreCN=0</span><br></pre></td></tr></table></figure>

<p>为了在证书中添加SANs信息，我们将下面自定义配置保存到<code>server.cnf</code>文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ req ]</span><br><span class="line">default_bits       = 4096</span><br><span class="line">default_md		= sha256</span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line">req_extensions     = req_ext</span><br><span class="line"></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line">countryName                 = Country Name (2 letter code)</span><br><span class="line">countryName_default         = CN</span><br><span class="line">stateOrProvinceName         = State or Province Name (full name)</span><br><span class="line">stateOrProvinceName_default = BEIJING</span><br><span class="line">localityName                = Locality Name (eg, city)</span><br><span class="line">localityName_default        = BEIJING</span><br><span class="line">organizationName            = Organization Name (eg, company)</span><br><span class="line">organizationName_default    = DEV</span><br><span class="line">commonName                  = Common Name (e.g. server FQDN or YOUR name)</span><br><span class="line">commonName_max              = 64</span><br><span class="line">commonName_default          = liwenzhou.com</span><br><span class="line"></span><br><span class="line">[ req_ext ]</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1   = localhost</span><br><span class="line">DNS.2   = liwenzhou.com</span><br><span class="line">IP      = 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>执行下面的命令生成自签名证书——<code>server.crt</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -nodes -new -x509 -sha256 -days 3650 -config server.cnf -extensions <span class="string">&#x27;req_ext&#x27;</span> -key server.key -out server.crt</span><br></pre></td></tr></table></figure>

<h4 id="建立安全连接"><a href="#建立安全连接" class="headerlink" title="建立安全连接"></a>建立安全连接</h4><p>Server端使用<code>credentials.NewServerTLSFromFile</code>函数分别加载证书<code>server.cert</code>和秘钥<code>server.key</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">creds, _ := credentials.NewServerTLSFromFile(certFile, keyFile)</span><br><span class="line">s := grpc.NewServer(grpc.Creds(creds))</span><br><span class="line">lis, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>)</span><br><span class="line"><span class="comment">// error handling omitted</span></span><br><span class="line">s.Serve(lis)</span><br></pre></td></tr></table></figure>

<p>而client端使用上一步生成的证书文件——<code>server.cert</code>建立安全连接。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">creds, _ := credentials.NewClientTLSFromFile(certFile, <span class="string">&quot;&quot;</span>)</span><br><span class="line">conn, _ := grpc.Dial(<span class="string">&quot;127.0.0.1:8972&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class="line"><span class="comment">// error handling omitted</span></span><br><span class="line">client := pb.NewGreeterClient(conn)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>除了这种自签名证书的方式外，生产环境对外通信时通常需要使用受信任的CA证书。</p>
<h2 id="拦截器（中间件）"><a href="#拦截器（中间件）" class="headerlink" title="拦截器（中间件）"></a>拦截器（中间件）</h2><p>gRPC 为在每个 ClientConn&#x2F;Server 基础上实现和安装拦截器提供了一些简单的 API。 拦截器拦截每个 RPC 调用的执行。用户可以使用拦截器进行日志记录、身份验证&#x2F;授权、指标收集以及许多其他可以跨 RPC 共享的功能。</p>
<p>在 gRPC 中，拦截器根据拦截的 RPC 调用类型可以分为两类。第一个是普通拦截器（一元拦截器），它拦截普通RPC 调用。另一个是流拦截器，它处理流式 RPC 调用。而客户端和服务端都有自己的普通拦截器和流拦截器类型。因此，在 gRPC 中总共有四种不同类型的拦截器。</p>
<h3 id="客户端端拦截器"><a href="#客户端端拦截器" class="headerlink" title="客户端端拦截器"></a>客户端端拦截器</h3><h4 id="普通拦截器-一元拦截器"><a href="#普通拦截器-一元拦截器" class="headerlink" title="普通拦截器&#x2F;一元拦截器"></a>普通拦截器&#x2F;一元拦截器</h4><p><a href="https://godoc.org/google.golang.org/grpc#UnaryClientInterceptor">UnaryClientInterceptor</a> 是客户端一元拦截器的类型，它的函数前面如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, method <span class="type">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>一元拦截器的实现通常可以分为三个部分: 调用 RPC 方法之前（预处理）、调用 RPC 方法（RPC调用）和调用 RPC 方法之后（调用后）。</p>
<ul>
<li>预处理：用户可以通过检查传入的参数(如 RPC 上下文、方法字符串、要发送的请求和 CallOptions 配置)来获得有关当前 RPC 调用的信息。</li>
<li>RPC调用：预处理完成后，可以通过执行<code>invoker</code>执行 RPC 调用。</li>
<li>调用后：一旦调用者返回应答和错误，用户就可以对 RPC 调用进行后处理。通常，它是关于处理返回的响应和错误的。 若要在 <code>ClientConn</code> 上安装一元拦截器，请使用<code>DialOptionWithUnaryInterceptor</code>的<code>DialOption</code>配置 Dial 。</li>
</ul>
<h4 id="流拦截器"><a href="#流拦截器" class="headerlink" title="流拦截器"></a>流拦截器</h4><p><a href="https://godoc.org/google.golang.org/grpc#StreamClientInterceptor">StreamClientInterceptor</a>是客户端流拦截器的类型。它的函数签名是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, desc *StreamDesc, cc *ClientConn, method <span class="type">string</span>, streamer Streamer, opts ...CallOption)</span></span> (ClientStream, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>流拦截器的实现通常包括预处理和流操作拦截。</p>
<ul>
<li>预处理：类似于上面的一元拦截器。</li>
<li>流操作拦截：流拦截器并没有事后进行 RPC 方法调用和后处理，而是拦截了用户在流上的操作。首先，拦截器调用传入的<code>streamer</code>以获取 <code>ClientStream</code>，然后包装 <code>ClientStream</code> 并用拦截逻辑重载其方法。最后，拦截器将包装好的 <code>ClientStream</code> 返回给用户进行操作。</li>
</ul>
<p>若要为 <code>ClientConn</code> 安装流拦截器，请使用<code>WithStreamInterceptor</code>的 DialOption 配置 Dial。</p>
<h3 id="server端拦截器"><a href="#server端拦截器" class="headerlink" title="server端拦截器"></a>server端拦截器</h3><p>服务器端拦截器与客户端类似，但提供的信息略有不同。</p>
<h4 id="普通拦截器-一元拦截器-1"><a href="#普通拦截器-一元拦截器-1" class="headerlink" title="普通拦截器&#x2F;一元拦截器"></a>普通拦截器&#x2F;一元拦截器</h4><p><a href="https://godoc.org/google.golang.org/grpc#UnaryServerInterceptor">UnaryServerInterceptor</a>是服务端的一元拦截器类型，它的函数签名是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span></span> (resp <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>服务端一元拦截器具体实现细节和客户端版本的类似。</p>
<p>若要为服务端安装一元拦截器，请使用 <code>UnaryInterceptor</code> 的<code>ServerOption</code>配置 <code>NewServer</code>。</p>
<h4 id="流拦截器-1"><a href="#流拦截器-1" class="headerlink" title="流拦截器"></a>流拦截器</h4><p><a href="https://godoc.org/google.golang.org/grpc#StreamServerInterceptor">StreamServerInterceptor</a>是服务端流式拦截器的类型，它的签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ss ServerStream, info *StreamServerInfo, handler StreamHandler)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>实现细节类似于客户端流拦截器部分。</p>
<p>若要为服务端安装流拦截器，请使用 <code>StreamInterceptor</code> 的<code>ServerOption</code>来配置 <code>NewServer</code>。</p>
<h3 id="拦截器示例"><a href="#拦截器示例" class="headerlink" title="拦截器示例"></a>拦截器示例</h3><p>下面将演示一个完整的拦截器示例，我们为一元RPC和流式RPC服务都添加上拦截器。</p>
<p>我们首先定义一个名为<code>valid</code>的校验函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// valid 校验认证信息.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">valid</span><span class="params">(authorization []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(authorization) &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	token := strings.TrimPrefix(authorization[<span class="number">0</span>], <span class="string">&quot;Bearer &quot;</span>)</span><br><span class="line">	<span class="comment">// 执行token认证的逻辑</span></span><br><span class="line">	<span class="comment">// 这里是为了演示方便简单判断token是否与&quot;some-secret-token&quot;相等</span></span><br><span class="line">	<span class="keyword">return</span> token == <span class="string">&quot;some-secret-token&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端拦截器定义"><a href="#客户端拦截器定义" class="headerlink" title="客户端拦截器定义"></a>客户端拦截器定义</h4><h5 id="一元拦截器"><a href="#一元拦截器" class="headerlink" title="一元拦截器"></a>一元拦截器</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unaryInterceptor 客户端一元拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unaryInterceptor</span><span class="params">(ctx context.Context, method <span class="type">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> credsConfigured <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">		_, ok := o.(grpc.PerRPCCredsCallOption)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			credsConfigured = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !credsConfigured &#123;</span><br><span class="line">		opts = <span class="built_in">append</span>(opts, grpc.PerRPCCredentials(oauth.NewOauthAccess(&amp;oauth2.Token&#123;</span><br><span class="line">			AccessToken: <span class="string">&quot;some-secret-token&quot;</span>,</span><br><span class="line">		&#125;)))</span><br><span class="line">	&#125;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	err := invoker(ctx, method, req, reply, cc, opts...)</span><br><span class="line">	end := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;RPC: %s, start time: %s, end time: %s, err: %v\n&quot;</span>, method, start.Format(<span class="string">&quot;Basic&quot;</span>), end.Format(time.RFC3339), err)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>grpc.PerRPCCredentials()</code>函数指明每个 RPC 请求使用的凭据，它接收一个<code>credentials.PerRPCCredentials</code>接口类型的参数。<code>credentials.PerRPCCredentials</code>接口的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PerRPCCredentials <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// GetRequestMetadata 获取当前请求的元数据,如果需要则会设置token。</span></span><br><span class="line">	<span class="comment">// 传输层在每个请求上调用，并且数据会被填充到headers或其他context。</span></span><br><span class="line">	GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// RequireTransportSecurity 指示该 Credentials 的传输是否需要需要 TLS 加密</span></span><br><span class="line">	RequireTransportSecurity() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而示例代码中使用的<code>oauth.NewOauthAccess()</code>是内置oauth包提供的一个函数，用来返回包含给定token的<code>PerRPCCredentials</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewOauthAccess constructs the PerRPCCredentials using a given token.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOauthAccess</span><span class="params">(token *oauth2.Token)</span></span> credentials.PerRPCCredentials &#123;</span><br><span class="line">	<span class="keyword">return</span> oauthAccess&#123;token: *token&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(oa oauthAccess)</span></span> GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	ri, _ := credentials.RequestInfoFromContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> err := credentials.CheckSecurityLevel(ri.AuthInfo, credentials.PrivacyAndIntegrity); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to transfer oauthAccess PerRPCCredentials: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;authorization&quot;</span>: oa.token.Type() + <span class="string">&quot; &quot;</span> + oa.token.AccessToken,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(oa oauthAccess)</span></span> RequireTransportSecurity() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="流式拦截器"><a href="#流式拦截器" class="headerlink" title="流式拦截器"></a>流式拦截器</h5><p>自定义一个<code>ClientStream</code>类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> wrappedStream <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wrappedStream</code>重写<code>grpc.ClientStream</code>接口的<code>RecvMsg</code>和<code>SendMsg</code>方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wrappedStream)</span></span> RecvMsg(m <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	logger(<span class="string">&quot;Receive a message (Type: %T) at %v&quot;</span>, m, time.Now().Format(time.RFC3339))</span><br><span class="line">	<span class="keyword">return</span> w.ClientStream.RecvMsg(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wrappedStream)</span></span> SendMsg(m <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	logger(<span class="string">&quot;Send a message (Type: %T) at %v&quot;</span>, m, time.Now().Format(time.RFC3339))</span><br><span class="line">	<span class="keyword">return</span> w.ClientStream.SendMsg(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWrappedStream</span><span class="params">(s grpc.ClientStream)</span></span> grpc.ClientStream &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;wrappedStream&#123;s&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的<code>wrappedStream</code>嵌入了<code>grpc.ClientStream</code>接口类型，然后又重新实现了一遍<code>grpc.ClientStream</code>接口的方法。</p>
</blockquote>
<p>下面就定义一个流式拦截器，最后返回上面定义的<code>wrappedStream</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streamInterceptor 客户端流式拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">streamInterceptor</span><span class="params">(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method <span class="type">string</span>, streamer grpc.Streamer, opts ...grpc.CallOption)</span></span> (grpc.ClientStream, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> credsConfigured <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">		_, ok := o.(*grpc.PerRPCCredsCallOption)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			credsConfigured = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !credsConfigured &#123;</span><br><span class="line">		opts = <span class="built_in">append</span>(opts, grpc.PerRPCCredentials(oauth.NewOauthAccess(&amp;oauth2.Token&#123;</span><br><span class="line">			AccessToken: <span class="string">&quot;some-secret-token&quot;</span>,</span><br><span class="line">		&#125;)))</span><br><span class="line">	&#125;</span><br><span class="line">	s, err := streamer(ctx, desc, cc, method, opts...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newWrappedStream(s), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务端拦截器定义"><a href="#服务端拦截器定义" class="headerlink" title="服务端拦截器定义"></a>服务端拦截器定义</h4><h5 id="一元拦截器-1"><a href="#一元拦截器-1" class="headerlink" title="一元拦截器"></a>一元拦截器</h5><p>服务端定义一个一元拦截器，对从请求元数据中获取的<code>authorization</code>进行校验。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unaryInterceptor 服务端一元拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// authentication (token verification)</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.InvalidArgument, <span class="string">&quot;missing metadata&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !valid(md[<span class="string">&quot;authorization&quot;</span>]) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.Unauthenticated, <span class="string">&quot;invalid token&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	m, err := handler(ctx, req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;RPC failed with error %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流拦截器-2"><a href="#流拦截器-2" class="headerlink" title="流拦截器"></a>流拦截器</h4><p>同样为流RPC也定义一个从元数据中获取认证信息的流式拦截器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// streamInterceptor 服务端流拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">streamInterceptor</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// authentication (token verification)</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(ss.Context())</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> status.Errorf(codes.InvalidArgument, <span class="string">&quot;missing metadata&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !valid(md[<span class="string">&quot;authorization&quot;</span>]) &#123;</span><br><span class="line">		<span class="keyword">return</span> status.Errorf(codes.Unauthenticated, <span class="string">&quot;invalid token&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err := handler(srv, newWrappedStream(ss))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;RPC failed with error %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h4><p>客户端注册拦截器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn, err := grpc.Dial(<span class="string">&quot;127.0.0.1:8972&quot;</span>,</span><br><span class="line">	grpc.WithTransportCredentials(creds),</span><br><span class="line">	grpc.WithUnaryInterceptor(unaryInterceptor),</span><br><span class="line">	grpc.WithStreamInterceptor(streamInterceptor),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>服务端注册拦截器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := grpc.NewServer(</span><br><span class="line">	grpc.Creds(creds),</span><br><span class="line">	grpc.UnaryInterceptor(unaryInterceptor),</span><br><span class="line">	grpc.StreamInterceptor(streamInterceptor),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="go-grpc-middleware"><a href="#go-grpc-middleware" class="headerlink" title="go-grpc-middleware"></a>go-grpc-middleware</h3><p>社区中有很多开源的常用的grpc中间件——<a href="https://github.com/grpc-ecosystem/go-grpc-middleware">go-grpc-middleware</a>，根据需要选择使用。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>函数与defer</title>
    <url>/2023/06/04/Go/8/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h2><p>函数是执行特定任务的代码块。</p>
<h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><p>go 语言至少有一个 main 函数</p>
<p>语法格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(parametername type1, parametername type2)</span></span> (output1 type1, output2 type2) &#123;</span><br><span class="line"><span class="comment">//这里是处理逻辑代码</span></span><br><span class="line"><span class="comment">//返回多个值</span></span><br><span class="line"><span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>func：函数由 func 开始声明</li>
<li>funcName：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parametername type：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>output1 type1, output2 type2：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>上面返回值声明了两个变量 output1 和 output2，如果你不想声明也可以，直接就两个类型。</li>
<li>如果只有一个返回值且不声明返回值变量，那么你可以省略包括返回值的括号（即一个返回值可以不声明返回类型）</li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<h2 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, k <span class="type">string</span>)</span></span> (v <span class="type">string</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	v, ok = m[k]</span><br><span class="line">	<span class="keyword">return</span> v, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res := add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(res) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">	v, ok := exists(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>&#125;, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">	fmt.Println(v, ok) <span class="comment">// A True</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">A true</span><br></pre></td></tr></table></figure>

<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="参数的使用"><a href="#参数的使用" class="headerlink" title="参数的使用"></a>参数的使用</h3><p>形式参数：定义函数时，用于接收外部传入的数据，叫做形式参数，简称形参。</p>
<p>实际参数：调用函数时，传给形参的实际的数据，叫做实际参数，简称实参。</p>
<p>函数调用：</p>
<p> A：函数名称必须匹配</p>
<p> B：实参与形参必须一一对应：顺序，个数，类型</p>
<h3 id="可变参"><a href="#可变参" class="headerlink" title="可变参"></a>可变参</h3><p>Go 函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(arg ...<span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>arg ...int</code> 告诉 Go 这个函数接受不定数量的参数。注意，这些参数的类型全部是 int。在函数体中，变量 arg 是一个 int 的 slice：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arg &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;And the number is: %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>go 语言函数的参数也是存在<strong>值传递</strong>和<strong>引用传递</strong></p>
<p>函数运用场景</p>
<p><strong>值传递</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明函数变量 */</span></span><br><span class="line">   getSquareRoot := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用函数 */</span></span><br><span class="line">   fmt.Println(getSquareRoot(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用传递</strong></p>
<p>这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。</p>
<p>只有 add1 函数知道 x 变量所在的地址，才能修改 x 变量的值。所以我们需要将 x 所在地址 &amp; x 传入函数，并将函数的参数的类型由 int 改为 * int，即改为指针类型，才能在函数中修改 x 变量的值。此时参数仍然是按 copy 传递的，只是 copy 的是一个指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// 请注意，</span></span><br><span class="line">	*a = *a + <span class="number">1</span> <span class="comment">// 修改了a的值</span></span><br><span class="line">	<span class="keyword">return</span> *a   <span class="comment">// 返回新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">3</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">	x1 := add1(&amp;x)            <span class="comment">// 调用 add1(&amp;x) 传x的地址</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出 &quot;x+1 = 4&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x =  3</span><br><span class="line">x+1 =  4</span><br><span class="line">x =  4</span><br></pre></td></tr></table></figure>

<ul>
<li>传指针使得多个函数能操作同一个对象。</li>
<li>传指针比较轻量级 (8bytes), 只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话，在每次 copy 上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。</li>
<li><strong>Go 语言中 slice，map 这三种类型的实现机制类似指针</strong>，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变 slice 的长度，则仍需要取地址传递指针）</li>
</ul>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><h3 id="什么是函数的返回值"><a href="#什么是函数的返回值" class="headerlink" title="什么是函数的返回值"></a>什么是函数的返回值</h3><p>一个函数被调用后，返回给调用处的执行结果，叫做函数的返回值。</p>
<p>调用处需要使用变量接收该结果</p>
<h3 id="一个函数可以返回多个值"><a href="#一个函数可以返回多个值" class="headerlink" title="一个函数可以返回多个值"></a>一个函数可以返回多个值</h3><p>一个函数可以没有返回值，也可以有一个返回值，也可以有返回多个值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Mahesh&quot;</span>, <span class="string">&quot;Kumar&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (add <span class="type">int</span>, Multiplied <span class="type">int</span>) &#123;</span><br><span class="line">add = A+B</span><br><span class="line">Multiplied = A*B</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h3><p>_是 Go 中的空白标识符。它可以代替任何类型的任何值。让我们看看这个空白标识符的用法。</p>
<p>比如 rectProps 函数返回的结果是面积和周长，如果我们只要面积，不要周长，就可以使用空白标识符。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectProps</span><span class="params">(length, width <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">float64</span>) &#123;  </span><br><span class="line">    <span class="keyword">var</span> area = length * width</span><br><span class="line">    <span class="keyword">var</span> perimeter = (length + width) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> area, perimeter</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    area, _ := rectProps(<span class="number">10.8</span>, <span class="number">5.6</span>) <span class="comment">// perimeter is discarded</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area %f &quot;</span>, area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>作用域：变量可以使用的范围。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>一个函数内部定义的变量，就叫做局部变量</p>
<p>变量在哪里定义，就只能在哪个范围使用，超出这个范围，我们认为变量就被销毁了。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>一个函数外部定义的变量，就叫做全局变量</p>
<p>所有的函数都可以使用，而且共享这一份数据</p>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>一个函数自己调用自己，就叫做递归调用，一个递归函数一定要有出口，否则会陷入死循环</p>
<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><h2 id="延迟是什么？"><a href="#延迟是什么？" class="headerlink" title="延迟是什么？"></a>延迟是什么？</h2><p>即延迟（defer）语句，延迟语句被用于执行一个函数调用，在这个函数之前，延迟语句返回。</p>
<h2 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h2><p>你可以在函数中添加多个 defer 语句。当函数执行到最后时，这些 defer 语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。</p>
<ul>
<li>如果有很多调用 defer，那么 defer 是采用<code>后进先出</code>模式</li>
<li>在离开所在的方法时，执行（报错的时候也会执行）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后才执行 <code>file.Close()</code></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	b := <span class="number">2</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(b)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finished</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Finished finding largest&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largest</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> finished()    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Started finding largest&quot;</span>)</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">            max = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Largest number in&quot;</span>, nums, <span class="string">&quot;is&quot;</span>, max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">78</span>, <span class="number">109</span>, <span class="number">2</span>, <span class="number">563</span>, <span class="number">300</span>&#125;</span><br><span class="line">    largest(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Started finding largest  </span><br><span class="line">Largest number in [78 109 2 563 300] is 563  </span><br><span class="line">Finished finding largest </span><br></pre></td></tr></table></figure>

<h2 id="延迟方法"><a href="#延迟方法" class="headerlink" title="延迟方法"></a>延迟方法</h2><p>延迟并不仅仅局限于函数。延迟一个方法调用也是完全合法的。让我们编写一个小程序来测试这个。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	firstName <span class="type">string</span></span><br><span class="line">	lastName  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> fullName() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s %s&quot;</span>, p.firstName, p.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := person&#123;</span><br><span class="line">		firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">		lastName:  <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> p.fullName()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Welcome &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Welcome John Smith </span><br></pre></td></tr></table></figure>

<h2 id="延迟参数"><a href="#延迟参数" class="headerlink" title="延迟参数"></a>延迟参数</h2><p>延迟函数的参数在执行延迟语句时被执行，而不是在执行实际的函数调用时执行。</p>
<p>让我们通过一个例子来理解这个问题。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printA</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a in deferred function&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">5</span></span><br><span class="line">    <span class="keyword">defer</span> printA(a)</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a before deferred function call&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value of a before deferred function call 10 </span><br><span class="line">value of a in deferred function 5 </span><br></pre></td></tr></table></figure>

<h2 id="堆栈的推迟"><a href="#堆栈的推迟" class="headerlink" title="堆栈的推迟"></a>堆栈的推迟</h2><p>当一个函数有多个延迟调用时，它们被添加到一个堆栈中，并在 Last In First Out（LIFO）后进先出的顺序中执行。</p>
<p>编写一个小程序，它使用一堆 defers 打印一个字符串。示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    name := <span class="string">&quot;Naveen&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Orignal String: %s\n&quot;</span>, <span class="type">string</span>(name))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Reversed String: &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">rune</span>(name) &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%c&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>在 Go 语言中，<code>rune</code> 是一个整数类型别名，用于表示 Unicode 字符。它实际上是一个 32 位的整数，可以存储任何 Unicode 码点的值。在 Go 中，字符串是由一系列的 Unicode 字符组成的。每个 Unicode 字符可以由一个或多个字节表示。使用 <code>rune </code>类型，我们可以按字符而不是字节来处理字符串。<code>rune </code>类型的主要作用是允许我们在字符串中按字符进行迭代、索引和操作。当我们需要遍历字符串中的每个字符时，特别是在涉及多字节字符（如中文、日文或特殊符号）的情况下，使用<code>rune</code> 类型可以确保正确处理每个字符。在上面的代码示例中，我们使用 <code>[]rune(name)</code> 将字符串 <code>name</code> 转换为一个 <code>rune</code> 切片，以便我们可以按字符迭代处理它。这样可以确保逆序打印字符串中的每个字符，而不仅仅是按字节逆序打印。</p>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Orignal String: Naveen </span><br><span class="line">Reversed String: neevaN </span><br></pre></td></tr></table></figure>

<h2 id="defer-注意点"><a href="#defer-注意点" class="headerlink" title="defer 注意点"></a>defer 注意点</h2><p>defer 函数：<br>当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。<br>当执行外围函数中的 return 语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。<br>当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Xorm开发详细文档</title>
    <url>/2023/08/07/Go/33/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>xorm是一个简单而强大的Go语言ORM库. 通过它可以使数据库操作非常简便。xorm的目标并不是让你完全不去学习SQL，我们认为SQL并不会为ORM所替代，但是ORM将可以解决绝大部分的简单SQL需求。xorm支持两种风格的混用。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>支持Struct和数据库表之间的灵活映射，并支持自动同步</li>
<li>事务支持</li>
<li>同时支持原始SQL语句和ORM操作的混合执行</li>
<li>使用连写来简化调用</li>
<li>支持使用Id, In, Where, Limit, Join, Having, Table, SQL, Cols等函数和结构体等方式作为条件</li>
<li>支持级联加载Struct</li>
<li>Schema支持（仅Postgres）</li>
<li>支持缓存</li>
<li>支持根据数据库自动生成xorm的结构体</li>
<li>支持记录版本（即乐观锁）</li>
<li>内置SQL Builder支持</li>
<li>通过EngineGroup支持读写分离和负载均衡</li>
</ul>
<h2 id="支持的数据库"><a href="#支持的数据库" class="headerlink" title="支持的数据库"></a>支持的数据库</h2><ul>
<li>Mysql: <a href="https://github.com/go-sql-driver/mysql">github.com&#x2F;go-sql-driver&#x2F;mysql</a></li>
<li>MyMysql: <a href="https://github.com/ziutek/mymysql/godrv">github.com&#x2F;ziutek&#x2F;mymysql&#x2F;godrv</a></li>
<li>Postgres: <a href="https://github.com/lib/pq">github.com&#x2F;lib&#x2F;pq</a></li>
<li>Tidb: <a href="https://github.com/pingcap/tidb">github.com&#x2F;pingcap&#x2F;tidb</a></li>
<li>SQLite: <a href="https://github.com/mattn/go-sqlite3">github.com&#x2F;mattn&#x2F;go-sqlite3</a></li>
<li>MsSql: <a href="https://github.com/denisenkom/go-mssqldb">github.com&#x2F;denisenkom&#x2F;go-mssqldb</a></li>
<li>MsSql: <a href="https://github.com/lunny/godbc">github.com&#x2F;lunny&#x2F;godbc</a></li>
<li>Oracle: <a href="https://github.com/mattn/go-oci8">github.com&#x2F;mattn&#x2F;go-oci8</a> (试验性支持)</li>
<li>ql: <a href="https://github.com/cznic/ql">github.com&#x2F;cznic&#x2F;ql</a> (试验性支持)</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get xorm.io/xorm</span><br></pre></td></tr></table></figure>

<h1 id="创建-Engine"><a href="#创建-Engine" class="headerlink" title="创建 Engine"></a>创建 Engine</h1><p>所有操作均需要事先创建并配置 ORM 引擎才可以进行。XORM 支持两种 ORM 引擎，即 Engine 引擎和 Engine Group 引擎。一个 Engine 引擎用于对单个数据库进行操作，一个 Engine Group 引擎用于对读写分离的数据库或者负载均衡的数据库进行操作。Engine 引擎和 EngineGroup 引擎的API基本相同，所有适用于 Engine 的 API 基本上都适用于 EngineGroup，并且可以比较容易的从 Engine 引擎迁移到 EngineGroup 引擎。</p>
<h2 id="单引擎"><a href="#单引擎" class="headerlink" title="单引擎"></a>单引擎</h2><p>单个ORM引擎，也称为Engine。一个 APP 可以同时存在多个 Engine 引擎，一个Engine一般只对应一个数据库。Engine 通过调用 <code>xorm.NewEngine</code> 生成，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">    <span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> engine *xorm.Engine</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    engine, err = xorm.NewEngine(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:123@/test?charset=utf8&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;github.com/mattn/go-sqlite3&quot;</span></span><br><span class="line">    <span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> engine *xorm.Engine</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    engine, err = xorm.NewEngine(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;./test.db&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以用 <code>NewEngineWithParams</code>, <code>NewEngineWithDB</code> 和 <code>NewEngineWithDialectAndDB</code> 来创建引擎。</p>
<p>一般情况下如果只操作一个数据库，只需要创建一个 <code>engine</code> 即可。<code>engine</code> 是 GoRoutine 安全的。</p>
<p>创建完成 <code>engine</code> 之后，并没有立即连接数据库，此时可以通过 <code>engine.Ping()</code> 或者 <code>engine.PingContext()</code> 来进行数据库的连接测试是否可以连接到数据库。另外对于某些数据库有连接超时设置的，可以通过起一个定期Ping的Go程来保持连接鲜活。</p>
<p>对于有大量数据并且需要分区的应用，也可以根据规则来创建多个Engine，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++ &#123;</span><br><span class="line">    engines[i], err = xorm.NewEngine(<span class="string">&quot;sqlite3&quot;</span>, fmt.Sprintf(<span class="string">&quot;./test%d.db&quot;</span>, i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>engine 可以通过 engine.Close 来手动关闭，但是一般情况下可以不用关闭，在程序退出时会自动关闭。</p>
<p>NewEngine 传入的参数和<code>sql.Open</code>传入的参数完全相同，因此，在使用某个驱动前，请查看此驱动中关于传入参数的说明文档。以下为各个驱动的连接符对应的文档链接：</p>
<ul>
<li><a href="https://pkg.go.dev/github.com/mattn/go-sqlite3#SQLiteDriver.Open">sqlite3</a></li>
<li><a href="https://github.com/go-sql-driver/mysql#dsn-data-source-name">mysql dsn</a></li>
<li><a href="https://pkg.go.dev/github.com/ziutek/mymysql/godrv#Driver.Open">mymysql</a></li>
<li><a href="https://pkg.go.dev/github.com/lib/pq">postgres</a></li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>日志是一个接口，通过设置日志，可以显示SQL，警告以及错误等，默认的显示级别为 INFO。</p>
<ul>
<li><code>engine.ShowSQL(true)</code>，则会在控制台打印出生成的SQL语句；</li>
<li><code>engine.Logger().SetLevel(log.LOG_DEBUG)</code>，则会在控制台打印调试及以上的信息；</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">	<span class="string">&quot;xorm.io/xorm/log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> engine *xorm.Engine</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	engine, _ = xorm.NewEngine(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:@/test?charset=utf8mb4&quot;</span>)</span><br><span class="line">	engine.ShowSQL(<span class="literal">true</span>)</span><br><span class="line">	engine.Logger().SetLevel(log.LOG_DEBUG)</span><br><span class="line">	engine.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望将信息不仅打印到控制台，而是保存为文件，那么可以通过类似如下的代码实现，<code>NewSimpleLogger(w io.Writer)</code>接收一个io.Writer接口来将数据写入到对应的设施中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Create(<span class="string">&quot;sql.log&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(err.Error())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">engine.SetLogger(log.NewSimpleLogger(f))</span><br></pre></td></tr></table></figure>

<p>当然，如果希望将日志记录到 syslog 中，也可以如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">logWriter, err := syslog.New(syslog.LOG_DEBUG, <span class="string">&quot;rest-xorm-example&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;Fail to create xorm system logger: %v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger := log.NewSimpleLogger(logWriter)</span><br><span class="line">logger.ShowSQL(<span class="literal">true</span>)</span><br><span class="line">engine.SetLogger(logger)</span><br></pre></td></tr></table></figure>

<p>你也可以自定义自己的接口，可通过日志接口中包含的 <code>context</code> 进行更详细的跟踪。</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>engine内部支持连接池接口和对应的函数。</p>
<ul>
<li>如果需要设置连接池的空闲数大小，可以使用 <code>engine.SetMaxIdleConns()</code> 来实现。</li>
<li>如果需要设置最大打开连接数，则可以使用 <code>engine.SetMaxOpenConns()</code> 来实现。</li>
<li>如果需要设置连接的最大生存时间，则可以使用 <code>engine.SetConnMaxLifetime()</code> 来实现。</li>
</ul>
<h2 id="引擎组"><a href="#引擎组" class="headerlink" title="引擎组"></a>引擎组</h2><p>通过创建引擎组 EngineGroup 来实现对从数据库 (Master&#x2F;Slave) 读写分离的支持。在创建引擎章节中，我们已经介绍过了，在 xorm 里面，可以同时存在多个 Orm 引擎，一个 Orm 引擎称为 Engine，一个 Engine 一般只对应一个数据库，而 EngineGroup 一般则对应一组数据库。EngineGroup 通过调用 xorm.NewEngineGroup 生成，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">    <span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eg *xorm.EngineGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conns := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test?sslmode=disable;&quot;</span>, <span class="comment">// 第一个默认是master</span></span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test1?sslmode=disable;&quot;</span>, <span class="comment">// 第二个开始都是slave</span></span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test2?sslmode=disable&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	eg, err = xorm.NewEngineGroup(<span class="string">&quot;postgres&quot;</span>, conns)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">    <span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eg *xorm.EngineGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    master, err := xorm.NewEngine(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;postgres://postgres:root@localhost:5432/test?sslmode=disable&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    slave1, err := xorm.NewEngine(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;postgres://postgres:root@localhost:5432/test1?sslmode=disable&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    slave2, err := xorm.NewEngine(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;postgres://postgres:root@localhost:5432/test2?sslmode=disable&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">   	slaves := []*xorm.Engine&#123;slave1, slave2&#125;</span><br><span class="line">	eg, err = xorm.NewEngineGroup(master, slaves)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完成 EngineGroup 之后，并没有立即连接数据库，此时可以通过 eg.Ping() 来进行数据库的连接测试是否可以连接到数据库，该方法会依次调用引擎组中每个Engine的Ping方法。另外对于某些数据库有连接超时设置的，可以通过起一个定期Ping的Go程来保持连接鲜活。EngineGroup 可以通过 eg.Close() 来手动关闭，但是一般情况下可以不用关闭，在程序退出时会自动关闭。</p>
<ul>
<li>NewEngineGroup方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEngineGroup</span><span class="params">(args1 <span class="keyword">interface</span>&#123;&#125;, args2 <span class="keyword">interface</span>&#123;&#125;, policies ...GroupPolicy)</span></span> (*EngineGroup, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>前两个参数的使用示例如上，有两种模式。</p>
<ul>
<li><p>模式一：通过给定 DriverName，DataSourceName 来创建引擎组，每个引擎使用相同的Driver。每个引擎的 DataSourceNames 是 []string 类型，第一个元素是 Master 的 DataSourceName，之后的元素是 Slave的DataSourceName 。</p>
</li>
<li><p>模式二：通过给定*xorm.Engine，<code>[]*xorm.Engine</code> 来创建引擎组，每个引擎可以使用不同的 Driver。第一个参数为 Master 的 *xorm.Engine，第二个参数为 Slave 的 []*xorm.Engine。 NewEngineGroup 方法，第三个参数为 policies，为 Slave 设定负载策略，该参数将在负载策略章节详细介绍，如示例中未指定，则默认为轮询负载策略。</p>
</li>
<li><p>Master方法</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(eg *EngineGroup)</span></span> Master() *Engine</span><br></pre></td></tr></table></figure>

<p>返回Master数据库引擎</p>
<ul>
<li>Slave方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(eg *EngineGroup)</span></span> Slave() *Engine</span><br></pre></td></tr></table></figure>

<p>依据给定的负载策略返回一个Slave数据库引擎</p>
<ul>
<li>Slaves方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(eg *EngineGroup)</span></span> Slaves() []*Engine</span><br></pre></td></tr></table></figure>

<p>返回所以 Slave 数据库引擎</p>
<ul>
<li>SetPolicy方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(eg *EngineGroup)</span></span> SetPolicy(policy GroupPolicy) *EngineGroup</span><br></pre></td></tr></table></figure>

<h2 id="引擎组策略"><a href="#引擎组策略" class="headerlink" title="引擎组策略"></a>引擎组策略</h2><h3 id="负载策略"><a href="#负载策略" class="headerlink" title="负载策略"></a>负载策略</h3><p>通过 xorm.NewEngineGroup 创建 EngineGroup 时，第三个参数为 policies，我们可以通过该参数来指定 Slave 访问的负载策略。如创建EngineGroup 时未指定，则默认使用轮询的负载策略。</p>
<p>xorm 中内置五种负载策略，分别为随机访问负载策略，权重随机访问负载策略，轮询访问负载策略，权重轮询访问负载策略和最小连接数访问负载策略。开发者也可以通过实现 GroupPolicy 接口，来实现自定义负载策略。</p>
<ul>
<li>随机访问负载策略</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  _ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">  <span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eg *xorm.EngineGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  conns := []<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;postgres://postgres:root@localhost:5432/test?sslmode=disable;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;postgres://postgres:root@localhost:5432/test1?sslmode=disable;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;postgres://postgres:root@localhost:5432/test2?sslmode=disable&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">  eg, err = xorm.NewEngineGroup(<span class="string">&quot;postgres&quot;</span>, conns, xorm.RandomPolicy())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>权重随机访问负载策略</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">    <span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eg *xorm.EngineGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  conns := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test?sslmode=disable;&quot;</span>,</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test1?sslmode=disable;&quot;</span>,</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test2?sslmode=disable&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">  <span class="comment">//此时设置的test1数据库和test2数据库的随机访问权重为2和3</span></span><br><span class="line">	eg, err = xorm.NewEngineGroup(<span class="string">&quot;postgres&quot;</span>, conns, xorm.WeightRandomPolicy([]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>轮询访问负载策略</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">    <span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eg *xorm.EngineGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conns := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test?sslmode=disable;&quot;</span>,</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test1?sslmode=disable;&quot;</span>,</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test2?sslmode=disable&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	eg, err = xorm.NewEngineGroup(<span class="string">&quot;postgres&quot;</span>, conns, xorm.RoundRobinPolicy())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>权重轮询访问负载策略</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">    <span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eg *xorm.EngineGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  conns := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test?sslmode=disable;&quot;</span>,</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test1?sslmode=disable;&quot;</span>,</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test2?sslmode=disable&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">  <span class="comment">//此时设置的test1数据库和test2数据库的轮询访问权重为2和3</span></span><br><span class="line">	eg, err = xorm.NewEngineGroup(<span class="string">&quot;postgres&quot;</span>, conns, xorm.WeightRoundRobinPolicy([]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最小连接数访问负载策略</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">    <span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eg *xorm.EngineGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conns := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test?sslmode=disable;&quot;</span>,</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test1?sslmode=disable;&quot;</span>,</span><br><span class="line">		<span class="string">&quot;postgres://postgres:root@localhost:5432/test2?sslmode=disable&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	eg, err = xorm.NewEngineGroup(<span class="string">&quot;postgres&quot;</span>, conns, xorm.LeastConnPolicy())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义负载策略</li>
</ul>
<p>你也可以通过实现 GroupPolicy 接口来实现自定义负载策略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupPolicy <span class="keyword">interface</span> &#123;</span><br><span class="line">	Slave(*EngineGroup) *Engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="定义表结构体"><a href="#定义表结构体" class="headerlink" title="定义表结构体"></a>定义表结构体</h1><h2 id="各种映射规则"><a href="#各种映射规则" class="headerlink" title="各种映射规则"></a>各种映射规则</h2><p>跟名称相关的函数包含在 <code>xorm.io/xorm/names</code> 下。名称映射规则主要负责结构体名称到表名和结构体 field 到表字段的名称映射。由 <code>names.Mapper</code> 接口的实现者来管理，xorm 内置了三种 <code>Mapper</code> 实现：<code>names.SnakeMapper</code> ， <code>names.SameMapper</code>和<code>names.GonicMapper</code>。</p>
<ul>
<li>SnakeMapper 支持struct为驼峰式命名，表结构为下划线命名之间的转换，这个是默认的Maper；</li>
<li>SameMapper 支持结构体名称和对应的表名称以及结构体field名称与对应的表字段名称相同的命名；</li>
<li>GonicMapper 和SnakeMapper很类似，但是对于特定词支持更好，比如ID会翻译成id而不是i_d。</li>
</ul>
<p>当前 SnakeMapper 为默认值，如果需要改变时，在 engine 创建完成后使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.SetMapper(names.GonicMapper&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>同时需要注意的是：</p>
<ul>
<li>如果你使用了别的命名规则映射方案，也可以自己实现一个 Mapper。</li>
<li>表名称和字段名称的映射规则默认是相同的，当然也可以设置为不同，如：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.SetTableMapper(names.SameMapper&#123;&#125;)</span><br><span class="line">engine.SetColumnMapper(names.SnakeMapper&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>当结构体自动转换为对应的数据库类型时，下面的表显示了转换关系：</p>
<table>
<thead>
<tr>
<th>go type’s kind</th>
<th>value method</th>
<th>xorm type</th>
</tr>
</thead>
<tbody><tr>
<td>implemented Conversion</td>
<td>Conversion.ToDB &#x2F; Conversion.FromDB</td>
<td>Text</td>
</tr>
<tr>
<td>int, int8, int16, int32, uint, uint8, uint16, uint32</td>
<td></td>
<td>Int</td>
</tr>
<tr>
<td>int64, uint64</td>
<td></td>
<td>BigInt</td>
</tr>
<tr>
<td>float32</td>
<td></td>
<td>Float</td>
</tr>
<tr>
<td>float64</td>
<td></td>
<td>Double</td>
</tr>
<tr>
<td>complex64, complex128</td>
<td>json.Marshal &#x2F; json.UnMarshal</td>
<td>Varchar(64)</td>
</tr>
<tr>
<td>[]uint8</td>
<td></td>
<td>Blob</td>
</tr>
<tr>
<td>array, slice, map except []uint8</td>
<td>json.Marshal &#x2F; json.UnMarshal</td>
<td>Text</td>
</tr>
<tr>
<td>bool</td>
<td>1 or 0</td>
<td>Bool</td>
</tr>
<tr>
<td>string</td>
<td></td>
<td>Varchar(255)</td>
</tr>
<tr>
<td>time.Time</td>
<td></td>
<td>DateTime</td>
</tr>
<tr>
<td>cascade struct</td>
<td>primary key field value</td>
<td>BigInt</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>struct</td>
<td>json.Marshal &#x2F; json.UnMarshal</td>
<td>Text</td>
</tr>
<tr>
<td>Others</td>
<td></td>
<td>Text</td>
</tr>
</tbody></table>
<h2 id="前缀映射，后缀映射和缓存映射"><a href="#前缀映射，后缀映射和缓存映射" class="headerlink" title="前缀映射，后缀映射和缓存映射"></a>前缀映射，后缀映射和缓存映射</h2><ul>
<li>通过 <code>names.NewPrefixMapper(names.SnakeMapper&#123;&#125;, &quot;prefix&quot;)</code> 可以创建一个在 SnakeMapper 的基础上在命名中添加统一的前缀，当然也可以把 SnakeMapper{} 换成 SameMapper 或者你自定义的 Mapper。</li>
</ul>
<p>例如，如果希望所有的表名都在结构体自动命名的基础上加一个前缀而字段名不加前缀，则可以在 engine 创建完成后执行以下语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tbMapper := names.NewPrefixMapper(names.SnakeMapper&#123;&#125;, <span class="string">&quot;prefix_&quot;</span>)</span><br><span class="line">engine.SetTableMapper(tbMapper)</span><br></pre></td></tr></table></figure>

<p>执行之后，结构体 <code>type User struct</code> 默认对应的表名就变成了 <code>prefix_user</code> 了，而之前默认的是 <code>user</code></p>
<ul>
<li>通过 <code>names.NewSuffixMapper(names.SnakeMapper&#123;&#125;, &quot;suffix&quot;)</code> 可以创建一个在 SnakeMapper 的基础上在命名中添加统一的后缀，当然也可以把SnakeMapper换成SameMapper或者你自定义的Mapper。</li>
<li>通过 <code>names.NewCacheMapper(names.SnakeMapper&#123;&#125;)</code> 可以创建一个组合了其它的映射规则，起到在内存中缓存曾经映射过的命名映射。</li>
</ul>
<h2 id="使用-Table-和-Tag-改变名称映射"><a href="#使用-Table-和-Tag-改变名称映射" class="headerlink" title="使用 Table 和 Tag 改变名称映射"></a>使用 Table 和 Tag 改变名称映射</h2><p>如果所有的命名都是按照 Mapper 的映射来操作的，那当然是最理想的。但是如果碰到某个表名或者某个字段名跟映射规则不匹配时，我们就需要别的机制来改变。xorm 提供了如下几种方式来进行：</p>
<ul>
<li>如果结构体拥有 <code>TableName() string</code> 的成员方法，那么此方法的返回值即是该结构体对应的数据库表名。</li>
<li>通过 <code>engine.Table()</code> 方法可以改变 struct 对应的数据库表的名称，通过 sturct 中 field 对应的 Tag 中使用 <code>xorm:&quot;&#39;column_name&#39;&quot;</code>可以使该 field 对应的 Column 名称为指定名称。这里使用两个单引号将 Column 名称括起来是为了防止名称冲突，因为我们在Tag中还可以对这个Column进行更多的定义。如果名称不冲突的情况，单引号也可以不使用。</li>
</ul>
<p>到此名称映射的所有方法都给出了，一共三种方式，这三种是有优先级顺序的。</p>
<ul>
<li>表名的优先级顺序如下：<ul>
<li><code>engine.Table()</code> 指定的临时表名优先级最高</li>
<li><code>TableName() string</code> 其次</li>
<li><code>Mapper</code> 自动映射的表名优先级最后</li>
</ul>
</li>
<li>字段名的优先级顺序如下：<ul>
<li>结构体tag指定的字段名优先级较高</li>
<li><code>Mapper</code> 自动映射的表名优先级较低</li>
</ul>
</li>
</ul>
<h2 id="Column-属性定义"><a href="#Column-属性定义" class="headerlink" title="Column 属性定义"></a>Column 属性定义</h2><p>我们在 field 对应的 Tag 中对 Column 的一些属性进行定义，定义的方法基本和我们写SQL定义表结构类似，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id   <span class="type">int64</span></span><br><span class="line">    Name <span class="type">string</span>  <span class="string">`xorm:&quot;varchar(25) notnull unique &#x27;usr_name&#x27; comment(&#x27;姓名&#x27;)&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于不同的数据库系统，数据类型其实是有些差异的。因此xorm中对数据类型有自己的定义，基本的原则是尽量兼容各种数据库的字段类型，具体的字段对应关系可以查看<a href="https://xorm.io/zh/docs/chapter-02/4.columns/5.types.md">字段类型对应表</a>。对于使用者，一般只要使用自己熟悉的数据库字段定义即可。</p>
<p>具体的 Tag 规则如下，另 Tag 中的关键字均不区分大小写，但字段名根据不同的数据库是区分大小写：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>当前field对应的字段的名称，可选，如不写，则自动根据field名字和转换规则命名，如与其它关键字冲突，请使用单引号括起来。</th>
</tr>
</thead>
<tbody><tr>
<td>pk</td>
<td>是否是Primary Key，如果在一个struct中有多个字段都使用了此标记，则这多个字段构成了复合主键，单主键当前支持int32,int,int64,uint32,uint,uint64,string这7种Go的数据类型，复合主键支持这7种Go的数据类型的组合。</td>
</tr>
<tr>
<td>当前支持30多种字段类型，详情参见本文最后一个表格</td>
<td>字段类型</td>
</tr>
<tr>
<td>autoincr</td>
<td>是否是自增</td>
</tr>
<tr>
<td>[not ]null 或 notnull</td>
<td>是否可以为空</td>
</tr>
<tr>
<td>unique或unique(uniquename)</td>
<td>是否是唯一，如不加括号则该字段不允许重复；如加上括号，则括号中为联合唯一索引的名字，此时如果有另外一个或多个字段和本unique的uniquename相同，则这些uniquename相同的字段组成联合唯一索引</td>
</tr>
<tr>
<td>index或index(indexname)</td>
<td>是否是索引，如不加括号则该字段自身为索引，如加上括号，则括号中为联合索引的名字，此时如果有另外一个或多个字段和本index的indexname相同，则这些indexname相同的字段组成联合索引</td>
</tr>
<tr>
<td>extends</td>
<td>应用于一个匿名成员结构体或者非匿名成员结构体之上，表示此结构体的所有成员也映射到数据库中，extends可加载无限级</td>
</tr>
<tr>
<td>-</td>
<td>这个Field将不进行字段映射</td>
</tr>
<tr>
<td>-&gt;</td>
<td>这个Field将只写入到数据库而不从数据库读取</td>
</tr>
<tr>
<td>&lt;-</td>
<td>这个Field将只从数据库读取，而不写入到数据库</td>
</tr>
<tr>
<td>created</td>
<td>这个Field将在Insert时自动赋值为当前时间</td>
</tr>
<tr>
<td>updated</td>
<td>这个Field将在Insert或Update时自动赋值为当前时间</td>
</tr>
<tr>
<td>deleted</td>
<td>这个Field将在Delete时设置为当前时间，并且当前记录不删除</td>
</tr>
<tr>
<td>version</td>
<td>这个Field将会在insert时默认为1，每次更新自动加1</td>
</tr>
<tr>
<td>default 0或default(0)</td>
<td>设置默认值，紧跟的内容如果是Varchar等需要加上单引号</td>
</tr>
<tr>
<td>json</td>
<td>表示内容将先转成Json格式，然后存储到数据库中，数据库中的字段类型可以为Text或者二进制</td>
</tr>
<tr>
<td>comment</td>
<td>设置字段的注释（当前仅支持mysql）</td>
</tr>
</tbody></table>
<p>另外有如下几条自动映射的规则：</p>
<ul>
<li>1.如果field名称为<code>Id</code>而且类型为<code>int64</code>并且没有定义tag，则会被xorm视为主键，并且拥有自增属性。如果想用<code>Id</code>以外的名字或非int64类型做为主键名，必须在对应的Tag上加上<code>xorm:&quot;pk&quot;</code>来定义主键，加上<code>xorm:&quot;autoincr&quot;</code>作为自增。这里需要注意的是，有些数据库并不允许非主键的自增属性。</li>
<li>2.string类型默认映射为<code>varchar(255)</code>，如果需要不同的定义，可以在tag中自定义，如：<code>varchar(1024)</code></li>
<li>3.支持<code>type MyString string</code>等自定义的field，支持Slice, Map等field成员，这些成员默认存储为Text类型，并且默认将使用Json格式来序列化和反序列化。也支持数据库字段类型为Blob类型。如果是Blob类型，则先使用Json格式序列化再转成[]byte格式。如果是[]byte或者[]uint8，则不做转换二十直接以二进制方式存储。具体参见 <a href="https://xorm.io/zh/docs/chapter-02/4.columns/chapter-02/5.types.md">Go与字段类型对应表</a></li>
<li>4.实现了Conversion接口的类型或者结构体，将根据接口的转换方式在类型和数据库记录之间进行相互转换，这个接口的优先级是最高的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Conversion <span class="keyword">interface</span> &#123;</span><br><span class="line">    FromDB([]<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line">    ToDB() ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>5.如果一个结构体包含一个 Conversion 的接口类型，那么在获取数据时，必须要预先设置一个实现此接口的struct或者struct的指针。此时可以在此struct中实现<code>BeforeSet(name string, cell xorm.Cell)</code>方法来进行预先给Conversion赋值。例子参见 <a href="https://gitea.com/xorm/tests/blob/master/base.go#L1826">testConversion</a></li>
</ul>
<p>下表为xorm类型和各个数据库类型的对应表：</p>
<table>
<thead>
<tr>
<th>xorm</th>
<th>mysql</th>
<th>sqlite3</th>
<th>postgres</th>
<th>remark</th>
</tr>
</thead>
<tbody><tr>
<td>BIT</td>
<td>BIT</td>
<td>INTEGER</td>
<td>BIT</td>
<td></td>
</tr>
<tr>
<td>TINYINT</td>
<td>TINYINT</td>
<td>INTEGER</td>
<td>SMALLINT</td>
<td></td>
</tr>
<tr>
<td>SMALLINT</td>
<td>SMALLINT</td>
<td>INTEGER</td>
<td>SMALLINT</td>
<td></td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>MEDIUMINT</td>
<td>INTEGER</td>
<td>INTEGER</td>
<td></td>
</tr>
<tr>
<td>INT</td>
<td>INT</td>
<td>INTEGER</td>
<td>INTEGER</td>
<td></td>
</tr>
<tr>
<td>INTEGER</td>
<td>INTEGER</td>
<td>INTEGER</td>
<td>INTEGER</td>
<td></td>
</tr>
<tr>
<td>BIGINT</td>
<td>BIGINT</td>
<td>INTEGER</td>
<td>BIGINT</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CHAR</td>
<td>CHAR</td>
<td>TEXT</td>
<td>CHAR</td>
<td></td>
</tr>
<tr>
<td>VARCHAR</td>
<td>VARCHAR</td>
<td>TEXT</td>
<td>VARCHAR</td>
<td></td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>TINYTEXT</td>
<td>TEXT</td>
<td>TEXT</td>
<td></td>
</tr>
<tr>
<td>TEXT</td>
<td>TEXT</td>
<td>TEXT</td>
<td>TEXT</td>
<td></td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>MEDIUMTEXT</td>
<td>TEXT</td>
<td>TEXT</td>
<td></td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>LONGTEXT</td>
<td>TEXT</td>
<td>TEXT</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>BINARY</td>
<td>BINARY</td>
<td>BLOB</td>
<td>BYTEA</td>
<td></td>
</tr>
<tr>
<td>VARBINARY</td>
<td>VARBINARY</td>
<td>BLOB</td>
<td>BYTEA</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DATE</td>
<td>DATE</td>
<td>NUMERIC</td>
<td>DATE</td>
<td></td>
</tr>
<tr>
<td>DATETIME</td>
<td>DATETIME</td>
<td>NUMERIC</td>
<td>TIMESTAMP</td>
<td></td>
</tr>
<tr>
<td>TIME</td>
<td>TIME</td>
<td>NUMERIC</td>
<td>TIME</td>
<td></td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>TIMESTAMP</td>
<td>NUMERIC</td>
<td>TIMESTAMP</td>
<td></td>
</tr>
<tr>
<td>TIMESTAMPZ</td>
<td>TEXT</td>
<td>TEXT</td>
<td>TIMESTAMP with zone</td>
<td>timestamp with zone info</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>REAL</td>
<td>REAL</td>
<td>REAL</td>
<td>REAL</td>
<td></td>
</tr>
<tr>
<td>FLOAT</td>
<td>FLOAT</td>
<td>REAL</td>
<td>REAL</td>
<td></td>
</tr>
<tr>
<td>DOUBLE</td>
<td>DOUBLE</td>
<td>REAL</td>
<td>DOUBLE PRECISION</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DECIMAL</td>
<td>DECIMAL</td>
<td>NUMERIC</td>
<td>DECIMAL</td>
<td></td>
</tr>
<tr>
<td>NUMERIC</td>
<td>NUMERIC</td>
<td>NUMERIC</td>
<td>NUMERIC</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>TINYBLOB</td>
<td>BLOB</td>
<td>BYTEA</td>
<td></td>
</tr>
<tr>
<td>BLOB</td>
<td>BLOB</td>
<td>BLOB</td>
<td>BYTEA</td>
<td></td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>MEDIUMBLOB</td>
<td>BLOB</td>
<td>BYTEA</td>
<td></td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>LONGBLOB</td>
<td>BLOB</td>
<td>BYTEA</td>
<td></td>
</tr>
<tr>
<td>BYTEA</td>
<td>BLOB</td>
<td>BLOB</td>
<td>BYTEA</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>BOOL</td>
<td>TINYINT</td>
<td>INTEGER</td>
<td>BOOLEAN</td>
<td></td>
</tr>
<tr>
<td>SERIAL</td>
<td>INT</td>
<td>INTEGER</td>
<td>SERIAL</td>
<td>auto increment</td>
</tr>
<tr>
<td>BIGSERIAL</td>
<td>BIGINT</td>
<td>INTEGER</td>
<td>BIGSERIAL</td>
<td>auto increment</td>
</tr>
</tbody></table>
<h2 id="Go与字段类型对应表"><a href="#Go与字段类型对应表" class="headerlink" title="Go与字段类型对应表"></a>Go与字段类型对应表</h2><p>如果不使用 tag 来定义 field 对应的数据库字段类型，那么系统会自动给出一个默认的字段类型，对应表如下：</p>
<table>
<thead>
<tr>
<th>go type’s kind</th>
<th>value method</th>
<th>xorm type</th>
</tr>
</thead>
<tbody><tr>
<td>implemented Conversion</td>
<td>Conversion.ToDB &#x2F; Conversion.FromDB</td>
<td>Text</td>
</tr>
<tr>
<td>int, int8, int16, int32, uint, uint8, uint16, uint32</td>
<td></td>
<td>Int</td>
</tr>
<tr>
<td>int64, uint64</td>
<td></td>
<td>BigInt</td>
</tr>
<tr>
<td>float32</td>
<td></td>
<td>Float</td>
</tr>
<tr>
<td>float64</td>
<td></td>
<td>Double</td>
</tr>
<tr>
<td>complex64, complex128</td>
<td>json.Marshal &#x2F; json.UnMarshal</td>
<td>Varchar(64)</td>
</tr>
<tr>
<td>[]uint8</td>
<td></td>
<td>Blob</td>
</tr>
<tr>
<td>array, slice, map except []uint8</td>
<td>json.Marshal &#x2F; json.UnMarshal</td>
<td>Text</td>
</tr>
<tr>
<td>bool</td>
<td>1 or 0</td>
<td>Bool</td>
</tr>
<tr>
<td>string</td>
<td></td>
<td>Varchar(255)</td>
</tr>
<tr>
<td>time.Time</td>
<td></td>
<td>DateTime</td>
</tr>
<tr>
<td>cascade struct</td>
<td>primary key field value</td>
<td>BigInt</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>struct</td>
<td>json.Marshal &#x2F; json.UnMarshal</td>
<td>Text</td>
</tr>
<tr>
<td>Others</td>
<td></td>
<td>Text</td>
</tr>
</tbody></table>
<h1 id="表结构操作"><a href="#表结构操作" class="headerlink" title="表结构操作"></a>表结构操作</h1><p>xorm 提供了一些动态获取和修改表结构的方法，通过这些方法可以动态同步数据库结构，导出数据库结构，导入数据库结构。</p>
<h2 id="获取数据库信息"><a href="#获取数据库信息" class="headerlink" title="获取数据库信息"></a>获取数据库信息</h2><ul>
<li>DBMetas()</li>
</ul>
<p>xorm支持获取表结构信息，通过调用 <code>engine.DBMetas()</code> 可以获取到数据库中所有的表，字段，索引的信息。</p>
<ul>
<li>TableInfo()</li>
</ul>
<p>根据传入的结构体指针及其对应的Tag，提取出模型对应的表结构信息。这里不是数据库当前的表结构信息，而是我们通过struct建模时希望数据库的表的结构信息。</p>
<h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><ul>
<li>CreateTables()</li>
</ul>
<p>创建表使用<code>engine.CreateTables()</code>，参数为一个或多个空的对应Struct的指针。同时可用的方法有Charset()和StoreEngine()，如果对应的数据库支持，这两个方法可以在创建表时指定表的字符编码和使用的引擎。Charset()和StoreEngine()当前仅支持Mysql数据库。</p>
<ul>
<li>IsTableEmpty()</li>
</ul>
<p>判断表是否为空，参数和CreateTables相同</p>
<ul>
<li>IsTableExist()</li>
</ul>
<p>判断表是否存在</p>
<ul>
<li>DropTables()</li>
</ul>
<p>删除表使用<code>engine.DropTables()</code>，参数为一个或多个空的对应Struct的指针或者表的名字。如果为string传入，则只删除对应的表，如果传入的为Struct，则删除表的同时还会删除对应的索引。</p>
<h2 id="创建索引和唯一索引"><a href="#创建索引和唯一索引" class="headerlink" title="创建索引和唯一索引"></a>创建索引和唯一索引</h2><ul>
<li>CreateIndexes</li>
</ul>
<p>根据struct中的tag来创建索引</p>
<ul>
<li>CreateUniques</li>
</ul>
<p>根据struct中的tag来创建唯一索引</p>
<h2 id="同步数据库结构"><a href="#同步数据库结构" class="headerlink" title="同步数据库结构"></a>同步数据库结构</h2><p>同步能够部分智能的根据结构体的变动检测表结构的变动，并自动同步。目前有两个实现：</p>
<ul>
<li>Sync</li>
</ul>
<p>Sync将进行如下的同步操作：</p>
<ul>
<li>自动检测和创建表，这个检测是根据表的名字</li>
<li>自动检测和新增表中的字段，这个检测是根据字段名</li>
<li>自动检测和创建索引和唯一索引，这个检测是根据索引的一个或多个字段名，而不根据索引名称</li>
</ul>
<p>调用方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := engine.Sync(<span class="built_in">new</span>(User), <span class="built_in">new</span>(Group))</span><br></pre></td></tr></table></figure>

<ul>
<li>Sync2</li>
</ul>
<p>Sync2对Sync进行了改进，目前推荐使用Sync2。Sync2函数将进行如下的同步操作：</p>
<ul>
<li>自动检测和创建表，这个检测是根据表的名字</li>
<li>自动检测和新增表中的字段，这个检测是根据字段名，同时对表中多余的字段给出警告信息</li>
<li>自动检测，创建和删除索引和唯一索引，这个检测是根据索引的一个或多个字段名，而不根据索引名称。因此这里需要注意，如果在一个有大量数据的表中引入新的索引，数据库可能需要一定的时间来建立索引。</li>
<li>自动转换varchar字段类型到text字段类型，自动警告其它字段类型在模型和数据库之间不一致的情况。</li>
<li>自动警告字段的默认值，是否为空信息在模型和数据库之间不匹配的情况</li>
</ul>
<p>以上这些警告信息需要将<code>engine.ShowWarn</code> 设置为 <code>true</code> 才会显示。</p>
<p>调用方法和Sync一样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := engine.Sync2(<span class="built_in">new</span>(User), <span class="built_in">new</span>(Group))</span><br></pre></td></tr></table></figure>

<h2 id="导出导入SQL脚本"><a href="#导出导入SQL脚本" class="headerlink" title="导出导入SQL脚本"></a>导出导入SQL脚本</h2><h3 id="Dump数据库结构和数据"><a href="#Dump数据库结构和数据" class="headerlink" title="Dump数据库结构和数据"></a>Dump数据库结构和数据</h3><p>如果需要在程序中Dump数据库的结构和数据可以调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.DumpAll(w io.Writer)</span><br></pre></td></tr></table></figure>

<p>和</p>
<p><code>engine.DumpAllToFile(fpath string)</code>。</p>
<p>DumpAll方法接收一个io.Writer接口来保存Dump出的数据库结构和数据的SQL语句，这个方法导出的SQL语句并不能通用。只针对当前engine所对应的数据库支持的SQL。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">	<span class="string">&quot;xorm.io/xorm/log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	engine, err := xorm.NewEngine(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:123@/weblog?charset=utf8mb4&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	engine.ShowSQL(<span class="literal">true</span>)</span><br><span class="line">	engine.Logger().SetLevel(log.LOG_DEBUG)</span><br><span class="line"></span><br><span class="line">	f, err := os.Create(<span class="string">&quot;dump.sql&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	engine.DumpAll(f)</span><br><span class="line">	f.Close()</span><br><span class="line">	engine.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Import-执行数据库SQL脚本"><a href="#Import-执行数据库SQL脚本" class="headerlink" title="Import 执行数据库SQL脚本"></a>Import 执行数据库SQL脚本</h3><p>如果你需要将保存在文件或者其它存储设施中的SQL脚本执行，那么可以调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Import(r io.Reader)</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.ImportFile(fpath <span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<p>同样，这里需要对应的数据库的SQL语法支持。</p>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><p>插入数据使用Insert方法，Insert方法的参数可以是一个或多个Struct的指针，一个或多个Struct的Slice的指针。</p>
<p>如果传入的是Slice并且当数据库支持批量插入时，Insert会使用批量插入的方式进行插入。</p>
<ul>
<li>插入一条数据，此时可以用Insert或者InsertOne</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">user.Name = <span class="string">&quot;myname&quot;</span></span><br><span class="line">affected, err := engine.Insert(user)</span><br><span class="line"><span class="comment">// INSERT INTO user (name) values (?)</span></span><br></pre></td></tr></table></figure>

<p>在插入单条数据成功后，如果该结构体有自增字段(设置为autoincr)，则自增字段会被自动赋值为数据库中的id。这里需要注意的是，如果插入的结构体中，自增字段已经赋值，则该字段会被作为非自增字段插入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(user.Id)</span><br></pre></td></tr></table></figure>

<ul>
<li>插入同一个表的多条数据，此时如果数据库支持批量插入，那么会进行批量插入，但是这样每条记录就无法被自动赋予id值。如果数据库不支持批量插入，那么就会一条一条插入。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">users := <span class="built_in">make</span>([]User, <span class="number">1</span>)</span><br><span class="line">users[<span class="number">0</span>].Name = <span class="string">&quot;name0&quot;</span></span><br><span class="line">...</span><br><span class="line">affected, err := engine.Insert(&amp;users)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用指针Slice插入多条记录，同上</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">users := <span class="built_in">make</span>([]*User, <span class="number">1</span>)</span><br><span class="line">users[<span class="number">0</span>] = <span class="built_in">new</span>(User)</span><br><span class="line">users[<span class="number">0</span>].Name = <span class="string">&quot;name0&quot;</span></span><br><span class="line">...</span><br><span class="line">affected, err := engine.Insert(&amp;users)</span><br></pre></td></tr></table></figure>

<ul>
<li>插入多条记录并且不使用批量插入，此时实际生成多条插入语句，每条记录均会自动赋予Id值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">users := <span class="built_in">make</span>([]*User, <span class="number">1</span>)</span><br><span class="line">users[<span class="number">0</span>] = <span class="built_in">new</span>(User)</span><br><span class="line">users[<span class="number">0</span>].Name = <span class="string">&quot;name0&quot;</span></span><br><span class="line">...</span><br><span class="line">affected, err := engine.Insert(users)</span><br></pre></td></tr></table></figure>

<ul>
<li>插入不同表的一条记录</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">user.Name = <span class="string">&quot;myname&quot;</span></span><br><span class="line">question := <span class="built_in">new</span>(Question)</span><br><span class="line">question.Content = <span class="string">&quot;whywhywhwy?&quot;</span></span><br><span class="line">affected, err := engine.Insert(user, question)</span><br></pre></td></tr></table></figure>

<ul>
<li>插入不同表的多条记录</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">users := <span class="built_in">make</span>([]User, <span class="number">1</span>)</span><br><span class="line">users[<span class="number">0</span>].Name = <span class="string">&quot;name0&quot;</span></span><br><span class="line">...</span><br><span class="line">questions := <span class="built_in">make</span>([]Question, <span class="number">1</span>)</span><br><span class="line">questions[<span class="number">0</span>].Content = <span class="string">&quot;whywhywhwy?&quot;</span></span><br><span class="line">affected, err := engine.Insert(&amp;users, &amp;questions)</span><br></pre></td></tr></table></figure>

<ul>
<li>插入不同表的一条或多条记录</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">user.Name = <span class="string">&quot;myname&quot;</span></span><br><span class="line">...</span><br><span class="line">questions := <span class="built_in">make</span>([]Question, <span class="number">1</span>)</span><br><span class="line">questions[<span class="number">0</span>].Content = <span class="string">&quot;whywhywhwy?&quot;</span></span><br><span class="line">affected, err := engine.Insert(user, &amp;questions)</span><br></pre></td></tr></table></figure>

<p>这里需要注意以下几点：</p>
<ul>
<li>这里虽然支持同时插入，但这些插入并没有事务关系。因此有可能在中间插入出错后，后面的插入将不会继续。此时前面的插入已经成功，如果需要回滚，请开启事务。</li>
<li>批量插入会自动生成<code>Insert into table values (),(),()</code>的语句，因此各个数据库对SQL语句有长度限制，因此这样的语句有一个最大的记录数，根据经验测算在150条左右。大于150条后，生成的sql语句将太长可能导致执行失败。因此在插入大量数据时，目前需要自行分割成每150条插入一次。</li>
</ul>
<h2 id="创建时间Created"><a href="#创建时间Created" class="headerlink" title="创建时间Created"></a>创建时间Created</h2><p>Created可以让您在数据插入到数据库时自动将对应的字段设置为当前时间，需要在xorm标记中使用created标记，如下所示进行标记，对应的字段可以为time.Time或者自定义的time.Time或者int,int64等int类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int64</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    CreatedAt time.Time <span class="string">`xorm:&quot;created&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> JsonTime time.Time</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j JsonTime)</span></span> MarshalJSON() ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">`&quot;`</span>+time.Time(j).Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)+<span class="string">`&quot;`</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int64</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    CreatedAt JsonTime <span class="string">`xorm:&quot;created&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int64</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    CreatedAt <span class="type">int64</span> <span class="string">`xorm:&quot;created&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Insert()或InsertOne()方法被调用时，created标记的字段将会被自动更新为当前时间或者当前时间的秒数（对应为time.Unix())，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">engine.Insert(&amp;user)</span><br><span class="line"><span class="comment">// INSERT user (created...) VALUES (?...)</span></span><br></pre></td></tr></table></figure>

<p>最后一个值得注意的是时区问题，默认xorm采用Local时区，所以默认调用的time.Now()会先被转换成对应的时区。要改变xorm的时区，可以使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.TZLocation, _ = time.LoadLocation(<span class="string">&quot;Asia/Shanghai&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="查询和统计数据"><a href="#查询和统计数据" class="headerlink" title="查询和统计数据"></a>查询和统计数据</h1><p>所有的查询条件不区分调用顺序，但必须在调用Get，Exist, Sum, Find，Count, Iterate, Rows这几个函数之前调用。同时需要注意的一点是，在调用的参数中，如果采用默认的<code>SnakeMapper</code>所有的字符字段名均为映射后的数据库的字段名，而不是field的名字。</p>
<h3 id="查询条件方法"><a href="#查询条件方法" class="headerlink" title="查询条件方法"></a>查询条件方法</h3><p>查询和统计主要使用<code>Get</code>, <code>Find</code>, <code>Count</code>, <code>Rows</code>, <code>Iterate</code>这几个方法，同时大部分函数在调用<code>Update</code>, <code>Delete</code>时也是可用的。在进行查询时可以使用多个方法来形成查询条件，条件函数如下：</p>
<ul>
<li>Alias(string)</li>
</ul>
<p>给Table设定一个别名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Alias(<span class="string">&quot;o&quot;</span>).Where(<span class="string">&quot;o.name = ?&quot;</span>, name).Get(&amp;order)</span><br></pre></td></tr></table></figure>

<ul>
<li>And(string, …interface{})</li>
</ul>
<p>和Where函数中的条件基本相同，作为条件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Where(...).And(...).Get(&amp;order)</span><br></pre></td></tr></table></figure>

<ul>
<li>Asc(…string)</li>
</ul>
<p>指定字段名正序排序，可以组合</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Asc(<span class="string">&quot;id&quot;</span>).Find(&amp;orders)</span><br></pre></td></tr></table></figure>

<ul>
<li>Desc(…string)</li>
</ul>
<p>指定字段名逆序排序，可以组合</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Asc(<span class="string">&quot;id&quot;</span>).Desc(<span class="string">&quot;time&quot;</span>).Find(&amp;orders)</span><br></pre></td></tr></table></figure>

<ul>
<li>ID(interface{})</li>
</ul>
<p>传入一个主键字段的值，作为查询条件，如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">engine.ID(<span class="number">1</span>).Get(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM user Where id = 1</span></span><br></pre></td></tr></table></figure>

<p>如果是复合主键，则可以</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.ID(schemas.PK&#123;<span class="number">1</span>, <span class="string">&quot;name&quot;</span>&#125;).Get(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM user Where id =1 AND name= &#x27;name&#x27;</span></span><br></pre></td></tr></table></figure>

<p>传入的两个参数按照struct中pk标记字段出现的顺序赋值。</p>
<ul>
<li>Or(interface{}, …interface{})</li>
</ul>
<p>和Where函数中的条件基本相同，作为条件</p>
<ul>
<li>OrderBy(string)</li>
</ul>
<p>按照指定的顺序进行排序</p>
<ul>
<li>Select(string)</li>
</ul>
<p>指定select语句的字段部分内容，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Select(<span class="string">&quot;a.*, (select name from b limit 1) as name&quot;</span>).Find(&amp;beans)</span><br><span class="line"></span><br><span class="line">engine.Select(<span class="string">&quot;a.*, (select name from b limit 1) as name&quot;</span>).Get(&amp;bean)</span><br></pre></td></tr></table></figure>

<ul>
<li>SQL(string, …interface{})</li>
</ul>
<p>执行指定的Sql语句，并把结果映射到结构体。有时，当选择内容或者条件比较复杂时，可以直接使用Sql，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.SQL(<span class="string">&quot;select * from table&quot;</span>).Find(&amp;beans)</span><br></pre></td></tr></table></figure>

<ul>
<li>Where(string, …interface{})</li>
</ul>
<p>和SQL中Where语句中的条件基本相同，作为条件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Where(<span class="string">&quot;a = ? AND b = ?&quot;</span>, <span class="number">1</span>, <span class="number">2</span>).Find(&amp;beans)</span><br><span class="line"></span><br><span class="line">engine.Where(builder.Eq&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;).Find(&amp;beans)</span><br><span class="line"></span><br><span class="line">engine.Where(builder.Eq&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;.Or(builder.Eq&#123;<span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;)).Find(&amp;beans)</span><br></pre></td></tr></table></figure>

<ul>
<li>In(string, …interface{})</li>
</ul>
<p>某字段在一些值中，这里需要注意必须是[]interface{}才可以展开，由于Go语言的限制，[]int64等不可以直接展开，而是通过传递一个slice。第二个参数也可以是一个*builder.Builder 指针。示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// select from table where column in (1,2,3)</span></span><br><span class="line">engine.In(<span class="string">&quot;cloumn&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).Find()</span><br><span class="line"></span><br><span class="line"><span class="comment">// select from table where column in (1,2,3)</span></span><br><span class="line">engine.In(<span class="string">&quot;column&quot;</span>, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).Find()</span><br><span class="line"></span><br><span class="line"><span class="comment">// select from table where column in (select column from table2 where a = 1)</span></span><br><span class="line">engine.In(<span class="string">&quot;column&quot;</span>, builder.Select(<span class="string">&quot;column&quot;</span>).From(<span class="string">&quot;table2&quot;</span>).Where(builder.Eq&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;)).Find()</span><br></pre></td></tr></table></figure>

<ul>
<li>Cols(…string)</li>
</ul>
<p>只查询或更新某些指定的字段，默认是查询所有映射的字段或者根据Update的第一个参数来判断更新的字段。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Cols(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;name&quot;</span>).Get(&amp;usr)</span><br><span class="line"><span class="comment">// SELECT age, name FROM user limit 1</span></span><br><span class="line">engine.Cols(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT age, name FROM user</span></span><br><span class="line">engine.Cols(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;name&quot;</span>).Update(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE user SET age=? AND name=?</span></span><br></pre></td></tr></table></figure>

<ul>
<li>AllCols()</li>
</ul>
<p>查询或更新所有字段，一般与Update配合使用，因为默认Update只更新非0，非””，非bool的字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.AllCols().ID(<span class="number">1</span>).Update(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE user SET name = ?, age =?, gender =? WHERE id = 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MustCols(…string)</li>
</ul>
<p>某些字段必须更新，一般与Update配合使用。</p>
<ul>
<li>Omit(…string)</li>
</ul>
<p>和cols相反，此函数指定排除某些指定的字段。注意：此方法和Cols方法不可同时使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1：</span></span><br><span class="line">engine.Omit(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>).Update(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE user SET name = ? AND department = ?</span></span><br><span class="line"><span class="comment">// 例2：</span></span><br><span class="line">engine.Omit(<span class="string">&quot;age, gender&quot;</span>).Insert(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO user (name) values (?) // 这样的话age和gender会给默认值</span></span><br><span class="line"><span class="comment">// 例3：</span></span><br><span class="line">engine.Omit(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT name FROM user //只select除age和gender字段的其它字段</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Distinct(…string)</li>
</ul>
<p>按照参数中指定的字段归类结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Distinct(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;department&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT DISTINCT age, department FROM user</span></span><br></pre></td></tr></table></figure>

<p>注意：当开启了缓存时，此方法的调用将在当前查询中禁用缓存。因为缓存系统当前依赖Id，而此时无法获得Id</p>
<ul>
<li>Table(nameOrStructPtr interface{})</li>
</ul>
<p>传入表名称或者结构体指针，如果传入的是结构体指针，则按照IMapper的规则提取出表名</p>
<ul>
<li>Limit(int, …int)</li>
</ul>
<p>限制获取的数目，第一个参数为条数，第二个参数表示开始位置，如果不传则为0</p>
<ul>
<li>Top(int)</li>
</ul>
<p>相当于Limit(int, 0)</p>
<ul>
<li>Join(string,interface{},string)</li>
</ul>
<p>第一个参数为连接类型，当前支持INNER, LEFT OUTER, CROSS中的一个值， 第二个参数为string类型的表名，表对应的结构体指针或者为两个值的[]string，表示表名和别名， 第三个参数为连接条件</p>
<ul>
<li>GroupBy(string)</li>
</ul>
<p>Groupby的参数字符串</p>
<ul>
<li>Having(string)</li>
</ul>
<p>Having的参数字符串</p>
<h3 id="临时开关方法"><a href="#临时开关方法" class="headerlink" title="临时开关方法"></a>临时开关方法</h3><ul>
<li>NoAutoTime()</li>
</ul>
<p>如果此方法执行，则此次生成的语句中Created和Updated字段将不自动赋值为当前时间</p>
<ul>
<li>NoCache()</li>
</ul>
<p>如果此方法执行，则此次生成的语句则在非缓存模式下执行</p>
<ul>
<li>NoAutoCondition()</li>
</ul>
<p>禁用自动根据结构体中的值来生成条件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;lunny&quot;</span>).Get(&amp;User&#123;Id:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM user where name=&#x27;lunny&#x27; AND id = 1 LIMIT 1</span></span><br><span class="line">engine.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;lunny&quot;</span>).NoAutoCondition().Get(&amp;User&#123;Id:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM user where name=&#x27;lunny&#x27; LIMIT 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>UseBool(…string)</li>
</ul>
<p>当从一个struct来生成查询条件或更新字段时，xorm会判断struct的field是否为0,””,nil，如果为以上则不当做查询条件或者更新内容。因为bool类型只有true和false两种值，因此默认所有bool类型不会作为查询条件或者更新字段。如果可以使用此方法，如果默认不传参数，则所有的bool字段都将会被使用，如果参数不为空，则参数中指定的为字段名，则这些字段对应的bool值将被使用。</p>
<ul>
<li>NoCascade()</li>
</ul>
<p>是否自动关联查询field中的数据，如果struct的field也是一个struct并且映射为某个Id，则可以在查询时自动调用Get方法查询出对应的数据。</p>
<h3 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h3><p>查询单条数据使用<code>Get</code>方法，在调用Get方法时需要传入一个对应结构体的指针，同时结构体中的非空field自动成为查询的条件和前面的方法条件组合在一起查询。</p>
<p>如：</p>
<ol>
<li>根据Id来获得单条数据:</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">has, err := engine.ID(id).Get(user)</span><br><span class="line"><span class="comment">// 复合主键的获取方法</span></span><br><span class="line"><span class="comment">// has, errr := engine.ID(xorm.PK&#123;1,2&#125;).Get(user)</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据Where来获得单条数据：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">has, err := engine.Where(<span class="string">&quot;name=?&quot;</span>, <span class="string">&quot;xlw&quot;</span>).Get(user)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根据user结构体中已有的非空数据来获得单条数据：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := &amp;User&#123;Id:<span class="number">1</span>&#125;</span><br><span class="line">has, err := engine.Get(user)</span><br></pre></td></tr></table></figure>

<p>或者其它条件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := &amp;User&#123;Name:<span class="string">&quot;xlw&quot;</span>&#125;</span><br><span class="line">has, err := engine.Get(user)</span><br></pre></td></tr></table></figure>

<p>返回的结果为两个参数，一个<code>has</code>为该条记录是否存在，第二个参数<code>err</code>为是否有错误。不管err是否为nil，has都有可能为true或者false。</p>
<h3 id="Find方法"><a href="#Find方法" class="headerlink" title="Find方法"></a>Find方法</h3><p>查询多条数据使用<code>Find</code>方法，Find方法的第一个参数为<code>slice</code>的指针或<code>Map</code>指针，即为查询后返回的结果，第二个参数可选，为查询的条件struct的指针。</p>
<ol>
<li>传入Slice用于返回数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">everyone := <span class="built_in">make</span>([]Userinfo, <span class="number">0</span>)</span><br><span class="line">err := engine.Find(&amp;everyone)</span><br><span class="line"></span><br><span class="line">pEveryOne := <span class="built_in">make</span>([]*Userinfo, <span class="number">0</span>)</span><br><span class="line">err := engine.Find(&amp;pEveryOne)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>传入Map用户返回数据，map必须为<code>map[int64]Userinfo</code>的形式，map的key为id，因此对于复合主键无法使用这种方式。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">users := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]Userinfo)</span><br><span class="line">err := engine.Find(&amp;users)</span><br><span class="line"></span><br><span class="line">pUsers := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*Userinfo)</span><br><span class="line">err := engine.Find(&amp;pUsers)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>也可以加入各种条件</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">users := <span class="built_in">make</span>([]Userinfo, <span class="number">0</span>)</span><br><span class="line">err := engine.Where(<span class="string">&quot;age &gt; ? or name = ?&quot;</span>, <span class="number">30</span>, <span class="string">&quot;xlw&quot;</span>).Limit(<span class="number">20</span>, <span class="number">10</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果只选择单个字段，也可使用非结构体的Slice</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ints []<span class="type">int64</span></span><br><span class="line">err := engine.Table(<span class="string">&quot;user&quot;</span>).Cols(<span class="string">&quot;id&quot;</span>).Find(&amp;ints)</span><br></pre></td></tr></table></figure>

<h3 id="Count方法"><a href="#Count方法" class="headerlink" title="Count方法"></a>Count方法</h3><p>统计数据使用<code>Count</code>方法，Count方法的参数为struct的指针并且成为查询条件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">total, err := engine.Where(<span class="string">&quot;id &gt;?&quot;</span>, <span class="number">1</span>).Count(user)</span><br></pre></td></tr></table></figure>

<h3 id="Exist系列方法"><a href="#Exist系列方法" class="headerlink" title="Exist系列方法"></a>Exist系列方法</h3><p>判断某个记录是否存在可以使用<code>Exist</code>, 相比<code>Get</code>，<code>Exist</code>性能更好。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">has, err := testEngine.Exist(<span class="built_in">new</span>(RecordExist))</span><br><span class="line"><span class="comment">// SELECT * FROM record_exist LIMIT 1</span></span><br><span class="line">has, err = testEngine.Exist(&amp;RecordExist&#123;</span><br><span class="line">		Name: <span class="string">&quot;test1&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM record_exist WHERE name = ? LIMIT 1</span></span><br><span class="line">has, err = testEngine.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;test1&quot;</span>).Exist(&amp;RecordExist&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM record_exist WHERE name = ? LIMIT 1</span></span><br><span class="line">has, err = testEngine.SQL(<span class="string">&quot;select * from record_exist where name = ?&quot;</span>, <span class="string">&quot;test1&quot;</span>).Exist()</span><br><span class="line"><span class="comment">// select * from record_exist where name = ?</span></span><br><span class="line">has, err = testEngine.Table(<span class="string">&quot;record_exist&quot;</span>).Exist()</span><br><span class="line"><span class="comment">// SELECT * FROM record_exist LIMIT 1</span></span><br><span class="line">has, err = testEngine.Table(<span class="string">&quot;record_exist&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;test1&quot;</span>).Exist()</span><br><span class="line"><span class="comment">// SELECT * FROM record_exist WHERE name = ? LIMIT 1</span></span><br></pre></td></tr></table></figure>

<h4 id="与Get的区别"><a href="#与Get的区别" class="headerlink" title="与Get的区别"></a>与Get的区别</h4><p>Get与Exist方法返回值都为bool和error，如果查询到实体存在，则Get方法会将查到的实体赋值给参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := &amp;User&#123;Id:<span class="number">1</span>&#125;</span><br><span class="line">has,err := testEngine.Get(user)	<span class="comment">// 执行结束后，user会被赋值为数据库中Id为1的实体</span></span><br><span class="line">has,err = testEngine.Exist(user)	<span class="comment">// user中仍然是初始声明的user，不做改变</span></span><br></pre></td></tr></table></figure>

<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>如果你的需求是：判断某条记录是否存在，若存在，则返回这条记录。</p>
<p>建议直接使用Get方法。</p>
<p>如果仅仅判断某条记录是否存在，则使用Exist方法，Exist的执行效率要比Get更高。</p>
<h3 id="Iterate方法"><a href="#Iterate方法" class="headerlink" title="Iterate方法"></a>Iterate方法</h3><p>Iterate方法提供逐条执行查询到的记录的方法，它所能使用的条件和Find方法完全相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := engine.Where(<span class="string">&quot;age &gt; ? or name=?)&quot;</span>, <span class="number">30</span>, <span class="string">&quot;xlw&quot;</span>).Iterate(<span class="built_in">new</span>(Userinfo), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, bean <span class="keyword">interface</span>&#123;&#125;)</span></span><span class="type">error</span>&#123;</span><br><span class="line">    user := bean.(*Userinfo)</span><br><span class="line">    <span class="comment">//do somthing use i and user</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Join的使用"><a href="#Join的使用" class="headerlink" title="Join的使用"></a>Join的使用</h3><ul>
<li>Join(string,interface{},string)</li>
</ul>
<p>第一个参数为连接类型，当前支持INNER, LEFT OUTER, CROSS中的一个值， 第二个参数为string类型的表名，表对应的结构体指针或者为两个值的[]string，表示表名和别名， 第三个参数为连接条件。</p>
<p>以下将通过示例来讲解具体的用法：</p>
<p>假如我们拥有两个表user和group，每个User只在一个Group中，那么我们可以定义对应的struct</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">int64</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">int64</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	GroupId <span class="type">int64</span> <span class="string">`xorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题来了，我们现在需要列出所有的User，并且列出对应的GroupName。利用extends和Join我们可以比较优雅的解决这个问题。代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    User <span class="string">`xorm:&quot;extends&quot;`</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UserGroup)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">users := <span class="built_in">make</span>([]UserGroup, <span class="number">0</span>)</span><br><span class="line">engine.Join(<span class="string">&quot;INNER&quot;</span>, <span class="string">&quot;group&quot;</span>, <span class="string">&quot;group.id = user.group_id&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>这里我们将User这个匿名结构体加了xorm的extends标记（实际上也可以是非匿名的结构体，只要有extends标记即可），这样就减少了重复代码的书写。实际上这里我们直接用Sql函数也是可以的，并不一定非要用Join。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">users := <span class="built_in">make</span>([]UserGroup, <span class="number">0</span>)</span><br><span class="line">engine.Sql(<span class="string">&quot;select user.*, group.name from user, group where user.group_id = group.id&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>然后，我们忽然发现，我们还需要显示Group的Id，因为我们需要链接到Group页面。这样又要加一个字段，算了，不如我们把Group也加个extends标记吧，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    User <span class="string">`xorm:&quot;extends&quot;`</span></span><br><span class="line">    Group <span class="string">`xorm:&quot;extends&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UserGroup)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">users := <span class="built_in">make</span>([]UserGroup, <span class="number">0</span>)</span><br><span class="line">engine.Join(<span class="string">&quot;INNER&quot;</span>, <span class="string">&quot;group&quot;</span>, <span class="string">&quot;group.id = user.group_id&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>这次，我们把两个表的所有字段都查询出来了，并且赋值到对应的结构体上了。</p>
<p>这里要注意，User和Group分别有Id和Name，这个是重名的，但是xorm是可以区分开来的，不过需要特别注意UserGroup中User和Group的顺序，如果顺序反了，则有可能会赋值错误，但是程序不会报错。</p>
<p>这里的顺序应遵循如下原则：</p>
<blockquote>
<p>结构体中extends标记对应的结构顺序应和最终生成SQL中对应的表出现的顺序相同。</p>
</blockquote>
<p>还有一点需要注意的，如果在模板中使用这个UserGroup结构体，对于字段名重复的必须加匿名引用，如：</p>
<p>对于不重复字段，可以<code>&#123;&#123;.GroupId&#125;&#125;</code>，对于重复字段<code>&#123;&#123;.User.Id&#125;&#125;</code>和<code>&#123;&#123;.Group.Id&#125;&#125;</code></p>
<p>这是2个表的用法，3个或更多表用法类似，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">int64</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserGroupType <span class="keyword">struct</span> &#123;</span><br><span class="line">    User <span class="string">`xorm:&quot;extends&quot;`</span></span><br><span class="line">    Group <span class="string">`xorm:&quot;extends&quot;`</span></span><br><span class="line">    Type <span class="string">`xorm:&quot;extends&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">users := <span class="built_in">make</span>([]UserGroupType, <span class="number">0</span>)</span><br><span class="line">engine.Table(<span class="string">&quot;user&quot;</span>).Join(<span class="string">&quot;INNER&quot;</span>, <span class="string">&quot;group&quot;</span>, <span class="string">&quot;group.id = user.group_id&quot;</span>).</span><br><span class="line">	Join(<span class="string">&quot;INNER&quot;</span>, <span class="string">&quot;type&quot;</span>, <span class="string">&quot;type.id = user.type_id&quot;</span>).</span><br><span class="line">	Find(&amp;users)</span><br></pre></td></tr></table></figure>

<p>同时，在使用Join时，也可同时使用Where和Find的第二个参数作为条件，Find的第二个参数同时也允许为各种bean来作为条件。Where里可以是各个表的条件，Find的第二个参数只是被关联表的条件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Table(<span class="string">&quot;user&quot;</span>).Join(<span class="string">&quot;INNER&quot;</span>, <span class="string">&quot;group&quot;</span>, <span class="string">&quot;group.id = user.group_id&quot;</span>).</span><br><span class="line">	Join(<span class="string">&quot;INNER&quot;</span>, <span class="string">&quot;type&quot;</span>, <span class="string">&quot;type.id = user.type_id&quot;</span>).</span><br><span class="line">	Where(<span class="string">&quot;user.name like ?&quot;</span>, <span class="string">&quot;%&quot;</span>+name+<span class="string">&quot;%&quot;</span>).Find(&amp;users, &amp;User&#123;Name:name&#125;)</span><br></pre></td></tr></table></figure>

<p>当然，如果表名字太长，我们可以使用别名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Table(<span class="string">&quot;user&quot;</span>).Alias(<span class="string">&quot;u&quot;</span>).</span><br><span class="line">	Join(<span class="string">&quot;INNER&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;group&quot;</span>, <span class="string">&quot;g&quot;</span>&#125;, <span class="string">&quot;g.id = u.group_id&quot;</span>).</span><br><span class="line">	Join(<span class="string">&quot;INNER&quot;</span>, <span class="string">&quot;type&quot;</span>, <span class="string">&quot;type.id = u.type_id&quot;</span>).</span><br><span class="line">	Where(<span class="string">&quot;u.name like ?&quot;</span>, <span class="string">&quot;%&quot;</span>+name+<span class="string">&quot;%&quot;</span>).Find(&amp;users, &amp;User&#123;Name:name&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Rows方法"><a href="#Rows方法" class="headerlink" title="Rows方法"></a>Rows方法</h3><p>Rows方法和Iterate方法类似，提供逐条执行查询到的记录的方法，不过Rows更加灵活好用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">rows, err := engine.Where(<span class="string">&quot;id &gt;?&quot;</span>, <span class="number">1</span>).Rows(user)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    err = rows.Scan(user)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sum系列方法"><a href="#Sum系列方法" class="headerlink" title="Sum系列方法"></a>Sum系列方法</h3><p>求和数据可以使用<code>Sum</code>, <code>SumInt</code>, <code>Sums</code> 和 <code>SumsInt</code> 四个方法，Sums系列方法的参数为struct的指针并且成为查询条件。</p>
<ul>
<li>Sum 求某个字段的和，返回float64</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SumStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int64</span></span><br><span class="line">    Money <span class="type">int</span></span><br><span class="line">    Rate <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ss := <span class="built_in">new</span>(SumStruct)</span><br><span class="line">total, err := engine.Where(<span class="string">&quot;id &gt;?&quot;</span>, <span class="number">1</span>).Sum(ss, <span class="string">&quot;money&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;money is %d&quot;</span>, <span class="type">int</span>(total))</span><br></pre></td></tr></table></figure>

<ul>
<li>SumInt 求某个字段的和，返回int64</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SumStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int64</span></span><br><span class="line">    Money <span class="type">int</span></span><br><span class="line">    Rate <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ss := <span class="built_in">new</span>(SumStruct)</span><br><span class="line">total, err := engine.Where(<span class="string">&quot;id &gt;?&quot;</span>, <span class="number">1</span>).SumInt(ss, <span class="string">&quot;money&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;money is %d&quot;</span>, total)</span><br></pre></td></tr></table></figure>

<ul>
<li>Sums 求某几个字段的和， 返回float64的Slice</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ss := <span class="built_in">new</span>(SumStruct)</span><br><span class="line">totals, err := engine.Where(<span class="string">&quot;id &gt;?&quot;</span>, <span class="number">1</span>).Sums(ss, <span class="string">&quot;money&quot;</span>, <span class="string">&quot;rate&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;money is %d, rate is %.2f&quot;</span>, <span class="type">int</span>(total[<span class="number">0</span>]), total[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>SumsInt 求某几个字段的和， 返回int64的Slice</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ss := <span class="built_in">new</span>(SumStruct)</span><br><span class="line">totals, err := engine.Where(<span class="string">&quot;id &gt;?&quot;</span>, <span class="number">1</span>).SumsInt(ss, <span class="string">&quot;money&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;money is %d&quot;</span>, total[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>更新数据使用<code>Update</code>方法，Update方法的第一个参数为需要更新的内容，可以为一个结构体指针或者一个Map[string]interface{}类型。当传入的为结构体指针时，只有非空和0的field才会被作为更新的字段。当传入的为Map类型时，key为数据库Column的名字，value为要更新的内容。</p>
<p><code>Update</code>方法将返回两个参数，第一个为 更新的记录数，需要注意的是 <code>SQLITE</code> 数据库返回的是根据更新条件查询的记录数而不是真正受更新的记录数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">user.Name = <span class="string">&quot;myname&quot;</span></span><br><span class="line">affected, err := engine.ID(id).Update(user)</span><br></pre></td></tr></table></figure>

<p>这里需要注意，Update会自动从user结构体中提取非0和非nil得值作为需要更新的内容，因此，如果需要更新一个值为0，则此种方法将无法实现，因此有两种选择：</p>
<ul>
<li>通过添加Cols函数指定需要更新结构体中的哪些值，未指定的将不更新，指定了的即使为0也会更新。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">affected, err := engine.ID(id).Cols(<span class="string">&quot;age&quot;</span>).Update(&amp;user)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过传入map[string]interface{}来进行更新，但这时需要额外指定更新到哪个表，因为通过map是无法自动检测更新哪个表的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">affected, err := engine.Table(<span class="built_in">new</span>(User)).ID(id).Update(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>有时候希望能够指定必须更新某些字段，而其它字段根据值的情况自动判断，可以使用 <code>MustCols</code> 来组合 <code>Update</code> 使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">affected, err := engine.ID(id).MustCols(<span class="string">&quot;age&quot;</span>).Update(&amp;user)</span><br></pre></td></tr></table></figure>

<p>另外，如果需要更新所有的字段，可以使用 <code>AllCols()</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">affected, err := engine.ID(id).AllCols().Update(&amp;user)</span><br></pre></td></tr></table></figure>

<h3 id="乐观锁Version"><a href="#乐观锁Version" class="headerlink" title="乐观锁Version"></a>乐观锁Version</h3><p>要使用乐观锁，需要使用version标记</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int64</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Version <span class="type">int</span> <span class="string">`xorm:&quot;version&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Insert时，version标记的字段将会被设置为1，在Update时，Update的内容必须包含version原来的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">engine.ID(<span class="number">1</span>).Get(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM user WHERE id = ?</span></span><br><span class="line">engine.ID(<span class="number">1</span>).Update(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE user SET ..., version = version + 1 WHERE id = ? AND version = ?</span></span><br></pre></td></tr></table></figure>

<h3 id="更新时间Updated"><a href="#更新时间Updated" class="headerlink" title="更新时间Updated"></a>更新时间Updated</h3><p>Updated可以让您在记录插入或每次记录更新时自动更新数据库中的标记字段为当前时间，需要在xorm标记中使用updated标记，如下所示进行标记，对应的字段可以为time.Time或者自定义的time.Time或者int,int64等int类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int64</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    UpdatedAt time.Time <span class="string">`xorm:&quot;updated&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Insert(), InsertOne(), Update()方法被调用时，updated标记的字段将会被自动更新为当前时间，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">engine.ID(<span class="number">1</span>).Get(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM user WHERE id = ?</span></span><br><span class="line">engine.ID(<span class="number">1</span>).Update(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE user SET ..., updaetd_at = ? WHERE id = ?</span></span><br></pre></td></tr></table></figure>

<p>如果你希望临时不自动插入时间，则可以组合NoAutoTime()方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.NoAutoTime().Insert(&amp;user)</span><br></pre></td></tr></table></figure>

<p>这个在从一张表拷贝字段到另一张表时比较有用。</p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>删除数据用 <code>Delete</code>方法，参数为struct的指针并且成为查询条件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">affected, err := engine.ID(id).Delete(user)</span><br></pre></td></tr></table></figure>

<p><code>Delete</code>的返回值第一个参数为删除的记录数，第二个参数为错误。</p>
<p>注意1：</p>
<p>当删除时，如果user中包含有bool,float64或者float32类型，有可能会使删除失败。</p>
<p>注意2：必须至少包含一个条件才能够进行删除，这意味着直接用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Delete(<span class="built_in">new</span>(User))</span><br></pre></td></tr></table></figure>

<p>将会报一个保护性的错误，如果你真的希望将整个表删除，你可以</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Where(<span class="string">&quot;1=1&quot;</span>).Delete(<span class="built_in">new</span>(User))</span><br></pre></td></tr></table></figure>

<h3 id="软删除Deleted"><a href="#软删除Deleted" class="headerlink" title="软删除Deleted"></a>软删除Deleted</h3><p>Deleted可以让您不真正的删除数据，而是标记一个删除时间。使用此特性需要在xorm标记中使用deleted标记，如下所示进行标记，对应的字段可以为time.Time, type MyTime time.Time，int 或者 int64类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">int64</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    DeletedAt time.Time <span class="string">`xorm:&quot;deleted&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Delete()时，deleted标记的字段将会被自动更新为当前时间而不是去删除该条记录，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">engine.ID(<span class="number">1</span>).Get(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM user WHERE id = ?</span></span><br><span class="line">engine.ID(<span class="number">1</span>).Delete(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE user SET ..., deleted_at = ? WHERE id = ?</span></span><br><span class="line">engine.ID(<span class="number">1</span>).Get(&amp;user)</span><br><span class="line"><span class="comment">// 再次调用Get，此时将返回false, nil，即记录不存在</span></span><br><span class="line">engine.ID(<span class="number">1</span>).Delete(&amp;user)</span><br><span class="line"><span class="comment">// 再次调用删除会返回0, nil，即记录不存在</span></span><br></pre></td></tr></table></figure>

<p>那么如果记录已经被标记为删除后，要真正的获得该条记录或者真正的删除该条记录，需要启用Unscoped，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">engine.ID(<span class="number">1</span>).Unscoped().Get(&amp;user)</span><br><span class="line"><span class="comment">// 此时将可以获得记录</span></span><br><span class="line">engine.ID(<span class="number">1</span>).Unscoped().Delete(&amp;user)</span><br><span class="line"><span class="comment">// 此时将可以真正的删除记录</span></span><br></pre></td></tr></table></figure>

<h1 id="执行SQL查询"><a href="#执行SQL查询" class="headerlink" title="执行SQL查询"></a>执行SQL查询</h1><h2 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h2><p>也可以直接执行一个SQL查询，即Select命令。在Postgres中支持原始SQL语句中使用 &#96; 和 ? 符号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sql := <span class="string">&quot;select * from userinfo&quot;</span></span><br><span class="line">results, err := engine.Query(sql)</span><br></pre></td></tr></table></figure>

<p>当调用 <code>Query</code> 时，第一个返回值 <code>results</code> 为 <code>[]map[string][]byte</code> 的形式。</p>
<p><code>Query</code> 的参数也允许传入 <code>*builder.Buidler</code> 对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SELECT * FROM table</span></span><br><span class="line">results, err := engine.Query(builder.Select(<span class="string">&quot;*&quot;</span>).From(<span class="string">&quot;table&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="QueryInterface"><a href="#QueryInterface" class="headerlink" title="QueryInterface"></a>QueryInterface</h2><p>和 <code>Query</code> 类似，但是返回值为 <code>[]map[string]interface&#123;&#125;</code></p>
<h2 id="QueryString"><a href="#QueryString" class="headerlink" title="QueryString"></a>QueryString</h2><p>和 <code>Query</code> 类似，但是返回值为 <code>[]map[string]string</code></p>
<h1 id="执行SQL命令"><a href="#执行SQL命令" class="headerlink" title="执行SQL命令"></a>执行SQL命令</h1><p>也可以直接执行一个SQL命令，即执行Insert， Update， Delete 等操作。此时不管数据库是何种类型，都可以使用 &#96; 和 ? 符号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;update `userinfo` set username=? where id=?&quot;</span></span><br><span class="line">res, err := engine.Exec(sql, <span class="string">&quot;xiaolun&quot;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h1><p>当使用事务处理时，需要创建 Session 对象。在进行事务处理时，可以混用 ORM 方法和 RAW 方法，如下代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyTransactionOps</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    session := engine.NewSession()</span><br><span class="line">    <span class="keyword">defer</span> session.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add Begin() before any action</span></span><br><span class="line">    <span class="keyword">if</span> err := session.Begin(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user1 := Userinfo&#123;Username: <span class="string">&quot;xiaoxiao&quot;</span>, Departname: <span class="string">&quot;dev&quot;</span>, Alias: <span class="string">&quot;lunny&quot;</span>, Created: time.Now()&#125;</span><br><span class="line">    <span class="keyword">if</span> _, err := session.Insert(&amp;user1); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    user2 := Userinfo&#123;Username: <span class="string">&quot;yyy&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> _, err = session.Where(<span class="string">&quot;id = ?&quot;</span>, <span class="number">2</span>).Update(&amp;user2); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, err = session.Exec(<span class="string">&quot;delete from userinfo where username = ?&quot;</span>, user2.Username); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add Commit() after all actions</span></span><br><span class="line">    <span class="keyword">return</span> session.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意如果您使用的是 mysql，数据库引擎为 innodb 事务才有效，myisam 引擎是不支持事务的。</li>
</ul>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>xorm 内置了一致性缓存支持，不过默认并没有开启。要开启缓存，需要在 engine 创建完后进行配置。缓存相关的 内容存放在 xorm.io&#x2F;xorm&#x2F;caches 这个包中：</p>
<p>启用一个全局的内存缓存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cacher := caches.NewLRUCacher(caches.NewMemoryStore(), <span class="number">1000</span>)</span><br><span class="line">engine.SetDefaultCacher(cacher)</span><br></pre></td></tr></table></figure>

<p>上述代码采用了LRU算法的一个缓存，缓存方式是存放到内存中，缓存struct的记录数为1000条，缓存针对的范围是所有具有主键的表，没有主键的表中的数据将不会被缓存。 如果只想针对部分表，则：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cacher := caches.NewLRUCacher(caches.NewMemoryStore(), <span class="number">1000</span>)</span><br><span class="line">engine.MapCacher(&amp;user, cacher)</span><br></pre></td></tr></table></figure>

<p>如果要禁用某个表的缓存，则：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.MapCacher(&amp;user, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>设置完之后，其它代码基本上就不需要改动了，缓存系统已经在后台运行。</p>
<p>当前实现了内存存储的CacheStore接口MemoryStore，如果需要采用其它设备存储，可以实现CacheStore接口。</p>
<p>不过需要特别注意不适用缓存或者需要手动编码的地方：</p>
<ol>
<li>当使用了<code>Distinct</code>,<code>Having</code>,<code>GroupBy</code>方法将不会使用缓存</li>
<li>在<code>Get</code>或者<code>Find</code>时使用了<code>Cols</code>,<code>Omit</code>方法，则在开启缓存后此方法无效，系统仍旧会取出这个表中的所有字段。</li>
<li>在使用Exec方法执行了方法之后，可能会导致缓存与数据库不一致的地方。因此如果启用缓存，尽量避免使用Exec。如果必须使用，则需要在使用了Exec之后调用ClearCache手动做缓存清除的工作。比如：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.Exec(<span class="string">&quot;update user set name = ? where id = ?&quot;</span>, <span class="string">&quot;xlw&quot;</span>, <span class="number">1</span>)</span><br><span class="line">engine.ClearCache(<span class="built_in">new</span>(User))</span><br></pre></td></tr></table></figure>

<p>缓存的实现原理如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/cache_design.png"></p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>xorm 支持两种方式的事件，一种是在 Struct中的特定方法来作为事件的方法，一种是在执行语句的过程中执行事件。</p>
<p>在Struct中作为成员方法的事件如下：</p>
<ul>
<li><code>BeforeInsert()</code></li>
</ul>
<p>在将此struct插入到数据库之前执行</p>
<ul>
<li><code>BeforeUpdate()</code></li>
</ul>
<p>在将此struct更新到数据库之前执行</p>
<ul>
<li><code>BeforeDelete()</code></li>
</ul>
<p>在将此struct对应的条件数据从数据库删除之前执行</p>
<ul>
<li><code>func BeforeSet(name string, cell xorm.Cell)</code></li>
</ul>
<p>在 Get 或 Find 方法中，当数据已经从数据库查询出来，而在设置到结构体之前调用，name为数据库字段名称，cell为数据库中的字段值。</p>
<ul>
<li><code>func AfterSet(name string, cell xorm.Cell)</code></li>
</ul>
<p>在 Get 或 Find 方法中，当数据已经从数据库查询出来，而在设置到结构体之后调用，name为数据库字段名称，cell为数据库中的字段值。</p>
<ul>
<li><code>AfterLoad()</code></li>
</ul>
<p>在 Get 或 Find 方法中，当数据已经从数据库查询出来，而在设置到结构体之后调用。</p>
<ul>
<li><code>AfterLoad(*xorm.Session)</code></li>
</ul>
<p>在 Get 或 Find 方法中，当数据已经从数据库查询出来，而在设置到结构体之后调用，并传递<code>xorm.Session</code>参数。</p>
<ul>
<li><code>AfterInsert()</code></li>
</ul>
<p>在将此struct成功插入到数据库之后执行</p>
<ul>
<li><code>AfterUpdate()</code></li>
</ul>
<p>在将此struct成功更新到数据库之后执行</p>
<ul>
<li><code>AfterDelete()</code></li>
</ul>
<p>在将此struct对应的条件数据成功从数据库删除之后执行</p>
<p>在语句执行过程中的事件方法为：</p>
<ul>
<li><code>Before(beforeFunc interface&#123;&#125;)</code></li>
</ul>
<p>临时执行某个方法之前执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">before := <span class="function"><span class="keyword">func</span><span class="params">(bean <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;before&quot;</span>, bean)</span><br><span class="line">&#125;</span><br><span class="line">engine.Before(before).Insert(&amp;obj)</span><br></pre></td></tr></table></figure>

<ul>
<li>After(afterFunc interface{})</li>
</ul>
<p>临时执行某个方法之后执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">after := <span class="function"><span class="keyword">func</span><span class="params">(bean <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;after&quot;</span>, bean)</span><br><span class="line">&#125;</span><br><span class="line">engine.After(after).Insert(&amp;obj)</span><br></pre></td></tr></table></figure>

<p>其中beforeFunc和afterFunc的原型为func(bean interface{}).</p>
<h1 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h1><p>Builder 是一个 XORM 内置的轻量级快速 SQL 构建引擎。</p>
<p>请注意此包为独立安装，请确保你的 Go 版本在 1.8+ 以上可以如下安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get xorm.io/builder</span><br></pre></td></tr></table></figure>

<h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sql, args, err := builder.Insert(Eq&#123;<span class="string">&quot;c&quot;</span>: <span class="number">1</span>, <span class="string">&quot;d&quot;</span>: <span class="number">2</span>&#125;).Into(<span class="string">&quot;table1&quot;</span>).ToSQL()</span><br><span class="line"></span><br><span class="line"><span class="comment">// INSERT INTO table1 SELECT * FROM table2</span></span><br><span class="line">sql, err := builder.Insert().Into(<span class="string">&quot;table1&quot;</span>).Select().From(<span class="string">&quot;table2&quot;</span>).ToBoundSQL()</span><br><span class="line"></span><br><span class="line"><span class="comment">// INSERT INTO table1 (a, b) SELECT b, c FROM table2</span></span><br><span class="line">sql, err = builder.Insert(<span class="string">&quot;a, b&quot;</span>).Into(<span class="string">&quot;table1&quot;</span>).Select(<span class="string">&quot;b, c&quot;</span>).From(<span class="string">&quot;table2&quot;</span>).ToBoundSQL()</span><br></pre></td></tr></table></figure>

<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simple Query</span></span><br><span class="line">sql, args, err := Select(<span class="string">&quot;c, d&quot;</span>).From(<span class="string">&quot;table1&quot;</span>).Where(Eq&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;).ToSQL()</span><br><span class="line"><span class="comment">// With join</span></span><br><span class="line">sql, args, err = Select(<span class="string">&quot;c, d&quot;</span>).From(<span class="string">&quot;table1&quot;</span>).LeftJoin(<span class="string">&quot;table2&quot;</span>, Eq&#123;<span class="string">&quot;table1.id&quot;</span>: <span class="number">1</span>&#125;.And(Lt&#123;<span class="string">&quot;table2.id&quot;</span>: <span class="number">3</span>&#125;)).</span><br><span class="line">		RightJoin(<span class="string">&quot;table3&quot;</span>, <span class="string">&quot;table2.id = table3.tid&quot;</span>).Where(Eq&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;).ToSQL()</span><br><span class="line"><span class="comment">// From sub query</span></span><br><span class="line">sql, args, err := Select(<span class="string">&quot;sub.id&quot;</span>).From(Select(<span class="string">&quot;c&quot;</span>).From(<span class="string">&quot;table1&quot;</span>).Where(Eq&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;), <span class="string">&quot;sub&quot;</span>).Where(Eq&#123;<span class="string">&quot;b&quot;</span>: <span class="number">1</span>&#125;).ToSQL()</span><br><span class="line"><span class="comment">// From union query</span></span><br><span class="line">sql, args, err = Select(<span class="string">&quot;sub.id&quot;</span>).From(</span><br><span class="line">	Select(<span class="string">&quot;id&quot;</span>).From(<span class="string">&quot;table1&quot;</span>).Where(Eq&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;).Union(<span class="string">&quot;all&quot;</span>, Select(<span class="string">&quot;id&quot;</span>).From(<span class="string">&quot;table1&quot;</span>).Where(Eq&#123;<span class="string">&quot;a&quot;</span>: <span class="number">2</span>&#125;)),<span class="string">&quot;sub&quot;</span>).</span><br><span class="line">	Where(Eq&#123;<span class="string">&quot;b&quot;</span>: <span class="number">1</span>&#125;).ToSQL()</span><br><span class="line"><span class="comment">// With order by</span></span><br><span class="line">sql, args, err = Select(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>).From(<span class="string">&quot;table1&quot;</span>).Where(Eq&#123;<span class="string">&quot;f1&quot;</span>: <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;f2&quot;</span>: <span class="string">&quot;v2&quot;</span>&#125;).</span><br><span class="line">		OrderBy(<span class="string">&quot;a ASC&quot;</span>).ToSQL()</span><br><span class="line"><span class="comment">// With limit.</span></span><br><span class="line"><span class="comment">// Be careful! You should set up specific dialect for builder before performing a query with LIMIT</span></span><br><span class="line">sql, args, err = Dialect(MYSQL).Select(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>).From(<span class="string">&quot;table1&quot;</span>).OrderBy(<span class="string">&quot;a ASC&quot;</span>).</span><br><span class="line">		Limit(<span class="number">5</span>, <span class="number">10</span>).ToSQL()</span><br></pre></td></tr></table></figure>

<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sql, args, err := Update(Eq&#123;<span class="string">&quot;a&quot;</span>: <span class="number">2</span>&#125;).From(<span class="string">&quot;table1&quot;</span>).Where(Eq&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;).ToSQL()</span><br></pre></td></tr></table></figure>

<h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sql, args, err := Delete(Eq&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;).From(<span class="string">&quot;table1&quot;</span>).ToSQL()</span><br></pre></td></tr></table></figure>

<h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sql, args, err := Select(<span class="string">&quot;*&quot;</span>).From(<span class="string">&quot;a&quot;</span>).Where(Eq&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;1&quot;</span>&#125;).</span><br><span class="line">		Union(<span class="string">&quot;all&quot;</span>, Select(<span class="string">&quot;*&quot;</span>).From(<span class="string">&quot;a&quot;</span>).Where(Eq&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;)).</span><br><span class="line">		Union(<span class="string">&quot;distinct&quot;</span>, Select(<span class="string">&quot;*&quot;</span>).From(<span class="string">&quot;a&quot;</span>).Where(Eq&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;)).</span><br><span class="line">		Union(<span class="string">&quot;&quot;</span>, Select(<span class="string">&quot;*&quot;</span>).From(<span class="string">&quot;a&quot;</span>).Where(Eq&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;4&quot;</span>&#125;)).</span><br><span class="line">		ToSQL()</span><br></pre></td></tr></table></figure>

<h2 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h2><ul>
<li><code>Eq</code> is a redefine of a map, you can give one or more conditions to <code>Eq</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;xorm.io/builder&quot;</span></span><br><span class="line"></span><br><span class="line">sql, args, _ := ToSQL(Eq&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// a=? [1]</span></span><br><span class="line">sql, args, _ := ToSQL(Eq&#123;<span class="string">&quot;b&quot;</span>:<span class="string">&quot;c&quot;</span>&#125;.And(Eq&#123;<span class="string">&quot;c&quot;</span>: <span class="number">0</span>&#125;))</span><br><span class="line"><span class="comment">// b=? AND c=? [&quot;c&quot;, 0]</span></span><br><span class="line">sql, args, _ := ToSQL(Eq&#123;<span class="string">&quot;b&quot;</span>:<span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">// b=? AND c=? [&quot;c&quot;, 0]</span></span><br><span class="line">sql, args, _ := ToSQL(Eq&#123;<span class="string">&quot;b&quot;</span>:<span class="string">&quot;c&quot;</span>&#125;.Or(Eq&#123;<span class="string">&quot;b&quot;</span>:<span class="string">&quot;d&quot;</span>&#125;))</span><br><span class="line"><span class="comment">// b=? OR b=? [&quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line">sql, args, _ := ToSQL(Eq&#123;<span class="string">&quot;b&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;)</span><br><span class="line"><span class="comment">// b IN (?,?) [&quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line">sql, args, _ := ToSQL(Eq&#123;<span class="string">&quot;b&quot;</span>: <span class="number">1</span>, <span class="string">&quot;c&quot;</span>:[]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;)</span><br><span class="line"><span class="comment">// b=? AND c IN (?,?) [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Neq</code> is the same to <code>Eq</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;xorm.io/builder&quot;</span></span><br><span class="line"></span><br><span class="line">sql, args, _ := ToSQL(Neq&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// a&lt;&gt;? [1]</span></span><br><span class="line">sql, args, _ := ToSQL(Neq&#123;<span class="string">&quot;b&quot;</span>:<span class="string">&quot;c&quot;</span>&#125;.And(Neq&#123;<span class="string">&quot;c&quot;</span>: <span class="number">0</span>&#125;))</span><br><span class="line"><span class="comment">// b&lt;&gt;? AND c&lt;&gt;? [&quot;c&quot;, 0]</span></span><br><span class="line">sql, args, _ := ToSQL(Neq&#123;<span class="string">&quot;b&quot;</span>:<span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">// b&lt;&gt;? AND c&lt;&gt;? [&quot;c&quot;, 0]</span></span><br><span class="line">sql, args, _ := ToSQL(Neq&#123;<span class="string">&quot;b&quot;</span>:<span class="string">&quot;c&quot;</span>&#125;.Or(Neq&#123;<span class="string">&quot;b&quot;</span>:<span class="string">&quot;d&quot;</span>&#125;))</span><br><span class="line"><span class="comment">// b&lt;&gt;? OR b&lt;&gt;? [&quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line">sql, args, _ := ToSQL(Neq&#123;<span class="string">&quot;b&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;)</span><br><span class="line"><span class="comment">// b NOT IN (?,?) [&quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line">sql, args, _ := ToSQL(Neq&#123;<span class="string">&quot;b&quot;</span>: <span class="number">1</span>, <span class="string">&quot;c&quot;</span>:[]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;)</span><br><span class="line"><span class="comment">// b&lt;&gt;? AND c NOT IN (?,?) [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Gt</code>, <code>Gte</code>, <code>Lt</code>, <code>Lte</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;xorm.io/builder&quot;</span></span><br><span class="line"></span><br><span class="line">sql, args, _ := ToSQL(Gt&#123;<span class="string">&quot;a&quot;</span>, <span class="number">1</span>&#125;.And(Gte&#123;<span class="string">&quot;b&quot;</span>, <span class="number">2</span>&#125;))</span><br><span class="line"><span class="comment">// a&gt;? AND b&gt;=? [1, 2]</span></span><br><span class="line">sql, args, _ := ToSQL(Lt&#123;<span class="string">&quot;a&quot;</span>, <span class="number">1</span>&#125;.Or(Lte&#123;<span class="string">&quot;b&quot;</span>, <span class="number">2</span>&#125;))</span><br><span class="line"><span class="comment">// a&lt;? OR b&lt;=? [1, 2]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Like</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;xorm.io/builder&quot;</span></span><br><span class="line"></span><br><span class="line">sql, args, _ := ToSQL(Like&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// a LIKE ? [%c%]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Expr</code> you can customerize your sql with <code>Expr</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;xorm.io/builder&quot;</span></span><br><span class="line"></span><br><span class="line">sql, args, _ := ToSQL(Expr(<span class="string">&quot;a = ? &quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">// a = ? [1]</span></span><br><span class="line">sql, args, _ := ToSQL(Eq&#123;<span class="string">&quot;a&quot;</span>: Expr(<span class="string">&quot;select id from table where c = ?&quot;</span>, <span class="number">1</span>)&#125;)</span><br><span class="line"><span class="comment">// a=(select id from table where c = ?) [1]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>In</code> and <code>NotIn</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;xorm.io/builder&quot;</span></span><br><span class="line"></span><br><span class="line">sql, args, _ := ToSQL(In(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// a IN (?,?,?) [1,2,3]</span></span><br><span class="line">sql, args, _ := ToSQL(In(<span class="string">&quot;a&quot;</span>, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;))</span><br><span class="line"><span class="comment">// a IN (?,?,?) [1,2,3]</span></span><br><span class="line">sql, args, _ := ToSQL(NotIn(<span class="string">&quot;a&quot;</span>, Expr(<span class="string">&quot;select id from b where c = ?&quot;</span>, <span class="number">1</span>))))</span><br><span class="line"><span class="comment">// a NOT IN (select id from b where c = ?) [1]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Exists</code> and <code>NotExists</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;xorm.io/builder&quot;</span></span><br><span class="line"></span><br><span class="line">sql, args, _ := ToSQL(Exists(Select(<span class="string">&quot;a&quot;</span>).From(<span class="string">&quot;table&quot;</span>)))</span><br><span class="line"><span class="comment">// EXISTS (SELECT a FROM table)</span></span><br><span class="line">sql, args, _ := ToSQL(NotExists(Select(<span class="string">&quot;a&quot;</span>).From(<span class="string">&quot;table&quot;</span>)))</span><br><span class="line"><span class="comment">// NOT EXISTS (SELECT a FROM table)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>IsNull</code> and <code>NotNull</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;xorm.io/builder&quot;</span></span><br><span class="line"></span><br><span class="line">sql, args, _ := ToSQL(IsNull&#123;<span class="string">&quot;a&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// a IS NULL []</span></span><br><span class="line">sql, args, _ := ToSQL(NotNull&#123;<span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">	<span class="comment">// b IS NOT NULL []</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>And(conds ...Cond)</code>, And can connect one or more conditions via And</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;xorm.io/builder&quot;</span></span><br><span class="line"></span><br><span class="line">sql, args, _ := ToSQL(And(Eq&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;, Like&#123;<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;, Neq&#123;<span class="string">&quot;d&quot;</span>, <span class="number">2</span>&#125;))</span><br><span class="line"><span class="comment">// a=? AND b LIKE ? AND d&lt;&gt;? [1, %c%, 2]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Or(conds ...Cond)</code>, Or can connect one or more conditions via Or</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;xorm.io/builder&quot;</span></span><br><span class="line"></span><br><span class="line">sql, args, _ := ToSQL(Or(Eq&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;, Like&#123;<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;, Neq&#123;<span class="string">&quot;d&quot;</span>, <span class="number">2</span>&#125;))</span><br><span class="line"><span class="comment">// a=? OR b LIKE ? OR d&lt;&gt;? [1, %c%, 2]</span></span><br><span class="line">sql, args, _ := ToSQL(Or(Eq&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;, And(Like&#123;<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;, Neq&#123;<span class="string">&quot;d&quot;</span>, <span class="number">2</span>&#125;)))</span><br><span class="line"><span class="comment">// a=? OR (b LIKE ? AND d&lt;&gt;?) [1, %c%, 2]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Between</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;xorm.io/builder&quot;</span></span><br><span class="line"></span><br><span class="line">sql, args, _ := ToSQL(Between&#123;<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">// a BETWEEN 1 AND 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Define yourself conditions</li>
</ul>
<p>Since <code>Cond</code> is an interface.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">interface</span> &#123;</span><br><span class="line">	WriteTo(Writer) <span class="type">error</span></span><br><span class="line">	And(...Cond) Cond</span><br><span class="line">	Or(...Cond) Cond</span><br><span class="line">	IsValid() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can define yourself conditions and compose with other <code>Cond</code>.</p>
]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>部署开源项目 Casdoor 身份认证管理系统到本地</title>
    <url>/2023/07/18/Go/casdoor/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://github.com/casdoor/casdoor">Casdoor</a>是一个基于OAuth 2.0、OIDC、SAML 和 CAS 的，UI-first的身份和访问管理(IAM)&#x2F;单点登录(SSO)平台。使用 Go 和react开发，前后端分离，内置第三方应用登录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/c6d8b07cf2ea4ac095ea194cbbbf2e4d.png"><br>Casdoor 有四个核心概念，分别是 <code>组织(Organization)</code>，<code>用户(User)</code>，<code>应用(Application)</code> 和 <code>提供商(Provider)</code>。组织承载用户和应用，一个用户只能隶属于一个组织，但可以登录到自己组织的多个应用中；而提供商则代表了某种身份验证方式，例如电子邮件验证、短信验证、OAuth 验证等。</p>
<h1 id="部署-Casdoor"><a href="#部署-Casdoor" class="headerlink" title="部署 Casdoor"></a>部署 Casdoor</h1><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>支持所有主流的操作系统，包括Windows、Linux和macOS。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li>Go 1.17+</li>
<li>Node.js LTS (16或14)</li>
<li>Yarn 1.x</li>
</ul>
<blockquote>
<p>强烈建议您使用 Yarn 1.x 运行 Casdoor 前端，使用 NPM可能会导致UI 风格问题。 </p>
</blockquote>
<blockquote>
<p>注意：对于中国大陆用户，为了成功下载依赖关系包， 您需要通过配置 GOPROXY 环境变量来使用Go 代理。 We strongly recommend: <a href="https://goproxy.cn/">https://goproxy.cn/</a></p>
</blockquote>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Casdoor使用 XORM 与数据库进行交互。 基于 Xorm Drivers Support, 当前支持的数据库包括：</p>
<ul>
<li>MySQL</li>
<li>MariaDB</li>
<li>PostgreSQL</li>
<li>CockroachDB</li>
<li>SQL Server</li>
<li>Oracle</li>
<li>SQLite 3</li>
<li>TiDB</li>
</ul>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>The source code of Casdoor is hosted at GitHub: <a href="https://github.com/casdoor/casdoor">https://github.com/casdoor/casdoor</a>. Go 后端代码和 React 前端代码都在单个仓库中。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">描述</th>
<th align="center">语言</th>
<th align="center">源代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">前端</td>
<td align="center">Casdoor的网页前端界面</td>
<td align="center">JavaScript + React</td>
<td align="center"><a href="https://github.com/casdoor/casdoor/tree/master/web">https://github.com/casdoor/casdoor/tree/master/web</a></td>
</tr>
<tr>
<td align="center">后端</td>
<td align="center">Casdoor的ResTful API 后端</td>
<td align="center">Golang + Beego + XORM</td>
<td align="center"><a href="https://github.com/casdoor/casdoor">https://github.com/casdoor/casdoor</a></td>
</tr>
</tbody></table>
<p>Casdoor支持 Go Modules。 要下载代码，您直接通过git克隆仓库就可以了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /文件夹路径/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/casdoor/casdoor</span><br></pre></td></tr></table></figure>
<p>克隆仓库过后，前端页面就在web文件夹里。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><p>Casdoor支持MySQL， msSQL，Sqlite3，PostgreSQL等数据库。 默认使用MySQL。 如果您想使用支持以外的数据库，请自行修改object&#x2F;adapter包</p>
<ul>
<li>MySQL<br>  Casdoor将会把users，nodes和topics信息存储在一个命名为casdoor的MySQL数据库中。 如果数据库不存在，则需手动创建。 The DB connection string can be specified at: <a href="https://github.com/casdoor/casdoor/blob/master/conf/app.conf">https://github.com/casdoor/casdoor/blob/master/conf/app.conf</a><br>  前往 .&#x2F;conf&#x2F;app.conf 配置数据库信息，例如对于 MySQL，使用如下的配置文件：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driverName = mysql</span><br><span class="line">dataSourceName = root:123456@tcp(localhost:3306)/</span><br><span class="line">dbName = casdoor</span><br></pre></td></tr></table></figure>
  此文件也包含许多其他个性化配置，有需要的可根据官方文档修改。</li>
</ul>
<h2 id="编译运行casdoor"><a href="#编译运行casdoor" class="headerlink" title="编译运行casdoor"></a>编译运行casdoor</h2><p>首先确保你的电脑下载了yarn，下载教程参见官方文档：<a href="https://classic.yarnpkg.com/en/docs/install#windows-stable">https://classic.yarnpkg.com/en/docs/install#windows-stable</a><br>简单来说就是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install yarn -g</span><br></pre></td></tr></table></figure>
<ul>
<li><p>若想将 Casdoor 运行在开发模式下，则分别输入以下指令以编译并运行 Casdoor 的前端和后端服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> web</span><br><span class="line">yarn install</span><br><span class="line">yarn start</span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure>
<p>接下来，即可在 <a href="http://localhost:7001/">http://localhost:7001/</a> 访问 Casdoor（默认的管理员用户名和密码为 admin 和 123）。</p>
</li>
<li><p>若想将 Casdoor 运行在生产模式下，则首先输入以下指令编译前端文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> web</span><br><span class="line">yarn install</span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure>
<p>然后，编译并运行 Casdoor 的后端程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build</span><br><span class="line">./casdoor</span><br></pre></td></tr></table></figure>
<p>接下来，即可在 <a href="http://localhost:7001/">http://localhost:7001/</a> 访问 Casdoor（默认的管理员用户名和密码为 admin 和 123）。</p>
</li>
</ul>
<p>ps：如果npm和yarn下载包异常可以参见这篇文章：<a href="https://blog.csdn.net/m0_63230155/article/details/131786214?spm=1001.2014.3001.5502">npm和yarn换成淘宝源仍报错npm ERR! code ETIMEDOUT和info There appears to be trouble with your network……</a></p>
<h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/8b1690ba6dbf4a089c2f2cfbd7a8ae79.png"><br><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/d8e6c8c61e0c4d20a03df2949c660171.png"><br>至此，casdoor项目部署成功。<br>参考官方文档：<a href="https://casdoor.org/zh/docs/overview">https://casdoor.org/zh/docs/overview</a></p>
]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>指针与结构体</title>
    <url>/2023/06/05/Go/9/</url>
    <content><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针的概念"><a href="#指针的概念" class="headerlink" title="指针的概念"></a>指针的概念</h2><p>指针是存储另一个变量的内存地址的变量。</p>
<p>我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。</p>
<p>一个指针变量可以指向任何一个值的内存地址。</p>
<h2 id="获取变量的地址"><a href="#获取变量的地址" class="headerlink" title="获取变量的地址"></a>获取变量的地址</h2><p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span>   </span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;变量的地址: %x\n&quot;</span>, &amp;a  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量的地址: 20818a220</span><br></pre></td></tr></table></figure>

<h2 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h2><p>声明指针，*T是指针变量的类型，它指向T类型的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 指向整型*/</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="type">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;a 变量的地址是: %x\n&quot;</span>, &amp;a  )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;ip 变量的存储地址: %x\n&quot;</span>, ip )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a 变量的地址是: <span class="number">20818</span>a220</span><br><span class="line">ip 变量的存储地址: <span class="number">20818</span>a220</span><br><span class="line">*ip 变量的值: <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> name <span class="type">int8</span></span><br><span class="line"><span class="keyword">type</span> first <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">	b <span class="type">bool</span></span><br><span class="line">	name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = first&#123;<span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> b *first = &amp;a</span><br><span class="line">	fmt.Println(a.b, a.a, a.name, &amp;a, b.a, &amp;b, (*b).a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false 1 2 &amp;&#123;1 false 2&#125; 1 0xc042068018 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取指针地址在指针变量前加&amp;的方式</p>
</blockquote>
<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p><strong>Go 空指针</strong><br>当一个指针被定义后没有分配到任何变量时，它的值为 nil。<br>nil 指针也称为空指针。<br>nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。<br>一个指针变量通常缩写为 ptr。</p>
<p>空指针判断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr != <span class="literal">nil</span>)     <span class="comment">/* ptr 不是空指针 */</span></span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">nil</span>)    <span class="comment">/* ptr 是空指针 */</span></span><br></pre></td></tr></table></figure>

<h2 id="获取指针的值"><a href="#获取指针的值" class="headerlink" title="获取指针的值"></a>获取指针的值</h2><p>获取一个指针意味着访问指针指向的变量的值。语法是：*a</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    a := &amp;b</span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of b is&quot;</span>, *a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作指针改变变量的数值"><a href="#操作指针改变变量的数值" class="headerlink" title="操作指针改变变量的数值"></a>操作指针改变变量的数值</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    a := &amp;b</span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of b is&quot;</span>, *a)</span><br><span class="line">    *a++</span><br><span class="line">    fmt.Println(<span class="string">&quot;new value of b is&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address of b is 0x1040a124  </span><br><span class="line">value of b is 255  </span><br><span class="line">new value of b is 256  </span><br></pre></td></tr></table></figure>

<h2 id="使用指针传递函数的参数"><a href="#使用指针传递函数的参数" class="headerlink" title="使用指针传递函数的参数"></a>使用指针传递函数的参数</h2><p>示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(val *<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    *val = <span class="number">55</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">58</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a before function call is&quot;</span>,a)</span><br><span class="line">    b := &amp;a</span><br><span class="line">    change(b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a after function call is&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value of a before function call is 58  </span><br><span class="line">value of a after function call is 55  </span><br></pre></td></tr></table></figure>

<p><strong>不要将一个指向数组的指针传递给函数。使用切片。</strong></p>
<p>假设我们想对函数内的数组进行一些修改，并且对调用者可以看到函数内的数组所做的更改。一种方法是将一个指向数组的指针传递给函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    (*arr)[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[90 90 91]</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[90 90 91]</span><br></pre></td></tr></table></figure>

<p><strong>虽然将指针传递给一个数组作为函数的参数并对其进行修改，但这并不是实现这一目标的惯用方法。我们有切片。</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(sls []<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sls[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(a[:])</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[90 90 91]</span><br></pre></td></tr></table></figure>



<p>Go不支持指针算法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">b := [...]<span class="type">int</span>&#123;<span class="number">109</span>, <span class="number">110</span>, <span class="number">111</span>&#125;</span><br><span class="line">p := &amp;b</span><br><span class="line">p++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nvalid operation: p++ (non-numeric type *[3]int)</p>
</blockquote>
<p><strong>指针数组</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX <span class="type">int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   a := []<span class="type">int</span>&#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">200</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; MAX; i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, a[i] )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>有一种情况，我们可能需要保存数组，这样我们就需要使用到指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX <span class="type">int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> ptr [MAX]*<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; MAX; i++ &#123;</span><br><span class="line">		ptr[i] = &amp;a[i] <span class="comment">/* 整数地址赋值给指针数组 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; MAX; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, *ptr[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<h2 id="指针的指针"><a href="#指针的指针" class="headerlink" title="指针的指针"></a>指针的指针</h2><p><strong>指针的指针</strong></p>
<p>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr **<span class="type">int</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> ptr *<span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> pptr **<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   a = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指针 ptr 地址 */</span></span><br><span class="line">   ptr = &amp;a</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指向指针 ptr 地址 */</span></span><br><span class="line">   pptr = &amp;ptr</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 获取 pptr 的值 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;变量 a = %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;指针变量 *ptr = %d\n&quot;</span>, *ptr )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;指向指针的指针变量 **pptr = %d\n&quot;</span>, **pptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量 a = 3000</span><br><span class="line">指针变量 *ptr = 3000</span><br><span class="line">指向指针的指针变量 **pptr = 3000</span><br></pre></td></tr></table></figure>

<p><strong>指针作为函数参数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span>= <span class="number">200</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 b 的值 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用函数用于交换值</span></span><br><span class="line"><span class="comment">   * &amp;a 指向 a 变量的地址</span></span><br><span class="line"><span class="comment">   * &amp;b 指向 b 变量的地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   swap(&amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保存 x 地址的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 赋值给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 赋值给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">交换前 a 的值 : 100</span><br><span class="line">交换前 b 的值 : 200</span><br><span class="line">交换后 a 的值 : 200</span><br><span class="line">交换后 b 的值 : 100</span><br></pre></td></tr></table></figure>

<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="什么是结构体"><a href="#什么是结构体" class="headerlink" title="什么是结构体"></a>什么是结构体</h2><p>Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。<br>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</p>
<h2 id="结构体的定义和初始化"><a href="#结构体的定义和初始化" class="headerlink" title="结构体的定义和初始化"></a>结构体的定义和初始化</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦定义了结构体类型，它就能用于变量的声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初始化结构体</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.按照顺序提供初始化值</span></span><br><span class="line">P := person&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line"><span class="comment">// 2.通过field:value的方式初始化，这样可以任意顺序</span></span><br><span class="line">P := person&#123;age:<span class="number">24</span>, name:<span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 3.new方式,未设置初始值的，会赋予类型的默认初始值</span></span><br><span class="line">p := <span class="built_in">new</span>(person)</span><br><span class="line">p.age=<span class="number">24</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体的访问"><a href="#结构体的访问" class="headerlink" title="结构体的访问"></a>结构体的访问</h2><p>访问结构体成员(访问结构的各个字段)</p>
<p>通过点.操作符用于访问结构的各个字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="type">string</span></span><br><span class="line">   author <span class="type">string</span></span><br><span class="line">   subject <span class="type">string</span></span><br><span class="line">   book_id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* 声明 Book2 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 title : %s\n&quot;</span>, Book1.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 author : %s\n&quot;</span>, Book1.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 subject : %s\n&quot;</span>, Book1.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 book_id : %d\n&quot;</span>, Book1.book_id)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 title : %s\n&quot;</span>, Book2.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 author : %s\n&quot;</span>, Book2.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 subject : %s\n&quot;</span>, Book2.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 book_id : %d\n&quot;</span>, Book2.book_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Book 1 title : Go 语言</span><br><span class="line">Book 1 author : www.runoob.com</span><br><span class="line">Book 1 subject : Go 语言教程</span><br><span class="line">Book 1 book_id : 6495407</span><br><span class="line">Book 2 title : Python 教程</span><br><span class="line">Book 2 author : www.runoob.com</span><br><span class="line">Book 2 subject : Python 语言教程</span><br><span class="line">Book 2 book_id : 6495700</span><br></pre></td></tr></table></figure>

<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>指针指向一个结构体，也可以创建指向结构的指针。</p>
<p><strong>结构体指针</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br></pre></td></tr></table></figure>

<p>以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>

<p>使用结构体指针访问结构体成员，使用 “.” 操作符</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer.title;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="type">string</span></span><br><span class="line">   author <span class="type">string</span></span><br><span class="line">   subject <span class="type">string</span></span><br><span class="line">   book_id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* Declare Book1 of type Book */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* Declare Book2 of type Book */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   printBook(&amp;Book1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   printBook(&amp;Book2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book *Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Book title : Go 语言</span><br><span class="line">Book author : www.runoob.com</span><br><span class="line">Book subject : Go 语言教程</span><br><span class="line">Book book_id : 6495407</span><br><span class="line">Book title : Python 教程</span><br><span class="line">Book author : www.runoob.com</span><br><span class="line">Book subject : Python 语言教程</span><br><span class="line">Book book_id : 6495700</span><br></pre></td></tr></table></figure>

<p>结构体实例化也可以是这样的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Books)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;data&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, Books&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>在<code>Books</code>类型上定义了一个<code>String</code>方法。这个方法具有一个接收者<code>(s Books)</code>，表示它是<code>Books</code>类型的一个实例方法。这个方法返回一个字符串<code>&quot;data&quot;</code>。<code>Books&#123;&#125;</code>创建了一个<code>Books</code>类型的实例，然后通过<code>%v</code>打印输出。由于<code>Books</code>类型实现了<code>String</code>方法，该方法将被调用，返回字符串<code>&quot;data&quot;</code>。</p>
<h2 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h2><p><strong>结构体的匿名字段</strong></p>
<p>可以用字段来创建结构，这些字段只包含一个没有字段名的类型。这些字段被称为匿名字段。</p>
<p>在类型中，使用不写字段名的方式，使用另一个类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们初始化一个学生</span></span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="number">120</span>&#125;, <span class="string">&quot;Computer Science&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 我们访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His name is &quot;</span>, mark.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is &quot;</span>, mark.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is &quot;</span>, mark.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改对应的备注信息</span></span><br><span class="line">    mark.speciality = <span class="string">&quot;AI&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark changed his speciality&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改他的年龄信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark become old&quot;</span>)</span><br><span class="line">    mark.age = <span class="number">46</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is&quot;</span>, mark.age)</span><br><span class="line">    <span class="comment">// 修改他的体重信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark is not an athlet anymore&quot;</span>)</span><br><span class="line">    mark.weight += <span class="number">60</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is&quot;</span>, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">His name is  Mark</span><br><span class="line">His age is  25</span><br><span class="line">His weight is  120</span><br><span class="line">His speciality is  Computer Science</span><br><span class="line">Mark changed his speciality</span><br><span class="line">His speciality is  AI</span><br><span class="line">Mark become old</span><br><span class="line">His age is 46</span><br><span class="line">Mark is not an athlet anymore</span><br><span class="line">His weight is 180</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以使用”.”的方式进行调用匿名字段中的属性值</p>
<p>实际就是字段的继承</p>
<p>其中可以将匿名字段理解为字段名和字段类型都是同一个</p>
<p>基于上面的理解，所以可以<code>mark.Human = Human&#123;&quot;Marcus&quot;, 55, 220&#125; </code>和<code>mark.Human.age = 46</code></p>
<p>若存在匿名字段中的字段与非匿名字段名字相同，则最外层的优先访问，就近原则</p>
</blockquote>
<p>通过匿名访问和修改字段相当的有用，但是不仅仅是struct字段哦，所有的内置类型和自定义类型都是可以作为匿名字段的。</p>
<h2 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h2><p>嵌套的结构体<br>一个结构体可能包含一个字段，而这个字段反过来就是一个结构体。这些结构被称为嵌套结构。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;  </span><br><span class="line">    city, state <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    p.name = <span class="string">&quot;Naveen&quot;</span></span><br><span class="line">    p.age = <span class="number">50</span></span><br><span class="line">    p.address = Address &#123;</span><br><span class="line">        city: <span class="string">&quot;Chicago&quot;</span>,</span><br><span class="line">        state: <span class="string">&quot;Illinois&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Name:&quot;</span>, p.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Age:&quot;</span>,p.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>,p.address.city)</span><br><span class="line">    fmt.Println(<span class="string">&quot;State:&quot;</span>,p.address.state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提升字段"><a href="#提升字段" class="headerlink" title="提升字段"></a>提升字段</h2><p>在结构体中属于匿名结构体的字段称为提升字段，因为它们可以被访问，就好像它们属于拥有匿名结构字段的结构一样。理解这个定义是相当复杂的。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;  </span><br><span class="line">    city, state <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">    address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    p.name = <span class="string">&quot;Naveen&quot;</span></span><br><span class="line">    p.age = <span class="number">50</span></span><br><span class="line">    p.Address = Address&#123;</span><br><span class="line">        city:  <span class="string">&quot;Chicago&quot;</span>,</span><br><span class="line">        state: <span class="string">&quot;Illinois&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Name:&quot;</span>, p.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Age:&quot;</span>, p.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>, p.city) <span class="comment">//city is promoted field</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;State:&quot;</span>, p.state) <span class="comment">//state is promoted field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name: Naveen  </span><br><span class="line">Age: 50  </span><br><span class="line">City: Chicago  </span><br><span class="line">State: Illinois</span><br></pre></td></tr></table></figure>

<h2 id="导出结构体和字段"><a href="#导出结构体和字段" class="headerlink" title="导出结构体和字段"></a>导出结构体和字段</h2><p>如果结构体类型以大写字母开头，那么它是一个导出类型，可以从其他包访问它。类似地，如果结构体的字段以大写开头，则可以从其他包访问它们。</p>
<p>示例代码：</p>
<p>1.在computer目录下，创建文件spec.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> computer</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Spec <span class="keyword">struct</span> &#123; <span class="comment">//exported struct  </span></span><br><span class="line">    Maker <span class="type">string</span> <span class="comment">//exported field</span></span><br><span class="line">    model <span class="type">string</span> <span class="comment">//unexported field</span></span><br><span class="line">    Price <span class="type">int</span> <span class="comment">//exported field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建main.go 文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;structs/computer&quot;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> spec computer.Spec</span><br><span class="line">    spec.Maker = <span class="string">&quot;apple&quot;</span></span><br><span class="line">    spec.Price = <span class="number">50000</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Spec:&quot;</span>, spec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spec: &#123;apple  50000&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h2><p>结构体是值类型，如果每个字段具有可比性，则是可比较的。如果它们对应的字段相等，则认为两个结构体变量是相等的。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> name <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    name1 := name&#123;<span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;Jobs&quot;</span>&#125;</span><br><span class="line">    name2 := name&#123;<span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;Jobs&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> name1 == name2 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name1 and name2 are equal&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name1 and name2 are not equal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    name3 := name&#123;firstName:<span class="string">&quot;Steve&quot;</span>, lastName:<span class="string">&quot;Jobs&quot;</span>&#125;</span><br><span class="line">    name4 := name&#123;&#125;</span><br><span class="line">    name4.firstName = <span class="string">&quot;Steve&quot;</span></span><br><span class="line">    <span class="keyword">if</span> name3 == name4 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name3 and name4 are equal&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name3 and name4 are not equal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name1 and name2 are equal  </span><br><span class="line">name3 and name4 are not equal  </span><br></pre></td></tr></table></figure>

<p><strong>如果结构变量包含的字段是不可比较的，那么结构变量是不可比较的</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> image <span class="keyword">struct</span> &#123;  </span><br><span class="line">    data <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    image1 := image&#123;data: <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">155</span>,</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    image2 := image&#123;data: <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">155</span>,</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    <span class="keyword">if</span> image1 == image2 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;image1 and image2 are equal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invalid operation: image1 == image2 (struct containing map[int]int cannot be compared)</code></p>
<h2 id="结构体作为函数的参数"><a href="#结构体作为函数的参数" class="headerlink" title="结构体作为函数的参数"></a>结构体作为函数的参数</h2><p>结构体作为函数参数使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="type">string</span></span><br><span class="line">   author <span class="type">string</span></span><br><span class="line">   subject <span class="type">string</span></span><br><span class="line">   book_id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* 声明 Book2 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   printBook(Book1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   printBook(Book2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name     <span class="type">string</span></span><br><span class="line">	password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> checkPassword(password <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> u.password == password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> resetPassword(password <span class="type">string</span>) &#123;</span><br><span class="line">	u.password = password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := user&#123;name: <span class="string">&quot;wang&quot;</span>, password: <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">	a.resetPassword(<span class="string">&quot;2048&quot;</span>)</span><br><span class="line">	fmt.Println(a.checkPassword(<span class="string">&quot;2048&quot;</span>)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>make、new操作</strong></p>
<p>make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。<br>内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：new返回指针</p>
<p>内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值。make返回初始化后的（非零）值。</p>
<ul>
<li><code>new</code>用于任何类型的内存分配，返回的是类型的指针，指向新分配的零值内存空间。</li>
<li><code>make</code>仅用于切片、映射和通道的内存分配，返回的是经过初始化后的非零值。</li>
</ul>
<h1 id="指针与结构体举例"><a href="#指针与结构体举例" class="headerlink" title="指针与结构体举例"></a>指针与结构体举例</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name     <span class="type">string</span></span><br><span class="line">	password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := user&#123;name: <span class="string">&quot;wang&quot;</span>, password: <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">	b := user&#123;<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">	c := user&#123;name: <span class="string">&quot;wang&quot;</span>&#125;</span><br><span class="line">	c.password = <span class="string">&quot;1024&quot;</span></span><br><span class="line">	<span class="keyword">var</span> d user</span><br><span class="line">	d.name = <span class="string">&quot;wang&quot;</span></span><br><span class="line">	d.password = <span class="string">&quot;1024&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(a, b, c, d)                 <span class="comment">// &#123;wang 1024&#125; &#123;wang 1024&#125; &#123;wang 1024&#125; &#123;wang 1024&#125;</span></span><br><span class="line">	fmt.Println(checkPassword(a, <span class="string">&quot;haha&quot;</span>))   <span class="comment">// false</span></span><br><span class="line">	fmt.Println(checkPassword2(&amp;a, <span class="string">&quot;haha&quot;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPassword</span><span class="params">(u user, password <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> u.password == password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPassword2</span><span class="params">(u *user, password <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> u.password == password</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;wang 1024&#125; &#123;wang 1024&#125; &#123;wang 1024&#125; &#123;wang 1024&#125;</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>大二自学</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>npm和yarn换成淘宝源仍报错npm ERR! code ETIMEDOUT和info There appears to be trouble with your network......</title>
    <url>/2023/07/18/%E5%89%8D%E7%AB%AF/npmerror/</url>
    <content><![CDATA[<h1 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h1><p>最近在本地部署一个前后端分离项目的时候遇到了这个问题，npm命令无法使用总是显示网络连接异常，由于官方源在国外，我于是配置国内淘宝镜像来提升下载速度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置淘宝镜像源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"><span class="comment">#检查是否设置成功</span></span><br><span class="line">npm get registry  </span><br></pre></td></tr></table></figure>
<p>同时也将yarn设置了淘宝镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置淘宝镜像源</span></span><br><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"><span class="comment">#检查是否设置成功</span></span><br><span class="line">yarn config get registry   </span><br></pre></td></tr></table></figure>
<p>当然也可以下载cgr镜像源管理工具（前提是你能用npm下载）来方便管理：</p>
<ol>
<li>安装 cgr<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cgr</span><br></pre></td></tr></table></figure></li>
<li>列出当前可用的镜像源</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cgr <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ---- https://registry.npmjs.org/</span><br><span class="line">cnpm --- http://r.cnpmjs.org/</span><br><span class="line">taobao - https://registry.npmmirror.com/</span><br><span class="line">yarn --- https://registry.yarnpkg.com/</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>选择一个镜像源进行切换（淘宝）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cgr use taobao</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm registry has been set to: https://registry.npmmirror.com/</span><br><span class="line">yarn registry has been set to: https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>测试访问速度<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cgr <span class="built_in">test</span> taobao</span><br></pre></td></tr></table></figure>
但是当我换源之后遇到了以下问题：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/96422206011d43778ae782b4d905fd87.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/0869e3efb67f461a926019d549b6ec9c.png"></p>
<p>两个包管理工具下载都报类似的错误：ERR!network reguest to <a href="https://registry.npumirror/">https://registry.npumirror</a>. com&#x2F;yarn failed, reason: connect ETIMEDOUT 240c:c0a9:1600:1:3::3ie:443</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>可能是ipv6网络连接不稳定，导致下载连接异常。最后的解决办法是将本地WLAN属性的ipv6关掉，这样才能下载，当然镜像源还是得设置为淘宝源。</p>
<h2 id="打开本地控制面板，并点击网络和-Internet"><a href="#打开本地控制面板，并点击网络和-Internet" class="headerlink" title="打开本地控制面板，并点击网络和 Internet"></a>打开本地控制面板，并点击网络和 Internet</h2><p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/71b1033d47dd449d9f35d9396740332b.png"><br><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/99281b560152401782d58f3fe173e93a.png"></p>
<h2 id="点击网络和共享中心，再点击更改适配器设置"><a href="#点击网络和共享中心，再点击更改适配器设置" class="headerlink" title="点击网络和共享中心，再点击更改适配器设置"></a>点击网络和共享中心，再点击更改适配器设置</h2><p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/a7c68da883b34c7a855d5d281e2c4b47.png"><br><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/715771c87ec040d3bb7c5462fce81240.png"></p>
<h2 id="右键点击WLAN，再点击属性"><a href="#右键点击WLAN，再点击属性" class="headerlink" title="右键点击WLAN，再点击属性"></a>右键点击WLAN，再点击属性</h2><p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/a6a4b39664fc48f3ac0d841f00a8eea0.png"></p>
<h2 id="取消ipv6，不勾选"><a href="#取消ipv6，不勾选" class="headerlink" title="取消ipv6，不勾选"></a>取消ipv6，不勾选</h2><p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/c8770a0ca77a40b79a447b00d23e6d23.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此npm和yarn便能正常使用，问题得到解决，其实最开始我将npm的镜像源设置为华为源<code>https://mirrors.huaweicloud.com/repository/npm/</code>，ipv6也没有关闭，yarn也设置为华为源，但是这样有一个问题就是npm能用而yarn用不了，直到关闭ipv6，两个源都改成淘宝源才能正常下载依赖包，用npm和yarn下载依赖包的问题困扰了我6个多小时，故有感而发写下这篇文章，留给那些遇到类似问题而未能解决的coder，节省开发时间。</p>
]]></content>
      <tags>
        <tag>大二自学</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之存储器管理</title>
    <url>/2023/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1/</url>
    <content><![CDATA[<h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><p>操作系统的职能之一，主要任务是为<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F?fromModule=lemma_inlink">多道程序</a>的运行提供良好的环境，方便用户使用存储器，提高存储器的利用率以及能从逻辑上<a href="https://baike.baidu.com/item/%E6%89%A9%E5%85%85%E5%86%85%E5%AD%98?fromModule=lemma_inlink">扩充内存</a>。主要目的和功能：</p>
<p>1、主存储器的分配和管理</p>
<p>2、提高主存储器的利用率</p>
<p>3、“扩充”主存容量</p>
<p>4、存储保护</p>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><strong>主存储器</strong></p>
<p>　用于保存进程运行时的程序和数据。CPU的 控制部件只能从主存中取得指令和数据到CPU寄 存器，同样，CPU寄存器中的数据可存入主存。 CPU与外设交换数据必须依托于主存。</p>
<p><strong>寄存器</strong></p>
<p>　寄存器访问速度最快，能与CPU协调工作，价格昂贵，容量不大，寄存器用于加速存储器的访问速度，如用寄存器存放操作数，或用作地址寄存器加快地址转换速度等。</p>
<p><strong>高速缓存</strong></p>
<p>​	CPU对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。 根据程序执行的局部性原理，将主存中一些经常访问的数据存放在高速缓存中，减少访问主存的次数，提高程序的执行速度。 有些计算机系统设置了两级高速缓存，即，一级高速缓存与二级高速缓存。cpu访问一级高速缓存最快。（i9 12900K，三级缓存：30MB）</p>
<p><strong>磁盘缓存</strong></p>
<p>　内存中一块存储区，对应于某固定磁盘，临时存储磁盘数据（如，数据预取）。磁盘的IO速度远低于对主存的访问速度，因此将频繁使用的一部分磁盘数据和信息暂时存放在磁盘缓存中，可减少访问磁盘的次数，磁盘缓存本身并不是一种实际存在的存储介质，它依托于固定磁盘，提供对主存储器空间的扩充，即<strong>利用主存中的存储空间，来暂存从磁盘中读出或写入的信息</strong>，主存可以看做是辅存的高速缓存，因为，辅存中的数据必须复制到主存方能使用，反之，数据也必须先存在主存中，才能输出到辅存。</p>
<blockquote>
<p>速度：寄存器&gt;高速缓存&gt;主存&gt;磁盘缓存<br>容量：寄存器&lt;高速缓存&lt;主存&lt;磁盘缓存<br>价格：寄存器&gt;高速缓存&gt;主存&gt;磁盘缓存</p>
</blockquote>
<h3 id="存储分配的三种方式"><a href="#存储分配的三种方式" class="headerlink" title="存储分配的三种方式"></a>存储分配的三种方式</h3><p>1.<strong>直接指定方式</strong>：程序员在编程序时，或编译程序(汇编程序)对源程序进行编译(汇编)时，使用实际存储地址。</p>
<p>2.<strong>静态分配方式</strong>(Static Allocation) ： 用户在编程时，或由编译程序产生的目的程序，均可从其地址空间的零地址开始；当装配程序对其进行连接装入时才确定它们在主存中的相应位置，从而生成可执行程序。也就是说，存储分配是在装入时实现的。</p>
<p>3.<strong>动态分配方式</strong>(Dynamic Allocation)： 动态分配是一种更加有效的使用主存储器的方法。 这种动态存储分配方式的特点是： </p>
<blockquote>
<p>(1)作业在存储空间中的位置，也是在其装入时确定的；<br>(2)在其执行过程中可根据需要申请附加的存储空间；<br>(3)一个作业已占用的部分存储区域不再需要时，可以要求归还给系统。</p>
</blockquote>
<p>关于名空间，地址空间(逻辑地址集合，虚)，存储空间(物理地址集合，实)的理解:</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_09-18-41.png"></p>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>​	为了使程序能够运行，必须先为之创建进程，而创建进程的第一件事，就是将程序和数据装入内存，如何将一个用户源程序变为一个可在内存中执行的程序，通常要经过如下几步，首先是编译（由编译程序将用户源代码编译成若干个目标模块），其次是链接（由链接程序将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块），最后是装入（由装入程序将装入模块装入内存）。</p>
<h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><p>① <strong>绝对装入方式</strong>，如果在编译时知道程序驻留在内存的什么位置，那么，编译程序将产生绝对地址的目标代码，绝对装入方式按照装入模块中的地址，将程序和数据装入内存，装入模块被装入内存后，由于程序中的<strong>逻辑地址与实际内存地址完全相同</strong>，故不需要对程序和数据的地址进行修改。</p>
<p>② <strong>可重定位装入方式</strong>，绝对装入方式只适用于单道程序环境，在多道程序环境下(编译程序不可能事先知道所编译的目标模块应放在内存的何处)，所得到的目标模块的起始地址通常都是以0开始的，程序中的其他地址也都是相对于起始地址计算的，此时应采用可重定位装入方式，根据内存的当前情况，将装入模块装入到内存的适当位置。该方式会使装入模块中的所有逻辑地址与实际装入内存的物理地址不同，需要对数据地址和指令地址进行修改，通常把再装入时对目标程序中指令和数据的修改过程称为重定位。</p>
<p><em><strong>静态重定位</strong></em>  </p>
<p>地址变换是在装入内存时一次完成的，且以后不能移动。 一般情况下,物理地址&#x3D;相对地址+内存中的起始地址，适用于多道程序环境，可以将装入模块装入到内存中任何允许的位置。</p>
<p><em><strong>动态重定位</strong></em></p>
<p>装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到<font color=red>程序执行时</font>进行。在硬件地址变换机构的支持下，随着对每条指令或数据的访问自动进行地址变换。利用一个重定位寄存器(RR)来实现。</p>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><p>① <strong>静态链接</strong>，在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个</p>
<p>完整的装入模块（又称执行模块），需要对相对地址进行修改（由于编译程序产生的所有目标模块中，使用的都是相对地址，其起始地址都为0，每个模块中的地址都是相对于起始地址计算的）。也需要变换外部调用符号（将每个模块中所用的外部调用符号都变换为相对地址），这种先进行链接所<strong>形成的一个完整的装入模块</strong>，又称为可执行文件，通常都不再拆开它，要运行时可直接将它装入内存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_09-44-17.png"></p>
<p>② <strong>装入时动态链接</strong>，用户源程序经编译后所得是目标模块，是在<strong>装入内存时边装入边链接</strong>的，即在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存，装入时动态链接有如下优点，便于修改和更新（各目标模块是分开的存放的，所以要修改或更新各目标模块非常容易），便于实现对目标模块的共享（很容易将一个目标模块链接到几个应用模块上，实现多个应用程序对该模块的共享）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_09-46-03.png"></p>
<p>采用装入时动态链接方式，虽然可将一个装入模块装入 到内存的任何地方，但装入模块的结构是静态的，表现在： 1. 进程（程序）在整个执行期间，装入模块是不改变的； 2. 每次运行时的装入模块是相同的。并且事先无法知道本次 要运行哪些模块，只能将所有可能要运行的模块在装入时 全部链接在一起，而实际上往往有些目标模块根本不会运 行。</p>
<p>③ <strong>运行时动态链接</strong>，将某些模块的链接推迟到<strong>程序执行时才进行链接</strong>，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存，把它链接到调用者模块上，凡在执行过程中未被调用到的模块，都不会被调入内存和被链接到装入模块上，这样不仅加快程序的装入过程，同时也节省了大量的内存空间。</p>
<p><font color=red>运行时动态链接是目前最常使用的链接方式</font>。</p>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><h3 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h3><p><strong>单一连续分配</strong></p>
<p>　这是一种最简单的存储管理方式，但只能在单用户、单任务的操作系统中，将内存分为系统区和用户区，系统区供OS使用，通常放在内存的低地址，用户区是指除系统区以外的全部内存空间，提供给用户使用。</p>
<p><strong>固定分区分配</strong></p>
<p>　固定分区分配是一种最简单的可运行多道程序的存储管理方式，将内存用户空间划分为若干个固定大小的区域，在每个分区只装入一道作业，这样，便允许多道作业并发执行，当有空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区，当该作业结束时，又可再从后备作业队列中找出另一作业调入该分区。</p>
<p>　对于内存的用户空间的划分，有如下两种方法。</p>
<p>　① 分区大小相等，即所有的内存分区大小相等。缺点是缺乏灵活性，即当程序太小时，会造成内存资源的浪费，程序太大时，一个分区由不足以装入该程序，只是该程序无法运行。</p>
<p>　② 分区大小不等，把内存区划分成含有多个较小的分区、适量中等分配和少量大分区，这样，便可根据程序的大小为之分配适当的分区。</p>
<p>　为了便于内存分配，将分区按大小进行排队，并为之建立一张<strong>分区说明</strong>表，其中各表项包括可用于分配的分区数、每个分区的起始地址、大小、状态（是否已分配），当有一个程序需要装入时，由内存分配程序检索该表，从中找出一个能满足要求的，尚未分配的分区，将之分配给该程序，然后将该表项中的状态设置为已分配，若未找到大小足够的分区，则拒绝为该用户分配内存。</p>
<table>
<thead>
<tr>
<th>分区号</th>
<th>大小</th>
<th>始址</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>12K</td>
<td>20K</td>
<td>已分配</td>
</tr>
<tr>
<td>2</td>
<td>32K</td>
<td>32K</td>
<td>已分配</td>
</tr>
<tr>
<td>3</td>
<td>64K</td>
<td>64K</td>
<td>已分配</td>
</tr>
<tr>
<td>4</td>
<td>128K</td>
<td>128K</td>
<td>未分配</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-02-41.png"></p>
<p>内存中已分配给用户但未被利用的区域称 为 <font color=red>“内零头” （内碎片）</font>。 固定分区分配有内零头产生。</p>
<p><font color=red>外零头</font>(External Fragment )： 没有分配但无法分配的空间 ，太小而无法分配，“分不出去的空间”</p>
<p><strong>动态分区分配</strong></p>
<p>动态分区分配是指根据进程的实际需要，动态地为之分配连续的内存空间。即分区的边界可以移动，分区的大小是可变的。动态分区又有两种不同选择，一种是分区的数目固定大小是可变的，而另一种则允许分区的数目和大小都是可变的。 为了说明它们之间的重要差异，我 们考虑一个具有256K字节存储器的系统。</p>
<p><em>分区数目固定</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-13-50.png"></p>
<p><em>分区数目可变</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-14-02.png"></p>
<p>为实现可变分区分配，常用的数据结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-16-26.png"></p>
<p><strong>可重定位分区分配</strong></p>
<p>​	在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间，若果在系统中只有若干个小的分区，即使他们容量总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。若想装入，则将内存中的所有作业进行移动，使他们全部相邻接，这样，即可把原来分散的多个小分区拼接成一个大分区，这时，就可以把作业装入该区。经过紧凑后的某些用户程序在内存中的位置发生了变化，此时若不对程序和数据的地址加以修改（变换），则程序必将无法执行，为此，<strong>在每次紧凑之后，都必须对移动了的数据和程序进行重定向</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160625173645781-121254084.png"></p>
<p>　在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转化为物理地址的工作，退推迟到程序指令要真正执行时进行。为了使地址变换不影响指令的执行速度，在系统中增设了一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址。在程序执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。该动作是随着对每条指令或数据的访问自动进行的，故称为<strong>动态重定位</strong>，当系统对内存进行了紧凑而使若干程序在内存中移动时，不需要对程序做任何修改，只要用该程序在内存的新起始地址去置换原来的起始地址即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-59-06.png"></p>
<p>　动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，<strong>增加了紧凑功能</strong>，通常，在找不到足够大的空闲分区来满足用户需求时进行紧凑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-59-26.png"></p>
<h3 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h3><ul>
<li><p><strong>最佳适应算法</strong>(Best fit: BF) ：就是为一作业选择分区时总是寻找<em><strong>其大小最接近作业所要求的存储区域</strong></em>。即：把作业放 入这样的分区后剩下的零头最小。 </p>
<p>  优点：如果存储空间中具有正好是所要求大小的存储空白区，则必然被选中；如果不存在这样的空白区，也只对比要求稍大的空白区进行划分，而绝不会去划分一个更大的空白区。因此，其后遇到大作业到来时，作业要求的存储区域就比较容易得到满足。 为了加快查找速度，应将存储空间中所有的空白区按其<strong>大小递增</strong>的顺序链接起来，组成一空白区链(Free List)。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-22-52.png"></p>
<p>  缺点：采用最佳适应算法，在每次分配时，总是产生最小的空白区。因此，经过一段时期后，存储空间中 可能留许多这样的空白区，由于其太小而无法使用。为了改善这种情况，在该算法中设置一参数G，用它来确 定最小分区的大小。当选择一个分区时，如果选中的空白区与要求的大小之差小于G，则不再对它划分，而把整个这个空白区分配给申请的作业。 最佳适应算法的另一缺点是：在回收一个分区时， 为了把它插入到空白区链中合适的位置上也颇为费时。 所以，这种算法乍看起来是最佳的，其实则不然。　</p>
</li>
<li><p><strong>最坏适应算法</strong>(Worst fit: WF)：与最佳适应算法相反，它在为作业选择存储区域时，总是寻找最大的空白区。在划分后剩下的空白区也是最大的，因而对以后的分配很可能仍然是有用的，这是该算法的一个优点。但是，由于最大的空白块总是首先被分配而进行 划分，当有大的作业时，其存储空间的申请往往得不到满足，这是该算法的一个缺点。为了支持这个算法的实现，空白块应以<strong>大小递减</strong>的顺序链接起来。</p>
</li>
<li><p><strong>首次适应算法</strong>(First Fit: FF) ：每个空白区按其在存储空间中<strong>地址递增</strong>的顺序链在一 起，即每个后继空白区的起始地址总是比前者的大。在 为作业分配存储区域时，从这个空白区链的始端开始查找，选择第一个足以满足请求的空白块，而不管它究竟 有多大。 显然，这个算法倾向于优先利用存储空 间中低址部分的空白区。</p>
<p>主要优点：算法简单，查找速度快；留在高址部分的大的空白区被划分的机会较少，因而在大作业到来时也比较容易得到满足。 主要缺点：这种算法常常利用一个大的空白区适应小作业的请求，从而留下一些较小的无法用的空白区，存储空间利用率不高；而且，由于所有的请求都是从空白区链的始端开始查找，因而这些小而无用的空白区集中在这个链的前端，相应地，一些较大空白区在链的尾端才能发现，这种情况将使找到合适空白区的速度降低。<strong>在低地址部分会积累大量外零头</strong>。</p>
</li>
<li><p><strong>下次适应算法</strong>(Next fit: NF) ：该算法实际上是首次适应算法的一种变形，故也被称为带旋转指针的首次适应算法(Next Fit with Roving Pointer)。 为此，我们把存储空间中空白区构成一个循环链。每次为存储请求查找合适的分区时，总是从<em><strong>上次查找结束的地方开始</strong></em>，只要找到一个足够大的空白区，就将它划分后分配出去。显然，采用这一策略后，存储空间的利用更加均衡，而不至于使小的空白区集中于存储器的一端。 但是，在存储器的另一端也不可能保留大的空白块，因此，当需要获得相当大的空白区时，能满足的可能性减少了。</p>
</li>
<li><p><strong>快速适应算法</strong>（Quik fit: QF)：将空闲分区根据其容量大小进行分类，对于每一类具<br>有相同容量的所有空闲分区，单独设立一个空闲分区链表。这样，系统中存在多个空闲分区链表；同时，在内存中设立一张管理分区类型，并记录了该类型空闲分区链表表头的索引表，该表的每一个表项记录了对应类型空闲分区链表表头的指针。<br>➢分配过程：根据进程的长度，寻找到能容纳它的最小空闲分区链表，并取下第一块进行分配即可。</p>
<p>优点：1.查找效率高。2.该算法在进行空闲分区分配时，不会对任何分区产生分<br>割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。<br>➢缺点：1.在分区归还主存时算法复杂，系统开销较大。2.该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或<br>多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重。</p>
</li>
</ul>
<h3 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h3><p><em>分配内存</em></p>
<p>系统利用某种分配算法，从空闲分区链（表）中找到所需大小的分区，其流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-42-15.png"></p>
<p><em>回收内存</em></p>
<p>当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链（表）中找到相应的插入点，此时会出现如下四种情况之一：<strong>回收分区与插入点的前一个空闲区F1相邻接</strong>，此时将回收区与插入点的前一分区合并，不必为回收区分配新表项，只需要修改前一分区F1的大小。<strong>回收分区与插入点的后以空闲分区F2相邻接</strong>，此时将两分区合并，形成新的空闲分区，用回收区的首址作为新空闲区的首址，大小为两者之和。<strong>回收区同时与插入点的前、后两个分区邻接</strong>，此时将三个分区合并，使用F1的表项和F1的首址，取消F2的表项，大小为三者之和。<strong>回收区既不与F1邻接，也不与F2邻接</strong>，这时为回收区单独建立一个新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160625171237203-1234395843.png"></p>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>​	伙伴系统规定，无论已分配分区还是空闲分区，其大小均为2的k次幂，k为整数，1&lt;&#x3D; k &lt;&#x3D; m，其中，2^1表示分配的最小分区的大小，2^m表示分配的最大分区的大小，通常2^m是整个可分配内存的大小。假设系统开始时的初始容量为2^m个字，由于不断切分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了k个空闲分区链表。</p>
<p>　当需要为进程分配一个长度为n的存储空间时，首先计算一个i值，使2^i-1 &lt; n &lt;&#x3D; 2^i，然后，在空闲分区大小为2^i的空闲分区链表中查找，若找到，即把该空闲分区分配给进程，否则，表明2^i的空闲分区已经耗尽，在大小为2^i+1的空闲分区链表中查找，若存在，则将该空闲分区分为两个大小为2^i的分区，一个用于分配，一个加入到大小为2^i的空闲分区链表中，若还是不存在，则继续在大小为2^i+2的空闲分区链表中查找，若存在，则将空闲分区进行两次分割，一次分割为两个大小为2^i+1的空闲分区，一个加入到大小为2^i+1的空闲分区链表中，另外一个继续进行分割，分成两个大小2^i的空闲块，一个用于分配，另外一个加入到大小为2^i的空闲分区链表中，以此类推。在最坏的情况下，可能需要对2^k的空闲分区进行k此分割才能得到所需分区。</p>
<p>　当回收空闲分区时，也需要经过多次合并，如回收大小为2^i的空闲分区时，若事先已经存在2^i的空闲分区，则应将其与伙伴分区合并为一个大小为2^i+1的空闲分区，若事先已存在2^i+1的空闲分区，则再次进行合并，合并为2^i+2的分区，以此类推。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-52-24.png"></p>
<h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><h3 id="页面与页表"><a href="#页面与页表" class="headerlink" title="页面与页表"></a>页面与页表</h3><p>　分页存储管理是将一个<strong>进程的逻辑地址空间分成若干个大小相等的片</strong>，称为页面或页，并为各页进行编号，从0开始。相应地，<strong>把内存空间分成与页面相同大小的若干个存储块</strong>，称为（物理）块或者页框，也同样为它们编号，如0#块，1#块等。在未进程分配内存时，以块为单位将进程的若干个页分别装入到多个可以不相邻接的物理块中，由于进程的最后一页经常装不满一块而形成不可利用的碎片，称之为页内碎片(程序大小一般不是页大小的整数倍)。</p>
<p>　页面大小由机器的地址结构决定。某一机器只能采用一种大小的页面。</p>
<ul>
<li><p>小页面</p>
</li>
<li><p>大页面</p>
</li>
</ul>
<p>​	页面的大小通常在1KB~8KB之间。</p>
<p>　分页地址中的地址结构如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_11-15-18.png"></p>
<p>　在分页存储管理方式中，任何一个逻辑地址都可转变为：页号+页内位移量。前一部分为页号P，后一部分为位移量W（或称为页内地址），总共32位，其中0<del>11位为页内地址，每页大小4KB，12</del>31位为页号，地址空间最多允许1M个页面。</p>
<p>设有一逻辑地址A，页面大小为L，则在分页存储管理方式中，它的地址被转换：<br>页号 P&#x3D;INT[A&#x2F;L]<br>页内位移量 W&#x3D;A MOD L<br>如有逻辑地址为：2170，页面大小为1KB，则<br>P&#x3D;INT[2170&#x2F;1024]&#x3D;2；W&#x3D;2170 MOD 1024&#x3D;122</p>
<p>　为了能够保证在内存中找到每个页面所对应的物理块，系统为每个进程建立了一张页面映射表，简称为页表。页表项纪录了相应页在内存中对应的物理块号，在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号，<strong>页表实现了从页号到物理块号的地址映像</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_11-13-45.png"></p>
<p>　即使在简单的分页系统中，也常在页表的表项中设置一存取控制字段，用于对该存储块中的内存加以保护，当存取控制字段仅有一位时，可用来规定该存储块中的内存时允许读&#x2F;写，还是只读；若存取控制字段为二位，则可规定为读&#x2F;写、只读、只执行等存取方式。</p>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>　地址变换机构的功能将用户的逻辑地址转变为内存中的物理地址。逻辑地址由页号和页内位移量组成。页的大小和内存物理块的大小是相同的，所以页内位移量即为物理块内位移量。<strong>地址变换任务是借助页表来完成的</strong>。</p>
<p>　页表的功能可以由一组专门的寄存器来实现，一个页表项用一个寄存器，由于寄存器具有较高的访问速度，因而有利于提高地址变换的速度，但成本较高，且页表项一般会很多，都使用寄存器实现不太现实，因此，<strong>页表大多驻留在内存</strong>。在系统中只设置一个<strong>页表寄存器PTR(Page-Table Register)，用于存放页表在内存的始址和页表的长度</strong>，平时，页表的始址和页表长度存放在本进程的PCB中，当调度程序调度到某进程时，将这两个数据装入页表寄存器，因此，在单处理机环境下，虽然系统中可以运行多个进程，但只需要一个页表寄存器。</p>
<p>　当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址（相对地址）分为页号和页内偏移量两部分，从PTR中得到页表首址，再以页号为索引去检索页表，查找操作由硬件执行，在执行检索前，先将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址超越了进程的地址空间，这一错误将被系统发现并产生一个地址越界中断。若未出现错误，则将页表始址加上<em><strong>页号与页面大小乘积</strong></em>，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将之装入物理地址寄存器，与此同时，再将页内地址送入物理地址寄存器的块内地址字段中，这样，便完成了逻辑地址到物理地址的转换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160625211026453-286611371.png"></p>
<p>　上述操作中，每次存取一个数据时，都会<strong>访问内存两次</strong>，第一次是访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，以形成物理地址，第二次访问时，才是从第一次所得的地址中获得所需数据，因此，这种方式会使计算机的处理速度降低一半，为了提高地址变换速度，可以在地址变换机构中增设一个具有并行查询能力的<strong>高速缓冲寄存器</strong>，又称为<strong>联想寄存器或快表</strong>（TLB），专门保存当前进程最近访问过的一组页表项。</p>
<p>　此时的变换过程如下，在CPU给出有效地址后（逻辑地址），由地址变换机构自动的将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与之相匹配的页号（<strong>命中</strong>），便表示所要访问的页表项在快表中，于是，可以直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中，如在快表中没有找到（<strong>命中失败</strong>），则还需要再访问内存中的页表，找到后，把从页表项读出的物理块好送入地址寄存器，同时，再将此页表项存入快表的寄一个寄存器单元，即修改快表，如果快表已满，则OS需要找到一个老的且已被认为不再需要的页表项，将它换出。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160625212714688-1055550023.png">　</p>
<p><em>例1：某采用分页存储管理的系统中，物理地址占20位，逻辑地址中页号占6位，页面大小为1KB，问：</em><br>⑴该系统的内存空间大小为多少？每个存储块的大小为多少？逻辑地址共几位？每个作业的最大长度为多少？<br>⑵若第0、1、2页分别放在第3、7、9存储块中，则逻辑地址0420H对应的物理地址是多少？<br>在分页存储管理系统中，根据题意：<br>⑴物理地址占20位，所以该系统的内存空间大小<br>为：1MB<br>存储块的大小与页面大小相同，而页面大小为1KB，因此存储块的大小为：1KB<br>由于页面大小为1KB，占10位，而页号占6位，因此逻辑地址共16位，<br>从 而 该 系 统 中 每 个 作 业 的 最 大 长 度 为 ：64KB<br>⑵法1（全部转换成10进制）：<br>逻辑地址：0420H&#x3D;1056<br>因为1K&lt;&#x3D;1056&lt;2K-1，所以在1号页面内，其页内位移量为：1056-1K&#x3D;32； 而1号页面对应7号物理块，所以物理地址为：7×1K+32&#x3D;7200。<br>法2（将页面转换成16进制表示）：<br>页面大小：1K&#x3D;0400H 。因为0400H&lt;&#x3D;0420H&lt;07FFH，所以在1号页面内，其页内位移量为：0420H-0400H&#x3D;20H；而1号 页 面 对 应 7 号 物 理 块 ， 所 以 物 理 地 址 为 ：<br>7×0400H +20H&#x3D;1C20H。</p>
<p><em><strong>访问内存的有效时间 EAT</strong></em><br>定义：从进程发出指定逻辑地址的访问请求，经过地址变换，再到内存中找到对应的物理单元并取出数据，所花费的总时间。<br>➢如检索快表时间为20 ns，访问内存为100 ns。</p>
<ul>
<li>若能在快表中检索到CPU给出的页号，则CPU存取一<br>个数据共需120 ns。</li>
<li>否则，需要220 ns的时间。</li>
</ul>
<p><strong>有效访问时间</strong> &#x3D; HitR×(TLB+MA) + (1-HitR)×(TLB+2MA)，HitR为命中率。</p>
<p>例：设访问主存时间为200ns,访问联想存储器为40ns，命中率为90％，则平均存取时间为多少？<br>查页表两次访存：200＋200＝400ns<br>查快表，平均为：40+200&#x3D;240ns<br>(200+40)×90％＋(200+200+40)×10％&#x3D;260ns</p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>　现代计算机系统中，可以支持非常大的逻辑地址空间（2^32~2^64），这样，页表就变得非常大，要占用非常大的内存空间，如，具有32位逻辑地址空间的分页系统，规定页面大小为4KB，则在每个进程页表中的页表项可达1M(2^20)个，又因为每个页表项占用一个字节，故每个进程仅仅页表就要占用1MB的内存空间，而且要求连续，这显然是不现实的，可以通过如下两个方法解决该问题。</p>
<p>　　① 采用离散分配方式来解决难以找到一块连续的大内存空间的问题。</p>
<p>　　② 只将当前需要的部分页表项调入内存，其余页表项仍驻留在磁盘上，需要时再调入。</p>
<p>　　对于要求连续的内存空间来存放页表的问题，可利用将页表进行分页，并离散地将各个页面分别存放在不同的物理块中的办法来解决，同样的，也要为离散分配在页表再建立一张页表，称为外层页表。在每个页表项中记录了页表页面的物理块号，以32位逻辑地址空间为例进行说明。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_12-58-51.png"></p>
<p>　　层页号P1为10位，可以表示1024个物理块号，外层页表中的外层也内地址P2为10位，可以表示1024个物理块号，页内地址为12位，表示页面大小为4K。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160625203109875-1471651688.png"></p>
<p>　　在页表的每一个表项中存放的是进程的某页在内存中的<strong>物理块号</strong>，如第0页的0页存放1#物理块，第1页存放4#物理块，而在外层页表的每个页表项中，所存放的是某页表分页的<strong>首址</strong>，如第0页页表存放在1011#物理块中，第1页页表存放在1078#物理块中。</p>
<p>　　为了实现地址变换，在地址变换机构中需要增设一个外层页表寄存器，用于存放外层页表的始址，并利用逻辑地址中的外层页号，作为外层页表的索引，从中找到指定页表分页的始址，在利用P2作为指定页表分页的索引，找到指定的页表项，其中即含有该页在内存的物理块号，用该块号和页内地址d即可构成访问的内存物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_12-59-13.png"></p>
<p>　利用离散分配方法实现的两级页表只是解决了大页表无需大片连续存储空间问题，但并未减少用较少内存去存放大页表问题，有关此类问题的成功解决方案放在虚拟存储器<br>管理中。</p>
<p>　对于64位的机器而言，采用两级页表已经不太合适，如果页面大小仍采用4KB，那么剩下52位，若还是按照物理块的大小（2^12位）来划分页表，每个页表项4B，故一页中可存放2^10个页表项，则将余下的42位用于外层页号，此时，外层页表中可能有4096G个页表项，要占用16384GB的连续内存空间，显然是不行的。使用1MB的页面，剩44位。若按1MB来划分页表，还剩26位用于二级页表，二级页表有64M个页表项，占<br>256MB空间必须采用多级页表，即将外层页表再进行分页。若计算机的虚拟地址空间大小为2^64，页面大小为4KB，页表项为4B，则最少页表的级数为6级，首先总的页面个数为2^52（64 - 12），其次，每个物理块能装入的页表项为4KB&#x2F;4B &#x3D; 2^10个，10 * 6 &gt; 52，即最少需要6级。</p>
<p><em><strong>反置页表Inverted Page Table（IPT）</strong></em></p>
<p>逻辑空间越来越大，页表占内存也越来越大，为了解决大页表问题占内存多现象，减少内存开销，避免一个进程一个页表。<strong>IPT思想：</strong>（1）IPT是为主存中的每一个物理块建立一个页表项并按照块号排序；（2）该表每个表项包含正在访问该物理块的进程标识、页号及特征位,用来完成主存物理块到访问进程的页号的转换。</p>
<blockquote>
<p>常采用部分装入，所以必须为每个进程建立一个外部页表。当该页不在主存时，需要访问外部页表。<br>反置页表只索引正在运行的进程页面<br>因为IPT都大，所以利用进程标识符和页号去检索是相当费时的。采用Hash表来检索。</p>
</blockquote>
<p>反置页表地址转换过程如下:<br>给出进程标识和页号,用它们去比较IPT,若整个反置页表中未能找到匹配的页表项,说明该页不在主存,产生请求调页中断,请求操作系统调入;否则，该表项的序号便是物理块号,块号加上位移,便形成物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_13-38-32.png"></p>
<p><em><strong>对换</strong></em></p>
<p>　对换指把内存中暂不能运行的进程或暂时不用和程序和数据，换到外存上，以腾出足够的内存空间，把已具备运行条件的进程，或进程所需要的程序和数据，换入内存。对换是系统行为，是提高内存的利用率的有效措施。常用于多道程序系统或小型分时系统中，与分区存储管理配合使用。实现：可在系统中设一对换进程，以执行换进内存、换出至外存操作。</p>
<p>分类：</p>
<ul>
<li>“整体对换”（进程对换）：<br>对换以整个进程为单位，用于分时系统，以解决内存紧张的问题；</li>
<li>“页面对换&#x2F;分段对换”：<br>对换以“页”或“段”为单位进行“部分对换”，该方法是实现请求分页及请求分段存储器的基础，支持虚存系统。</li>
</ul>
<p>为实现对换，系统需要三方面的功能：　</p>
<ol>
<li><p><strong>对换空间的管理</strong>，在具有对换功能的OS中，通常把<strong>外存分为文件区和对换区</strong>，前者用于存放文件，后者用于存放从内存换出的进程。由于文件通常是较长久的驻留在外存上，文件区的管理主要目标是<em>提高存储空间的利用率</em>，采取离散分配方式(用指针相连)，进程通常在对换区中驻留的时间较短暂，对换操作较频繁，故对对换空间管理的主要目标是<em>提高进程换入和换出的速度</em>，采取的是连续分配的方式，较少考虑外存中的碎片问题。为了能对对换区中的空闲盘块进行管理，在系统中应配置相应的数据结构，以记录外存的使用情况。空闲分区表或空闲分区链。在空闲分区表中的每个表目应包含两项，即对换分区首址和对换区长度，它们的基本单位都是<strong>盘块</strong>。</p>
</li>
<li><p><strong>进程的换出</strong>，选择：首先选择<strong>阻塞</strong>或<strong>睡眠状态</strong>的进程，若有多个，按优先级<strong>由低到高</strong>进行选择。若没有此状态进程，则选择<strong>就绪</strong>状态的，仍然按优先级由低到高进行选择。为避免某进程被频繁的换入换出，还应考虑进程在内存中的驻留时间，优先选择<strong>驻留时间长</strong>的进程。</p>
</li>
<li><p><strong>进程的换入</strong>，①从 PCB集合中查找“就绪且换出”的进程，有多个，则选择换出时间最长的。②根据进程大小申请内存，成功则读入，否则要先执行换出，再换入。③若还有可换入进程，则转向①。直至无“就绪且换出”进程或无法获得足够内存空间为止。</p>
</li>
</ol>
<h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><p>从固定分区到动态分区分配，再到分页存储管理方式，其主要动力为提高内存利用率，引入分段存储管理的目的在于满足用户在编程和使用上多方面的要求。如</p>
<p>　① 方便编程，用户可以把自己的作业按照逻辑关系划分为若干段，每个段都是从0开始编址，并有自己的名字和长度。</p>
<p>　② 分段共享，在实现对程序和数据的共享时，是以信息的逻辑单位为基础的，比如共享某个函数。</p>
<p>　③ 分段保护，对内存中信息的保护同样是对信息的逻辑单位进行保护。</p>
<p>　④ 动态增长，在实际应用中，数据段在使用过程中往往会不断增长，而实现无法确切知道数据段会增长到多大，分段可以较好的解决这个问题。</p>
<p>　⑤ 动态链接，再运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中有需要调用某段时，才将该段调入内存并进行链接。</p>
<h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3><p>　在分段管理中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，如有主程序段MAIN，子程序段X，数据段D及栈段S，每个段都有自己的名字，每个段从0开始编址，并采用一段连续的地址空间，段的长度由相应的逻辑信息组的长度决定，因而各段长度不等，整个作业的地址空间由于是分成多个段，因而是二维的，即其<strong>逻辑地址由段号和段内地址构成</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_13-53-24.png"></p>
<p>​	该系统可允许一个作业允许最长有64K个段，每个段的最大长度为64KB。</p>
<p>　在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区，为了使程序正常运行，能够物理内存中找出每个逻辑段所对应的位置，应该为每个进程建立一张段映射表，称为<strong>段表</strong>，每个段在表中有一个表项，其中记录了该段在内存中的起始地址和段的长度。段表可以存放在一组寄存器中，这样有利于提高地址转换速度，但通常将段表放在内存中。<strong>段表用于实现从逻辑段到物理内存区的映射</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160626090308469-1366473959.png"></p>
<p>　为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，<strong>用于存放段表始址和段表长度TL</strong>，在进行地址变换时，系统将逻辑地址中的段号与段表长度TL进行比较，若S&gt;TL，表示段号太大，访问越界，产生越界中断信号，若未越界，则根据段表的始址和该段的段号，计算该段对应段表项的位置，从中读出该段在内存中的起始地址，然后，再检查段内地址d是否超过该段的段长SL，若超过，同样发出越界中断信号，若未超过，则将该段的基址与段内地址d相加，即得到要访问的内存物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160626092459344-1686459587.png"></p>
<p>　每次访问一个数据时（需给出段号和段内地址），也需要访问两次内存，第一次根据段号获得基址，第二次根据基址与段内地址之和访问真实数据的物理地址。这降低了计算机的速率，也可以增设一个联想存储器，用来保存最近常用的段表项，用来加速存取数据的时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_14-06-30.png"></p>
<h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><p>一个多用户系统可接纳40个用户，它们都执行一个文本编辑程序(ED)，ED代码共160K，每个用户还有40K的数据区(DA)。<br>不采用信息共享时需占用的内存空间？<br>( 160K + 40K ) * 40 &#x3D; 8000K<br>采用信息共享（若ED可共享）后占用的内存空间？<br>160K + 40K * 40 &#x3D; 1760K　</p>
<p>分页与分段存在很大的相似性，如都采用离散分配方式，都需要通过地址映射机构实现地址变换，但两者的主要<strong>区别</strong>如下。</p>
<p><em>分页共享</em></p>
<ul>
<li>对于数据页面，实现起来比较简单。因为这个数据页面可以安排在诸作业地址空间中的任何一页面上。</li>
<li>对于代码页面，它必须把共享的代码安排到所有共享它的作业地址空间中相同页号的页面中。即共享代码所在的地址空间必须重叠。之所以有这种要求，是因为一个作业在运行前必须链接好，而链接后，一个例程的所占页号就确定了。如果其它作业要共享该例程，则必须使它具有相同的页号，才能正确运行。</li>
</ul>
<p><em>分段共享</em>　</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_14-23-02.png"></p>
<p>分段的共享是通过两个作业段表的相应表目都指向COS过程的同一物理副本来实现的。<br>说明：<br>⑴由于段号是在动态链接过程中分配的，而且，系统不可能事先知道某个过程将为哪些作业所调用；因此，一个公共过程不一定也无需赋相同的段号。<br>例如，[COS]在作业1的地址空间中，其段号为6，但在作业2的地址空间中其段号为3。<br>⑵当某个共享段移出主存后，必须在共享该段的每个作业之段表的相应表目中，置状态为“不在主存”标志。</p>
<p><strong>分页和分段的主要区别</strong></p>
<p>① 页是信息的物理单位，分页是为实现离散分配方式，以<strong>消减内存的外零头，提高内存的利用率</strong>，或者说，分页仅仅是由于系统管理的需要而不是用户的需要，段则是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。</p>
<p>② 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，一个系统中，只存在一种大小的页面，段的长度则不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p>
<p>③ 分页的作业的地址空间是一维的，即单一的线性的地址空间，程序员只利用一个记忆符即可表示一个地址，而分段的作业地址空间是二维的，程序员在标识一个地址是，需要给出段名和段内地址。</p>
<h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><p>　分页系统能够有效的提高内存利用率（但是会存在页内碎片），分段系统则能够很好地满足用户需要。若能将两种方式结合起来，既具有分段系统的便于实现、分段可共享、易于保护、可动态链接等优点，又能像分页系统那样很好地解决内存的外部碎片问题，基于此，提出了段页式系统。</p>
<p>　段页式系统先将用户程序分成若干个段，再把段分为若干个页，并为每一个段赋予一个段名。段页式系统中，地址结构由段号、段内页号、页内地址三部分构成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_14-24-02.png"></p>
<p>　在段页式系统中，为了便于实现地址转换，须配置一个段表寄存器，其中存放段表始址和段表长TL，进行地址变换时，首先利用段号S，将它与段表长TL进行比较，若S&lt;TL，表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用b和页内地址构成物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160626100219578-1875843366.png"></p>
<p>　在段页式系统中，为了获得一条指令或数据，需要<strong>访问内存三次</strong>，第一次访问时访问内存中的段表，从中取得页表始址，第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址，第三次访问才是真正的从第二次访问所得的地址中，取出指令或数据。同样，也可以增设高速缓冲寄存器用于加快访问速度，表项应包括段号、页号、物理块号。</p>
<p>分页管理提供( A)维的地址结构，分段管理提供(B )维的地址结构，段页式管理提供(C )维的地址结构。</p>
<p>A. 1 B. 2 C. 3 D. 4</p>
<p>段页式管理每取一次数据，要访问(C )次内存;若改为分页式管理或者分段式管理，要访问( B)次内存。</p>
<p>A. 1 B. 2 C. 3 D. 4</p>
<p>页管理的主要任务之一是实现（逻辑页号 ）到（ 物理块号） 的内存地址映像。</p>
<p>在分段管理中，系统为每个运行的作业建立一个(段表)，其内容主要包括(段号)、(段长)、(内存起始地址)和状态标志。段表是一种数据结构，用于存储程序的逻辑段与物理内存之间的映射关系。当程序访问内存时，操作系统会使用段表来查找逻辑地址对应的物理地址，然后将数据从物理内存中读取或写入  。</p>
<p>在分段管理的地址变换过程中，若执行某条指令，首先要找到该作业段表的(始址)，然后根据逻辑地址中的段号去查找(段表项)，得到该段的内存中的(物理始址)，其值与段内位移量(相加)，得到(操作的实际地址)。</p>
<h2 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h2><h3 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h3><p>前面所介绍的存储器管理方式都有共同的特点：<br>“一次性”: 要求将一个作业全部装入内存才能运行，</p>
<ul>
<li><p>大作业无法运行。</p>
</li>
<li><p>限制作业并发执行的程度。</p>
</li>
</ul>
<p>“驻留性”: 作业装入后一直驻留内存直到作业完成。</p>
<ul>
<li>内存中存在一些已无用的、或暂时不用的程序或数据，浪费内存空间。</li>
</ul>
<p>出现了下面两种情况：</p>
<p>　① 有的作业很大，其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行。</p>
<p>　② 有大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让他们先运行，而将其他大量作业留在外存上等待。</p>
<p>　为了解决上述问题，可以增加物理内存，但是其不太现实，另外是从逻辑上扩充内存容量。</p>
<p>　基于程序的局部性原理（时间局限性和空闲局限性），程序在运行之前，没有必要全部装入内存，仅需将那些当前要运行的少数页面或段先装入内存便可运行。其余部分暂留在磁盘上，程序运行时，如果它所要访问的页（段）已经调入内存，便可继续执行下去，但如果程序所要访问的页（段）尚未调入内存（缺页或缺段），此时程序应利用OS的请求调页（段）功能，将它们调入内存，以使进程继续执行下去。如果此时内存已满，无法再装入新的页（段），则还需利用页（段）的置换功能，将内存中暂时不用的页（段）调至磁盘上，再将要访问的页（段）调入内存，使程序继续执行。这样，可以使很大的用户程序在较小的内存空间中运行。从用户的调入看，该系统具有很大的内存容量，但是，用户看到的大容量只是一种感觉，这种存储器被称为<strong>虚拟存储器</strong>。所谓虚拟存储器，是指具有<strong>请求调入功能和置换功能</strong>，能从逻辑上对内存容量加以扩充的一种存储器系统，其逻辑容量由<strong>内存容量和外存容量之和</strong>决定，<strong>其运行速度接近内存，成本接近外存</strong>。</p>
<p>虚拟存储器虽然给用户提供了特大地址空间，但其容量不<br>是无限大，主要受两个方面的限制：</p>
<ul>
<li>指令中表示地址的字长<br>如：若CPU的有效地址长度为32位，则可以表示的地址最大空间为2^32，逻辑空间大小为4G，即虚存容量为 4GB。<em>与物理空间的大小无直接关系</em>。</li>
<li>外存的容量（对换区）</li>
</ul>
<h3 id="虚拟存储器的实现方法"><a href="#虚拟存储器的实现方法" class="headerlink" title="虚拟存储器的实现方法"></a>虚拟存储器的实现方法</h3><p>一、请求分页系统<br>它是在纯分页系统的基础上增加了请求调页、页面置换两大功能所形成的页式虚拟存储系统。为了实现请求调页、页面置换两大功能，系统必须提供如下的硬件支持：</p>
<ol>
<li>请求分页的页表机制。</li>
<li>缺页中断机构。</li>
<li>地址变换机构。<br> 此外，实现请求调页、页面置换两大功能还需得到<br> OS的支持。</li>
</ol>
<p>二、请求分段系统<br>它是在纯分段系统的基础上增加了请求调段、分段置换两大功能所形成的段式虚拟存储系统。为了实现请求调段、分段置换两大功能，系统必须提供如下的硬件支持：</p>
<ol>
<li>请求分段的段表机制。</li>
<li>缺段中断机构。</li>
<li>地址变换机构。<br> 此外，实现请求调段、分段置换两大功能还需<br> 得到OS的支持。</li>
</ol>
<p>三、段页式虚拟系统<br>目前，许多虚拟存储管理系统是建立在段页式系统的基础上的，通过增加了请求调页、<br>页面置换两大功能所形成的段页式虚拟存储系统。<br>如：Intel 80386处理机便支持段页式虚拟存储系统。</p>
<h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><p>1．多次性<br>多次性是指一个作业被分成多次调入内存运行。<br>2．对换性<br>对换性是指作业的运行过程中进行换进、换出。换进和换出能有效地提高内存利用率。<br>3．虚拟性<br>虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</p>
<p>虚拟性是以多次性和对换性为基础的；而多次性和对换性又必须建立在离散分配的基础上。</p>
<p>虚存实现的理论依据是什么？程序执行的局部性原理</p>
<p>如何将程序划分成部分？分页或分段</p>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><p>请求分页是建立在分页基础上的，增加了请求调页功能和页面置换功能。</p>
<h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3><p>　① <strong>页表机制</strong>，在虚拟存储系统中的所有的页表，其页描述子有了新的扩充，这是进行地址变换机构所必须的，增加四个信息标识位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_14-50-00.png"></p>
<blockquote>
<p>(1)状态位(存在位)D：用于说明该页是否已调入内存，供程序访问时参考；D&#x3D;0，该页不在内存。D&#x3D;1，该页在内存。<br>(2)访问位A：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考。A&#x3D;0，该页未被访问 。A&#x3D;1，该页被访问<br>(3)修改位M：用于表示该页在调入内存后是否被修改过，也是提供给置换算法在换出页面时是否将该页面写回外存作参考。M&#x3D;0，该页在内存中未被修改。M&#x3D;1，该页在内存中已经被修改<br>(4)外存地址：用于指出该页在外存上的地址，供调入该页时使用。</p>
</blockquote>
<p>　② <strong>缺页中断机构</strong>，当要访问的页面不在内存时，产生一个缺页中断，请求OS将缺的页面调入内存，缺页作为中断，也需要经过保护CPU现场、分析中断原因、转入中断处理程序进行处理、恢复CPU环境等。但是，其与一般中断相比有一些不同，主要在于：在指令执行期间产生和处理中断信号（通常CPU都是在一条指令执行完后，才检查是否有中断请求到达，若有，则响应，否则，继续执行下一条指令，然而，缺页中断是在指令执行期间，发现所要访问的指令或数据不再内存时所产生和处理的），一条指令在执行期间，可能产生多次缺页中断。</p>
<p>　③ <strong>地址变换机构</strong>，在分页系统地址变换基础上，再为实现虚拟存储器而增加的某些功能而形成。如产生和处理缺页中断，以及从内存中换出一页功能等。</p>
<p><strong>缺页中断处理过程</strong></p>
<p>（1）操作系统接收到进程产生的缺页中断信号，启动中断处理例程，保留处理机现场；<br>（2）操作系统通知处理机从外存读取指定的页面；<br>（3）处理机激活I&#x2F;O设备；<br>（4） 检查内存有无足够的空闲空间装入该页面？若有，转（6），否则，执行（5）；<br>（5） 利用页面置换算法，选择内存中的某个页面，换出内存；<br>（6） 将指定页面从外存装入内存；<br>（7） 更新该进程的页表；<br>（8） 更新快表；<br>（9）计算物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_14-53-05.png"></p>
<h3 id="内存分配策略和分配算法"><a href="#内存分配策略和分配算法" class="headerlink" title="内存分配策略和分配算法"></a>内存分配策略和分配算法</h3><p><strong>最小物理块数</strong>：是指能保证进程正常运行所需的最少物理块数。若系统为某进程所分配的物理块数少于此值时，进程将无法运行。</p>
<p>对于某些简单的机器，若是单地址指令且采用直接寻址方式，则所需的最少物理块数为2。(在直接寻址方式中，指令中给出的是操作数的地址。因此，需要至少两个物理块，一个用于存储指令，另一个用于存储操作数。)<br>如果该机器允许间接寻址时，则至少要求有物理块数为3。(这是因为在间接寻址方式中，指令中给出的是操作数地址的地址。因此，需要至少三个物理块，一个用于存储指令，一个用于存储操作数地址的地址，另一个用于存储操作数)</p>
<h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><p>在请求分页系统中，可采取两种内存分配策略，固定和可变分配策略，在进行置换时，也可采用全局置换和局部置换，可组合出如下三种适用的策略。</p>
<p><strong>固定分配局部置换</strong>（为每个进程分配一定数目的物理块，整个运行期不再改变，如果进程在运行中发现缺页，则只能从该进程在内存的n个页面中选出一页换出，然后再调入一页，以保证分配给该进程的内存空间不变，若开始为进程分配的物理块数太少，则会频繁缺页，降低系统吞吐量，若太多，则使内存中驻留的进程数目减少，进而造成CPU空闲或其他资源空闲的情况）</p>
<p><strong>可变分配全局置换</strong>（先为系统中的每个进程分配一定数目的物理块，而OS自身也保持一个<strong>空闲物理块队列</strong>，当某进程发现缺页时，由系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的缺页装入其中，仅当空闲物理队列的物理块用完时，OS才能从内存中选择一页调出，该页可能是系统中任一进程的页，这样，会使那个进程的物理块减少，进而使缺页率增加）</p>
<p><strong>可变分配局部置换</strong>（为每个进程分配一定数目的物理块，当进程缺页时，只允许从该进程在内存中的页面中选出一页换出，这样不会影响其他进程的运行，<em>如果该进程频繁发生缺页，则系统需要再为该进程分配若干附加的物理块，直至该进程的缺页率减少到适当程度为止</em>，反之，若一个进程正在运行过程中的缺页率特别低，则此时可适当减少分配给该进程的物理块数，但不应该引起缺页率明显增加）。</p>
<h4 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h4><p>可采用<strong>平均分配算法</strong>（将系统中所有可供分配的物理块平均分配给各个进程）、<strong>按比例分配</strong>（根据进程的大小按比例分配物理块）、<strong>考虑优先权的分配算法</strong>（将重要的，紧迫的作业分配较多的内存空间，可将系统的物理块分成两部分，一部分按比例分配给各进程，另一部分则根据进程的优先权适当地增加相应份额后，分配给进程。在有的系统中，如重要的实时控制系统，则可能是完全按优先权来为各进程分配物理块。）</p>
<h3 id="调页策略"><a href="#调页策略" class="headerlink" title="调页策略"></a>调页策略</h3><p><em>系统应当在何时把一个页面装入内存？</em></p>
<ul>
<li><p>预调页 (Prepaging)</p>
<p>可采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面，预先调入内存。<br>处理过程：<br>当进程创建时，预先为进程装入多个页面。缺页中断时，系统为进程装入指定的页面以及与之相临的多个页面。<br>若局部性很差，预先装入的很多页面不会很快被引用，并会占用大量的内存空间，反而降低系统的效率。预调页的成功率仅约50％。</p>
</li>
<li><p>请求调页 (Demand Paging)</p>
<p>仅当进程执行过程中，通过检查页表发现相应<br>页面不在内存时，才装入该页面。当进程刚开始执行时，由于预先未装入进程的<br>页面，故需要频繁地申请装入页面。执行一段时<br>间以后，进程的缺页率将下降。采用请求调页方式，一次装入请求的一个页面，<br>磁盘I&#x2F;O的启动频率较高，系统的开销较大。</p>
</li>
</ul>
<p><em>何处调入页面？</em></p>
<p>（1）对换区：系统拥有足够的对换区空间，这时可以全部从对换区调入所需页面，以提高调页的速度。<br>（2）文件区、对换区：系统缺少足够的对换区空间，这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出，以后再调入时，仍从<strong>文件区</strong>直接调入。 但对于那些可能被修改的部分，在将它们换出时，便须调到<strong>对换区</strong>，以后需要时，再从对换区调入。<br>（3）UNIX方式。由于与进程有关的文件都放在文件区，应从文件区调入。故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。</p>
<p><em>页面调入过程？</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-22-39.png"></p>
<p><em>缺页率</em></p>
<p>假设：逻辑空间为n页，内存物理块数为m(m&lt;&#x3D;n)，在运行期间访问页面成功S次，失败F次，总访问次数为A&#x3D;S+F次，则缺页率为：f&#x3D;F&#x2F;A</p>
<p>缺页率的影响因素：</p>
<blockquote>
<p>页面大小<br>进程所分配物理块的数目<br>页面置换算法<br>程序的固有特性</p>
</blockquote>
<p>请求分页管理过程中，作业地址空间同样受到内存容量大小的限制。错误</p>
<p>系统是通过 ()、()和()来实现动态分页管理的，分别用以解决何时把作业需要的信息按()从外存调入内存；内存中无空闲页框，如何将已占据的页框释放；完成虚拟地址变换为对应的物理地址。(调入策略，替换策略，地址变换，一定规则；)</p>
<p>内存扩充的概念有两种，一种是在物理上进行扩充，为系统增配更多的存储芯片，以扩大 ()；另一种是利用目前机器中实际内存空间，借助软件技术，实现内存扩充，称为()，主要技术有()和()两种。(物理空间，虚拟内存，请求分页管理，请求分段管理；)</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法-Optimal"><a href="#最佳置换算法-Optimal" class="headerlink" title="最佳置换算法(Optimal)"></a>最佳置换算法(Optimal)</h4><p>最理想的页面置换策略是：<em><strong>从主存中移出永远不再需要的页面；如无这样的页面存在，则应选择最长时间不需要访问的页面</strong></em>。 最佳置换算法是一种理想化的算法，它具有最好的性能，但实际上却难于实现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-27-38.png"></p>
<h4 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a>先进先出置换算法(FIFO)</h4><p>该算法的实质是：总是选择作业中驻留时间最长(即最老)的一页淘汰。即：先进入主存的页面先退出主存。算法实现比较容易，如分配给一个作业的存储块数为m，只需建立一个m个元素的队列表Q(0)、Q(1)、…、Q(m-1)和一个替换指针。该队列是按页面调入主存的先后顺序排列的，而<strong>指针始终指向最早调入主存的一页</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-29-09.png"></p>
<p>1、该算法的出发点是最早调入内存的页面不再被访问的可能性会大一些。<br>2、该算法实现比较简单，对具有线性顺序访问的程序比较合适，而对其他情况效率不高。因为经常被访问的页面，往往在内存中停留最久，结果这些常用的页面却因变老而被淘汰。</p>
<p>先进先出算法存在一种异常现象，即在某些情况下会出现分配给的进程物理块数增多，缺页次数有时增加，有时减少的奇怪现象，这种现象称为<strong>Belady</strong>现象。例如：</p>
<table>
<thead>
<tr>
<th>物理块数</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>缺页次数</td>
<td>9</td>
<td>10</td>
<td>5</td>
</tr>
</tbody></table>
<h4 id="最近最久未使用-LRU-置换算法"><a href="#最近最久未使用-LRU-置换算法" class="headerlink" title="最近最久未使用(LRU)置换算法"></a>最近最久未使用(LRU)置换算法</h4><p>这种算法的基本思想是，利用局部性原理，根据一个作业在执行过程中过去的页面访问踪迹来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。<br>算法的实质是：当需要置换一页面时，选择在最近一段时间内最久不用的页面予以淘汰。<br>实现这种技术，是通过周期性地对“页面访问”位进行检查，并利用它来记录一个页面自上次访问以来所经历的时间 t ，并选择 t 为最大的页予以淘汰。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-38-21.png"></p>
<p>一般来说，对于任何一个页的访问顺序(或序列)和任何一种换页算法，如果分给的物理块数增加，则缺页(所访问页不在主存)的频率应该减少。但这个结论并不普遍成立，对于某些页面访问序列，FIFO有随着分给的页架数增加，缺页频率也增加的异常现象。</p>
<p><strong>LRU算法</strong>需要以下两类硬件的支持：<br>1.寄存器。用于记录某进程在内存中各页使用情况。<br>2.栈。用于保存当前进程使用的各个页面的页面号。</p>
<p>（1）移位寄存器：<br>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器可表示为：<br>R&#x3D;Rn-1Rn-2Rn-3···R2R1RO</p>
<ul>
<li>当进程访问某物理块时，要将相应寄存器的最高位Rn-1位置<br>成1。系统每隔一定时间（例如100 ms）将寄存器右移一位。</li>
<li>如果我们把n位寄存器的数看作是一个整数，那么，具有最<br>小数值的寄存器所对应的页面，就是最近最久未使用的页面。</li>
</ul>
<p>例：某进程在内存中具有8个页面<br>R&#x3D; R7 R6 R5 R4 R3 R2 R1 R0，每100ms将寄存器右移一位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-41-09.png"></p>
<p>(2) 栈。每当进程访问时某页面时，便将该页面号从<strong>栈中移出，压入栈顶</strong>。这样栈底则是最近最久未使用页面的页面号。 例如:假定一进程访问某页面的时页面号如下(5个存储块）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-41-21.png"></p>
<h4 id="最少使用置换算法LFU"><a href="#最少使用置换算法LFU" class="headerlink" title="最少使用置换算法LFU"></a>最少使用置换算法LFU</h4><p>最少使用置换算法LFU（Least Frequently Used)选择到当前时间为止被访问次数最少的页面被置换。<br>1、基本方法：<br>记录每个页面的访问次数，最少访问的页面首先考虑淘汰<br>2、实际采取方法<br>为页面设置移位寄存器。<br>与LRU的区别：R1&#x3D;10000000，R2&#x3D;01110100<br>LRU———-淘汰R2<br>LFU———-淘汰R1</p>
<h4 id="简单的Clock置换算法（NRU）"><a href="#简单的Clock置换算法（NRU）" class="headerlink" title="简单的Clock置换算法（NRU）"></a>简单的Clock置换算法（NRU）</h4><p>当采用简单clock算法时，为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。<br>➢当某页被访问时，其访问位被置1。<br>➢置换程序从<strong>上次停止位置</strong>开始检查页面的访问位。<br>➢如果是0，就选择该页换出；<br>➢若为1，则重新将它置0，暂不换出，而给该页第二次驻留内存的机会。<br>➢由于该算法是循环地检查各页面的使用情况，故称为clock算法。置换时是将未使用过的页面换出去，故又把该算法称为最近未用算法NRU。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-42-14.png"></p>
<h4 id="改进型Clock置换算法"><a href="#改进型Clock置换算法" class="headerlink" title="改进型Clock置换算法"></a>改进型Clock置换算法</h4><p>系统把一个页面移出内存时，如果该页面驻留内存期间没有被修改过，那么不必把它写回辅存，否则系统必须把它写回辅存。这表明，换出未修改过的页面比换出被修改过的页面开销小。<br>❖ 显然，我们可以依据上述结论改进CLOCK算法。改进后的CLOCK算法将在置换范围内首选：<br>❖ <em><strong>在最近没有被使用过</strong></em>；<br>❖ <em><strong>在驻留内存期间没有被修改过的页面作为被置换页面</strong></em>。<br>➢由访问位A和修改位M可以组合成下面四种类型<br>的页面：<br>➢1类（A&#x3D;0，M&#x3D;0）：表示该页最近既未彼访问，又未被修改，是最佳淘汰页。<br>➢2类（A&#x3D;0，M&#x3D;1）：表示该页最近未被访问，但已被修改，并不是很好的淘汰页。<br>➢3类（A&#x3D;1，M&#x3D;0）：最近已被访问，但未被修改：该页有可能再被访问。<br>➢4类（A&#x3D;1，M&#x3D;1）：最近已被访问且被修改，该页可能再被访问。<br>执行过程可分成以下三步：</p>
<blockquote>
<p>（1）从指针所指示的当前位置开始，扫描循环队列，寻找A&#x3D;0且M&#x3D;0的第一类页面，将所遇到的第一个页面作为所选中的淘汰页。在第一次扫描期间不改变访问位A。<br>（2）如果第一步失败，即查找一周后未遇到<strong>第一类页面</strong>，则开始第二轮扫描，寻找A&#x3D;0且M＝1的<strong>第二类页面</strong>，将所遇到的第一个这类页面作为淘汰页。<em><strong>在第二轮扫描期间，将所有扫描过的页面的访问位A都置0</strong></em>。<br>（3）如果第二步也失败，亦即未找到第二类页面，则将指针返回到开始的位置，并将所有的访问位复0。然后重复第一步，如果仍失败，必要时再重复第二步，此时一定能找到被淘汰的页 。</p>
</blockquote>
<h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><p>有效访问时间是指访问存储器所需时间的平均值。假设使用了快表，则CPU访问内存时有以下三种情况：<br>设内存读写周期为t，查找快表时间为λ，缺页中断处理时间为ɛ</p>
<ul>
<li>页面在内存且页表项在快表中：只需一次访问内存<br>EAT&#x3D; λ + t</li>
<li>页面在内存但页表项不在快表中：需两次访问内存，一次读取页<br>表，一次读取数据，另外还需更新快表。<br>EAT&#x3D; λ + t + t + λ&#x3D;2(λ + t)</li>
<li>页面不在内存：考虑查找快表时间、查找页表时间、缺页中断处<br>理时间、更新快表时间、访问实际物理地址时间<br>EAT&#x3D; λ + t +ɛ + λ + t &#x3D; ɛ + 2(λ + t)<br>引入快表命中率为α，缺页中断率为f，则有效访问内存<br>时间为：<br>EAT&#x3D; λ + α t + (1- α)[t + f(t +ɛ +λ) + (1-f)(t+λ)]</li>
</ul>
<p>当进程要求装入新的页面或程序段时，如果当前没有足够的空闲空间，需要交换一些页面或段到外存。如果被交换出去的页面或段很快将被进程使用，则<br>又需要将其换入内存。<br>如果系统花费大量的时间把程序和数据频繁地换入和换出内存而不是执行用户指令，那么，称系统出现了<strong>抖动</strong>。出现抖动现象时，系统显得非常繁忙，但是吞吐量很低，甚至产出为零。<br>根本原因：选择的页面或段不恰当。显然，防止的根本手段给进程分配足够多的帧。</p>
<p><strong>抖动</strong>：如果运行进程的大部分时间都用于页面的换入&#x2F;换出，而几乎不能完成任何有效的工作，则称此进程处于抖动状态。抖动又称为颠簸。<br>抖动分为：</p>
<ul>
<li><p>局部抖动</p>
</li>
<li><p>全局抖动</p>
</li>
</ul>
<p>抖动产生的原因有：</p>
<blockquote>
<p>进程分配的物理块太少<br>置换算法选择不当<br>全局置换使抖动传播</p>
</blockquote>
<p>只要分配的帧空间能覆盖整个局部就不会出现太多的缺页!工作集模型就用来计算一个局部的宽度(帧数)。</p>
<p>工作集定义：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-08-44.png"></p>
<h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><p>一、<strong>段表机制</strong><br>在虚拟存储系统中的所有段表，其段描述子增加五个信息标识位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-09-13.png"></p>
<p>(1)状态位(存在位)P：用于说明该段是否已调入内存，供程序访问时参考；<br>P&#x3D;0，该段不在内存。P&#x3D;1，该段在内存<br>(2)访问位A：用于记录本段在一段时间内被访问的次数，提供给置换算法选择换出段时参考。A&#x3D;0，该段未被访问。 A&#x3D;1，该段被访问<br>(3)修改位M：用于表示该段在调入内存后是否被修改过，也是提供给置换算法在换出段时是否将该段写回外存作参考。M&#x3D;0，该段在内存中未被修改。M&#x3D;1，该段在内存中已经被修改<br>(4)外存地址：用于指出该段在外存上的地址，供调入该段时使用。<br>(5)增补位：说明该分段是否允许扩展，此外如该段已被增补，则在写回辅存时，需另选择辅存空间；</p>
<p> 二、<strong>缺页中断机构</strong>，进程运行时发现所需的段尚未调入内存，便由缺段中断机构产生一个缺段中断信号，进入OS后由缺段中断处理程序将所需要的段调入内存。需要在一条指令的执行期间，产生和处理中断，以及一条指令执行期间，可能会产生多次缺段中断。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-10-24.png"></p>
<p>三、<strong>地址变换机构</strong>，其在分段系统地址变换机构基础上形成，增加了缺段中断的请求和处理功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-10-35.png"></p>
<p>为了实现分段共享，可在系统中配置一张共享段表，所有共享段都在共享段表<br>中占有一个表项。</p>
<p>共享进程计数：记录有多少进程共享该段。<br>存取控制字段：对同一共享段，不同进程有不同的操作权限。<br>段号：共享段在不同进程中有不同的段号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-10-50.png"></p>
<p>共享段的分配与回收</p>
<ul>
<li><p>共享段的分配<br>在为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中增加一表项，填写有关数据，把count置为1；之后，当又有其它进程需要调用该共享段时，由于该共享段已被调入内存，故此时无须再为该段分配内存，而只需在调用进程的段表中，增加一表项，填写该共享段的物理地址；在共<br>享段表中，填上调用进程的进程名、存取控制等，再执行count：＝count＋1操作，以表明有两个进程共享该段。</p>
</li>
<li><p>共享段的回收<br>当共享此段的某进程不再需要该段时，应将该段释放，包括撤消该进程段表中共享段所对应的表项，以及执行count:&#x3D;count-1操作。若count结果为0，则须由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项，表明此时已没有进程使用该段；否则(减1结果不为0)， 则只是取消调用者进程在共享段表中的有关记录。</p>
</li>
</ul>
<p><em><strong>环保护</strong></em></p>
<p>低编号的环具有高优先权。OS核心处于0环内；某些重要的实用程序和操作系统服务，占居中间环；而一般的应用程序在外环上。</p>
<p>环保护的基本原则是：</p>
<ul>
<li>一个程序可以访问驻留在相同环或较低特权环中的<br>数据；</li>
<li>一个程序可以调用驻留在相同环或较高特权环中的<br>服务。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-11-18.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-11-39.png"></p>
<p>在虚拟段式存储管理中，若逻辑地址的段内地址大于段表中该段的段长，则发生(越界中断)   。</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之操作系统引论</title>
    <url>/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4/</url>
    <content><![CDATA[<ul>
<li>操作系统定义</li>
</ul>
<p>操作系统是一组<strong>控制和管理计算机软硬件资源</strong>、<strong>合理地对各类作业进行调度以及方便用户使用</strong>的程序集合。</p>
<p>操作系统是 位于硬件层(HAL)之上，所有其它系统软件层之下的一个<strong>系统软件</strong>，使得管理系统中的各种软件和硬件资源得以充分利用，方便用户使用计算机系统。</p>
<ul>
<li>OS的目标</li>
</ul>
<p><strong>方便性</strong>: 操作系统使计算机更易于使用。 </p>
<p><strong>有效性</strong>: 操作系统允许以更有效的方式使用计算机系统资源。 提高系统资源利用率 、提高系统的吞吐量。 </p>
<p><strong>可扩展性</strong>: 在操作系统中,允许有效地开发，测试和引进新的系统功能。 </p>
<p><strong>开放性</strong>: 实现应用程序的可移植性和互操作性,要求具有统一 的开放的环境。</p>
<p>其中有效性，可扩展性最重要。</p>
<ul>
<li>OS的作用</li>
</ul>
<p>1.作为用户与计算机硬件系统之间的接口</p>
<p>2.作为计算机系统资源的管理者(软硬件资源)</p>
<p>3.作为扩充机器</p>
<ul>
<li>OS的特征</li>
</ul>
<p>1、并发性（最重要的特征） 2、共享性 3、虚拟性 4、异步性</p>
<p><strong>并发是最重要的特征</strong>，其它特征都以并发为前提。其中最基本特征是<strong>并发和共享</strong>。</p>
<ul>
<li>OS的主要功能</li>
</ul>
<p>1、处理机管理（CPU）</p>
<p>2、存储器管理</p>
<p>3、设备管理</p>
<p>4、文件管理</p>
<p>5、方便用户使用的用户接口。</p>
<ul>
<li>OS的基本类型</li>
</ul>
<p><strong>批处理操作系统、分时操作系统和实时操作系统。</strong></p>
<ul>
<li>批处理、分时、实时系统（比较）</li>
</ul>
<p>批处理系统(batchprocessingsystem):操作员把用户提交的作业分类,把一批作业编成一个作业执行序列,由专门编制的监督程序(monitor)自动依次处理。其主要特征是:用户脱机使用计算机、成批处理、多道程序运行。</p>
<p>分时系统(timesharingoperationsystem):把处理机的运行时间分成很短的时间片,按时间片轮转的方式,把处理机分配给各进程使用。其主要特征是交互性、多用户同时性、独立性。</p>
<p>所谓“实时”，是表示“及时”，而实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的运行。其特征主要体现在实时控制和实时信息处理。</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之文件系统</title>
    <url>/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3/</url>
    <content><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>​	文件系统是操作系统用于明确<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87/3340812?fromModule=lemma_inlink">存储设备</a>（常见的是磁盘）或分区上的文件的方法和<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fromModule=lemma_inlink">数据结构</a>；即在存储设备上组织文件的方法。操作系统中负责管理和<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6/23734835?fromModule=lemma_inlink">存储文件</a>信息的软件机构称为<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/8164847?fromModule=lemma_inlink">文件管理系统</a>，简称文件系统。</p>
<h2 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h2><p>文件系统的功能：</p>
<blockquote>
<p>有效地管理文件的存储空间；<br>管理文件目录；<br>完成文件的读&#x2F;写操作；<br>实现文件共享与保护；<br>为用户提供交互式命令接口和程序调用接口。</p>
</blockquote>
<p>​	文件系统定义：<strong>操作系统中的各类文件、管理文件的软件，以及管理文件所涉及到的数据结构等信息的集合</strong>。</p>
<p>​	现代OS几乎都是通过文件系统来组织和管理在计算机中所存储的大量程序和数据的。文件系统的管理功能是通过把它所管理的程序和数据组织成一系列文件的方法来实现的。而文件则是指具有文件名的若干相关元素的集合<strong>。</strong>元素通常是记录，而记录是一组有意义的数据项的集合。可以把数据组成分为<strong>数据项、记录、文件</strong>。</p>
<p>　① <strong>数据项</strong>，数据项是最低级数据组织形式。分为基本数据项（用于描述一个对象某种属性的字符集，是数据组织中可以命名的最小逻辑数据单位，即原子数据，又称为数据元素或字段）和组合数据项（由若干个基本数据项组成，简称组项）</p>
<p>　② <strong>记录</strong>，是一组相关数据项的集合，用于描述一个对象在某方面的属性，为了能够唯一标识一个记录，需要在一个记录的各个数据项中确定一个或几个数据项，把他们的集合称为<em><strong>关键字</strong></em>，关键字是能够唯一标识一个记录的数据项。</p>
<p>　③ <strong>文件</strong>，文件是具有文件名的一组相关元素的集合，分为有结构文件和无结构文件。有结构文件由若干个相关记录组成，无结构文件则被看成一个字符流。文件是文件系统的最大数据单位，它描述了一个对象集。</p>
<p><em><strong>一个文件可对应若干个记录，一个记录可对应若干个数据项。</strong></em></p>
<p>文件应该具有自己的属性，包括文件类型，文件长度，文件的物理位置，文件的建立时间。文件长度（文件的当前长度，也可能是最大允许长度），文件的物理位置（指示文件在哪一个设备上及在该设备的哪个位置的指针），文件的建立时间（文件最后一次修改时间）。</p>
<p><strong>文件类型</strong></p>
<ul>
<li><p><em>按用途分类</em><br>(1)系统文件<br> 这是指由系统软件构成的文件。大多数的系统文件只允许用户调用，但不允许用户去读，更不允许修改；有的系统文件不直接对用户开放。<br>(2) 用户文件<br> 由用户的源代码、目标文件、可执行文件或数据等所构成的文件。<br>(3) 库文件<br> 这是由标准子例程及常用的例程等所构成的文件。这类文件允许用户调用，但不允许修改。　</p>
</li>
<li><p><em>按文件中数据的形式分类</em><br>(1)源文件<br>指由源程序和数据构成的文件。<br>(2) 目标文件<br>指把源程序经过相应语言的编译程序编译过，但尚未经过链接程序链接的目标代码所构成的文件。它属于二进制文件。<br>(3) 可执行文件<br>指把编译后所产生的目标代码再经过链接程序链接后所形成的文件。</p>
</li>
<li><p><em>按存取控制属性分类</em><br>根据系统管理员或用户所规定的存取控制属性，可将文件分为三类：<br>(1)只执行文件<br>该类文件只允许被核准的用户调用执行，既不允许读，更不允许写。<br>(2) 只读文件<br>该类文件只允许文件主及被核准的用户去读，但不允许写。<br>(3) 读写文件<br>这是指允许文件主和被核准的用户去读或写的文件。</p>
</li>
<li><p><em>按组织形式和处理方式分类</em></p>
<p>分为普通文件，目录文件，特殊文件。</p>
</li>
</ul>
<p><em><strong>文件系统模型</strong></em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_10-13-38.png"></p>
<p>​	文件系统管理的对象有：<strong>文件</strong>（作为文件管理的直接对象），<strong>目录</strong>（为了方便用户对文件的存取和检索，在文件系统中配置目录，每个目录项中，必须含有文件名及该文件所在的物理地址，对目录的组织和管理是方便用户和提高对文件存取速度的关键），<strong>磁盘（磁带）存储空间</strong>（文件和目录必定占用存储空间，对这部分空间的有效管理，不仅能提高外存的利用率，而且能提高对文件的存取速度）。</p>
<p>​	为方便用户使用文件系统，文件系统通常向用户提供两种类型的接口：<br>(1) <strong>命令接口</strong>。这是指作为用户与文件系统交互的接口。 用户可通过键盘终端键入命令，取得文件系统的服务。<br>(2) <strong>程序接口</strong>。这是指作为用户程序与文件系统的接口。 用户程序可通过系统调用来取得文件系统的服务。</p>
<p><em><strong>文件操作</strong></em></p>
<p>​	用户通过文件系统提供的<strong>系统调用</strong>实施对文件的操作。最基本的文件操作有：创建文件、删除文件。读文件、写文件、截断文件和设置文件的读／写位置。</p>
<p>　当前OS所提供的大多数对文件的操作，其过程大致都是这样两步：首先，检索文件目录来找到指定文件的属性及其在外存上的位置；然后，对文件实施相应的操作，如读&#x2F;写文件等，当用户要求对一个文件实施多次读&#x2F;写或其他操作时，每次都要从检索目录开始，为了避免多次重复地检索目录，在大多数OS中都引入了打开这一文件系统调用，当用户第一次请求对某文件系统进行操作时，先利用open系统调用将该文件打开。</p>
<p>　<strong>打开是指系统将指名文件的属性（包括该文件在外存上的物理位置）从外存拷贝到内存打开文件表的一个表目中，并将该表目的编号（索引）返回给用户</strong>，以后，当用户再要求对该文件进行操作时，便可利用系统所返回的索引号向系统提出操作请求，系统便可直接利用该索引到打开文件表中去查找，从而避免了对该文件的再次检索，如果用户不再需要对该文件实施操作，可利用关闭系统调用来关闭此文件，OS将会把该文件从打开文件表中的表目上删除掉。</p>
<p>文件操作实例（Linux）</p>
<blockquote>
<p>open：打开一个文件，并指定访问该文件的方式，调用成功后返回一个文件描述符。<br>creat：打开一个文件，如果该文件不存在，则创建它，调用成功后返回一个文件描述符。<br>close：关闭文件，进程对文件所加的锁全都被释放。<br>read：从文件描述符对应的文件中读取数据，调用成功后返回读出的字节数。<br>write：向文件描述符对应的文件中写入数据，调用成功后返回写入的字节数。</p>
</blockquote>
<h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><p>　对任何的文件，都存在以下两种形式的结构</p>
<p>　① <strong>文件的逻辑结构</strong>，这是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称为文件组织。文件逻辑结构的类型：顺序文件、索引文件、索引顺序文件。</p>
<p>　② <strong>文件的物理结构</strong>，又称为文件的存储结构，是指文件在外存上的存储组织形式，不仅与存储介质的存储性能有关，还与外存分配方式有关。（分为顺序、链接及索引结构）</p>
<p>​	文件的物理结构即文件的外存分配方式，是从系统的角度来看文件，从文件在物理介质上的存放方式来研究文件。要考虑的主要问题： 如何有效地利用外存空间、如何提高对文件的访问速度。<br>目前常用的外存分配方法：<br>（1）连续分配（顺序分配）－&gt; 顺序文件结构<br>（2）链接分配－&gt; 链接文件结构<br>（3）索引分配－&gt; 索引文件结构　</p>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>　连续分配要求为每个文件分配一组相邻接的盘块，一组盘块地址定义了磁盘上的一段线性地址。采用连续分配方式时，<strong>把逻辑文件中的数据顺序地存储到邻接的各物理盘块中，这样所形成的物理文件可以进行顺序存取</strong>。文件目录中为每个文件建立一个表项，其中记载文件的第一个数据块地址及文件长度。对于顺序文件，连续读&#x2F;写多个数据块内容时，性能较好。这种分配方式保证了逻辑文件中的记录顺序与存储器中文件占用盘块的顺序的一致性。下图为连续分配方式（假设记录与盘块一样大）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_10-36-44.png">　　</p>
<p>连续分配的优点如下：</p>
<p>　① 顺序访问容易，可以随机存取, 能很快检索文件中的一个数据块。例如，如果一个文件的第一个数据块的序号为x，需要检索文件的第y块，则该数据块在外存中的位置为x+y-1。</p>
<p>　② 顺序访问速度快，磁头移动距离短，效率最高。</p>
<p>连续分配的缺点如下：</p>
<p>　① 要求又连续的存储空间，要为每个文件分配一段连续的存储空间，这样，可能产生许多磁盘碎片，严重地降低了外存空间利用率。解决方法：系统定期或不定期采用紧凑技术，将小分区合并为大的、连续分区，将文件占用空间合并在一起。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_10-37-04.png"></p>
<p>　② 必须事先知道文件的长度，事先知道文件的长度，然后根据其大小，在存储空间中找出一块其大小足够的存储区，将文件装入，对于动态增长的文件非常低效。<strong>空间利用率不高；不利于文件尺寸的动态增长。</strong></p>
<h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><p>　如果将一个逻辑文件存储到外存上，并不要求为整个文件分配一块连续的空间，而是可以将文件装到多个离散的盘块中，采用链接分配方式，可通过在每个盘块上的链接指针，<strong>将同属于一个文件的多个离散盘块链接成一个链表</strong>，把这样形成的物理文件称为链接文件。链接分配采取离散分配方式，消除了外部碎片，故而显著地提高了外存空间的利用率，并且对文件的增、删、改、查十分方便。链接方式可分为<em><strong>隐式链接和显示链接</strong></em>两种形式。</p>
<p>　① <strong>隐式链接</strong>， 在文件目录的每个目录项中，都须含有<strong>指向链接文件第一个盘块和最后一个盘块的指针</strong>。<strong>每个盘块中都含有一个指向下一个盘块的指针</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_10-37-35.png"></p>
<p>　第9个盘块指向第16个盘块，第16个盘块指向第1个盘块，第1个盘块指向第10个盘块，第10个盘块指向第25个盘块（结束块）。　　</p>
<p>　隐式链接分配的主要问题在于：其只适合于顺序访问，对随机访问的效率极其低效。如果要访问文件所在的第 i 个盘块，则必须先读出文件的第一个盘块……，就这样顺序地查找直至第 i 块。此外，其可靠性较差，任何一个指针出现问题，都会导致整个链的断开。可以将几个盘块组成一个簇，然后以簇为单位进行分配，会减少查找指定块的时间，但是会增加内部碎片。</p>
<p>　② <strong>显示链接</strong>，把用于链接文件各物理块的指针，显式的放在内存的一张链接表中，在整个磁盘仅设置一张<strong>文件分配表</strong>（FAT）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-01-31.png"></p>
<p>　表的序号从0开始，直至N-1，N为盘块总数，在每个表项中存放链接指针，即下一个盘块号，在该表中，凡是属于某一文件的第一个盘块号，或者说是每一条链的链首指针所对应的盘块号，均作为文件地址被填入相应的文件的FCB(File Control Block)的<strong>物理地址</strong>字段中，由于查找记录的过程是在内存中进行的，因而提<strong>高了检索速度，减少了访问磁盘的次数</strong>，由于分配给文件的所有盘块号都在该表中，故把该表称为文件分配表FAT（File Allocation Table）。</p>
<ul>
<li>链接分配优点<br>1、无外部碎片，没有磁盘空间浪费<br>2、无需事先知道文件大小。文件动态增长时，可动态分配空闲盘块。对文件的增、删、改十分方便。</li>
<li>缺点<br>  1、<em><strong>不能支持高效随机&#x2F;直接访问，仅适合于顺序存取</strong></em><br>  2、需为指针分配空间。（隐式链接）<br>  3、可靠性较低（指针丢失&#x2F;损坏）<br>  4、<em><strong>文件分配表FAT（显式链接），FAT需占用较大的内存空间</strong></em>。</li>
</ul>
<h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><p>​	事实上，在打开某个文件时，只需要把该文件占用的盘块号的编号调入内存即可，完全没有必要把整个FAT调入内存，为此，应该<strong>将每个文件所对应的盘块号集中地放在一起</strong>，索引分配方式就是基于这种想法所形成的一种分配方式。<em>其为每个文件分配一个索引块（表），再把分配给该文件的所有盘块号都记录在该索引块中，因而该索引块就是一个含有许多磁盘块号的数组</em>。在建立一个文件时，只需要在为之建立的目录项中填上指向该索引块的指针（单级索引）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-02-23.png"></p>
<p>　索引方式支持直接访问，可在索引块中直接找到第i个盘块，索引方式也不会产生外部碎片，当文件较大时，索引分配方式要优于链接分配方式。其主要问题在于：大文件索引项较多，可能使一个数据块容纳不了一个文件的所有分区的索引。可能需要花费较多的外存空间，每当建立一个文件时，便须为之分配一个索引块，将分配给该文件的所有盘块号记录其中。对于小文件而言，索引块的利用率非常低。</p>
<p>　当文件太大，其一级索引块太多时，这种方法是低效的。此时，应为这些索引块再建立一级索引，形成<strong>两级索引分配</strong>方式。即系统再分配一个索引块，作为第一级索引的索引块，将第一块、第二块……等索引块的盘块号填入到此索引表中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-02-32.png"></p>
<p>　在二级索引分配方式下，若每个盘块的大小为1KB，每个盘块号占4个字节，则在一个索引块可以存放256个盘块号，这样，在两级索引时，最多可以包括存放文件的盘块号总数为64K(256 * 256)个盘块号，所允许文件最大长度为64MB，若盘块大小为4KB，则一级索引的最大文件大小为4MB，二级索引的最大文件大小为4GB。</p>
<p>　④ <strong>混合索引分配方式</strong>，将多种索引分配方式相结合而形成的一种分配方式，如<strong>直接地址</strong>（在索引结点中设置10个直接地址项，每项中所存放的是该文件数据所在盘块的盘块号，假如每个盘块大小为4KB，当文件不大于40KB时，可以直接从索引结点中读出该文件的全部盘号），<strong>一次间接地址</strong>（利用索引结点中的地址项来提供一次间接地址，其实质就是一级索引分配方式，可存放1K个盘块号，允许最大文件为4MB），<strong>多次间接地址</strong>（当文件大于4MB + 40KB时，系统采用二次间址分配方式，其实质是两级索引分配方式，采用二次间址的最大文件大小为4GB，同理，可采用三次间接地址，允许文件最大大小为4TB）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-31-01.png"></p>
<h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><p>文件管理要解决的重要问题之一是如何为<strong>新创建的文件</strong>分配存储空间。<br>存储空间的<em><strong>基本分配单位是磁盘块</strong></em>。<br>其分配方法与内存的分配有许多相似之处，即同样可采取<em>连续分配方式或离散分配方式</em>。<br>系统应为分配存储空间而设置相应的数据结构；其次，系统应提供对存储空间进行分配和回收的手段。</p>
<p>文件存储空间的管理方法：</p>
<ul>
<li>空闲分区表</li>
<li>空闲链表法</li>
<li>位示图</li>
<li>成组链接法</li>
</ul>
<h3 id="空闲分区表"><a href="#空闲分区表" class="headerlink" title="空闲分区表"></a>空闲分区表</h3><p>　空闲表法属于<strong>连续分配方式</strong>，它与内存的动态分配方式雷同，它为每个文件分配一块连续的存储空间，即<strong>系统也为外存上所有空闲区建立一张空闲表，每个空闲区对应于一个空闲表项</strong>，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块号等信息，再将所有空闲区按其起始盘块号递增排列。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-39-03.png"></p>
<p>　适合于<em><strong>可变大小分区的连续分配</strong></em>方式。为文件分配存储空间时，首先顺序查找空闲分<br>区表中的各个表项，直至找到第一个大小适合的空闲分区。可以采用首次适应分配算法、最佳适应分配算法等。然后，将该分区分配给文件，同时修改空闲分区表，删除相应表项。当删除文件释放出空间时，系统回收其存储空间，合并相邻空闲分区.系统在对用户所释放的存储空间进行回收时，也采取类似于内存回收的方法，即考虑回收区是否与空闲表中插入点的前区和后区相邻接，对相邻接者应该予以合并。<em><strong>对交换分区一般都采用连续分配方式。当文件较小时，采用连续分配方式，当文件较大时，可采用离散分配方式。</strong></em></p>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>　空闲链表法是将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，把链表分成两种形式，空闲盘块链和空闲盘区链。</p>
<p>　① 空闲盘块链，这是将磁盘上的所有空闲空间，<em><strong>以盘块为单位拉成一条链</strong></em>，当用户因创建文件而请求分配存储空间时，系统从链首开始，依次摘下适当数目的空闲盘块分配给用户，当删除文件而释放空间时，系统将回收的盘块依次插入空闲盘块链的末尾，其优点是用于分配和回收一个盘块的过程简单，但在为文件分配盘块时，可能要重复操作多次。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-40-19.png"></p>
<p>　② 空闲盘区链，这是将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链，在每个盘区上除了含有只是下一个空闲盘区的指针外，还应有能指明本盘区大小（盘块数）的信息。盘区分配与内存的动态分配类似，可采用首次适应算法，在回收盘区时，同样也要将回收区和相邻接的空闲盘区相合并，在采用首次适应算法时，可以采用显式链接法提高检索速度，在内存中为空闲盘区建立一张链表。每个分区结点内容：起始盘块号、盘块数、指向下一个空闲盘区的指针。</p>
<p>​	可能的问题：</p>
<p>​	一段时间以后，可能会使空闲分区链表中包含太多小分区，使文件分配到的存储空间过分离散。删除一个由许多离散小分区组成的文件时，将回收的小分区链接到空闲分区链表中需要很长时间。若一个文件申请连续存储空间，则需要花费较长的时间查找相邻的空闲分区。因此，这种空闲空间组织方法<em><strong>适合于非连续存储</strong></em>文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-53-58.png"></p>
<h3 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h3><p>　利用二进制的一位表示磁盘中的一个盘块的使用情况，当其值为0时，表示对应的盘块空闲，为1时，表示已经分配，磁盘上的所有盘块都有一个二进制位与之对应，这样，由所有盘块所对应的位构成一个集合，称为<strong>位示图</strong>，通常可用m×n个位数来构成位示图，并使m * n等于磁盘的总块数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-39-38.png"></p>
<p>　对于盘块的分配分为如下三步</p>
<p>　① <strong>顺序扫描位示图</strong>，从中找出一个或一组值为0的二进制位。</p>
<p>　② 将所找到的一个或一组二进制位转换成与之相应的盘块号。</p>
<p>​	假定找到的其值为“0”的二进制位位于位示图的第i 行、第j列，则其相应的盘块号按式计算：b &#x3D; n( i - 1) + j</p>
<p>　③ 修改位示图，令map[i,j]&#x3D;1。</p>
<p>　对于盘块的回收分为如下两步</p>
<p>　① 将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为：</p>
<p>​	i &#x3D; (b - 1)DIV n + 1<br>​	j &#x3D; (b - 1)MOD n + 1</p>
<p>　② 修改位示图，令map[i,j] &#x3D;0。</p>
<p>　此方法的优点在于从位示图中很容易找到一个或一组连续的空闲分区，例如，我们需要找到8个相邻接的空闲盘块，这只需在位示图中找出8个其值连续为“0”的位即可。<br>一个位示图需要占用的存储空间大小为：磁盘容量（字节数）&#x2F; （8 * 数据块大小）<br>由于位示图很小，占用空间少，因而可将其保存在内存中，进而使在每次进行盘区分配时，无需首先把盘区分配表读入内存，节省磁盘启动时间。</p>
<p>​	但是，对于一个16GB的磁盘，若数据块大小为512字节，则位示图大小为4MB，大约需要占用8000个磁盘块的存储空间。很难一次性将该位示图全部装入内存。即使内存<br>足够大，可以存放全部或绝大部分位示图数据，搜索一个很大的位示图将会降低文件系统的性能。尤其当磁盘空间快用完，剩下的空闲磁盘块很少时，文件系统的性能将严重降低。</p>
<h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><p>　空闲表法和空闲链表法都不适用于大型系统，因为这会使空闲表或空闲链表很长，在UNIX采用的成组链接法，结合上述两种方法。</p>
<p>　① 空线盘块的组织，空闲盘块栈用来存放当前可用的一组空闲盘块的盘块号（最多含100个号），以及栈中尚有的空闲盘块号数N，顺便指出，N兼做栈顶指针使用，栈是临界资源，系统设置一把锁供进程互斥访问。其中，S.free(0)是栈底，栈满时栈顶为S.free(99)。</p>
<p>　② 文件区中的所有空闲盘块被分成若干个组，如每100个盘块作为一组。</p>
<p>　③ 将每一组含有的盘块总数N和该组所有的盘块号记入其前一组的第一个盘块S.free(0)~S.free(99)中，这样，由各组的第一个盘块可链接成一条链。</p>
<p>　④ 将第一组的盘块总数和所有的盘块号记入空闲盘块号栈中，作为当前可供分配的空闲盘块号。</p>
<p>　⑤ 最末一组只有99个盘块，其盘块号分别记入其前一组的S.free(1)~S.free(99)中，而在S.free(0)中则存放0，作为空闲盘块链的结束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_13-12-13.png"></p>
<p>　当系统要为用户分配文件所需的盘块时，须调用盘块分配过程来完成。该过程首先检查空闲盘块号栈是否上锁，如未上锁，便从栈顶取出一空闲盘块号，将与之对应的盘块分配给用户，然后将栈顶指针下移一格。若该盘块号已是栈底，即S.free(0)，这是当前栈中最后一个可分配的盘块号。由于在该盘块号所对应的盘块中记有下一组可用的盘块号，因此，须调用磁盘读过程，将栈底盘块号所对应盘块的内容读入栈中，作为新的盘块号栈的内容，并把<strong>原栈底对应的盘块分配出去</strong>(其中的有用数据已读入栈中)。然后，再分配一相应的缓冲区(作为该盘块的缓冲区)。最后，把栈中的空闲盘块数减1并返回。</p>
<p>　在系统回收空闲盘块时，须调用盘块回收过程进行回收。它是将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加1操作。当栈中空闲盘块号数目已达100时，表示栈已满，<strong>便将现有栈中的100个盘块号，记入新回收的盘块中，再将其盘块号作为新栈底</strong>。</p>
<p>例：在  UNIX  系统中有空闲盘块栈如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/6100690_1492936796345_072774B6B658B3603E1AA7198722775C.png"></p>
<p>​    (1)    现有一个进程要释放4 个物理块，其块号为150＃、156＃、172 ＃、177＃，画出空闲盘块栈每次的变化情况。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/6100690_1492936877377_072774B6B658B3603E1AA7198722775C.png"></p>
<p>​    (2)   在（ 1 ）的基础上假定一个进程要求分配5 个空闲块，画出分配完成后的空闲盘块栈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/6100690_1492936928232_072774B6B658B3603E1AA7198722775C.png"></p>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>　为了能够对文件实施有效的管理，必须对它们加以妥善组织，这主要是通过文件目录实现的，文件目录也是一种数据结构，用于标识系统中的文件及其物理地址，供检索时使用，对目录的管理要求如下：</p>
<p>　① **实现”按名存取”**，即用户只须向系统提供所需访问的文件的名字，便能够快速准确地找到指定文件在外存上的存储位置，这是目录管理中最基本的功能。</p>
<p>　② <strong>提高对目录检索速度</strong>，通过合理地组织目录结构的方法，可加快对目录的检索速度，从而提高对文件的存取速度。</p>
<p>　③ <strong>文件共享</strong>，在多用户系统中，应该允许用户共享一个文件。</p>
<p>　④ <strong>允许文件重名</strong>，系统应允许不同用户对不同文件采用相同的名字，以便用户按照自己的习惯给文件命名和使用文件。</p>
<p><strong>文件控制块</strong></p>
<p>　为了能对文件进行正确的存取，必须为文件设置<strong>用于描述和控制文件的数据结构</strong>，称之为文件控制块(FCB)，FCB是文件存在的标志。文件管理程序可借助于文件控制块中的信息，对文件施加各种操作，文件与文件控制块一一对应，而人们把<strong>文件控制块的有序集合称为文件目录</strong>，一个文件控制块就是一个文件目录项。为了实现对文件目录的管理，通常将<strong>文件目录以文件的形式保存在外存</strong>，这个文件就叫目录文件。</p>
<p>FCB的内容：</p>
<blockquote>
<p>基本信息：文件名、文件类型等；<br>地址信息：卷（存储文件的设备）、起始地址（起始物理地址）、文件长度（以字节、字或块为单位）等。<br>访问控制信息：文件所有者、访问信息（用户名和口令等）、合法操作等；<br>使用信息：创建时间、创建者身份、当前状态、最近修改时间、最近访问时间等。</p>
</blockquote>
<p>　<strong>文件目录通常是存放在磁盘上的</strong>，当文件很多时，文件目录可能要占用大量的盘块，在查找的过程中，先将存放目录文件的第一个盘块中的目录调入内存，然后把用户所给定的文件名和目录项中的文件名逐一对比。若未找到指定文件，则再将下一个盘块中的目录项调入内存。在检索目录文件时，只用到了文件名，仅当找到一个目录项（即其中的文件名与指定要查找的文件名相匹配）时，才需要从该目录项中读出该文件的物理地址，而其他一些对该文件进行描述的信息，在检索目录时一概不用，显然，这些信息在检索目录时不需要调入内存。为此，在有的系统中，如UNIX系统，便采用了把文件名和文件描述信息分开的方法，亦即，使文件描述信息单独形成一个称为<strong>索引结点</strong>的数据结构，简称为i结点，在文件目录中的每个目录项由文件名和指向该文件所对应的i结点的指针所构成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_14-28-08.png"></p>
<p>　<strong>每个文件都有唯一的磁盘索引结点（磁盘索引结点信息与文件名等信息一起构成了FCB）</strong>	</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>　目录结构的组织，关系到文件系统的存取速度，也关系到文件的共享性和安全性，目前常用的目录结构形式有单级目录、两级目录、多级目录。</p>
<p>　① <strong>单级目录结构</strong>，所有用户的全部文件目录保存在一张目录表中，每个文件的目录项占用一个表项。</p>
<p>单级目录的优点是简单且能实现目录管理的基本功能——<strong>按名存取</strong><br>存在下述一些缺点：</p>
<blockquote>
<p>(1) 查找速度慢<br>(2) 不允许重名<br>(3) 不便于实现文件共享</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_14-37-20.png"></p>
<p>② <strong>两级目录结构</strong>，为每个用户建立一个单独的<strong>用户文件目录UFD</strong>（User File Directory），这些文件目录具有相似的结构，由用户所有文件的文件控制块组成。此外，系统中还有一个<strong>主文件目录MFD</strong>（Master File Directory)，在主文件目录中，每个用户目录文件都占有一个目录项，其目录项包括<strong>用户名和指向用户目录文件的指针</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_14-38-57.png"></p>
<p>　具有如下优点：<strong>提高了检索目录的速度</strong>（如果在主目录中有n个子目录，每个用户目录最多为m个目录项，则为查找一指定的目录项，最多只需要检索n+m个目录项）。<strong>在不同的用户目录中，可以使用相同的文件名</strong>（只要在用户自己的UFD中，每个文件名都是唯一的，不同用户可以有文件名相同的文件）。<strong>不同用户还可使用不同的文件名来访问系统中同一个共享文件</strong>。但在多个用户需要合作完成一个大任务时，不便于用户之间共享文件。</p>
<p>　③ 多级目录结构，对于大型文件系统，通常采用三级或三级以上的目录结构，以提高对目录的检索速度和文件系统的性能。多级目录结构又称为树形目录结构，<strong>主目录被称为根目录</strong>，把<strong>数据文件称为树叶</strong>，<strong>其他的目录均作为树的结点</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_14-39-30.png"></p>
<p>　方框代表目录文件，圆圈代表数据文件，主目录中有是哪个用户总目录A、B、C，在B用户的总目录B中，又包括三个分目录F、E、D，其中每个分目录中又包含多个文件，为提高系统的灵活性，<strong>应该允许在一个目录文件中的目录项既是作为目录文件的FCB，又是数据文件的FCB</strong>，这一信息可用目录项中的一位来指示。如用户A总目录中，目录项A是目录文件FCB，而目录项B和D则是数据文件的FCB。</p>
<p>　在树形目录结构中，从根目录到任何数据文件，都只有一条唯一的通路，在该路径上从树的根开始，把全部目录文件名和数据文件名依次用”&#x2F;“连接起来，即构成该数据文件的路径名。<strong>系统中的每个文件都有唯一的路径名</strong>。例如，用户B访问文件J，则使用路径名&#x2F;B&#x2F;F&#x2F;J来访问。路径名：从树的根（即主目录）开始，把全部目录文件名与数据文件名，依次地用“&#x2F;”连接起来，即构成该数据文件的路径名（path name）。<strong>系统中的每一个文件都有惟一的路径名</strong>。当前目录：为每个进程设置一个“当前目录”，又称为“工作目录”，进程对各文件的访问都相对于“当前目录”而进行。<strong>把从当前目录开始的数据文件为止所构成的路径名称为相对路径名</strong>，而<strong>把从树根开始的路径名称为绝对路径名</strong>。</p>
<p><em><strong>增加和删除目录</strong></em></p>
<p>​	在树形目录结构中，用户可为自己建立UFD，并可再创建子目录，在用户要创建一个新文件时，只需要查看自己的UFD及其子目录中有无与新建文件相同的文件名，若无，便可在UFD或其某个子目录中增加一个新目录项。在树形目录中，如何删除一个目录，应该视情况而定，若要删除的目录为空，则简单地将其删除，使它在其上一级目录中所对应的目录项为空。若不为空，可采用如下方法：<strong>不删除非空目录</strong>（当目录不为空时，为了删除一个非空目录，必须先删除目录中所有的文件，使之称为空目录，然后再删除，如果目录中包含有子目录，则应该递归调用方式删除），<strong>可删除非空目录</strong>（将目录中的所有文件和子目录同时删除）。</p>
<h3 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h3><p>　当用户要访问一个已存在的文件时，系统首先利用用户提供的文件名对目录进行查询，找出该文件的文件控制块或对应索引结点，然后，根据FCB或索引结点中所记录的文件物理地址（盘块号），换算出文件在磁盘上的物理位置，最后，再通过磁盘驱动程序，将所需文件读入内存。目前常用的方式有<strong>线性检索法</strong>和<strong>Hash方法。</strong></p>
<p>　① <strong>线性检索法</strong>，其又称为顺序检索法，<em>在单级目录中</em>，利用用户提供的文件名，用顺序查找法直接从文件目录中找到指名文件的目录项。<em>在树形目录中</em>，用户提供的文件名是由多个文件分量名组成的路径名，此时须对多级目录进行查找，假定用户给定的文件路径名为&#x2F;usr&#x2F;ast&#x2F;mbox，则查找过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_14-59-42.png"></p>
<p>　首先，系统应先读入第一个文件分量名usr，用它与根目录文件（或当前目录文件）中各目录项中的文件名顺序地进行比较，从中找到匹配者，并得到匹配项的索引结点号是6，再从6号索引结点中得到usr目录文件放在132号盘块中，将该盘块内容读入内存。接着，系统再将路径名中的第二个分量名ast读入，用它与放在132号盘块中的第二级目录文件中各目录项的文件名顺序进行比较，又找到匹配项，从中得到ast的目录文件放在26号索引结点中，再从26号索引结点中得知&#x2F;usr&#x2F;ast是存放在496号盘块中，再读入496号盘块。然后，将文件的第三个分量名mbox读入，用它与第三级目录文件&#x2F;usr&#x2F;ast中各目录项的文件名进行比较，最后得到&#x2F;usr&#x2F;ast&#x2F;mbox的索引结点号为60，即在60号索引结点中存放了指定文件的物理地址，目录查询操作到此结束，如果在顺序查找过程中发现有一个文件分量名没有找到，则停止查找，并返回文件未找到信息。</p>
<p>　② <strong>Hash方法</strong>，系统利用用户提供的文件名并将它转换为文件目录的索引值，再利用该索引值到目录中去查找，这将提高检索速度。</p>
<p>①在利用Hash值查找目录时，如果目录表中相应的目录项是空的，则表示系统中并无指定文件。<br>②如果目录项中的文件名与指定文件名相匹配，则表示该目录项正是所要寻找的文件所对应的目录项，故而可从中找到该文件所在的物理地址。<br>③如果在目录表的相应目录项中的文件名与指定文件名并不匹配，则表示发生了“Hash冲突”<br>解决Hash冲突的方法 ：将其Hash值再加上一个<strong>常数</strong>（该常数应与目录的长度值互质），形成新的索引值，再返回到第一步重o新开始查找。</p>
<h2 id="文件共享和访问控制"><a href="#文件共享和访问控制" class="headerlink" title="文件共享和访问控制"></a>文件共享和访问控制</h2><p>文件共享的有效控制涉及两个方面：</p>
<ul>
<li>同时存取（Simultaneous Access）</li>
<li>存取权限（Access Rights）</li>
</ul>
<p>​	允许多个用户同时读文件内容，但<strong>不允许同时修改</strong>，或<strong>同时读且修改文件内容</strong>。共享用户之一修改文件内容时，可以将整个文件作为<em>临界资源</em>，锁定整个文件，不允许其他共享用户同时读或写文件。也可以仅仅锁定指定的一条记录，允许其他共享用户读&#x2F;写该文件的其它记录。后者的并发性能更好。</p>
<p>控制授权用户以合法的方式访问文件，包括：</p>
<blockquote>
<p>执行（Execution） — 用户可以装载并执行程序，但不允许拷贝程序内容。</p>
<p>读（Reading）— 允许用户读文件内容，包括拷贝和执行文件。某些系统严格地将浏览文件内容和拷贝权限分开，可以控制文件只能被浏览（显示），不能被拷贝。</p>
<p>追加（Appending）— 允许用户向文件添加数据，通常只能将数据添加到文件尾。但是，不能修改或删除文件内容。例如，超市收银员只能将新结帐的数据添加到文件中，不允许其修改或删除已有的数据。</p>
<p>更新（Updating）— 允许用户修改、删除、增加文件内容。包括创建文件、重写文件的全部或部分内容、移动文件的全部或部分数据等操作。</p>
<p>更改权限 (Changing protection) —一般只有文件主才能更改共享该文件的其他用户对该文件的存取权限。有的系统允许文件主将更改文件存取权限赋予其他某个用户，但必须限制授权用户更改的权限范围。</p>
<p>删除 (Deletion) 允许用户删除文件</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_15-00-00.png"></p>
<p>​	在树型结构的目录中，当有两个(或多个)用户要共享一个子目录或文件时，必须<em><strong>将共享文件或子目录链接到两个(或多个)用户的目录中</strong></em>，才能方便地找到该文件。此时该文件系统的目录结构已不再是树型结构，而是个<em><strong>有向非循环图</strong></em>。</p>
<p>​	实现文件共享的<strong>实质</strong>就是可以<strong>从不同地方打开同一个文件</strong>。打开文件的首要步骤就是找到文件的目录项，读取文件在外存的起始地址。<br>实现文件共享的方式：</p>
<ul>
<li>利用链接目录项实现法</li>
<li>利用索引节点实现法</li>
<li>利用符号链实现法</li>
</ul>
<p><strong>利用链接目录项实现法</strong></p>
<p>文件目录项中设置一个链接指针，用于指向共享文件的目录项。访问文件时，根据链接指针内容找到共享文件的目录项，读取该目录项中文件起始位置等信息，操作该文件。每当有用户（进程）共享文件时，共享文件目录项中的“共享计数”加1；当用户不再共享该文件，撤消链接指针时，“共享计数”减1。只有当共享文件用户数为1时，才能删除共享文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_15-00-27.png"></p>
<p><strong>利用索引节点实现法</strong>（硬链接）</p>
<p>​	文件的物理地址及其它的文件属性等信息，不再是放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。由任何用户对文件进行Append 操作或修改，所引起的相应结点内容的改变(例如，增加了新的盘块号和文件长度等)，都是其他用户可见的，从而也就能提供给其他用户来共享。</p>
<p>​	可以通过<em><strong>共享文件索引节点来共享文件</strong></em>，即当用户需要共享文件时，在自己的文件目录中新建一个目录项，为共享文件命名(也可用原名)，并将<em><strong>索引节点指针指向共享文件的索引节点</strong></em>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_15-00-37.png"></p>
<p>​	在索引结点中还应有一个链接计数count，用于表示链接到本索引结点(亦即文件)上的用户目录项的数目。当用户C创建一个新文件时，他便是该文件的所有者，此时将count 置1。当有用户B要共享此文件时，在用户B 的目录<br>中增加一目录项，并设置一指针指向该文件的索引结点，此时，文件主仍然是C，count&#x3D;2。<br>​	如果用户C 不再需要此文件，是否能将此文件删除呢？因为若删除了该文件，也必然删除了该文件的索引结点，这样便会便用户B的指针悬空，而用户B则可能正在此文件上执行写操作，此时用户B会无法访问到文件。因此用户C不能删除此文件，只是将该文件的count减1，然后删除自己目录中的相应目录项。用户B仍可以使用该文件。当count &#x3D;0时，表示没有用户使用该文件，系统将负责删除该文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_15-00-52.png"></p>
<p><strong>利用符号链实现法</strong>（软链接）</p>
<p>​	为使B能共享C的一个文件F，可以由系统<em><strong>创建一个LINK类型的新文件</strong></em>，也取名为F并将F写入B的目录中，以实现B的目录与文件F的链接；在新文件<em><strong>只<br>包含被创文件F的路径名</strong></em>。这样的链接方法被称为<strong>符号链接</strong>。新文件中的路径名，则只被看作是符号链。当B要访问被链接的文件F且正要读LINK类新文件时，<em><strong>将被OS截获， OS根据新文件中的路径名去读该文件</strong></em>，于是就实现了用户B对文件F的共享。<br>​	在利用符号链方式实现文件共享时，只是文件主才拥有指向其索引结点的指针,而共享该文件的其它用户，则只有该文件的路径名，并不拥有指向其索引结点的指针。</p>
<p>符号链方式优点：能连接任何机器上的文件。每增加一个连接，就增加一个文件名，各用户使用自己的名字去共享文件。<br>缺点：备份可能会产生多个拷贝。这是因为每个用户都有自己的符号链接，而备份程序可能无法识别这些符号链接实际上指向同一个文件。因此，它可能会为每个符号链接创建一个单独的备份，从而导致多个拷贝。</p>
<p><strong>利用URL实现文件共享</strong><br>    统一资源定位器URL (Uniform Resource Locator)是Internet上用来链接超文本文件的一种方法。它可以链接同一台计算机中的本地文件，也可链接Internet中任何主机上的远程文件。一个完整的URL包括访问文件的方法（协议）、文件所在的主机域名、目录路径名和文件名几部份。例如，<br><a href="http://www.uestc.edu.cn/templates/index2k3/index.html">http://www.uestc.edu.cn/templates/index2k3/index.html</a></p>
<p><strong>文件保护</strong></p>
<p>​	不同对象允许实施的操作各不相同。例如，文件可施加读、写、执行等操作，信号量只能施加wait()和signal()操作。因此，<em><strong>系统为所有对象设置一个允许进程实施操作的操作集</strong></em>，任何对对象的操作必须符合操作集中的规定，防止未授权进程访问对象。</p>
<p>例一：存放在某个磁盘上的文件系统，对于采用混合索引分配方式，其FCB中共有13项地址项，第0～9个地址项为直接地址，第10个地址项为一次间接地址，第11个地址项为二次 间接地址，第12个地址项为三次间接地址。如果每个盘块的大小为512字节，盘块号需要3个字节来描述，则每个盘块最多存放170个盘块地址。<br> (1) 该文件系统允许的最大长度是多少？<br> (2) 将文件的字节偏移量5000、15000、150000转换为物理块号和块内偏移量。<br> (3) 假设某文件的索引结点已在内存中，但其他信息均在外存，为了访问该文件中某个位置的内容，最多需要几次访 问磁盘？</p>
<p>(1) 该文件系统中一个文件的最大长度可达:</p>
<p>10+170+170×170+170×170×170&#x3D;4942080块,共4942080×512字节&#x3D;2471040KB</p>
<p>(2)5000&#x2F;512得到商为9,余数为392,即字节偏移量5000对应的逻辑块号为9,块内偏移量为392。由于9&lt;10,故可直接从该文件的FCB的第9个地址项处得到物理盘块号,块内偏移量为392。</p>
<p>15000&#x2F;512得到商为29,余数为152,即字节偏移量15000对应的逻辑块号为29,块内偏移量为152。由于10&lt; 29&lt; 10+170,而29-10&#x3D;19,故可从FCB的第10个地址项,即一次间址项中得到一次间址块的地址;并从一次间址块的第19项(即该块的第57~59这3个字节)中获得对应的物理盘块号,块内偏移量为152。</p>
<p>150000&#x2F;512得到商为292,余数为496,即字节偏移量150000对应的逻辑块号为292,块内偏移量为496。由于10+170&lt; 292&lt; 10+170+170×170,而292-(10+170)&#x3D;112,112&#x2F;170得到商为0,余数为112,故可从FCB的第11个地址项,即二次间址项中得到二次间址块的地址,并从二次间址块的第0项中获得一个一次间址块的地址,再从这一次间址块的第112项中获得对应的物理盘块号,块内偏移量为496。</p>
<p>(3) 由于文件的FCB己在内存，为了访问文件中某个位置的内容，最少需要1次访问磁盘(即可通过直接地址直接读文件盘块)，最多需要4次访问磁盘(第一次是读三次间址块,第二次是读二次间址块,第三次是读一次间址块,第四次是读文件盘块)。</p>
<p>例二：有一个磁盘组共用10个盘面，每个盘面上有100个磁道，每个磁道有16个扇区，假定以扇区为单位，若使 用位示图管理磁盘空间，问位示图需要占多少空间？ 若空闲表的每个空闲表项占用5个字节，问什么时候空闲表大于位示图？</p>
<p>​	磁盘组的总扇区数为10 * 100 * 16 &#x3D; 16000。因此，位示图需要占用16000位 &#x3D; 2000字节的空间。</p>
<p>​	若空闲表的每个空闲表项占用5个字节，则当空闲表项数大于2000&#x2F;5&#x3D;400时，空闲表的大小将大于位示图。也就是说，当磁盘组中有超过400个连续的空闲扇区时，使用空闲表管理磁盘空间所需的存储空间将大于使用位示图所需的存储空间。</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之输入输出系统</title>
    <url>/2023/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2/</url>
    <content><![CDATA[<h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><p>​	输入输出系统是计算机系统中的主机与外部进行通信的系统。在计算机系统中，通常把处理机和主存储器之外的部分称为输入输出系统，输入输出系统的特点是异步性、实时性和设备无关性。</p>
<h2 id="I-O系统简介"><a href="#I-O系统简介" class="headerlink" title="I&#x2F;O系统简介"></a>I&#x2F;O系统简介</h2><p>​	<strong>设备管理的对象</strong>：主要是I&#x2F;O设备。<br>​	<strong>设备管理的基本任务</strong>：完成用户提出的I&#x2F;O请求，提高I&#x2F;O速率以及改善I&#x2F;O设备的利用率。<br>​	<strong>设备管理的主要功能有</strong>：缓冲区管理、设备分配、设备处理、虚拟设备及实现设备独立性等。</p>
<p>​	I&#x2F;O设备类型繁多，按设备的<strong>共享属性</strong>分类，可以分为三类，<strong>独占设备</strong>，在一段时间内只允许一个用户（进程）访问的设备，即临界资源。<strong>共享设备</strong>，在一段时间内允许多个进程同时访问的设备，当然，每一时刻仍然只允许一个进程访问，如磁盘（可寻址和可随机访问）。<strong>虚拟设备</strong>，通过虚拟技术将一台设备变换为若干台逻辑设备，供若干个用户（进程）同时使用。</p>
<p><strong>I&#x2F;O 系统的基本功能</strong></p>
<ol>
<li>设备分配</li>
<li>设备映射</li>
<li>设备驱动</li>
<li>I&#x2F;O缓冲区的管理</li>
</ol>
<p><strong>通用设备管理分层模型</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_20-16-19.png"></p>
<p>​	通常，设备并不是直接与CPU进行通信，而是与设备控制器通信，因此，在I&#x2F;O设备中应该含有与设备控制器之间的接口，在该接口有三种类型的信号，各对应一条信号线。</p>
<p>　① 数据信号线，用于在设备控制器之间传送数据信号，<em>对于输入设备而言</em>，由外界输入的信号经转换器转换后所形成的数据，通常先送入缓冲器中，当数量达到一定的比特（字符）数后，再从缓冲器通过一组信号线传送给设备控制器。<em>对输出设备而言</em>，则先将从设备控制器经过数据信号线传送来的一批数据先暂存于缓冲器中，经转换器做适当转换后，再逐个字符地输出。</p>
<p>　② 控制信号线，作为由设备控制器向I&#x2F;O设备发送控制信号时的通路，该信号规定了设备将要执行的操作，如读操作（指由设备向控制器传送数据）或写操作（由控制器接受数据），或执行磁头移动等操作。</p>
<p>　③ 状态信号线，用于传送设备当前状态的信号，设备的当前状态有正在读（或写）；设备已读（写）完成，并准备好新的数据传送。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628151650952-1466573946.png"></p>
<p><em><strong>设备控制器</strong></em>是计算机中的一个实体，其<strong>主要职责</strong>是<em><strong>控制一个或多个I&#x2F;O设备</strong></em>，以实现I&#x2F;O设备和计算机之间的数据交换，它是CPU与I&#x2F;O设备之间的接口，它接收从CPU发来的命令，并去控制I&#x2F;O设备工作，以使处理从繁杂的设备控制事务中解脱出来。它是一个可编址的设备，当它仅控制一个设备时，它只有一个唯一的设备地址，若控制器可连接多个设备时，则应该含有多个设备地址，并使每个设备地址对应一个设备。</p>
<p>在控制器中设置一状态寄存器，用其中的每一位来反映设备的某一种状态，当CPU将该寄存器的内存读入后，便可了解该设备的状态。<strong>I&#x2F;O逻辑</strong>，用于实现对设备的控制，通过一组控制线与处理机交互，处理机利用该逻辑向控制器发送I&#x2F;O命令，I&#x2F;O逻辑对收到的命令进行译码，每当CPU要启动一个设备时，<em>一方面将启动命令发送给控制器</em>，<em>另一方面又同时通过地址线把地址发送给控制器</em>，由控制器的I&#x2F;O逻辑对收到的地址进行译码，再根据所译出的命令对所选设备进行控制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_20-34-48.png"></p>
<p> <em><strong>I&#x2F;O通道</strong></em></p>
<p>　虽然在CPU与I&#x2F;O设备之间增加了设备控制器后，可以大大减少CPU对I&#x2F;O的干预，但是当主机所配置的外设很多时，CPU的负担仍然很重，因此，在CPU和设备控制器之间又增设了通道。其主要目的使一些原来由CPU处理的I&#x2F;O任务转由通道来承担，从而把CPU从繁杂的I&#x2F;O任务中解脱出来。在设置了通道后，<strong>CPU只需要向通道发送一条I&#x2F;O指令，通道在收到该指令后，便从内存中取出本次要执行的通道程序，然后执行该通道程序，仅当通道完成了规定的I&#x2F;O任务后，才向CPU发中断信号</strong>。I&#x2F;O通道是一种特殊的处理机，<em>具有执行I&#x2F;O指令的能力</em>，并通过执行通道（I&#x2F;O）程序来控制I&#x2F;O操作，但I&#x2F;O通道与一般的处理机不同，因为其指令类型单一同时没有自己的内存，<em>与CPU共享主内存</em>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_20-35-21.png"></p>
<p>虚拟设备是指被多个用户或进程交替使用的设备，宏观上好象多个用户同时在使用。(×）</p>
<p><font color=red>虚拟设备是指采用采用某种I&#x2F;O技术，将某个独占设备改进为多用户共享的设备，以提高资源的利用率。(通过虚拟技术将一台独占设备虚拟成多台逻辑设备，供多个进程同时使用)</font><br>我感觉说法差不多，但是网上给的答案是❌。</p>
<p>通道技术根本上是从软件上解决操作系统对输入输出操作的 控制问题。（× ）应该是硬件</p>
<p>逻辑设备是物理设备属性的表示，用来指定某一具体设备。（×）不特指某个具体设备，而是对应一类设备。</p>
<p>从设备的资源属性分类，可把设备分为独占设备、共享设备和虚拟设备。（ √）</p>
<p>用户在使用I&#x2F;O设备时，通常采用物理设备名，指明具体的设备。（×）用户在使用I&#x2F;O设备时，通常采用逻辑设备名，指明设备类型。</p>
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p><strong>中断处理程序</strong></p>
<p>对于为每一类设备设置一个I&#x2F;O进程的设备处理方式，其中断处理程序的处理过程分成以下几个步骤<br>▪测定是否有未响应的中断信号<br>▪程序完成当前指令后测试是否有未响应的中断信号。<br>▪如果没有，继续执行下一条指令。<br>▪如果有，则停止原有进程的执行，准备转去执行中断处理程序，为把处理机的控制权转交给中断处理程序做准备。</p>
<p><strong>保护被中断进程的CPU 环境</strong></p>
<p>通常由硬件自动将处理机状态字PSW 和程序计数器(PC)中的内容，保存在中断保留区(栈)中，然后把被中断进程的CPU现场信息(即包括所有的CPU寄存器，如通用寄存器、段寄存器等内容)都压入中断栈中。</p>
<p><strong>转入相应的设备处理程序</strong></p>
<p>由处理机对各个中断源进行测试，以确定引起本次中断的I&#x2F;O 设备，并发送一应答信号给发出中断请求的进程，使之消除该中断请求信号，然后将相应的设备中断处理程序的入口地址装入到程序计数器中，使处理机转向中断处理程序。</p>
<p><strong>中断处理</strong></p>
<p>该程序首先从设备控制器中读出设备状态，以判别本次中断是正常完成中断，还是异常结束中断。<br>▪ 若是前者，中断程序便进行结束处理；若还有命令，可再向控制器发送新的命令，进行新一轮的数据传送。<br>▪ 若是异常结束中断，则根据发生异常的原因做相应的处理。</p>
<p><strong>恢复被中断进程的现场</strong></p>
<p>当中断处理完成以后，便可将保存在中断栈中的被中断进程的现场信息取出，并装入到相应的寄存器中，其中包括该程序下一次要执行的指令的地址N+1、处理机状态字<br>PSW，以及各通用寄存器和段寄存器的内容。这样，当处理机再执行本程序时，便从N+1处开始，最终返回到被中断的程序。</p>
<h2 id="I-O设备的控制方式"><a href="#I-O设备的控制方式" class="headerlink" title="I&#x2F;O设备的控制方式"></a>I&#x2F;O设备的控制方式</h2><p><strong>轮询的可编程I&#x2F;O方式</strong></p>
<p>​	对I&#x2F;O设备的控制采取<strong>程序I&#x2F;O</strong>方式，或称为<font color=blue>忙-等待</font>方式，即在处理机向控制器发出一条I&#x2F;O指令启动输入设备输入数据时，要同时把状态寄存器中的忙&#x2F;闲标志busy设置为1，然后便不断地循环测试busy，只有当其为0时，表示输入完成，于是处理机将数据寄存器中的数据取出，送入内存指定单元中，这样便完成了一次的I&#x2F;O。在程序I&#x2F;O方式中，由于CPU的高速性和I&#x2F;O设备的低速性，致使CPU的绝大部分时间都处于等待I&#x2F;O设备完成数据I&#x2F;O的循环测试中，造成对CPU的极大浪费。</p>
<p><strong>中断的可编程I&#x2F;O方式</strong></p>
<p>　当某进程要启动某个I&#x2F;O设备工作时，便由CPU向相应的设备控制器发出一条I&#x2F;O命令，然后立即返回继续执行原来的任务，设备控制器于是按照该命令的要求去控制指定I&#x2F;O设备，此时，CPU与I&#x2F;O设备并行操作。一旦数据进入数据寄存器，控制器便通过控制线向CPU发送一个中断信号，由CPU检查输入过程中是否出错，若无错，便由控制器发送取走数据的信号，再通过控制器及数据线将数据写入内存指定单元中。在I&#x2F;O设备输入每个数据的过程中，由于无需CPU干预，因而可使CPU与I&#x2F;O设备并行工作，仅当完成一个数据输入时，才需CPU花费极短的时间去做一些中断处理。</p>
<p><strong>直接存储器访问方式</strong></p>
<p>　虽然中断驱动I&#x2F;O比程序I&#x2F;O方式更有效，但是，它仍是以字（节）为单位进行I&#x2F;O的，每当完成一个字（节）的I&#x2F;O时，控制器便要向CPU请求一次中断，换言之，采用中断驱动I&#x2F;O方式时的CPU是以字（节）为单位进行干预的，将这种方式用于块设备的I&#x2F;O是非常低效的，例如，为了从磁盘读取1KB的数据块，需要中断CPU1K次，为了进一步减少CPU对I&#x2F;O的干预而引入了直接存储器访问方式，该方式的特点如下：</p>
<p>　① 数据传输的基本单位是<strong>数据块</strong>，即在CPU与I&#x2F;O设备之间，每次传送至少一个数据块。</p>
<p>　② 所传送的数据是<strong>从设备直接送入内存</strong>的，或者相反。</p>
<p>　③ 仅在传送一个或多个数据块的开始和结束时，需要CPU干预，整块数据的传送是在控制器的控制下完成的。</p>
<p>　DMA控制器由三部分组成，主机与DMA控制器的接口；DMA控制器与块设备的接口；I&#x2F;O控制逻辑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628173514952-543939858.png"></p>
<p>　① 命令&#x2F;状态寄存器（CR），用于接收从CPU发送来的I&#x2F;O命令，或有关控制信息，或设备的状态。</p>
<p>　② 内存地址寄存器（MAR），在输入时，它存放把数据从设备传送到内存的起始目标地址，在输出时，它存放由内存到设备的内存源地址。</p>
<p>　③ 数据寄存器（DR），用于暂存从设备到内存，或从内存到设备的数据。</p>
<p>　④ 数据计数器（DC），存放本次CPU要读或写的字（节）数。</p>
<p> 　当CPU要从磁盘读入一个数据块时，便向磁盘控制器发送一条读命令，该命令被送到其中的命令寄存器（CR）中，同时，还需要发送本次要将数据读入的内存起始目标地址，该地址被送入内存地址寄存器（MAR）中，本次要读数据的字（节）数被送入数据寄存器（DC）中，还须将磁盘中的源地址直接送至DMA控制器的I&#x2F;O控制逻辑上，然后，启动DMA控制器进行数据传送，以后，CPU便可去处理其他任务，此后，整个数据传送过程便由DMA控制器进行控制，当DMA控制器已从磁盘中读入一个字（节）的数据并送入数据寄存器（DR）后，再挪用一个存储器周期，将该字（节）传送到MAR所指示的内存单元中，接着便对MAR内容加1，将DC内存减1，若减后DC内存不为0，表示传送未完成，便继续传送下一个字（节），否则，由DMA控制发出中断请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628174538171-789907791.png"></p>
<p>　下图展示了三种不同方式的流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628193955531-1354950266.png">　　</p>
<p><strong>I&#x2F;O通道控制方式</strong></p>
<p>　虽然DMA方式比起中断方式已经显著地减少CPU的干预，即已由以字（节）为单位的干预减少到了以数据块为单位进行干预，但CPU每发出一条I&#x2F;O指令，也只能去读（或写）一个连续的数据块，而当我们需要一次去读多个数据块且将他们分别传送到不同的内存区域，或者相反时，则须由CPU分别发出多条I&#x2F;O指令及进行多次中断才能完成。I&#x2F;O通道方式是DMA的发展，它可以进一步减少CPU的干预，即把一个数据块的读（或写）为单位的干预减少为<strong>对一组数据块的读（或写）及有关的控制和管理为单位的干预</strong>。同时，可以实现CPU、通道、I&#x2F;O设备的并行操作，提高资源利用率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_21-17-58.png"></p>
<p><strong>什么是中断？系统内部中断与外部中断有什么区别？</strong></p>
<p>中断是指计算机在执行程序的过程中，由于某些事件的发生而暂时中止当前程序的执行，转而去执行相应的事件处理程序，处理完毕后再返回原来程序继续执行的过程</p>
<p>中断可以分为两类：系统内部中断和外部中断。系统内部中断是指由CPU内部产生的中断，例如除零错误、溢出错误等。外部中断是指由CPU外部产生的中断，例如来自外设的中断请求。外部中断可以进一步分为可屏蔽中断和不可屏蔽中断。可屏蔽中断是指可以被屏蔽或忽略的中断，例如来自硬盘、打印机、网卡等外设的中断请求。不可屏蔽中断是指不能被屏蔽或忽略的中断，例如电源掉电、硬件线路故障等。</p>
<p><strong>缺页中断与一般中断的主要区别是什么？</strong></p>
<p>缺页中断作为中断,同样需要经历保护CPU现场、分析中断原因、转缺页中断处理程序进行处理、恢复CPU现场等步骤。但缺页中断又是一种特殊的中断,它与一般中断的主要区别是:</p>
<p>(1) 在指令执行期间产生和处理中断信号。通常,CPU都是在一条指令执行完后去检查是否有中断请求到达。若有便去响应中断;否则继续执行下一条指令。而缺页中断是在指令执行期间,发现所要访问的指令或数据不在内存时产生和处理的。</p>
<p>(2) 一条指令在执行期间,可能产生多次缺页中断。例如,对于一条读取数据的多字节指令,指令本身跨越两个页面,假定指令后一部分所在页面和数据所在页面均不在内存,则该指令的执行至少产生两次缺页中断。</p>
<p>总之，缺页中断与一般中断的主要区别在于它们产生和处理的时间不同。缺页中断是在指令执行期间产生和处理的，而一般中断是在指令执行完后检查是否有中断请求再进行处理的。</p>
<p><strong>什么是设备的独立性？</strong></p>
<p>也称设备无关性，指应用程序独立于具体使用的物理设备。应用程序中使用逻辑设备名请求使用某类设备，系统实际执行时使用物理设备名，系统完成逻辑设备名到物理设备名的转换。</p>
<p><strong>I&#x2F;O控制方式中的中断控制方式和DMA方式有什么不同？</strong></p>
<p>(1) 中断方式是在数据缓冲寄存区满后,发中断请求,CPU进行中断处理,但它以字（节)为单位进行I&#x2F;0，对块设备低效。;DMA方式则是在所要求传送的数据块全部传送结束时要求CPU进行中断处理,大大减少了CPU进行中断处理的次数。</p>
<p>(2) 中断方式的数据传送是由CPU控制完成的;而DMA方式则是在DMA控制器的控制下不经过CPU控制完成的。</p>
<h2 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h2><p>　在设备管理中，为了缓和CPU与I&#x2F;O设备速度不匹配的矛盾，提高CPU与I&#x2F;O设备的并行性，在I&#x2F;O设备与处理机交换数据时都用到了缓冲区。</p>
<p>　① 缓和CPU和I&#x2F;O设备间速度不匹配的矛盾。</p>
<p>　② 减少对CPU的中断频率，放宽对CPU中断响应时间的限制。</p>
<p>　③ 提高CPU和I&#x2F;O设备之间的并行性。</p>
<p><strong>单缓冲</strong></p>
<p>　每当用户进程发出一个I&#x2F;O请求时，操作系统便在主存中为之分配一个缓冲区，假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理（计算）的时间为C，由于T和C是可以并行的，当T&gt;C时，系统对每一块数据的处理时间为M+T，反之，为M+C，系统对每一块数据的处理时间为<strong>Max(C，T) + M</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628201003046-1717232929.png"></p>
<p>　在字符设备输入时，缓冲区用于暂存用户输入的一行数据，在输入期间，用户进程被挂起以等待数据输入完毕，在输出时，用户进程将一行数据输入到缓冲区后，继续进行处理，当用户进程已有第二行数据输出时，如果第一行数据尚未被提取完毕，则此时用户进程应该阻塞。</p>
<p><strong>双缓冲</strong></p>
<p>　为了加快输入和输出的速度，提高设备利用率，人们又引入了双缓冲区机制，称为缓冲对换，在设备输入时，先将数据送入第一个缓冲区，装满后便转向第二个缓冲区，此时操作系统可以从第一缓冲区中移出数据，并送入用户进程，接着由CPU对数据进行计算，在双缓冲时，系统处理一块数据的时间可以粗略地认为是Max(C，T)，如果C&lt;T，可使块设备连续输入，如果C&gt;T，则可使CPU不必等待设备输入。对于字符设备，若采用行输入方式，则采用双缓冲通常能消除用户的等待时间，即用户在输入完第一行后，在CPU执行第一行中的命令时，用户可继续向第二缓冲区输入下一行数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628202211796-1310715249.png"></p>
<p><strong>循环缓冲</strong></p>
<p>　当输入与输出或生产者与消费者的速度基本相匹配时，采用双缓冲能获得较好的效果，可使生产者和消费者基本上能并行操作，但若两者速度相差甚远，双缓冲的效果则不够理想，因此，引入了多缓冲机制，可将多个缓冲组织成循环缓冲形式。对于用作输入的循环缓冲，通常是提供给输入进程或计算进程使用，输入进程不断向空缓冲去输入数据，而计算进程则从中提取数据进行计算。</p>
<p>　循环缓冲区的组成如下</p>
<p>　① 多个缓冲区，在循环缓冲区中包括多个缓冲区，每个缓冲区的大小相同，作为输入的多缓冲区可分为三种类型，用于装输入数据的空缓冲区R、已装满数据的缓冲区G以及计算进程正在使用的先行工作缓冲区C</p>
<p>　② 多个指针，作为输入的缓冲区可设置三个指针，用于指示计算进程下一个可用缓冲区G的指针Nextg、指示输入进程下次可用的空缓冲区R的指针Nexti、以及用于指示计算进程正在使用的缓冲区C的指针Current。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628203538952-358207840.png"></p>
<p>　计算进程和输入进程可以利用下述两个过程来使用循环缓冲区（循环缓冲的使用）。</p>
<p>　① Getbuf过程，当计算进程要使用缓冲区中的数据时，可调用Getbuf过程，该过程将由指针Nextg所指示的缓冲区提供给进程使用，相应的，须把它改为现行工作缓冲区，并将Current指针指向该缓冲区的第一个单元，同时将Nextg移向下一个G缓冲区，类似地，当输入进程要使用空缓冲区来装入数据时，调用Getbuf过程，由该过程将指针Nexti所指示的缓冲区提供给输入进程使用，同时将Nexti指针移向下一个R缓冲区。</p>
<p>　② Releasebuf过程，当计算进程把C缓冲区中的数据提取完毕时，便调用Releasebuf过程，将缓冲区C释放，此时，把该缓冲区由当前（现行）工作缓冲区C改为空缓冲区R，类似地，当输入进程把缓冲区装满时，也应该调用Releasebuf过程，将该缓冲区释放，并改为G缓冲区。</p>
<p>　使用输入循环缓冲，可使输入进程和计算进程并行执行（<strong>进程同步</strong>），相应地，指针Nexti和指针Nextg将不断地沿着顺时针方向移动，这样就会出现如下两种情况。</p>
<p>　① Nexti指针追赶上Nextg指针，这意味着输入进程的速度大于计算进程处理数据的速度，已把全部可用的空缓冲区装满，再无缓冲区可用，此时，输入进程应该阻塞，直到计算进程把某个缓冲区中的数据全部提取完，使之成为空缓冲区R，并调用Releasebuf过程将它释放时，才将输入进程唤醒，这种情况称为<strong>系统受计算限制</strong>。</p>
<p>　② Nextg指针追赶上Nexti指针，这意味着输入数据的速度低于计算进程处理数据的速度，使全部装有输入数据的缓冲区都被抽空，再无装有数据的缓冲区供计算进程提取数据，这时，计算进程应该阻塞，直至输入进程又装满某个缓冲区，并调用Releasebuf过程将它释放时，才去唤醒计算进程，这种情况称为<strong>系统受I&#x2F;O限制</strong>。</p>
<p><strong>缓冲池</strong></p>
<p>​	上述的缓冲区仅适用于某特定的I&#x2F;O进程和计算进程，因而它们属于专用缓冲，当系统较大时，将会有许多这样的循环缓冲，这样会消耗大量的内存空间，而且利用率不高，为了提高缓冲区的利用率，引入缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。</p>
<p>对于既可以用于输出的共用缓冲池，其中至少包含有一下三种类型的缓冲区：</p>
<p>　① 空（闲）缓冲区。</p>
<p>　② 装满输入数据的缓冲区。</p>
<p>　③ 装满输出数据的缓冲区。</p>
<p>　为了管理方便，将相同类型的缓冲区链成一个队列，形成了空缓冲队列emq、输入队列inq、输出队列outq。还具有四种工作缓冲区，用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区、用于提取输出数据的工作缓冲区。</p>
<p>　缓冲区可以工作在收容输入、提取输入、收容输出、提取输出四种工作方式下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_09-33-43.png"></p>
<p>　① <strong>收容输入</strong>，在输入进程需要输入数据时，便调用Getbuf(emp)过程，从空缓冲队列的队首取出一个空缓冲区，把它作为收容输入工作缓冲hin，然后，把数据输入其中，装满后再调用Putbuf(inq,hin)过程，将该缓冲区挂在输入队列上。</p>
<p>　② <strong>提取输入</strong>，当计算进程需要输入数据时，调用Getbuf(inq)过程，从输入队列队首取出一个缓冲区，作为提取输入工作缓冲区sin，计算进程从中提取数据，计算进程用完该数据后，再调用Putbuf(emq,sin)过程，将该缓冲区挂到空缓冲队列emq上。</p>
<p>　③ <strong>收容输出</strong>，当计算进程需要输出时，调用Getbuf(emq)过程从空缓冲区队列emq的队首取出一个空缓冲区，作为收容输出工作缓冲区hout，当其中装满输出数据后，又调用Putbuf(outq,hout)过程，将该缓冲区挂在outq末尾。</p>
<p>　④ <strong>提取输出</strong>，由输出进程调用Getbuf(outq)过程，从输出队列队首取出一个装满输出数据的缓冲区，作为提取输出工作缓冲区sout，在数据提取完后，再调用Putbuf(emq,sout)过程，将该缓冲区挂在空缓冲队列末尾。</p>
<h2 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I&#x2F;O软件"></a>与设备无关的I&#x2F;O软件</h2><p><em><strong>设备独立性</strong></em></p>
<p>　应用程序独立于具体使用的物理设备，为了实现设备独立性而引入了<strong>逻辑设备</strong>和<strong>物理设备</strong>这两个概念，在应用程序中，使用逻辑设备名称来请求使用某类设备，而系统在实际执行时，还必须使用物理设备名称。因此，系统需具有将逻辑设备名称转换为某物理设备名称的功能，这类似于存储器管理所介绍的逻辑地址和物理地址的概念，在应用程序中使用的是逻辑地址，系统在分配和使用内存时，必须使用物理地址。</p>
<p>实现设备独立性后，可带来<em>两方面</em>的好处。</p>
<p>　① <strong>设备分配时的灵活性</strong>，进程能够以逻辑设备名称来请求某类设备时，系统可立即将该类设备中的任一台分配给进程，仅当所有此类设备全部分配完毕时，进程才会阻塞。</p>
<p>　② <strong>易于实现I&#x2F;O重定向</strong>，用于I&#x2F;O操作的设备可以更换，而不必改变应用程序。　　</p>
<p>驱动程序是一个与硬件(或设备)紧密相关的软件，为了实现设备独立性，必须再在驱动程序之上设置一层软件，称为<strong>设备独立性软件</strong>。</p>
<p>设备独立性软件的主要功能可分为以下两个方面：<br>(1) 执行所有设备的公有操作。<br>① 对独立设备的分配与回收；<br>② 将逻辑设备名映射为物理设备名，进一步可以找到相应物理设备的驱动程序；<br>③ 对设备进行保护，禁止用户直接访问设备；<br>④ 缓冲管理<br>⑤ 差错控制<br>⑥ 提供独立于设备的逻辑块</p>
<p>(2) 向用户层(或文件层)软件提供统一接口<br>无论何种设备，它们向用户所提供的接口应该是相同的。例如，对各种设备的读操作，在应用程序中都使用read；而对各种设备的写操作，也都使用write。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_21-41-20.png"></p>
<h2 id="磁盘系统及磁盘调度"><a href="#磁盘系统及磁盘调度" class="headerlink" title="磁盘系统及磁盘调度"></a>磁盘系统及磁盘调度</h2><p>现代计算机系统中，都配置了磁盘存储器，并以它为主来存放文件。对文件的操作，都将涉及到对磁盘的访问，磁盘I／O速度的高低和磁盘系统的可靠性，都将直接影响到系统性能。因此，设法改善磁盘系统的性能，已成为现代操作系统的重要任务之一 。</p>
<p>提高磁盘I&#x2F;O速度的主要途径：<br>（1）选择性能好的磁盘<br>（2）采用好的磁盘调度算法<br>（3）设置磁盘高速缓存（Disk Cache）<br>（4）其它方法<br>（5）采用高度可靠、快速的容量磁盘系统——磁盘冗余阵列</p>
<p>数据的组织和格式<br>▪ 存储面(surface)<br>▪ 磁道(track)<br>▪ 柱面<br>▪ 扇区(sectors)</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_21-51-03.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_21-51-19.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_21-52-33.png"></p>
<p><em><strong>磁盘调度</strong></em></p>
<p>　磁盘是多个进程共享的设备，当有多个进程都要求访问磁盘时，应采用一种最佳的调度算法，使<strong>各进程对磁盘的平均访问时间最小</strong>。由于在访问磁盘中，主要是寻道时间，因此，磁盘调度的目标是<strong>使磁盘的平均寻道时间最少</strong>。</p>
<p>请求序列：55,58,39,18,90,160,150,38,184</p>
<p>　① <strong>先来先服务（FCFS, First Come First Service）</strong>，这是一种最简单的磁盘调度算法，其根据进程请求访问磁盘的先后顺序进行调度，优点是<strong>公平、简单</strong>，每个进程的请求都能得到依次处理，不会出现某个进程的请求长期得不到满足的情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160629084945437-806152901.png"></p>
<p>　② <strong>最短寻道时间优先（SSTF，Shortest Seek Time First）</strong>，要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。但这种算法不能保证平均寻道时间最短。SSTF算法虽然能获得较好的寻道性能，但却可能导致某个进程发生<strong>“饥饿”</strong>现象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-18_08-50-31.png"></p>
<p>　③ <strong>扫描（SCAN）算法</strong>，该算法不仅考虑到欲访问的磁盘与当前磁道之间的距离，更<strong>优先考虑的是磁头当前的移动方向</strong>。例如，当磁头正在自里向外移动时，SCAN算法所考虑的下一个访问对象，应是其欲访问的磁道既在当前磁道之外，又是距离最近的。直至再无更外的磁道需要访问时，才将磁臂换向自外向里移动。其类似电梯的运行，也称为<strong>电梯调度算法</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160629090041437-489747422.png"></p>
<p>　　④ <strong>循环扫描（CSCAN）算法</strong>，SCAN算法既能够获得较好的寻道性能，又能防止饥饿现象，但是，当磁头刚从里向外移动而越过了某个磁道时，恰好又有一进程请求访问此磁道，这时，该进程必须等待，待磁头继续从里向外，然后再从外向里扫描完所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被大大地推迟。为了减少这种延迟，<strong>CSCAN算法规定磁头单向移动</strong>，例如，致使自里向外移动，当磁头移到最外的磁道访问后，磁头立即返回最里的欲访问的磁道，亦即<strong>将最小的磁道号紧接着最大的磁道号构成循环，进行循环扫描</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160629091148124-624346017.png"></p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之进程管理</title>
    <url>/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5/</url>
    <content><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>操作系统的进程管理是整个操作系统管理中的核心，它包含了进程的调度、协调以及进程通信。</p>
<h2 id="进程和线程的概念-、比较"><a href="#进程和线程的概念-、比较" class="headerlink" title="进程和线程的概念 、比较"></a>进程和线程的概念 、比较</h2><p>​	典型的进程定义有：<br>（1）进程是程序的一次执行。<br>（2）进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>（3）进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p>
<p>​	<strong>线程</strong>是进程的一个实体，是<strong>独立运行和独立调度</strong>的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的<strong>线程共享</strong>进程所拥有的全部资源。</p>
<p>对比：</p>
<p>线程只拥有少量在运行中必不可少的资源。<br>进程占用资源多，线程占用资源少，使用灵活。<br>线程不能脱离进程而存在，线程的层次关系，执行顺序并不明显，会增加程序的复杂度。<br>没有通过代码显示创建线程的进程，可以看成是只有一个线程的进程。</p>
<blockquote>
<p>进程是资源分配的基本单位，线程是程序执行的基本单位</p>
<p>进程拥有自己的资源空间，而线程与CPU资源分配无关，多个线程共享同一进程内的资源，使用相同的地址空间。</p>
<p>一个进程可以包含若干个线程。</p>
</blockquote>
<h2 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h2><p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_22-37-22.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_22-37-36.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_22-37-52.png"></p>
<h2 id="进程的基本状态及转换"><a href="#进程的基本状态及转换" class="headerlink" title="进程的基本状态及转换"></a>进程的基本状态及转换</h2><p><em><strong>进程的三种基本状态</strong></em></p>
<p>就绪状态(Ready)：当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，就可以立即运行，进程这时的状态称为就绪状态。在一个系统中可能多个进程处于就绪状态，通常将它们排成一个队列，称为就绪队列。</p>
<p>执行状态(Running)：进程已获得CPU，其程序正在执行。</p>
<p>阻塞状态(Blocked)：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，把这种暂停状态称为阻塞状态，有时也称为等待状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_09-14-09.png"></p>
<p><em><strong>进程五种状态及转换模型</strong></em></p>
<p>◼就绪：准备执行<br>◼执行：占用处理机（单处理机环境中，某一时刻仅一个进程占用处理机）<br>◼阻塞：等待某事件发生才能执行，如等待I&#x2F;O完成等<br>◼新建：进程已经创建，但未被OS接纳为可执行进程，并且程序还在辅存，PCB在内存<br>◼终止：因停止或取消，被OS从执行状态释放</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_09-21-57.png"></p>
<p><em><strong>状态转换</strong></em><br>① 空 → 新状态	新创建的进程首先处于新状态。<br>② 新状态 → 就绪状态	当系统允许增加就绪进程时，操作系统接纳新建状态进程，将它变为就绪状态，插入就绪队列中。<br>③ 就绪状态 → 执行状态	当处理机空闲时，将从就绪队列中选择一个进程执行，该选择过程称为<strong>进程调度</strong>，或将处理机分派给一个进程，该进程状态从就绪转变为执行。<br>④ 执行状态 → 终止状态	执行状态的进程执行完毕，或出现诸如访问地址越界、非法指令等错误，而被异常结束，则进程从执行状态转换为终止状态。</p>
<p>⑤ 执行状态 → 就绪状态	分时系统中，<strong>时间片用完，或优先级高的进程到来</strong>，将中断较低优先级进程的执行。进程从执行状态转变为就绪状态，等待下一次调度。<br>⑥ 执行状态 → 阻塞状态	执行进程需要等待某事件发生。通常，会因为进程需要的系统调用不能立即完成，如读文件、共享虚拟内存、等待I&#x2F;O操作、等待另一进程与之通信等事件而阻塞。<br>⑦ 阻塞状态 → 就绪状态	当阻塞进程等待的事件发生，就转换为就绪状态。进入就绪队列排队，等待被调度执行。</p>
<p><em><strong>多个进程竞争内存资源</strong></em></p>
<p>◼内存资源紧张<br>◼无就绪进程，处理机空闲：I&#x2F;O的速度比处理机的速度慢得多，可能出现全部进程阻塞,等待I&#x2F;O</p>
<p><em>解决办法</em></p>
<p>◼采用交换技术：换出一部分进程到外存，以腾出内存空间（对换）<br>◼采用虚拟存储技术：每个进程只能装入一部分程序和数据（存储管理部分）</p>
<p>使执行的进程暂停执行、静止下来。我们把这种静止状态称为<strong>挂起状态</strong>（由活动到静止，由内存到外存）。</p>
<p><em><strong>挂起与阻塞</strong></em></p>
<p>区分两个概念：<br>进程是否等待事件，阻塞与否? 进程是否被换出内存，挂起与否？</p>
<p>４种状态组合<br>就绪：进程在内存，准备执行<br>阻塞：进程在内存，等待事件<br>就绪&#x2F;挂起（静止就绪）：进程在外存，只要调入内存即可执行<br>阻塞&#x2F;挂起（静止阻塞）：进程在外存，等待事件</p>
<p>若进程处于阻塞状态，当引起阻塞的条件被解除时，进程状态应变为运行状态。(×)</p>
<p>① 进程由程序和数据两部分组成。（× ）<br>② 程序的封闭性是指该程序不允许某些进程调用。（ ×）<br>③ 操作系统中，进程是<strong>资源分配</strong> 、<strong>调度</strong>和管理的最小独立单位 ， 操作系统的各种活动都与<strong>进程</strong>有关。</p>
<h2 id="PCB的作用"><a href="#PCB的作用" class="headerlink" title="PCB的作用"></a>PCB的作用</h2><p>为使程序（含数据）能独立运行，应为之配置一进程控制块，即<strong>PCB</strong>(Process Control Block)； 而由程序段、相关的数据段和PCB三部分便构成了进程实体。所谓创建进程，实质上是创建进程实体中的PCB；而撤消进程，实质上是撤消进程的PCB。</p>
<p><em><strong>进程控制块的作用</strong></em><br>1） 作为独立运行基本单位的标志；<br>2） 能实现间断性运行方式；<br>3） 提供进程管理所需要的信息；<br>4） 提供进程调度所需要的信息；<br>5） 实现与其他进程的同步与通信。</p>
<p>PCB(process control block)常驻内存，是进程存在的唯一标志；</p>
<p><em><strong>进程控制块中的信息</strong></em><br>1）进程标识符<br>2）处理机状态<br>3）进程调度信息<br>4）进程控制信息</p>
<p><em><strong>PCB的组织方式</strong></em></p>
<p>1）线性方式<br>将系统中的所有PCB组织在一张线性表中，将该表的首地址存放在一个专用区域中。<br>2）链接方式<br>把具有同一状态的PCB，用其中的链接字链接成一个队列，排成就绪队列，若干个阻塞队列以及空白队列。<br>3）索引方式<br>系统根据所有进程的状态建立几张索引表。</p>
<h2 id="进程控制的原语操作"><a href="#进程控制的原语操作" class="headerlink" title="进程控制的原语操作"></a>进程控制的原语操作</h2><p><strong>原语</strong></p>
<p>是由若干条指令组成的，是用于完成一定功能的一个过程。<br>➢ 原语是原子操作：一个操作中的所有动作要么全做，要么全不做。（操作不可中断）<br>➢ <em>原子操作在系统态下执行，常驻内存</em>。<br>➢ 原语的作用是为了实现进程的通信和控制，系统对进程的控制如不使用原语会造成其状态的不确定性，达不到进程控制的目的。</p>
<p><em><strong>进程创建</strong></em><br>调用进程<strong>创建原语Creat</strong>（ ）按下述步骤创建一个新进程：<br>（1）申请空白PCB。<br>（2）为新进程分配资源。<br>（3）初始化进程控制块。包括：①初始化标识信息。②初始化处理机状态信息。③初始化处理机控制信息。<br>（4）将新进程插入就绪队列。</p>
<p><em><strong>进程阻塞过程</strong></em><br>1)正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用<strong>阻塞原语block</strong>( )把自己阻塞。<br>2)把进程控制块中的现行状态由“执行”改为“阻塞”，并将PCB插入阻塞队列。<br>3)转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换。</p>
<p><em><strong>进程的唤醒</strong></em><br>当被阻塞进程所期待的事件出现时，则由有关进程（比如，用完并释放了该I&#x2F;O设备的进程）调用<strong>唤醒原语wakeup</strong>（ ），将等待该事件的进程唤醒。<br>1）首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪。<br>2）然后再将该PCB插入到就绪队列中。</p>
<p>Block原语和Wakeup是一对作用相反的原语；有前者就必定由后者，否则：被阻塞的进程将会因不能被唤醒而长期处于阻塞状态，从而无法继续运行。</p>
<p><em><strong>进程的挂起</strong></em><br>当出现了引起进程挂起的事件时，系统将利用<strong>挂起原语suspend</strong>（ ）将指定进程进程挂起。<br>挂起原语的执行过程是：<br>•首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪；<br>•对于活动阻塞状态的进程，则将之改为静止阻塞状态。</p>
<p><em><strong>进程的激活过程</strong></em><br>1）当发生激活进程的事件时，则可将在外存上处于静止就绪状态的进程换入内存。<br>2）系统利用<strong>激活原语active</strong>（ ）将指定进程激活:<br>▪激活原语先将进程从外存调入内存，检查该进程的现行状态;<br>▪若是静止就绪，便将之改为活动就绪；若为静止阻塞，便将之改为活动阻塞。</p>
<ol>
<li>原语是指操作系统中的初始化程序。（× ）</li>
<li>一个进程可以由系统创建，或者由(父进程 )用创建原语创建。被创建的进程开始处于等待状态。在条件成熟时，采用(调度 ) 原语为它们分配除（处理机）以外的所需资源，并被排列到(就绪 )队列中。</li>
<li>进程运行过程中，因为(缺乏资源 )、等待I&#x2F;O操作等事件发生时，通过( 阻塞)原语将它撤下，排入( 等待)队列，并引起新的( 进程调度)。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160619213048991-866706486.png"></p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>一次仅允许一个进程访问的资源为<strong>临界资源</strong>。</p>
<p>每个进程中访问临界资源的那段代码称为<strong>临界区</strong></p>
<p><strong>进程互斥</strong>：一个进程正在访问临界资源，另一个要访问该资源的进程必须等待。</p>
<p><em><strong>同步机制应遵循的规则</strong></em><br>1)空闲让进<br>2)忙则等待<br>3)有限等待<br>4)让权等待</p>
<p>并发进程可以同时进入临界区，交替访问临界资源。（×）</p>
<p><em><strong>解决临界区（互斥）问题的几类方法</strong></em><br>（1）硬件同步机制<br>（2）信号量机制<br>（3）管程机制</p>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>1）整型信号量<br>2）记录型信号量<br>3）AND型信号量<br>4）信号量集</p>
<p><em><strong>整型信号量</strong></em></p>
<p>定义为一个整型量 ,仅能通过两个标准的原子操作wait（S）和signal（S）来访问。又称为P、V操作。<br><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_10-30-23.png"></p>
<p>1）P、V操作(即wait(s)和signal(s))为原语操作——不可中断<br>2）整型信号量的使用：<br>① 必须置一次且只能置一次初值，并且初值不能为负数。<br>② 只能执行P、V操作。<br>③必须成对使用P、V操作：P操作遗漏则不能保证互斥访问，V操作遗漏则不能在使用临界资源之后将其释放；P，V次序不能错误、重复或遗漏。<br>3）整型信号量的缺点：未遵循同步机制的“让权等待”一直判断是否处理完，占用处理机。（使程序处于忙等状态，这意味着当一个进程在等待信号量时，它会不断地检查信号量的值，而不是释放CPU资源，这会浪费大量的CPU时间。）</p>
<p><em><strong>记录型信号量</strong></em></p>
<p>记录型信号量机制，则是一种不存在“忙等”现象的进程同步机制。</p>
<p>记录型信号量的wait（S）操作（ 即P(S) ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure wait(S)</span><br><span class="line">	var S: semaphore;</span><br><span class="line">		begin</span><br><span class="line">			S.value:＝S.value-1;</span><br><span class="line">			if S.value＜0 then block(S.L);</span><br><span class="line">		end</span><br></pre></td></tr></table></figure>

<p>S.value＜0，该类资源已经分配完毕，进程必须放弃处理机，自我阻塞。</p>
<p>记录型信号量采用了“让权等待”策略，当一个进程在等待信号量时，它会被<strong>阻塞并释放CPU资源</strong>，直到被唤醒这样就避免了忙等现象。</p>
<p>记录型信号量的signal（S）操作（ 即V(S) ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure signal（S）</span><br><span class="line">	var S:semaphore;</span><br><span class="line">	begin</span><br><span class="line">		S.value:＝S.value+1;</span><br><span class="line">		if S.value≤0 then wakeup(S.L);</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<p>S.value&gt;0表示有S.value个资源可用;S.value&#x3D;0表示无资源可用。</p>
<p>S.value≤0 ，在信号量链表中，仍有等待该资源的进程被阻塞。</p>
<p>记录型信号量: 若S.value&lt;0，则| S.value|表示S等待队列中的进程个数。</p>
<p><em><strong>AND型信号量</strong></em></p>
<p>AND同步机制的基本思想：将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。 在wait操作中，增加了一个“AND”条件，故称为AND同步，或称为<strong>同时wait</strong>操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swait（S1，S2，···，Sn ） &#123;</span><br><span class="line">	while（true）&#123;</span><br><span class="line">		if（ S1≥1 and S2≥1 and…and Sn≥1 ）&#123;</span><br><span class="line">			for (i = 1 ; i&lt;= n; i++)&#123;</span><br><span class="line">				Si = Si – 1;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">			调用进程进入第一个小于1的信号量的等待队列Sj.queue;阻塞调用进程;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ssignal（S1，S2，···，Sn）&#123;</span><br><span class="line">	for( i = 1; i&lt;= n; i++ )&#123;</span><br><span class="line">		Si = Si+1;</span><br><span class="line">		for (each process P waiting in Si.queue)</span><br><span class="line">			从等待队列Si.queue中取出进程P放入就绪队列;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>信号量集</strong></em></p>
<p>一般信号量集是指同时需要<strong>多种资源</strong>、每种<strong>占用的数目不同</strong>、且可分配的资源还存在一个临界值时的信号量处理。一般信号量集的基本思路就是在AND型信号量集的基础上进行扩充，在一次原语操作中完成所有的资源申请</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swait（S1，t1，d1，…，Sn，tn，dn）（满足ti≥ di）</span><br><span class="line">	if( S1 ≥t1 &amp;…&amp; Sn≥tn)&#123;</span><br><span class="line">		for( i =1; i&lt;=n; i++)&#123;</span><br><span class="line">			Si ＝Si － di;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">			调用进程进入第一个小于1的信号量的等待队列Sj.queue;阻塞调用进程;</span><br><span class="line">	&#125;//end if</span><br><span class="line">&#125;//end Swait</span><br></pre></td></tr></table></figure>

<p>tn为资源下限值，dn为需求量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ssignal（S1，d1，···，Sn，dn）&#123;</span><br><span class="line">	for( i =1; i&lt;= n; i++)&#123;</span><br><span class="line">		Si = Si + di；</span><br><span class="line">		for (each process P waiting in Si.queue)</span><br><span class="line">			从等待队列Si.queue中取出进程P放入就绪队列;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号量应用"><a href="#信号量应用" class="headerlink" title="信号量应用"></a>信号量应用</h2><p><em><strong>利用信号量实现进程互斥</strong></em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_11-35-54.png"></p>
<p><em><strong>利用信号量实现前趋关系</strong></em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_10-31-12.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p1( )&#123; S1； signal（a）；signal（b）；&#125;</span><br><span class="line">p2( )&#123; wait(a); S2；signal（c）；signal（d）; &#125;</span><br><span class="line">p3( )&#123; wait（b）；S3；signal（e）；&#125;</span><br><span class="line">p4( )&#123; wait（c）；S4；signal（f）；&#125;</span><br><span class="line">p5( )&#123; wait（d）；S5；signal（g）；&#125;</span><br><span class="line">p6( )&#123; wait（e）；wait（f）；wait（g）；S6；&#125;</span><br><span class="line"></span><br><span class="line">void main( )&#123;</span><br><span class="line">	semaphore a,b,c,d,e,f,g;</span><br><span class="line">	a.value=b.value=c.value=0;</span><br><span class="line">	d.value=e.value=f.value=g.value=0;</span><br><span class="line">cobegin</span><br><span class="line">	p1( ); p2( ); p3( ); p4( ); p5( ); p6( );</span><br><span class="line">coend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量的物理意义是当信号量大于零时表示（资源的数目 ）；当信号量小于零时，其绝对值为（ 等待该资源的进程数目） 。</p>
<p>有m个进程共享同一临界资源，若使用信号量机制实现对临界资源的互斥访问，则信号<br>量值的变化范围是（ [1-m，1]）。</p>
<h2 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h2><p>◼生产者——消费者问题<br>◼哲学家进餐问题<br>◼读者——写者问题</p>
<h3 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h3><p>生产者和消费者进程共享一个大小固定的缓冲区，其中，一个或多个生产者生产数据，并将生产的数据存入缓冲区，并有一个消费者从缓冲区中取数据。</p>
<p>◆假设缓冲区的大小为n（存储单元的个数），它可以被生产者和消费者循环使用。<br>◆分别设置两个指针in和out，指向生产者将存放数据的存储单元和消费者将取数据的存储单元</p>
<p>生产者－消费者之间满足的条件：<br>◆ 消费者想接收数据时，有界缓冲区中至少有一个单元是满的（同步问题）<br>◆ 生产者想发送数据时，有界缓冲区中至少有一个单元是空的（同步问题）<br>◆ 有界缓冲区是临界资源（互斥问题）</p>
<p>full&#x3D;0; 表示当前队列中已有的数据个数<br>empty&#x3D;n; 表示当前队列中还可以放的数据个数</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_12-54-32.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_12-55-12.png"></p>
<p><em><strong>利用记录型信号量解决生产者一消费者问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int in=0, out=0;</span><br><span class="line">item buffer [n];</span><br><span class="line">semaphore mutex=1, empty=n, full=0; </span><br><span class="line">void producer();</span><br><span class="line">void consumer();</span><br><span class="line">void main()&#123;</span><br><span class="line">	cobegin</span><br><span class="line">		producer(); consumer();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void producer( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		…</span><br><span class="line">		Produce an item in nextp;</span><br><span class="line">		…</span><br><span class="line">		wait(empty);</span><br><span class="line">		wait(mutex);</span><br><span class="line">		buffer(in):=nextp;</span><br><span class="line">		in:=(in+1) mod n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(full);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">        wait(full);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextc:=buffer(out);</span><br><span class="line">        out:=(out+1) mod n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);</span><br><span class="line">		Consumer the item in nextc;</span><br><span class="line">		……</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wait(empty)</code>是一个同步P操作，因为它用于同步生产者和消费者之间的操作。当缓冲区已满时，生产者需要等待消费者从缓冲区中取出一个产品，才能继续向缓冲区中添加新的产品。<code>wait(mutex)</code>是一个互斥P操作，因为它用于保护对共享资源（即缓冲区）的互斥访问。当生产者或消费者需要访问缓冲区时，它们必须先获得对缓冲区的互斥访问权。</p>
<p>① P.V操作必须成对出现，有一个P操作就一定有一个V操作；<br>② 当为互斥操作时，PV处于同一进程；<br>③ 当为同步操作时，则PV不在同一进程中出现；<br>④ 如果P(S1)和P(S2)两个操作在一个进程中，那么P操作的顺序至关重要，<strong>一个同步P操作与一个互斥P操作在一起时,同步P操作在互斥P操作之前</strong>；<br>⑤ 两个V操作的顺序无关紧要。</p>
<p><em><strong>利用AND信号量解决生产者—消费者问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int in=0, out=0;</span><br><span class="line">item buffer[ n ];</span><br><span class="line">semaphore mutex=1, empty=n, full=0;</span><br><span class="line">void producer( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		…</span><br><span class="line">		produce an item in nextp;</span><br><span class="line">		…</span><br><span class="line">		Swait(empty, mutex);</span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        in = (in+1) % n;</span><br><span class="line">		Ssignal(mutex, full);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125; //end producer</span><br><span class="line"></span><br><span class="line">void consumer&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">        Swait(full, mutex);</span><br><span class="line">        nextc = buffer[out];</span><br><span class="line">        out = (out+1) % n;</span><br><span class="line">        Ssignal(mutex, empty);</span><br><span class="line">        consumer the item in nextc;</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>5个哲学家围绕一张圆桌而坐，每个哲学家前面有一碟空心面，由于面很滑，所以要两把筷子才能夹住。相邻两个碟子之间有一把筷子。哲学家只有两种活动，在感觉到饿时，分两次取左边和右边的筷子（不分次序），如果成功的得到两把筷子，就吃饭，吃完后继续思考。</p>
<p><em><strong>利用记录型信号量解决哲学家进餐问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    wait(chopstick[i]);</span><br><span class="line">    wait(chopstick[(i + 1) % 5]);</span><br><span class="line"></span><br><span class="line">    // Eat</span><br><span class="line"></span><br><span class="line">    signal(chopstick[i]);</span><br><span class="line">    signal(chopstick[(i + 1) % 5]);</span><br><span class="line"></span><br><span class="line">    // Think</span><br><span class="line"></span><br><span class="line">&#125; while (TRUE);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然上述解法可以保证不会有两个相邻的哲学家同时进餐。但却有可能引起死锁。假如五位哲学家同时饥饿而各自拿起左边的筷子的时候，就会使五个信号量chopstick均为零。当他们在试图去拿右边的筷子，都将因为无筷子可拿而无限期的等待。</p>
<p>解决办法：</p>
<ol>
<li><strong>至多只允许有四位哲学家同时去拿左边的筷子</strong>，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。</li>
<li>仅当哲学家的<strong>左、右两只筷子均可用</strong>时，才允许他拿起筷子进餐。</li>
<li>规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐。</li>
</ol>
<p><em><strong>利用AND信号量解决哲学家进餐问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    think;</span><br><span class="line"></span><br><span class="line">    Sswait(chopstick[(i + 1) % 5], chopstick[i]);</span><br><span class="line"></span><br><span class="line">    // Eat</span><br><span class="line"></span><br><span class="line">    Ssignal(chopstick[(i + 1) % 5], chopstick[i]);</span><br><span class="line"></span><br><span class="line">&#125; while (TRUE);</span><br></pre></td></tr></table></figure>

<h3 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h3><p>问题描述：对于系统中的共享对象，把只要求读该文件的进程称为“reader进程”，其它进程称为“writer进程”。所谓读者——写者问题，是指保证一个write进程必须与其它进程互斥地访问共享对象的同步问题。</p>
<p><em><strong>利用记录型信号量解决读者—写者问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore rmutex=1, wmutex = 1;</span><br><span class="line">int readcount = 0;</span><br><span class="line"></span><br><span class="line">void reader() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(rmutex);</span><br><span class="line">        if (readcount == 0) then wait(wmutex);</span><br><span class="line">        readcount = readcount + 1;</span><br><span class="line">        signal(rmutex);</span><br><span class="line"></span><br><span class="line">        // Perform read operation</span><br><span class="line"></span><br><span class="line">        wait(rmutex);</span><br><span class="line">        readcount = readcount - 1;</span><br><span class="line">        if (readcount == 0) then signal(wmutex);</span><br><span class="line">        signal(rmutex);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(wmutex);</span><br><span class="line">        </span><br><span class="line">        // Perform write operation</span><br><span class="line">        </span><br><span class="line">        signal(wmutex);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        reader();</span><br><span class="line">        writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>信号量集解决读者—写者问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int RN;</span><br><span class="line">Semaphore L = RN, mx = 1;</span><br><span class="line"></span><br><span class="line">// RN标示同时允许多少读进程存在</span><br><span class="line">void reader() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        swait(L, 1, 1);</span><br><span class="line">        swait(mx, 1, 0);</span><br><span class="line"></span><br><span class="line">        // Perform read operation</span><br><span class="line"></span><br><span class="line">        ssignal(L, 1);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        swait(mx, 1, 1;L, RN, 0);</span><br><span class="line">        </span><br><span class="line">        // Perform write operation</span><br><span class="line"></span><br><span class="line">        ssignal(mx, 1);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        reader();</span><br><span class="line">        writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><p>有一个理发师，一把理发椅和n把供等候理发的顾客坐的椅子。如果没有顾客，理发师便在理发椅上睡觉；当一个顾客到来时，必须唤醒理发师进行理发；如果理发师正在理发时又有顾客到来，则如果有空椅子可坐，他就坐下来等，如果没有空椅子，他就离开。为理发师和顾客各编一段程序描述他们的行为。</p>
<p>使用三个信号量：<br>◼ customers用来记录等候理发的顾客数（不包括正在理发的顾客），其初值为0；<br>◼ barbers记录正在等候顾客的理发师数，其值为0或1；<br>◼ mutex用于实现共享变量的互斥访问，其初值为1。<br>◼ 共享变量count，它也用于记录等候的顾客数，它实际上是customers的一个备份，之所以使用count是因为无法读取信号量的当前值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore customers = 0; // 等候的顾客数</span><br><span class="line">semaphore barbers = 0;   // 等候顾客的理发师数</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">int count = 0;           // 等候的顾客数（还没理发）</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        barbers();</span><br><span class="line">        customers();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">barber() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        p(customers); // 是否有等候的顾客</span><br><span class="line">        p(mutex);</span><br><span class="line">        count = count - 1; // 顾客数减1</span><br><span class="line">        v(barbers);       // 理发师开始理发</span><br><span class="line">        v(mutex);</span><br><span class="line">        理发;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customer() &#123;</span><br><span class="line">    p(mutex);</span><br><span class="line">    if (count &lt; n) &#123;</span><br><span class="line">        count = count + 1; // 若有空椅子则等候的顾客数加1</span><br><span class="line">        v(customers);</span><br><span class="line">        v(mutex);</span><br><span class="line">        p(barbers);//无理发师,顾客坐着</span><br><span class="line">        理发;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        v(mutex); // 无空椅子则离开</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信——是指进程之间的信息交换。由于每个进程都有自己独立的地址空间，因此一个进程无法直接访问另一个进程的变量或数据结构。</p>
<p><em><strong>进程通信的类型</strong></em></p>
<p>1.共享存储器系统<br>（1）基于共享数据结构的通信方式。<br>（2）基于共享存储区的通信方式。<br>2.消息传递系统<br>• 是目前的主要通信方式，信息单位：消息（报文）<br>• 实现：一组通信命令（原语），具有透明性→同步的实现。<br>实现方式的不同，而分成：<br>（1）直接通信方式</p>
<p>这是指发送进程利用OS所提供的发送命令，直接把消息发送给目标进程。<br>系统提供下述两条通信命令（原语）：<br>Send （Receiver， message）；Receive（Sender， message）；</p>
<p>例：解决生产—消费问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	… </span><br><span class="line">	produce an item in nextp; </span><br><span class="line">	…</span><br><span class="line">	send(consumer, nextp);</span><br><span class="line">&#125;while(TRUE);</span><br><span class="line">do&#123;</span><br><span class="line">	receive( producer, nextc);</span><br><span class="line">	…</span><br><span class="line">	consumer the item in nextc;</span><br><span class="line">&#125;while(TRUE);</span><br></pre></td></tr></table></figure>

<p>（2）间接通信方式</p>
<p>指进程之间利用<strong>信箱</strong>的通信方式。发送进程发送给目标进程的消息存放信箱；接收进程则从该信箱中，取出对方发送给自己的消息；消息在信箱中可以安全地保存，只允许核准的目标用户随时读取。系统为信箱通信提供了若干条原语，分别用于信箱的<br>创建、撤消和消息的发送、接收等。</p>
<p>Send (mailbox, message);Receive (mailbox, message)</p>
<p>3.管道（Pipe）通信</p>
<p>管道：连接一个读进程和一个写进程之间通信的共享文件。<br>功能：大量的数据发收。</p>
<p>4.信号</p>
<hr>
<p>在生产者—消费者问题中，如果缺少了signal(full)或signal(empty)，对执行结果将会有何影响？</p>
<p><strong>如果缺少了<code>signal(full)</code>，则消费者进程将无法从缓冲区中取出产品</strong>。这是因为消费者进程在每次取出产品之前，都会调用<code>wait(full)</code>来检查缓冲区中是否有产品。如果缺少了<code>signal(full)</code>，则缓冲区中的产品数量将永远为0，消费者进程将一直被阻塞。<strong>如果缺少了<code>signal(empty)</code>，则生产者进程将无法向缓冲区中添加新的产品</strong>。这是因为生产者进程在每次生产新产品之前，都会调用<code>wait(empty)</code>来检查缓冲区是否有空闲位置。如果缺少了<code>signal(empty)</code>，则缓冲区中的空闲位置数量将永远为0，生产者进程将一直被阻塞。</p>
<p>尝试利用记录型信号量写出一个不会出现死锁的哲学家进餐问题的算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">semaphore num = 4;</span><br><span class="line"></span><br><span class="line">void philosopher(int i) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        wait(num);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[(i + 1) % 5]);</span><br><span class="line"></span><br><span class="line">        // 进行进餐操作</span><br><span class="line"></span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[(i + 1) % 5]);</span><br><span class="line">        signal(num);</span><br><span class="line"></span><br><span class="line">        // 进行思考操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试修改下面生产者—消费者问题解法中的错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void producer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 生成一个项目 nextp</span><br><span class="line"></span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(full);</span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        signal(mutex);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(empty);</span><br><span class="line">        nextc = buffer[out];</span><br><span class="line">        out = (out + 1) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line"></span><br><span class="line">        // 消费 nextc 项目</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void producer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 生成一个项目 nextp</span><br><span class="line"></span><br><span class="line">        wait(empty);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        in = (in + 1) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(full);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(full);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextc = buffer[out];</span><br><span class="line">        out = (out + 1) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);</span><br><span class="line"></span><br><span class="line">        // 消费 nextc 项目</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之处理机调度与死锁</title>
    <url>/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6/</url>
    <content><![CDATA[<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><p>处理机是系统最重要的资源，提高处理机的利用率和改善系统性能，在很大程度上取决于处理机调度性能的好坏。</p>
<h2 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h2><p>1）高级调度（作业调度，长程调度）<br>2）低级调度（进程调度，短程调度）<br>3）中级调度（交换调度， 中程调度）</p>
<p>1、高级调度<br>▪调度对象：作业<br>▪又称作业调度、长程调度、接纳调度<br>▪实现：作业管理程序<br>▪将<strong>外存作业调入内存</strong>，创建PCB等，插入就绪队列。<br>▪用于批处理系统，分&#x2F;实时系统一般直接入内存，无此环节。<br>▪频度：最低，分钟级</p>
<p>2、低级调度<br>▪又称进程调度或短程调度<br>▪对象：就绪进程（或内核线程）<br>▪功能：决定就绪队列中的哪个进程应获得处理机，并将处理机分配给选中的进程。<br>▪实现者 ：分派程序（dispatcher)<br>▪应用范围：都有<br>▪频度：最频繁，毫秒级</p>
<p> 引起进程调度的因素可归结为这样几个：<br>①正在执行的进程执行完毕，或因发生某事件而不能再继续执行；<br>②执行中的进程因提出I&#x2F;O请求而暂停执行；<br>③在进程通信或同步过程中执行了某种原语操作，如P操作（wait操作）、Block原语、 Wakeup原语等。</p>
<p>3.中级调度<br>▪又称内存调度、中程调度<br>▪对象：挂起的进程<br>▪功能：把外存上那些已经具备运行条件的就绪进程重新载入内存。从静止就绪到活动就绪。<br>▪实现：内存管理中的对换进程<br>▪应用范围：具有对换功能的操作系统<br>▪频度：中等</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_19-10-49.png"></p>
<h2 id="调度算法的准则"><a href="#调度算法的准则" class="headerlink" title="调度算法的准则"></a>调度算法的准则</h2><p><em><strong>面向用户的准则</strong></em></p>
<p>　① 周转时间短，周转时间是指从作业被提交给系统开始，到作业完成为止这段时间间隔，它包括四部分：作业在外存后备队列上等待调度的时间，进程在就绪队列上等待进程调度的时间，进程在CPU上执行的时间，进程等待I&#x2F;O操作完成的时间。</p>
<p>　② 响应时间快，从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的一段时间间隔。包括三个部分：输入时间、处理时间、显示时间。</p>
<p>　③ 截止时间的保证，某任务必须开始执行的最迟时间，或必须完成的最迟时间。</p>
<p>　④ 优先权准则，让某些紧急的作业能够得到及时处理。</p>
<p><em><strong>面向系统的准则</strong></em></p>
<p>　① 系统吞吐量高，指在单位时间内系统所完成的作业数。</p>
<p>　② 处理机利用率好</p>
<p>　③ 各类资源的平衡利用</p>
<p><em><strong>最优准则</strong></em></p>
<p>❖最大的CPU利用率<br>❖最大的吞吐量<br>❖最短的周转时间<br>❖最短的等待时间<br>❖最短的响应时间</p>
<p>CPU利用率 &#x3D; CPU的有效工作时间 &#x2F; （CPU有效工作时间 + CPU空闲等待时间）</p>
<p>平均周转时间：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_19-14-39.png"></p>
<p>带权周转时间：作业的周转时间T与系统为它提供服务的时间Ts之比。 W &#x3D; T&#x2F;Ts<br>▪带权周转时间标明了作业额外等待和作业执行时间之间的比例。<br>▪平均带权周转时间：反应调度算法的好坏。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_19-25-56.png"></p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务调度算法"><a href="#先来先服务调度算法" class="headerlink" title="先来先服务调度算法"></a>先来先服务调度算法</h3><p>先来先服务调度算法（First Come FirstService，FCFS)：按照作业提交或进程变为就绪状态的先后次序，分派CPU；当前作业或进程占用CPU，直到执行完或阻塞，才主动地出让CPU。 FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。 FCFS调度算法有利于CPU繁忙型的作业，而不利于I&#x2F;O繁忙型的作业。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_19-37-49.png"></p>
<p>可见短作业的带权周转时间明显高于长作业。</p>
<h3 id="短作业优先调度算法"><a href="#短作业优先调度算法" class="headerlink" title="短作业优先调度算法"></a>短作业优先调度算法</h3><p>短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。<br>➢短作业优先(SJF)的调度算法，是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。<br>➢短进程优先(SPF)调度算法，则是从就绪队列中选出一估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_19-40-34.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_19-41-38.png"></p>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>Priority-scheduling algorithm, PSA，外部赋予作业（进程）相应的优先级，例如以作<br>业的紧迫程度作为优先级。选择优先级高的进程投入运行。即可用于作业调度算法，也可用于进程调度。分为非抢占式优先级调度算法和抢占式优先级调度算法。</p>
<p>例题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/20210420203522284.png"></p>
<p>非抢占式：</p>
<blockquote>
<p>0时刻(P1):只有P1到达，P1上处理机。</p>
<p>7时刻(P2、P3，P4):P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机。</p>
<p>8时刻(P2、P4):P3完成，P2P4优先级相同，由于P2先到达，因此P2优先上处理机。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/20210420203821701.png"></p>
<p>抢占式：</p>
<blockquote>
<p>0时刻(P1):只有P1到达，P1上处理机。</p>
<p>2时刻(P2):P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机。</p>
<p>4时刻(P1、P3):P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机。</p>
<p>5时刻(P1、P2、P4):P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机</p>
<p>7时刻(P1P4):P2完成，就绪队列只剩P1、P4，P4上处理机。11时刻(P1):P4完成，P1上处理机</p>
<p>16时刻():P1完成，所有进程均完成。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/20210420204141551.png"></p>
<h3 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h3><p>Highest Response Ratio Next， HRRN，赋予作业动态优先级，优先级随作业等待时间延长而增加，从而使长作业的优先级在等待期间不断增加。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_19-41-38.png"></p>
<p>优先级相当于响应比Rp。</p>
<p>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。对于长作业，作业的优先级可以随等待时间的增加而提高， 从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。</p>
<table>
<thead>
<tr>
<th>作业</th>
<th>到达时间</th>
<th>服务时间</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<td>B</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>C</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>D</td>
<td>4</td>
<td>1</td>
</tr>
</tbody></table>
<p>（1）先执行A作业</p>
<table>
<thead>
<tr>
<th>作业</th>
<th>到达时间</th>
<th>服务时间</th>
<th>开始时间</th>
<th>结束时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>6</td>
<td>0</td>
<td>6</td>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>3</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>4</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>4</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>（2）根据响应比，执行D作业</p>
<p>等待时间 &#x3D; 上一个作业调入完成时间 - 该作业到达的时间</p>
<p>响应比高的先执行</p>
<p>R（B） &#x3D; 1 + （6 - 3）&#x2F; 2 &#x3D; 2.5<br>R（C） &#x3D; 1 + （6 - 4）&#x2F; 4 &#x3D; 1.5<br>R（D）&#x3D; 1 + （6 - 4） &#x2F; 1 &#x3D; 3</p>
<table>
<thead>
<tr>
<th>作业</th>
<th>到达时间</th>
<th>服务时间</th>
<th>开始时间</th>
<th>结束时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>6</td>
<td>0</td>
<td>6</td>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>3</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>4</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>4</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>
<p>（3）根据响应比，执行B作业<br>R（B） &#x3D; 1 + （7 - 3）&#x2F; 2 &#x3D; 3<br>R（C） &#x3D; 1 + （7 - 4）&#x2F; 4 &#x3D; 1.75</p>
<table>
<thead>
<tr>
<th>作业</th>
<th>到达时间</th>
<th>服务时间</th>
<th>开始时间</th>
<th>结束时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>6</td>
<td>0</td>
<td>6</td>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>3</td>
<td>2</td>
<td>7</td>
<td>10</td>
<td>7</td>
<td>3.5</td>
</tr>
<tr>
<td>C</td>
<td>4</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>4</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>
<p>（4）最后执行C作业</p>
<table>
<thead>
<tr>
<th>作业</th>
<th>到达时间</th>
<th>服务时间</th>
<th>开始时间</th>
<th>结束时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>6</td>
<td>0</td>
<td>6</td>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>3</td>
<td>2</td>
<td>7</td>
<td>10</td>
<td>7</td>
<td>3.5</td>
</tr>
<tr>
<td>C</td>
<td>4</td>
<td>4</td>
<td>10</td>
<td>14</td>
<td>10</td>
<td>2.5</td>
</tr>
<tr>
<td>D</td>
<td>4</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>
<h3 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h3><p>RR，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片，当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信息来停止该进程的执行，将它送到<strong>就绪队列末尾</strong>，然后，再把处理机分配给就绪<strong>队列中心的队首</strong>进程，同时也让它执行一个时间片，这样就可以保证就绪队列中的所有进程在一个给定的时间内均能获得一个时间片的处理机执行时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_20-17-31.png"></p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>（1）设置多个就绪队列，并为各个队列赋予不同的优先级。 第一个最高，以后依次降低。<br>（2）每个队列中进程执行时间片的大小也各不相同，进程所在队列的优先级越高，其相应的时间片就越短。</p>
<p>（3）当一个新进程进入内存后，首先将它放入第一队列的<strong>末尾</strong>，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的<strong>末尾</strong>，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……。</p>
<p>（4）<strong>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行</strong>。</p>
<p>未执行完时间片的进程被抢占后如何处理？<br>答：不降级，到队列末尾，且下一次运行时仍然是一个完整时间片（该队列对应的）</p>
<p>注意：统一为抢占式。高优先级队列中有进程进入时，会抢占低优先级队列中进程的CPU。被抢占的进程不降级，回到原级队列中，下次仍然执行该级队列的时间片。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_20-18-14.png"></p>
<p>例题：假设一个多级反馈队列的实现共有4级，各个队列的时间片长度是1、2、4、6秒，已知当前仅在第一级队列上有一个执行时长为10秒的进程，在两秒后将有一个执行时长为8秒的任务A到达，请算出任务A的周转时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_20-19-50.png"></p>
<p>A任务结束时间为18秒。A任务的周转时间为16秒。</p>
<h2 id="死锁的概念、原因"><a href="#死锁的概念、原因" class="headerlink" title="死锁的概念、原因"></a>死锁的概念、原因</h2><p>所谓死锁（Deadlock），是指<strong>多个进程在运行过程中因争夺资源而造成的一种僵局</strong>（DeadlyEmbrace），当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<p><strong>可重用资源</strong>是一种可供用户重复使用多次的资源。</p>
<p>可消耗资源又称为<strong>临时性资源</strong>。</p>
<p><strong>可抢占性资源</strong>，又称可剥夺性资源</p>
<p>一个进程在使用某个资源时,系统可以剥夺其使用权,将该资源分配给其他进程.</p>
<p>典型资源：CPU 、内存</p>
<p><strong>不可抢占性资源</strong>，又称非剥夺性资源</p>
<p>某个资源一旦分配给某个进程，则系统不能剥夺进程的使用权，只能由进程释放资源，或者进程终止运行。</p>
<p>典型资源：打印机、光盘刻录机、磁带机</p>
<p><em><strong>产生死锁的原因</strong></em></p>
<p>（1）竞争资源<br>（2）进程间推进顺序非法</p>
<p>产生死锁中的竞争资源之一指的是竞争不可剥夺资源(例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞)。产生死锁中的竞争资源另外一种资源指的是竞争临时资源(临时资源包括硬件中断、信号、消息、缓冲区内的消息等)，通常消息通信顺序进行不当，则会产生死锁。</p>
<p>产生死锁的原因之一是对计算机操作不当，造成计算机死机。（ ×）</p>
<h2 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h2><p>死锁的发生必须具备下列四个必要条件：<br>（1）互斥条件<br>（2）请求和保持条件<br>（3）不剥夺条件<br>（4）环路等待条件</p>
<p>环路等待条件是指，在死锁发生的时候，两个线程获取资源的顺序构成了环形链。比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环形图。</p>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>为了不发生死锁，必须设法破坏产生死锁的四个必要条件之一。因为<strong>互斥条件</strong>是由设备的固有属性所决定的，不仅不能改变，还应加以保证。</p>
<p><em><strong>破坏“请求和保持”条件</strong></em></p>
<p>系统规定所有进程在开始运行之前，都必须<strong>一次性地申请其在整个运行过程所需的全部资源</strong>。从而进程在整个运行期间，便不会再提出资源要求，从而摒弃了请求和保持条件，由此可以避免发生死锁。</p>
<p>优点：简单、易于实现且很安全。缺点：资源被严重浪费，使进程延迟运行</p>
<p><em><strong>摒弃“不剥夺”条件</strong></em></p>
<p>当一个已经保持了某些资源的进程，<strong>再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源</strong>。待以后需要时再重新申请。从而摒弃了“不剥夺”条件。<br>缺点：实现起来比较复杂且要付出很大代价。<br>一个资源在使用一段时间后，它的被迫释放可能会造成前段工作的失效。会使进程前后两次运行的信息不连续。因反复地申请和释放资源，致使进程执行被无限推迟，延长进程周转时间、增加系统开销、降低吞吐量。</p>
<p><em><strong>摒弃“环路等待”条件</strong></em></p>
<p>系统将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出。</p>
<p>优点：资源利用率和系统吞吐量都有明显的改善。</p>
<p>存在的问题：首先是为系统中各类资源所分配（确定）的序号，必须相对稳定，这就限制了新类型设备的增加；作业（进程）使用各类资源的顺序，与系统规定的顺序不同，造成对资源的浪费 ;限制用户简单、自主地编程 。</p>
<h2 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h2><p>所谓安全状态，是指系统能按某种进程顺序，如&lt;P1，P2，…，Pn&gt;，依次为n个进程分配其所需资源，直至其最大需求，使每个进程都可顺利地完成，称系统处于安全状态。称〈P1，P2，…，Pn〉序列为安全序列。否则，如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p>
<p>如果一个系统在安全状态，就没有死锁。如果一个系统处于不安全状态，就有可能死锁。避免死锁的实质：确保系统不进入不安全状态。</p>
<p>假定系统中有三个进程P1、P2和P3，共有12台磁带机。进程P1总共要求10台磁带机，P2和P3分别要求4台和9台。假设在T0 时刻进程P1、P2和P3已分别获得5台、2台和2台磁带机，尚有3台空闲未分配，在T0时刻系统是否安全？</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>最大需求</th>
<th>已分配</th>
<th>可用</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>10</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>P2</td>
<td>4</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>P3</td>
<td>9</td>
<td>2</td>
<td></td>
</tr>
</tbody></table>
<p>T0时刻系统是安全的,存在一个安全序列&lt;P2,P1,P3&gt;</p>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>避免死锁的关键在于如何准确的预测是否会出现死锁，从而避免死锁。</p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>例：有四个顾客：A，B，C，D，每个顾客分成若干次借款；并在第一次借款时，顾客提出的最大贷款数量分别为6、5、4、7。银行家知道不是所有顾客都马上需要其全部贷款（6+5+4+7&#x3D;22）。 因此，他只保留10个单位数量(而不是全部22个单位)为这些顾客服务。</p>
<table>
<thead>
<tr>
<th>顾客</th>
<th>拥有</th>
<th>最大要求</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>D</td>
<td>0</td>
<td>7</td>
</tr>
</tbody></table>
<p>银行家拥有量:10</p>
<table>
<thead>
<tr>
<th>顾客</th>
<th>拥有</th>
<th>最大要求</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>D</td>
<td>4</td>
<td>7</td>
</tr>
</tbody></table>
<p>当前剩余量: 2</p>
<table>
<thead>
<tr>
<th>顾客</th>
<th>拥有</th>
<th>最大要求</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>B</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>D</td>
<td>4</td>
<td>7</td>
</tr>
</tbody></table>
<p>当B请求1个时，当前剩余量:1。现在银行家要破产了，剩余的资金贷给谁都不够，因此项目不能完成，银行家不能收回贷款。错误发生在最后贷款给B的1个亿上。</p>
<table>
<thead>
<tr>
<th>顾客</th>
<th>拥有</th>
<th>最大要求</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>D</td>
<td>4</td>
<td>7</td>
</tr>
</tbody></table>
<p>当前剩余量: 2<br>B请求：不贷款；C请求2个亿：可以贷款<br>C完成项目后，还出4，这个4银行家下次可贷给B，也可贷给D其中的3，不管如何处理，B或D都能完成归还5或归还7；最后贷给A所需资金5。最终，A、B、C、D都完成了项目，银行家得到了贷款利润。存在的安全序列是：C、B、D、A或C、D、B、A</p>
<p>银行家算法能预测一笔贷款业务对银行是否是安全的，该算法也能预测一次资源分配对计算机系统是否是安全的。为实现银行家算法，系统中必须设置若干<strong>数据结构</strong>。</p>
<ul>
<li>n个进程（P1，P2，…，Pn）</li>
<li>m类资源（R1，R2，…，Rm）</li>
<li>可利用资源向量：available[j]&#x3D;k，资源Rj类有k个可用</li>
<li>最大需求矩阵：Max[i, j]&#x3D;k，进程Pi最大请求k个Rj类资源</li>
<li>分配矩阵：Allocation[i, j]&#x3D;k，进程Pi分配到k个Rj类资源</li>
<li>需求矩阵：Need[i, j]&#x3D;k，进程Pi还需要k个Rj类资源</li>
</ul>
<p>三个矩阵的关系： Need[i, j] &#x3D; Max[i, j] – Allocation[i, j]</p>
<p>设Requesti，是进程Pi的请求向量，当Pi发出资源请求后，系统按下述步骤进行检查：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_21-30-34.png"></p>
<p><em>系统所执行的安全性算法可描述如下</em>：</p>
<p>（1）设置两个向量：<br>①工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，Work &#x3D;Available<br>②Finish：开始时先做Finish[i] &#x3D; false；当有足够资源分配给进程时，再令Finish[i] &#x3D; true。<br>（2）从进程集合中找到一个能满足下述条件的进程：<br>①Finish[i] &#x3D; false；<br>②Need[i,j] ≤ work[j]；<br>若找到，执行步骤（3)；否则，执行步骤（4）。</p>
<p>（3）当进程只获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：<br>    Work[ j ] &#x3D; Work[ i ] + Allocation[ i,j ]；<br>    Finish[ i ] &#x3D; true;<br>    go to step 2；<br>（4）如果所有进程的Finish[i] ＝ true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_21-31-12.png"></p>
<p>例题：假定系统中有五个进程{P0，P1，P2，P3，P4} 和三类资源{A ,B,C},各种资源的数量分别为10、5、7，在T0 时刻的资源分配情况</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>Max (A, B, C)</th>
<th>Allocation (A, B, C)</th>
<th>Need (A, B, C)</th>
<th>Available (A, B, C)</th>
</tr>
</thead>
<tbody><tr>
<td>P0</td>
<td>7 5 3</td>
<td>0 1 0</td>
<td>7 4 3</td>
<td>3 3 2</td>
</tr>
<tr>
<td>P1</td>
<td>3 2 2</td>
<td>2 0 0</td>
<td>1 2 2</td>
<td></td>
</tr>
<tr>
<td>P2</td>
<td>9 0 2</td>
<td>3 0 2</td>
<td>6 0 0</td>
<td></td>
</tr>
<tr>
<td>P3</td>
<td>2 2 2</td>
<td>2 1 1</td>
<td>0 1 1</td>
<td></td>
</tr>
<tr>
<td>P4</td>
<td>4 3 3</td>
<td>0 0 2</td>
<td>4 3 1</td>
<td></td>
</tr>
</tbody></table>
<p><em>利用安全性算法对T0时刻的资源分配情况进行分析</em></p>
<table>
<thead>
<tr>
<th>进程</th>
<th>Work (A, B, C)</th>
<th>Need (A, B, C)</th>
<th>Allocation (A, B, C)</th>
<th>Work+Allocation (A, B, C)</th>
<th>Finish</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>3 3 2</td>
<td>1 2 2</td>
<td>2 0 0</td>
<td>5 3 2</td>
<td>TRUE</td>
</tr>
<tr>
<td>P3</td>
<td>5 3 2</td>
<td>0 1 1</td>
<td>2 1 1</td>
<td>7 4 3</td>
<td>TRUE</td>
</tr>
<tr>
<td>P4</td>
<td>7 4 3</td>
<td>4 3 1</td>
<td>0 0 2</td>
<td>7 4 5</td>
<td>TRUE</td>
</tr>
<tr>
<td>P2</td>
<td>7 4 5</td>
<td>6 0 0</td>
<td>3 0 2</td>
<td>10 4 7</td>
<td>TRUE</td>
</tr>
<tr>
<td>P0</td>
<td>10 4 7</td>
<td>7 4 3</td>
<td>0 1 0</td>
<td>10 5 7</td>
<td>TRUE</td>
</tr>
</tbody></table>
<p><em>判断请求是否可以满足</em></p>
<p>P1请求资源：P1发出请求向量Request1(1,0,2),系统按银行家算法进行检查<br>①Request1（1，0，2）≤Need1（1，2，2）<br>②Request1（1，0，2）≤Available1（3,3,2)<br>③系统先假定可为P1分配资源，并修改Available，Allocation1和Need1向量，由此形成的资源变化情况如下表所示。<br>④再利用安全性算法检查此时系统是否安全。</p>
<p><em>假设分配后调整表格</em></p>
<table>
<thead>
<tr>
<th>进程</th>
<th>Max (A, B, C)</th>
<th>Allocation (A, B, C)</th>
<th>Need (A, B, C)</th>
<th>Available (A, B, C)</th>
</tr>
</thead>
<tbody><tr>
<td>P0</td>
<td>7 5 3</td>
<td>0 1 0</td>
<td>7 4 3</td>
<td>2 3 0</td>
</tr>
<tr>
<td>P1</td>
<td>3 2 2</td>
<td>3 0 2</td>
<td>0 2 0</td>
<td></td>
</tr>
<tr>
<td>P2</td>
<td>9 0 2</td>
<td>3 0 2</td>
<td>6 0 0</td>
<td></td>
</tr>
<tr>
<td>P3</td>
<td>2 2 2</td>
<td>2 1 1</td>
<td>0 1 1</td>
<td></td>
</tr>
<tr>
<td>P4</td>
<td>4 3 3</td>
<td>0 0 2</td>
<td>4 3 1</td>
<td></td>
</tr>
</tbody></table>
<p><em>P1 申请资源时的安全性检查</em></p>
<table>
<thead>
<tr>
<th>进程</th>
<th>Work (A, B, C)</th>
<th>Need (A, B, C)</th>
<th>Allocation (A, B, C)</th>
<th>Work+Allocation (A, B, C)</th>
<th>Finish</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>2 3 0</td>
<td>0 2 0</td>
<td>2 0 3</td>
<td>5 3 2</td>
<td>TRUE</td>
</tr>
<tr>
<td>P3</td>
<td>5 3 2</td>
<td>0 1 1</td>
<td>2 1 1</td>
<td>7 4 3</td>
<td>TRUE</td>
</tr>
<tr>
<td>P4</td>
<td>7 4 3</td>
<td>4 3 1</td>
<td>0 0 2</td>
<td>7 4 5</td>
<td>TRUE</td>
</tr>
<tr>
<td>P0</td>
<td>7 4 5</td>
<td>7 5 5</td>
<td>0 1 0</td>
<td>7 5 5</td>
<td>TRUE</td>
</tr>
<tr>
<td>P2</td>
<td>10 5 5</td>
<td>6 0 0</td>
<td>3 0 2</td>
<td>10 5 7</td>
<td>TRUE</td>
</tr>
</tbody></table>
<p>P4请求资源：P4发出请求向量Request4（3,3,0），系统按银行家算法进行检查：<br>①Request4（3，3，0）≤Need4（4，3，1）；<br>②Request4(3，3， 0)≮Available（2，3，0），让P4等待。</p>
<p>P0请求资源：P0发出请求向量Requst0(0,2,0），系统按银行家算法进行检查：<br>①Request0（0, 2,0）≤Need0（7，4，3）；<br>②Request0（0,2,0）≤Available（2，3，0）；<br>③系统暂时先假定可为P0分配资源，并修改有关数据，<br>如下表所示。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>Allocation (A, B, C)</th>
<th>Need (A, B, C)</th>
<th>Available (A, B, C)</th>
</tr>
</thead>
<tbody><tr>
<td>P0</td>
<td>0 3 0</td>
<td>7 2 3</td>
<td>2 1 0</td>
</tr>
<tr>
<td>P1</td>
<td>3 0 2</td>
<td>0 2 0</td>
<td></td>
</tr>
<tr>
<td>P2</td>
<td>3 0 2</td>
<td>6 0 0</td>
<td></td>
</tr>
<tr>
<td>P3</td>
<td>2 1 1</td>
<td>0 1 1</td>
<td></td>
</tr>
<tr>
<td>P4</td>
<td>0 0 2</td>
<td>4 3 1</td>
<td></td>
</tr>
</tbody></table>
<p>进行安全性检查：可用资源Available（2，1，0）已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。</p>
<p><em><strong>避免死锁的限制条件</strong></em><br>a) 预先必须申明每个进程需要的资源总量；<br>b) 进程之间相互独立，其执行顺序取决于系统安全，而非进程间的同步要求；<br> c) 系统必须提供固定数量的资源供进程使用；</p>
<p>补充问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_22-30-20.png"></p>
<h2 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h2><p>检测死锁的基本思想: 利用某种算法对资源请求和分配信息加以检查，以判断是否存<br>在死锁。</p>
<p><em><strong>资源分配图 G &#x3D; (N,E)</strong></em></p>
<p>（1）把N分为两个互斥的子集，即一组进程结点P&#x3D;{P1,P2，…，Pn）和一组资源结点R&#x3D;{r1, r2, …, rn}，N＝P U R。<br>（2）凡属于E中的一个边e∈ E都连接着P中的一个结点和R中的一个结点，e＝{Pi,rj} 它表示进程pj请求一个单位的rj资源。 e&#x3D;{rj，Pi} 它表示把一个单位的资源rj分配给进程Pi。</p>
<p><strong>重要结论</strong>：如果资源分配图中不存在环路，则系统中不存在死锁；反之，如果资源分配图中存在环路，则系统中可能存在死锁，也可能不存在死锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-17_09-36-47.png"></p>
<p><strong>资源分配图加以简化的方法</strong></p>
<p>（1）寻找一个既不阻塞又非孤立的进程结点Pi（能分配给满足Pi要求的资源数），若无，则算法结束；<br>（2）去除Pi的所有分配边和请求边，使Pi成为一个孤立节点；<br>（3）转步骤（1）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-17_09-46-23.png"></p>
<p>若能消去资源分配图中所有结点的连接边，使全部结点都成为孤立结点，则称该图是可完全简化图；若不能使该图完全简化，则称该图是不可完全化简图。 可以证明：当且仅当<strong>系统某状态S所对应的资源分配图是不可完全化简的，则S是死锁状态</strong>。该充分条件称为死锁定理。</p>
<p><em><strong>死锁的解除</strong></em></p>
<p>当发现有进程死锁时，常采用的两种方法是<br>解除死锁：<br>（1）剥夺资源。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。<br>（2）撤消进程。最简单的撤消进程的方法，是使全部死锁进程都夭折掉；或者按照某种顺序（<strong>按照解除死锁复杂度递增的顺序</strong>）逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为止。</p>
<hr>
<p>死锁产生，必须要满足四个必要条件，所以，为避免死锁产生，主要注意如何不让这四个必要条件成立，并打破循环等待资源的环路。（×）注意避免与预防的差异</p>
<p>死锁的检测可以通过（资源分配 ）图，利用（ 死锁）定理来实现。</p>
<p>什么叫系统处于安全状态？常用什么方法保持系统处于安全状态？</p>
<p>如果操作系统能保证所有的进程在有限的时间内得到需要的全部资源,则称系统处于安全状态。常用银行家算法动态地检测系统中的资源分配情况和进程对资源的需求情况进行资源分配,确保系统处于安全状态。</p>
<p>系统中有3个进程，4个相同类型的资源，每个进程最多需要2个资源，该系统是否回发生死锁？为什么？</p>
<p>不会发生死锁，6-4&lt;3。</p>
<p>资源分配图如下图，系统是否处于死锁状态？</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-17_09-58-35.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-17_09-58-47.png"></p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之shell编程</title>
    <url>/2023/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7/</url>
    <content><![CDATA[<p><strong>Shell</strong>是系统的<strong>用户界面</strong>，提供了<strong>用户</strong>与<strong>内核</strong>进行交互操作的一种<strong>接口</strong>。它接收用户输入的命令并把它送入内核去执行。</p>
<p>①Shell是一个<strong>命令解释器</strong>，它解释由用户输入的命令并且把它们送到内核。</p>
<p>②Shell是一个解释型的程序设计语言。</p>
<p>以下对linux进程管理的作用描述正确的有（ABC） </p>
<p> A.判断服务器的健康状态 </p>
<p>B.查看系统中所有的进程 </p>
<p>C.杀死进程 </p>
<p>D.查看服务器CPU信息</p>
<h2 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h2><ol>
<li><p>date：打印或设置系统日期和时间。</p>
</li>
<li><p>who：查看系统中所有已登录用户的情况。</p>
</li>
<li><p>passwd：修改用户密码。</p>
</li>
<li><p>logout, login：登录shell的登录和注销命令。</p>
</li>
<li><p>pwd：打印工作路径。</p>
</li>
<li><p>more, less, head,tail：显示或部分显示文件内容。</p>
</li>
<li><p>lp&#x2F;lpstat&#x2F;cancel, lpr&#x2F;lpq&#x2F;lprm：打印文件。</p>
</li>
<li><p>chmod u+x：更改文件权限。</p>
</li>
<li><p>rm -fr dir：删除非空目录。</p>
</li>
<li><p>cp -R dir：拷贝目录。</p>
</li>
<li><p>fg jobid：将一个后台进程放到前台。</p>
<ul>
<li>使用Ctrl+z可以将前台进程挂起（suspend），然后可以使用bgjobid命令将其放到后台运行。</li>
</ul>
<ul>
<li>使用job&amp;可以直接让作业在后台运行。</li>
</ul>
</li>
<li><p>kill：删除执行中的程序或工作。</p>
</li>
<li><p>ps：列出当前运行的进程。</p>
<ul>
<li>不带参数的ps命令运行时, 显示该用户当前活动进程的基本信息</li>
<li>ps命令的常用任选项 -e (或-a) 显示系统中所有活动进程的信息.</li>
<li>-f 显示该进程的所有信息.</li>
</ul>
</li>
</ol>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><blockquote>
<p>标准输入： 键盘 fd &#x3D; 0</p>
<p>标准输出： 荧光屏 fd &#x3D; 1</p>
<p>标准错误输出：荧光屏 fd &#x3D; 2</p>
</blockquote>
<p>command &gt; filename 进程输出覆盖文件 filename </p>
<p>command &gt;&gt; filename 进程输出追加到文件filename后面, 不覆盖filename</p>
<p>例如:</p>
<p>把文件myfile的内容输出到标准输出文件—-荧光屏上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> myfile</span></span><br></pre></td></tr></table></figure>

<p>把文件myfile的内容输出到文件newfile中(标准输出已被重新定向到newfile). 其结果相当于拷贝文件.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> myfile &gt; newfile</span></span><br></pre></td></tr></table></figure>

<p>把abc添加到xyz已有内容后面, 而不是覆盖xyz</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> abc &gt;&gt; xyz</span></span><br></pre></td></tr></table></figure>

<p>应用举例:<br>① 按字母顺序显示当前系统中所有已登录的用户:</p>
<p> 把当前登录用户的名单保存在temp1中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span> &gt; temp1</span></span><br></pre></td></tr></table></figure>

<p>把排序后的名单保存在temp2中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> temp1 &gt; temp2</span> </span><br></pre></td></tr></table></figure>

<p>逐屏显示排好序的用户名单</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more temp2</span> </span><br></pre></td></tr></table></figure>

<p>删除不用的临时文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> temp1 temp2</span> </span><br></pre></td></tr></table></figure>

<p>② 记录长时间运行程序的日志:</p>
<p>把排序后的名单累加(而不是覆盖)到文件temp2中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> temp1 &gt;&gt; temp2</span> </span><br></pre></td></tr></table></figure>

<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>command &lt; filename<br>进程的输入来自文件filename, 例如:</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-17_11-33-54.png"></p>
<p>cat进程的输入不是来自命令行参数，而是来自重定向文件abc，cat进程的输出送到标准输出荧光屏上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt; abc</span></span><br><span class="line">aaaaaaaaaaaaaaa</span><br><span class="line">bbbbbbbb</span><br><span class="line">cccccccccccccccccc</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p><em><strong>常见输入输出重定向方式</strong></em></p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th>输入</th>
<th>输出</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cat</td>
<td>键盘</td>
<td>屏幕</td>
<td>将键盘输入显示在屏幕上</td>
</tr>
<tr>
<td align="left">cat  file1</td>
<td>file1</td>
<td>屏幕</td>
<td>file1的内容显示在屏幕上</td>
</tr>
<tr>
<td align="left">cat  file1 &gt; file2</td>
<td>file1</td>
<td>file2</td>
<td>file1的内容写入file2中</td>
</tr>
<tr>
<td align="left">cat           &gt; file2</td>
<td>键盘</td>
<td>file2</td>
<td>键盘输入的内容写入file2</td>
</tr>
<tr>
<td align="left">cat &lt; file1</td>
<td>file1</td>
<td>屏幕</td>
<td>file1的内容显示在屏幕上</td>
</tr>
<tr>
<td align="left">cat &lt; file1 &gt; file2</td>
<td>file1</td>
<td>file2</td>
<td>file1的内容写入file2中</td>
</tr>
</tbody></table>
<p>command 2&gt; filename ( 2和&gt;之间没有空格 )，进程运行中的错误信息重定向到文件filename, 例如：</p>
<p>如果命令运行正常, 则把结果(连接file1和file2)存入file3中；如果出现错误, 则把错误信息存放到errfile中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> file1 file2 &gt; file3 2&gt; errfile</span></span><br></pre></td></tr></table></figure>

<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道用于连接两个命令, 它把前一个命令的标准输出重定向给后一个命令作为标准输入, 其格式为:<br>                                    command1 | command2<br>对command1来说标准输出被重新定向到管道, 对command2来说标准输入也被重新定向为管道.</p>
<p>例1：按字母顺序显示当前系统中所有已登录的用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span> | <span class="built_in">sort</span> | more</span></span><br></pre></td></tr></table></figure>

<p>例2:</p>
<p>查看系统当前有几个用户在上机使用系统.(wc - 统计文件的字节数、字数、行数)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span> | <span class="built_in">wc</span> –l</span></span><br></pre></td></tr></table></figure>

<p>把文件myfile按标准打印格式处理后, 送到打印机打印出来(原文件myfile并未作任何修改)。lp - 打印文件或修改排队的打印任务。pr - 将文本文件转换成适合打印的格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pr</span> myfile | lp</span></span><br></pre></td></tr></table></figure>


<p>在包含所有用户名单的文件user_list中, 查找包含student的行, 并把结果排序后存放在文件stu_list中. (管道和输出重定向混合使用)。grep - 强大的文本搜索工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep student user_list | <span class="built_in">sort</span> &gt; stu_list</span></span><br></pre></td></tr></table></figure>

<h2 id="命令形式"><a href="#命令形式" class="headerlink" title="命令形式"></a>命令形式</h2><p><em><strong>单条命令</strong></em></p>
<p>这是最常用命令形式, 本命令执行完成后出现shell提示符, 再接收下一条键盘命令.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> file1</span></span><br></pre></td></tr></table></figure>

<p><em><strong>多条命令</strong></em></p>
<p>第一条命令执行完成后, (无停顿)再执行第二条命令, 如此下去. 运行功能和效果与在键盘上逐条输入命令并运行是完全一样的, 其主要目的是提高键盘命令输入效率。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span>; <span class="built_in">who</span>; <span class="built_in">date</span></span></span><br></pre></td></tr></table></figure>

<p><em><strong>复合命令</strong></em></p>
<p>管道前后的命令任意组合、同时运行, 形成功能更强大灵活的复合命令.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps –e | grep student2</span></span><br></pre></td></tr></table></figure>

<p>括号内的命令任意组合、顺序执行，且由一个子shell来单独控制运行, 相当于一个小的功能程序. 方便灵活, 运行效率高。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(<span class="built_in">ls</span> ; <span class="built_in">cat</span> file3 ; <span class="built_in">pwd</span>) &gt; run_log</span></span><br></pre></td></tr></table></figure>

<p><em><strong>后台命令</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> –lR &gt; file_list &amp;</span></span><br><span class="line">	[1] 7981</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>


<p>普通命令行的行尾加上&amp;符号，就表示该命令在后台执行。</p>
<p>[1]: 当前shell的后台作业（进程）序号</p>
<p>7981: 当前这个后台进程（ls进程）的进程号（PID）。<br>Shell 启动该后台进程后不再等待该进程结束，立即开始接受新的键盘命令——多进程并发, 数量不限, 充分利用系统资源。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>系统的基本环境变量放在&#x2F;etc&#x2F;profile中, 用户环境变量放在用户主目录下的.profile文件中, 用户shell启动时, 先执行&#x2F;etc&#x2F;profile, 再执行用户主目录下的.profile。环境变量可在shell运行时动态修改。</p>
<p>常用的shell环境变量及实例:</p>
<blockquote>
<p>HOME&#x3D;&#x2F;usr&#x2F;computer&#x2F;student6 		用户主目录, 注册时的初始目录</p>
<p>PATH&#x3D;&#x2F;bin:&#x2F;usr&#x2F;bin:$HOME&#x2F;bin:.&#x2F; 		键盘命令的搜索路径</p>
<p>SHELL&#x3D;&#x2F;bin&#x2F;sh 										用户的初始shell的路径名称</p>
<p>TERM&#x3D;vt100 												当前所用的终端类型</p>
<p>PS1&#x3D;$ 															shell的主提示符</p>
<p>IFS&#x3D; 												域分隔符, 通常为空白符, 用来分隔命令行各个域</p>
</blockquote>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>echo命令的基本功能就是在标准输出上显示后面的字符串，或变量的值。当字符串中带空白符或其它控制字符时，用引号将其括起来。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 12345</span></span><br><span class="line">12345</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;department computer&quot;</span></span></span><br><span class="line">department computer</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;My home directory is: <span class="variable">$HOME</span>&quot;</span></span></span><br><span class="line">My home directory is: /usr/teacher/david</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> –n <span class="string">&quot;Input your choice (y/n) [ ]\b\b&quot;</span></span></span><br><span class="line">Input your choice (y/n) [ _ ]</span><br></pre></td></tr></table></figure>

<p>使用echo命令时，输出会自动换行，而使用echo -n命令时，输出不会换行。</p>
<h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>常用系统变量:</p>
<blockquote>
<p>$0 									当前shell程序的名字</p>
<p>$1 ~ $9 							命令行上的第一到第九个参数</p>
<p>$# 									命令行上的参数个数</p>
<p>$* 									命令行上的所有参数</p>
<p>$@ 									分别用双引号引用命令行上的所有参数</p>
<p>$$ 									当前进程的进程标识号(PID)</p>
<p>$? 									上一条命令的退出状态</p>
<p>$! 										最后一个后台进程的进程标识号</p>
</blockquote>
<p>系统变量只能引用不能修改!</p>
<p>系统变量应用举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> aa bb cc <span class="built_in">dd</span> $$</span></span><br><span class="line">aa bb cc dd 2391</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> file1 file2 &gt; file3 2&gt; errlog</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $? 	(非0表示命令运行失败, 错误信息在 errlog 文件中)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span></span></span><br><span class="line">								(空行, 即echo输出串尾隐含的换行符)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> This is a <span class="built_in">test</span>. 			(单词间多个空格)</span></span><br><span class="line">This is a test.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;This is a test.&quot;</span> 		(用引号包括时结果如何?)</span></span><br></pre></td></tr></table></figure>

<h2 id="局部变量-用户变量"><a href="#局部变量-用户变量" class="headerlink" title="局部变量(用户变量)"></a>局部变量(用户变量)</h2><p>局部变量是由用户根据需要任意创建的. 变量名通常由一个字母后跟零个到多个字母、数字或下划线组成。引用变量的值时，在变量名前面加上$符号. 例如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">AA=123 				定义变量AA</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$AA</span> 				引用变量AA的值</span></span><br><span class="line">123 					(变量AA的值)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">B=<span class="string">&quot;this is a string&quot;</span> 	定义变量B， (字符串中有空格时用引号)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$B</span> 				引用变量B的值</span></span><br><span class="line">this is a string 		(变量B的值)</span><br></pre></td></tr></table></figure>

<h2 id="单引号、双引号、反撇号和花括号"><a href="#单引号、双引号、反撇号和花括号" class="headerlink" title="单引号、双引号、反撇号和花括号"></a>单引号、双引号、反撇号和花括号</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">a=<span class="string">&quot;he is a student&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;She said: <span class="variable">$a</span>&quot;</span></span></span><br><span class="line">She said: he is a student 	echo执行时，替换了变量$a的值</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">b=<span class="string">&#x27;The value of a is $a&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$b</span></span></span><br><span class="line">The value of a is $a 		echo执行时，未替换了变量$a的值</span><br><span class="line"></span><br><span class="line">shell规定单引号禁止变量替换, 元字符$和*等保持其符号本身; 而双引号允许元字符变量替换.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c=<span class="string">&quot;The value of a is <span class="variable">$a</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$c</span></span></span><br><span class="line">The value of a is he is a student</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">a=<span class="built_in">date</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$a</span></span></span><br><span class="line">date (变量a的值是字符串date)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">b=`<span class="built_in">date</span>` (反撇号中的字符串作为命令名)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$b</span></span></span><br><span class="line">Sat Feb 1 16:28:19 Beijing 2003 </span><br><span class="line">(变量b的值是反撇号中命令的执行结果)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c=<span class="string">&quot;There is a teach&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$cer</span> reading room&quot;</span></span></span><br><span class="line">reading room (未定义变量cer, 其值用空串替代)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;c&#125;</span>er reading room&quot;</span></span></span><br><span class="line">There is a teacher reading room </span><br><span class="line">(花括号将变量名和后面的字符串区分开)</span><br></pre></td></tr></table></figure>

<h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><p>shell 编程的基本过程主要包含以下三步:</p>
<ol>
<li>建立 shell 文件<br> 包含任意多行操作系统命令或shell命令的文本文件;</li>
<li>赋予shell文件执行权限<br> 用chmod命令修改权限;</li>
<li>执行shell文件<br> 直接在命令行上调用该shell程序.</li>
</ol>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 建立shell文件 (可用任何建立文本文件的方法):</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> prog1</span></span><br><span class="line">who | grep $1</span><br><span class="line">2. 赋予执行权限: (初始文本文件无执行权限)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 740 prog1</span></span><br><span class="line">3. 执行该shell程序</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">prog1 student5</span></span><br><span class="line">prog1: not found </span><br><span class="line">(shell在标准搜索目录中找不到prog1命令)</span><br><span class="line">4. 指定路径或修改环境变量PATH后执行shell程序</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./prog1 student5</span></span><br><span class="line">student5 tty06 Feb 8 09:12</span><br></pre></td></tr></table></figure>

<h3 id="shell-程序和语句"><a href="#shell-程序和语句" class="headerlink" title="shell 程序和语句"></a>shell 程序和语句</h3><p>shell 程序由零至多条shell语句构成. shell语句包括三大类: 功能性语句、结构性语句和说明性语句。<br>说明性语句（注释行）：</p>
<blockquote>
<p>以#号开始到行尾的部分，不被解释执行。</p>
</blockquote>
<p>功能性语句: </p>
<blockquote>
<p>任意的操作系统命令、shell内部命令、自编程序、其它shell程序名等。</p>
</blockquote>
<p>结构性语句：</p>
<blockquote>
<p>条件测试语句、多路分支语句、循环语句、循环控制语句等。</p>
</blockquote>
<p><em><strong>read命令</strong></em><br>read从标准输入读入一行, 并赋值给后面的变量, 其语法为:</p>
<blockquote>
<p>. read var</p>
<p>把读入的数据全部赋给var</p>
</blockquote>
<blockquote>
<p>. read var1 var2 var3</p>
<p>把读入行中的第一个参数赋给var1, 第二个参数赋给 var2, ……，把其余所有的参数赋给最后一个变量.</p>
</blockquote>
<p>如果执行read语句时标准输入无数据, 则程序在此停留等侯, 直到数据的到来或被终止运行.</p>
<p>read应用实例（命令行执行）<br>read 读取标准输入（键盘）, 输入的内容赋给后面的变量. </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">read</span> name age</span><br><span class="line">yilan 23 								<span class="comment">#从键盘输入的内容</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;student <span class="variable">$name</span> is <span class="variable">$age</span> years old&quot;</span></span><br><span class="line">student yilan is 23 years old 			<span class="comment">#屏幕显示的内容</span></span><br></pre></td></tr></table></figure>

<p> read应用实例（shell脚本程序）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#example1 for read</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Input your name: &quot;</span></span><br><span class="line"><span class="built_in">read</span> username</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your name is <span class="variable">$username</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#example2 for read</span></span><br><span class="line"><span class="built_in">echo</span> –n <span class="string">&quot;Input date with format yyyy mm dd: &quot;</span></span><br><span class="line"><span class="built_in">read</span> year month day</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Today is <span class="variable">$year</span>/<span class="variable">$month</span>/<span class="variable">$day</span>, right?&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Press any key to confirm and continue&quot;</span></span><br><span class="line"><span class="built_in">read</span> answer</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I know the date, bye!&quot;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>expr 命令</strong></em></p>
<p>算术运算命令expr主要用于进行简单的整数运算，包括加(+)、减（-）、<br>乘（\*)、整除（&#x2F;）和求模（%）等操作。例如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">expr</span> 12 + 5 \* 3		<span class="comment">#反斜线去掉*号的元字符含义</span></span></span><br><span class="line">27</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">expr</span> 3 - 8 / 2</span></span><br><span class="line">-1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">expr</span> 25 % 4</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">num=9</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sum</span>=`<span class="built_in">expr</span> <span class="variable">$num</span> \* 6`	<span class="comment">#反撇号引用命令的运行结果</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$sum</span></span></span><br><span class="line">54</span><br></pre></td></tr></table></figure>

<p><em><strong>条件语句</strong></em></p>
<p>语法结构:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式</span><br><span class="line"><span class="keyword">then</span> 命令表</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 表达式</span><br><span class="line"><span class="keyword">then</span> 命令表1</span><br><span class="line"><span class="keyword">else</span> 命令表2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><em>if语句应用实例</em></p>
<p>shell程序prog2, 测试命令行参数是否为一个已存在的文件或目录。 用法为:prog2  file<br>prog2脚本内容如下: </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#The statement of if…then…fi (注释语句)</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$1</span> ] (测试命令行第一个参数是否为文件)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$1</span> exists&quot;</span> (引用变量值)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$HOME</span>/<span class="variable">$1</span> ] (测试参数是否为目录)</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$1</span> is a directory&quot;</span> (引用变量值)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>应用实例: shell程序prog3, 用法为: prog3 file<br>prog3的内容如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#The statement of if…then…else…fi</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$1</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is a directory&quot;</span></span><br><span class="line">	<span class="built_in">exit</span> (立即退出当前的shell程序)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	<span class="keyword">if</span> [ -f <span class="variable">$1</span> ]</span><br><span class="line">	<span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is a common file&quot;</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;unknown&quot;</span> </span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><em><strong>测试语句</strong></em></p>
<p>test语句可测试三种对象:字符串，整数，文件属性<br>每种测试对象都有若干测试操作符，例如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test &quot;$answer&quot; = &quot;yes&quot;</span><br></pre></td></tr></table></figure>

<p>变量answer的值是否为字符串yes</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test $num –eq 18</span><br></pre></td></tr></table></figure>

<p>变量num的值是否为整数18</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test -d tmp</span><br></pre></td></tr></table></figure>

<p>测试tmp是否为一个目录名</p>
<p>test命令的应用:<br>test命令测试的条件成立时, 命令返回值为真(0)，否则返回值为假(非0).<br>用法一. </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span> <span class="variable">$name</span> -eq <span class="variable">$1</span> </span><br><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>用法二.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -f <span class="variable">$filename</span></span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">……</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>用方括号替代test语句，通常简写为:<code> if [ -f $filename ]</code></p>
<p><em><strong>循环语句</strong></em></p>
<p>当循环次数已知或确定时, 使用for循环语句来多次执行一<br>条或一组命令. 循环体由语句括号do和done来限定。 格式为: </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 单词表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	命令表</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>变量依次取单词表中的各个单词, 每取一次单词, 就执行一次循环体中的命令. 循环次数由单词表中的单词数确定. 命令表中的命令可以是一条, 也可以是由分号或换行符分开的多条。如果单词表是命令行上的所有位置参数时, 可以在for语句中省略 “in 单词表” 部分。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 命令或表达式</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	命令表</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>while语句首先测试其后的命令或表达式的值，如果为真，就执行一次循环体中的命令，然后再测试该命令或表达式的值，执行循环体，直到该命令或表达式为假时退出循环。while语句的退出状态为“命令表”中被执行的最后一条命令的退出状态。</p>
<h2 id="shell示例"><a href="#shell示例" class="headerlink" title="shell示例"></a>shell示例</h2><p>第一题必须掌握，二三题看个人吧。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Put  line  numbers  on  all  lines  of  a  file </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span>  -ne  1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">       <span class="built_in">echo</span>  <span class="string">&quot;Usage: <span class="variable">$0</span>  filename &quot;</span>  &gt;&amp;2</span><br><span class="line">       <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">count=1                     <span class="comment"># Initialize count</span></span><br><span class="line"><span class="built_in">cat</span>  <span class="variable">$1</span>  |  <span class="keyword">while</span>  <span class="built_in">read</span>  line   </span><br><span class="line"><span class="comment"># Input is coming from file on command line</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span>  <span class="variable">$count</span>  <span class="variable">$line</span></span><br><span class="line">    count=`<span class="built_in">expr</span> <span class="variable">$count</span> + 1`</span><br><span class="line"><span class="keyword">done</span>  &gt;  tmp$$           <span class="comment"># Output is going to a temporary file</span></span><br><span class="line"><span class="built_in">mv</span>  tmp$$  <span class="variable">$1</span></span><br></pre></td></tr></table></figure>

<p>这段代码是一个shell脚本，其功能是为一个文件的每一行添加行号。首先，<code>#!/bin/sh</code>指定了脚本的解释器为&#x2F;bin&#x2F;sh。然后，脚本使用了一个条件判断语句，<code>if [ $# -ne 1 ]</code>，判断脚本的参数个数是否为1。<code>-ne</code>是一个条件测试运算符，用于比较两个数<strong>是否不相等</strong>。<code>$#</code>是一个特殊变量，表示传递给脚本的参数个数。如果参数个数不等于1，则执行条件判断中的代码块。在条件判断代码块中，<code>echo &quot;Usage: $0 filename&quot; &gt;&amp;2</code>用于输出错误信息到<strong>标准错误输出</strong>。<code>$0</code>是一个特殊变量，表示脚本的名称。<code>&gt;&amp;2</code>将输出重定向到标准错误输出。然后使用<code>exit 1</code>退出脚本，返回状态码1表示发生了错误。如果参数个数为1，则继续执行后面的代码。<code>count=1</code>初始化一个变量count，用于保存行号。接下来使用<code>cat $1 | while read line</code>语句，从命令行参数中的文件中逐行读取内容，并将每行内容赋值给变量<code>line</code>。<code>$1</code>：表示脚本的第一个参数，即文件名。<code>cat $1</code>：使用<code>cat</code>命令将文件内容输出到标准输出。在循环中，使用<code>echo $count $line</code>输出行号和当前行的内容。<code>echo $count $line</code>会在行号和内容之间输出一个空格。然后，使用<code>count=expr $count + 1</code>将行号加1，并将结果赋值给变量<code>count</code>。循环结束后，使用<code>done &gt; tmp$$</code>将循环中的输出重定向到一个临时文件<code>tmp$$</code>中。<code>$$</code>是一个特殊变量，表示当前脚本的进程ID。最后，使用<code>mv tmp$$ $1</code>将临时文件<code>tmp$$</code>重命名为原始文件名<code>$1</code>，覆盖原始文件，实现了为文件的每一行添加行号的功能。</p>
<hr>
<p>编写程序列出当前登录用户的账号，并在有新用户登录时显示新用户的登录信息。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># List current logged-in users and display new login information</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the initial list of logged-in users</span></span><br><span class="line"><span class="built_in">users</span>=$(<span class="built_in">who</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Continuously check for new logins</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># Get the updated list of logged-in users</span></span><br><span class="line">    new_users=$(<span class="built_in">who</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Check for new logins</span></span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> <span class="variable">$new_users</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [[ ! <span class="variable">$users</span> =~ <span class="variable">$user</span> ]]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;New login: <span class="variable">$user</span>&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Update the list of logged-in users</span></span><br><span class="line">    <span class="built_in">users</span>=<span class="variable">$new_users</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Sleep for 1 second before checking again</span></span><br><span class="line">    <span class="built_in">sleep</span> 3</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>使用<code>who</code>命令获取当前登录用户的信息，并使用<code>awk</code>命令提取每行的第一个字段（即用户名），将结果赋值给变量<code>users</code>，这是初始登录用户列表。<code>if [[ ! $users =~ $user ]]; then</code>：在循环中，检查当前用户是否为新用户。<code>$users</code>是之前保存的登录用户列表，<code>$user</code>是当前循环中的用户。</p>
<ul>
<li><code>[[ ... ]]</code>：这是bash中的条件表达式，用于进行条件判断。</li>
<li><code>!</code>：这是逻辑取反运算符，表示对后面条件的结果进行取反。</li>
<li><code>=~</code>：这是一个正则表达式匹配运算符，用于判断左侧的字符串是否匹配右侧的正则表达式。</li>
</ul>
<hr>
<p>编写程序列出指定目录下文件大小大于指定大小的文件名及其完整信息。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># List files in a directory larger than a specified size</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check for correct number of arguments</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$#</span> -ne 2 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> directory size&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the arguments</span></span><br><span class="line"><span class="built_in">dir</span>=<span class="variable">$1</span></span><br><span class="line">size=<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Find and list the files larger than the specified size</span></span><br><span class="line">find <span class="variable">$dir</span> -<span class="built_in">type</span> f -size +<span class="variable">$&#123;size&#125;</span>k -<span class="built_in">exec</span> <span class="built_in">ls</span> -lh &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>if [[ $# -ne 2 ]]; then</code>：这是一个条件判断语句，用于检查命令行参数的数量是否为2。</li>
<li><code>echo &quot;Usage: $0 directory size&quot;</code>：如果命令行参数数量不为2，则输出使用说明。</li>
</ul>
<p><code>find $dir -type f -size +$&#123;size&#125;k -exec ls -lh &#123;&#125; \;</code>：使用<code>find</code>命令查找目录<code>$dir</code>下的文件，其中：</p>
<ul>
<li><p><code>-type f</code>：限定查找的对象为文件。</p>
</li>
<li><p><code>-size +$&#123;size&#125;k</code>：限定文件大小大于指定的大小<code>$&#123;size&#125;</code>（单位为k）。</p>
</li>
<li><p><code>-exec ls -lh &#123;&#125; \;</code>：对于每个符合条件的文件，执行<code>ls -lh</code>命令来列出文件的详细信息。</p>
</li>
<li><p><code>&#123;&#125;</code>：在<code>find</code>命令中，<code>&#123;&#125;</code>表示找到的每个文件的占位符。<code>find</code>命令会将找到的每个文件依次替换为<code>&#123;&#125;</code>，从而允许对这些文件执行特定的操作。</p>
</li>
<li><p><code>\;</code>：在<code>find</code>命令中，<code>\;</code>表示一个分隔符，用于表示<code>-exec</code>选项的结束。它告诉<code>find</code>命令在每个被替换的文件后加上分号，以标记执行命令的结束。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之经典大题</title>
    <url>/2023/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8/</url>
    <content><![CDATA[<hr>
<p>用四种方法解决哲学家就餐问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore num = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        wait(num);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行进餐操作</span></span><br><span class="line"></span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        signal(num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行思考操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">    wait(chopstick[i]);        <span class="comment">//等左侧的筷子</span></span><br><span class="line">    wait(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);<span class="comment">//等右侧的筷子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">//等待右侧的筷子</span></span><br><span class="line">    wait(chopstick[i]);        <span class="comment">//等左侧的筷子     </span></span><br><span class="line">    &#125;</span><br><span class="line">         …</span><br><span class="line">        eat</span><br><span class="line">         …</span><br><span class="line">    signal(chopstick[i]);    <span class="comment">//放下左侧</span></span><br><span class="line">    signal(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);<span class="comment">//放下右侧</span></span><br><span class="line">         …</span><br><span class="line">        think</span><br><span class="line">         …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    think;</span><br><span class="line"></span><br><span class="line">    Sswait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>], chopstick[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eat</span></span><br><span class="line"></span><br><span class="line">    Ssignal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>], chopstick[i]);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过互斥信号量 mutex 对 eat之前取左右两侧筷子的操作进行保护，可以防止死锁的出现</span></span><br><span class="line"></span><br><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">		signal(mutex)</span><br><span class="line">        <span class="comment">// 进行进餐操作</span></span><br><span class="line"></span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行思考操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>假定系统有3个并发进程get 、copy 和put共享缓冲器B1和B2。进程get负责从输入设备上读信息，每读出一条记录后放到B1中。进程copy从缓冲器B1中取出一条记录拷贝后存入B2。进程put取出B2中的记录打印输出。B1和B2每次只能存放一条记录。要求3个进程协调完成任务，使打印出来的与读入的记录个数、次序完全一样。请用记录型信号量写出并发程序。</p>
<p>设置4个信号量，其中empty1对应空闲的缓冲区1，其初值为1；full1对应缓冲区1中的记录，其初值为0； empty2对应空闲的缓冲区2，其初值为1；full2对应缓冲区2中的记录，其初值为0。相应进程描述为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">get( )&#123;				</span><br><span class="line">	<span class="keyword">while</span>(ture)&#123;</span><br><span class="line">		从输入设备读入一条记录;</span><br><span class="line">		P(empty1);</span><br><span class="line">		将记录存入缓冲区<span class="number">1</span>；</span><br><span class="line">		V(full1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy( )&#123;				</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		P(full1);</span><br><span class="line">		从缓冲区<span class="number">1</span>中取出一条记录;</span><br><span class="line">		V(empty1);</span><br><span class="line">		P(empty2);</span><br><span class="line">		将取出的记录存入缓冲区<span class="number">2</span> ；</span><br><span class="line">		V(full2);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">put( )&#123;				</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		 P(full2);</span><br><span class="line">		从缓冲区<span class="number">2</span>中取出一条记录;</span><br><span class="line">		 V(empty2);</span><br><span class="line">		将取出的记录打印出来；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main( )&#123;</span><br><span class="line">     parbegin(get,copy,put);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>这是一个从键盘输入到打印机输出的数据处理流图,其中键盘输入进程通过缓冲区buf1 把输入数据传送给计算进程,计算进程把处理结果通过缓冲buf2 传送给打印进程。buf1 和buf2 为临界资源,试写出键盘输入进程,计算进程及打印进程间的同步算法。(10分)</p>
<p>输入进程→ buf1 →计算进程→ buf2 →打印进程</p>
<p>解答:从键盘输入到打印机输出的数据传送过程,可以看作是由键盘输入进程到计算进程,以及由计算进程到打印输出进程这两个数据传送进程所组成。其中,对键盘输入进程而言,计算进程是消费者进程;而对打印输出进程而言,计算进程又是生产者进程。据此可将它们之间的同步问题描述如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var:mutex1,mutex2,empty1,empty2,full1,full2:=<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">IP:begin</span><br><span class="line">repeat</span><br><span class="line"><span class="title function_">P</span><span class="params">(empty1)</span>;</span><br><span class="line">P(mutex1);</span><br><span class="line">input a charcter from keyboard;</span><br><span class="line">Add to buffer;</span><br><span class="line">V(mutex1);</span><br><span class="line">V(full1);</span><br><span class="line">until <span class="literal">false</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">CP:begin</span><br><span class="line">repeat</span><br><span class="line"><span class="title function_">P</span><span class="params">(full1)</span>;</span><br><span class="line">P(mutex1);</span><br><span class="line">Take a charactor form buffer1;</span><br><span class="line">Add to ch1;</span><br><span class="line">V(mutex1);</span><br><span class="line">V(empty1);</span><br><span class="line">P(empty2);</span><br><span class="line">P(mutex2);</span><br><span class="line">Take a charactor form ch1;</span><br><span class="line">Add to buffer2;</span><br><span class="line">V(mutex2);</span><br><span class="line">V(full2);</span><br><span class="line">until <span class="literal">false</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">OP:begin</span><br><span class="line">repeat</span><br><span class="line"><span class="title function_">p</span><span class="params">(full2)</span>;</span><br><span class="line">P(mutex2);</span><br><span class="line">Take a charactor from buffer2;</span><br><span class="line">Add to printer controler;</span><br><span class="line">start printer;</span><br><span class="line">V(mutex2);</span><br><span class="line">V(empty2);</span><br><span class="line">until <span class="literal">false</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<p>一台计算机有10台磁带机被n个进程竞争，每个进程最多需要3台磁带机，那么n最多为(4)时，系统没有死锁的危险？</p>
<p>补充：关于死锁的公式：当一个系统有N个并发进程，每个进程都需要M个同类资源，那么最少需要多少资源才能避免死锁的出现？  （M-1）*N+1    注：每个进程分配M-1个资源，然后再加上一个资源，该资源无论给哪个进程都可以保证当前系统不会出现死锁。</p>
<hr>
<p>在银行家算法中，若出现下述的资源分配情况：</p>
<table>
<thead>
<tr>
<th>Process</th>
<th>Max</th>
<th>Allocation</th>
<th>Available</th>
</tr>
</thead>
<tbody><tr>
<td>P0</td>
<td>0 0 4 4</td>
<td>0 0 3 2</td>
<td>1 6 2 2</td>
</tr>
<tr>
<td>P1</td>
<td>2 7 5 0</td>
<td>1 0 0 0</td>
<td></td>
</tr>
<tr>
<td>P2</td>
<td>3 6 10 10</td>
<td>1 3 5 4</td>
<td></td>
</tr>
<tr>
<td>P3</td>
<td>0 9 8 4</td>
<td>0 3 3 2</td>
<td></td>
</tr>
<tr>
<td>P4</td>
<td>0 6 6 10</td>
<td>0 0 1 4</td>
<td></td>
</tr>
</tbody></table>
<p>1）该状态是否安全？</p>
<p>2）若进程P2提出请求Request（1，2，2，2）后，系统能否将资源分配给它？</p>
<p>3）如果系统立即满足P2的上述请求，系统是否立即进入死锁状态？</p>
<p>解：</p>
<p>1）利用安全性算法对上面的状态进行分析（如下表所示），找到了一个安全序列{P0，P3，P4，P1，P2}或{P0，P3，P1，P4， P2}，故系统是安全的。</p>
<p>2）P2发出请求向量Request（1，2，2，2）后，系统按照银行家算法进行检查：Request2（1，2，2，2）≤Need2（2，3，5，6）；	Request2（1，2，2，2）≤Available（1，6，2，2）；系统先假定可为P2分配资源，并修改Available，Allocation2和Need2向量：Availabe&#x3D;（0，4，0，0）Allocation2&#x3D;（2，5，7，6）Need2&#x3D;(1,1,3,4) ，进行安全性检查：此时对所有进程，条件Needi≦ Available（0，4，0，0）都不成立，即Available不能满足任何进程的请求，故系统进入不安全状态。因此，当进程P2提出请求Request（1，2，2，2）后，系统不能将资源分配给它。</p>
<p>3）系统立即满足进程P2的请求（1，2，2，2）后，并没有马上进入死锁状态。因为，此时上述进程并没有申请新的资源，并未因得不到资源而进入阻塞状态。只有当上述进程提出新的请求，并导致所有没执行完的多个进程因得不到资源而阻塞时，系统才进入死锁状态。	</p>
<hr>
<p>已知某分页系统，用户空间有64个页面，主存容量为32KB，页面大小为1KB，对一个4页大的作业，其0、1、2、3页分别被分配到主存的2、4、6、7块中。</p>
<p>（1）将十进制的逻辑地址1023、2500、3500、4500转换成物理地址？</p>
<p>（2）以十进制的逻辑地址1023为例画出地址变换过程图？</p>
<p>逻辑地址位数      64*1K&#x3D;2^16 	16位</p>
<p>物理地址位数     32K&#x3D;2^15          15位</p>
<p>每个块大小：1KB</p>
<p>①逻辑地址1023：1023&#x2F;1K，得页号为0，页内地址为1023，查页表找到对应的物理块号为2，故物理地址为2×1K+1023&#x3D;3071</p>
<p>②逻辑地址2500：2500&#x2F;1K，得页号为2，页内地址为452，查页表找到对应的物理块号为6，故物理地址为6×1K+452&#x3D;6596</p>
<p>③逻辑地址3500：3500&#x2F;1K，得页号为3，页内地址为428，查页表找到对应的物理块号为7，故物理地址为7×1K+428&#x3D;7596</p>
<p>④逻辑地址4500：4500&#x2F;1K，得页号为4，页内地址为404，因页号大于页表长度，故产生越界中断。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-17_21-39-26.png"></p>
<hr>
<p>对访问串：1，2，3，4，1，2，5，1，2，3，4，5，指出在驻留集大小分别为3，4时，使用FIFO和LRU替换算法的缺页次数。结果说明了什么？</p>
<p>首先采用FIFO，当m&#x3D;3时，缺页次数＝9，当m&#x3D;4时，缺页次数＝10。采用LRU算法，当m&#x3D;3时，缺页次数＝10；当m&#x3D;4时，缺页次数＝8。结果说明：FIFO有Belady奇异现象，即不满足驻留集增大，缺页次数一定减小的规律；另外在m&#x3D;3时，LRU的缺页次数比FIFO要多，所以LRU算法并不总优于FIFO，还要看当前访问串的特点。</p>
<hr>
<p>一台计算机有四个页框，装入时间、上次引用时间、它们的R（读）与M（修改）位如下表所示（时间单位：嘀嗒），请问NRU、FIFO、LRU算法将替换哪一页？</p>
<table>
<thead>
<tr>
<th>页</th>
<th>装入时间</th>
<th>上次引用时间</th>
<th>R</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>126</td>
<td>279</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>230</td>
<td>260</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>120</td>
<td>272</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>160</td>
<td>280</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>FIFO算法在需要淘汰某一页时，淘汰最先进入内存的页。在题述条件下，第2页是最先进入内存的页。故FIFO算法将淘汰第2页。</p>
<p>LRU算法在需要淘汰某一页时，淘汰最近最久未使用的页面。在题述条件下，第1页是最近最久未使用的页面。故LRU算法将淘汰第1页。</p>
<p>NRU算法在需要淘汰某一页时，从那些最近一个时期内未被访问的页中任选一页淘汰。在题述条件下，只有第0页是最近一个时期内未被访问的页。故NRU算法将淘汰第0页。</p>
<hr>
<p>一个磁盘系统，平均寻道时间为12ms，转速为10000转&#x2F;分，每个磁道有18个扇区，每个扇区512个字节。请问要读取一个扇区所花的时间是多少？</p>
<p>TS &#x3D; 12ms</p>
<p>TR &#x3D; 1&#x2F;2r &#x3D; 60÷10000×0.5 &#x3D; 3ms （因为不知道扇区具体在哪按半圈算）</p>
<p>TA&#x3D;b&#x2F;rN &#x3D; 512÷[(10000&#x2F;60) ×(18×512)]&#x3D; 0.33ms </p>
<p>TT &#x3D; TS + TR + TA &#x3D;12 + 3 + 0.33 &#x3D; 15.33ms</p>
<p>答：读取一个扇区所花的时间是15.33ms。</p>
<hr>
<p>假定盘块的大小为1KB,硬盘的大小为500MB,采用显示链接分配方式时,其FAT需占用多少存储空间（FAT表项占2.5个字节）?如果文件A占用硬盘的11, 12 , 16, 14四个盘块,试画出文件A中各盘块在FAT表中的链接情况.</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-18_09-00-27.png"></p>
<hr>
<p>存放在某个磁盘上的文件系统，对于采用混合索引分配方式，其 FCB 中共有 13 项地址项，第 0～9 个地址项为直接地址，第 10 个地址项为一次间接地址，第 11 个地址项为二次 间接地址，第 12 个地址项为三次间接地址。如果每个盘块的大小为 512 字节，盘块号需要 3 个字节来描述，则每个盘块最多存放 170 个盘块地址。<br>(1) 该文件系统允许的最大长度是多少？<br>(2) 将文件的字节偏移量 5000、15000、150000 转换为物理块号和块内偏移量。<br>(3) 假设某文件的索引结点已在内存中，但其他信息均在外存，为了访问该文件中某个位置的内容，最多需要几次访 问磁盘？</p>
<p>(1) 该文件系统中一个文件的最大长度可达:</p>
<p>10+170+170×170+170×170×170&#x3D;4942080 块，共 4942080×512 字节 &#x3D; 2471040KB</p>
<p>(2) 5000&#x2F;512 得到商为 9, 余数为 392, 即字节偏移量 5000 对应的逻辑块号为 9, 块内偏移量为 392。由于 9&lt;10, 故可直接从该文件的 FCB 的第 9 个地址项处得到物理盘块号，块内偏移量为 392。</p>
<p>15000&#x2F;512 得到商为 29, 余数为 152, 即字节偏移量 15000 对应的逻辑块号为 29, 块内偏移量为 152。由于 10&lt;29&lt; 10+170, 而 29-10&#x3D;19, 故可从 FCB 的第 10 个地址项，即一次间址项中得到一次间址块的地址；并从一次间址块的第 19 项 (即该块的第 57~59 这 3 个字节) 中获得对应的物理盘块号，块内偏移量为 152。</p>
<p>150000&#x2F;512得商为292，余数为496。即逻辑块号为292，块内偏移为496。由于10+170≤292，故可从FCB的第11个地址项，即二次间址项中获得<strong>第1个</strong>一次间址块；并从该一次间址块的112项中获得对应的物理盘块号，块内偏移为496。<em>（150000&#x2F;512 得到商为 292, 余数为 496, 即字节偏移量 150000 对应的逻辑块号为 292, 块内偏移量为 496。由于 10+170&lt;292&lt; 10+170+170×170, 而 292-(10+170)&#x3D;112,112&#x2F;170 得到商为 0, 余数为 112, 故可从 FCB 的第 11 个地址项，即二次间址项中得到二次间址块的地址，并从二次间址块的第 0 项中获得一个一次间址块的地址，再从这一次间址块的第 112 项中获得对应的物理盘块号，块内偏移量为 496。）</em></p>
<p>(3) 由于文件的 FCB 己在内存，为了访问文件中某个位置的内容，最少需要 1 次访问磁盘 (即可通过直接地址直接读文件盘块)，最多需要 4 次访问磁盘 (第一次是读三次间址块，第二次是读二次间址块，第三次是读一次间址块，第四次是读文件盘块)。</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-18_09-23-50.png"></p>
<p>1）分配过程线形检索得：i1&#x3D;2，j1&#x3D;2； i2&#x3D;3，j2&#x3D;6。计算空闲盘块号： b1&#x3D;i1×16+j1+1&#x3D;2×16+2+1&#x3D;35 </p>
<p>b2&#x3D;i2×16+j2+1&#x3D;3×16+6+1&#x3D;55修改位示图：</p>
<p> 令map[2，2]&#x3D;map[3，6]&#x3D;1，并将对应块35，55分配出去。</p>
<p>2）释放过程计算出第300块所对应的二进制行号i和j</p>
<p>i&#x3D;（300-1）&#x2F;16&#x3D;18</p>
<p>j&#x3D; （300-1）% 16&#x3D;11</p>
<p>修改位示图： 令map[18，11]&#x3D;0。</p>
<p>（注意行号和列号不是从1开始编号）</p>
<hr>
<p>设正在处理器上执行的一个进程的页表如下表所示,表中的虚页号和物理块号是十进制数,起始页号(块号)均为0。所有的地址均是存储器字节地址。页的大小为1024字节。(10分)</p>
<p> ① 详述在设有快表的请求分页存储管理系统中,一个虚地址转换成物理内存地址的过程。</p>
<p> ② 下列虚地址对应于什么物理地址:5499,2221。</p>
<table>
<thead>
<tr>
<th>虚页号</th>
<th>状态位</th>
<th>访问位</th>
<th>修改位</th>
<th>物理块号</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>7</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>①</p>
<ol>
<li>首先，虚地址被分为两部分：页号和页内偏移量。</li>
<li>系统会检查快表（TLB），看看虚拟页号是否在快表中。如果在，快表会返回相应的物理页框号。</li>
<li>如果虚拟页号不在快表中，系统会查询页表，找到相应的物理页框号。如果该虚拟页没有分配物理页框，则会发生缺页中断，由操作系统负责分配物理页框并更新页表。</li>
<li>一旦找到物理页框号，系统会将其与虚地址的页内偏移量组合起来，形成物理内存地址。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-18_11-05-45.png"></p>
<p>②</p>
<table>
<thead>
<tr>
<th>虚地址（虚页号，页内地址）</th>
<th></th>
<th>物理地址 （物理块号，块内地址）</th>
</tr>
</thead>
<tbody><tr>
<td>5499&#x3D;1024*5+379</td>
<td>（5，379）</td>
<td>（0,379）</td>
</tr>
<tr>
<td>2221&#x3D;1024*2+173</td>
<td>（2,173）</td>
<td>（不在内存）</td>
</tr>
</tbody></table>
<hr>
<p>请求分页管理系统中,假设某进程的页表内容如下表所示。 </p>
<table>
<thead>
<tr>
<th>进程</th>
<th>页框(Page Frame)号</th>
<th>有效位(存在位)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>101H</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>254H</td>
<td>1</td>
</tr>
</tbody></table>
<p>页面大小为4KB,一次内存的访问时间是100ns,一次快表(TLB)的访问时间是10ns,处理一次缺页的平均时间为108ns(已含更新TLB和页表的时间),进程的驻留集大小固定为2,采用最近最少使用置换算法(LRU)和局部淘汰策略。假设</p>
<p>①TLB初始为空;</p>
<p>②地址转换时先访问TLB,若TLB未命中,再访问页表</p>
<p>(忽略访问页表之后的TLB更新时间);</p>
<p>③有效位为0表示页面不在内存,产生缺页中断,缺页中断处理后,返回到产生缺页中断的指令处重新执行。设有虚地址访问序列2362H、1565H、25A5H,请问:</p>
<p>(1) 依次访问上述三个虚地址,各需多少时间?</p>
<p>(2) 基于上述访问序列,虚地址1565H的 物理地址是多少?请说明理由。</p>
<p>1)由于页面大小为4KB&#x3D;212KB，故逻辑地址末尾12位表示页内偏移W，前4位表示页号P。 </p>
<p>对于逻辑地址2362H，其表示的页号为2，访问次序依次为：访问TLB未命中(10ns)； 访问页表命中2号页面，并将页表项副本放入TLB（100ns）,得到物理地址，访问内存（100ns）。</p>
<p>故逻辑地址2362H的访问时间为：EAT&#x3D;10+100+100&#x3D;210ns;<br>对于逻辑地址1565H，其表示的页号为1，访问次序依次为，访问TLB未命中(10ns)；访问页表未命中(100ns)；发生缺页中断(108ns)；访问TLB命中1号页面(10ns)；得到物理地址访问内存(100ns)。此时驻留集已满(0号页面和2号页面)</p>
<p>故逻辑地址1565H的访问时间为：<br>EAT&#x3D;108+2×(100+10)&#x3D;328ns。<br>对于逻辑地址25A5H，其表示的页号为2，访问次序依次为：访问TLB命中二号页面(10ns)；得到物理地址访问内存(100ns)。</p>
<p>故逻辑地址25A5H的访问时间为:EAT&#x3D;a+t&#x3D;10+100&#x3D;110ns;<br>2） 访问逻辑地址1565H时由于驻留集已满(0号页面和2号页面)。故应从页表中淘汰一个页面，根据LRU算法，2号页面刚被使用过，故淘汰0号页面，将1号页面调入获得内存块号101H。则地址由内存块号和页内偏移量拼接得到物理地址为：101565H。</p>
<hr>
<p>设系统有三种类型的资源,数量为(4,2,2),系统中有进程A,B,C按如下顺序请求资源:</p>
<p>进程A申请(3,2,1)</p>
<p>进程B申请(1,0,1)</p>
<p>进程A申请(0,1,0)</p>
<p>进程C申请(2,0,0)</p>
<p>请你给出一和防止死锁的资源剥夺分配策略,完成上述请求序列,并列出资源分配过程,指明哪些进程需要等待,哪些资源被剥夺。(10分)</p>
<p>解:(10分)</p>
<p>① 分配策略为:当进程Pi申请ri类资源时,检查ri中有无可分配的资源:有则分配给Pi;否则将Pi占有的资源全部释放而进入等待状态。(Pi等待原占有的所有资源和新申请的资源)</p>
<p>② 资源分配过程: 剩余资源</p>
<p>进程A:(3,2,1) (1,0,1)</p>
<p>进程B:(1,0,1) (0,0,0)</p>
<p>进程A:(0,1,0)(不满足) (3,2,1)</p>
<p>A的所有资源被剥夺,A处于等待</p>
<p>进程C:(2,0,0) (1,2,1)</p>
<p>C,B完成之后,A可完成。</p>
<hr>
<p>设公共汽车上,司机和售票员的活动分别是:</p>
<p>司机的活动:启动车辆;正常行车;到站停车。</p>
<p>售票员的活动:关车门;售票;开车门。</p>
<p>在汽车不断的到站、停站、行驶过程中,试用信号量和P,V操作实现司机和售票员的同步。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore run=<span class="number">0</span>; <span class="comment">//是否允许司机启动汽车</span></span><br><span class="line">Semaphore stop=<span class="number">0</span>; <span class="comment">//是否允许售票员开门</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    cobegin</span><br><span class="line">        <span class="title function_">driver</span><span class="params">()</span>;</span><br><span class="line">    	busman();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line">driver()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        p(run);</span><br><span class="line">        启动公交车，开车，到站停车；</span><br><span class="line">        V(stop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">busman()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;	</span><br><span class="line">        关车门</span><br><span class="line">        V(run);</span><br><span class="line">        售票；</span><br><span class="line">        P(stop);</span><br><span class="line">        开车门，上下乘客</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>某虚拟存储器的用户编程空间共 32 个页面，每页为 1KB ，内存为 16KB 。假定某时刻一用户进程的页表中已调入内存的页面的页号和物理块号的对照表如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/6100690_1492922396105_072774B6B658B3603E1AA7198722775C.png"></p>
<p>（ 1 ）此时，指令中逻辑地址至少需要多少位？</p>
<p>（2）逻辑地址0A 5C（十六进制）所对应的物理地址是什么（用十六进制表示）？给出计算过程。</p>
<p>页式存储管理的逻辑地址分为两部分：页号和页内地址。由已知条件“用户编程空间共32个页面”，可知页号部分占5位；由“每页为1KB”，1K&#x3D;210，可知内页地址占10位，则指令中逻辑地址至少需要15位。<br>逻辑地址0A5C（H）所对应的二进制表示形式是：000 1010 0101 1100 ，根据上面的分析，10 0101 1100 为页内地址，编码 “000 10” 为页号，表示该逻辑地址对应的页号为2。查页表，得到物理块号是4（十进制），即物理块地址为：01 00 ，拼接页内地址10 0101 1100，得01 0010 0101 1100，即125C（H）。</p>
<hr>
<p>进程A1、A2、…Anl通过m个缓冲区向进程B1、B2、…Bn2不断地发送消息。发送和接收工作遵循如下规则：</p>
<p>(1)每个发送进程一次发送一个消息，写入一个缓冲区，缓冲区大小与消息长度一样。</p>
<p>(2)对于每一个消息，B1、B2、…Bn2都需各接收一次，读入自己的数据区内。</p>
<p>(3)m个缓冲区都满时，发送进程等待；没有可读的消息时，接收进程等待。 试用wait、signal操作描述它们的同步关系。</p>
<p>每个缓冲区只要写一次但要读n2次，因此，可以看成n2组缓冲区，每个发送者要同时写n2个缓冲区，而每个接收者只要读它自己的缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mutex=<span class="number">1</span>; <span class="comment">//多进程互斥使用缓冲区</span></span><br><span class="line">empty[<span class="number">0</span>,<span class="number">1</span>,……n2]=&#123;m,m,……m&#125;;</span><br><span class="line">full[<span class="number">0</span>,<span class="number">1</span>,…..n2]=&#123;<span class="number">0</span>,<span class="number">0</span>,……<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//写进程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; n2; i++)&#123;</span><br><span class="line">	P(empty[i]);</span><br><span class="line">	&#125;</span><br><span class="line">P(mutex);</span><br><span class="line">消息放入缓冲区；</span><br><span class="line">V(mutex);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; n2; i++)&#123;</span><br><span class="line">	V(full[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//读进程</span></span><br><span class="line">&#123;</span><br><span class="line">P(full[i]);</span><br><span class="line">P(mutex);</span><br><span class="line">读取缓冲区；</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>一个进程的大小为5个页面,为它分配了4个物理块。当前每个块的情况如下表所示(都为十进制数,且从0开始计数)。当虚页4发生缺页时,使用下列的页面置换算法,哪一个物理块将被换出?并解释原因。</p>
<table>
<thead>
<tr>
<th>页号</th>
<th>块号</th>
<th>加载时间</th>
<th>访问时间</th>
<th>访问位R</th>
<th>修改位M</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>0</td>
<td>60</td>
<td>161</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>130</td>
<td>160</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>26</td>
<td>162</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>20</td>
<td>163</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>(1) FIFO算法;</p>
<p>(2) LRU算法;</p>
<p>(3) CLOCK算法;</p>
<p>(4) 当页面的访问串为:“4,0,0,0,2,4,2,1,0,3,2”的OPT算法。</p>
<p>解:(1) 换出第3号虚页,因为它加载的时间最早;</p>
<p>(2) 换出第1号虚页,因为它最近最久没被访问;</p>
<p>(3) 换出第1号虚页,因为它最近既没被访问,又没被修改;</p>
<p>(4) 换出第3号虚页,因为它离访问点最远。</p>
<hr>
<p>设某程序大小为460字,并且它有下面的存储访问序列:</p>
<p>10,11,104,170,73,309,185,245,246,434,458,364</p>
<p>设页面大小是100字,请给出该访问序列的页面走向.又设该程序基本可用内存是200字,采用先进先出置换算法(FIFO),求出其缺页率.如果采用最佳置换算法(OPT),其缺页率又是多少?(注:缺页率&#x3D;缺页次数&#x2F;访问页面总数)</p>
<p>根据已知条件页面大小是100字,将页面访问序列简化为:</p>
<p>0,0,1,1,0,3,1,2,2,4,4,3 (2分)</p>
<p>又因为该程序基本可用内存是200字,可知内存块数为2.</p>
<p>采用先进先出置换算法(FIFO),总共有6次缺页,缺页率为6&#x2F;12&#x3D;50%</p>
<p>采用最佳置换算法(OPT),总共有5次缺页,缺页率为5&#x2F;12&#x3D;41.7%</p>
<hr>
<p>有一个大学只有一个澡堂，门口上有一块牌子，如果有一个男生进去洗澡，他就会把牌子转到“男”字样，这样只有男生会进去，女生就不会进去了；如果澡堂没人，一个女生先进了澡堂，她就会把牌子转到“女”字样，那么女生就可以进去了；请用PV操作描述这个事件，避免男女生同时出现在澡堂。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semphore  boymutex=<span class="number">1</span>, girlmutex=<span class="number">1</span>,mutex=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> boycount=<span class="number">0</span>;  </span><br><span class="line"><span class="type">int</span> girlcount=<span class="number">0</span>;</span><br><span class="line">Parbegin </span><br><span class="line"></span><br><span class="line"><span class="title function_">Boy</span><span class="params">()</span></span><br><span class="line">begin</span><br><span class="line">  repeat</span><br><span class="line">    <span class="title function_">wait</span><span class="params">(boymutex)</span>; </span><br><span class="line">    <span class="keyword">if</span> boycount ==<span class="number">0</span> then wait(mutex);</span><br><span class="line">	boycount = boycount +<span class="number">1</span>; </span><br><span class="line">    signal(boymutex); </span><br><span class="line">    洗澡；</span><br><span class="line">    wait(boymutex); </span><br><span class="line">    boycount = boycount <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> boycount ==<span class="number">0</span> then signal(mutex);</span><br><span class="line">signal(boymutex);</span><br><span class="line">until <span class="literal">false</span>;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">Girl()</span><br><span class="line">begin </span><br><span class="line">  repeat </span><br><span class="line">    <span class="title function_">wait</span><span class="params">(girlmutex)</span>; </span><br><span class="line">	<span class="keyword">if</span> girlcount ==<span class="number">0</span> then wait(mutex);</span><br><span class="line">	girlcount = girlcount +<span class="number">1</span>; </span><br><span class="line">    signal(girlmutex); </span><br><span class="line">    洗澡；</span><br><span class="line">    wait(girlmutex); </span><br><span class="line">    girlcount = girlcount <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> girlcount ==<span class="number">0</span> then signal(mutex);</span><br><span class="line">	signal(girlmutex);</span><br><span class="line">until <span class="literal">false</span>;</span><br><span class="line">end;</span><br><span class="line">Parend</span><br></pre></td></tr></table></figure>

<hr>
<p>若程序PA和PB单独执行时分别用TA&#x3D;1小时,TB&#x3D;1.5小时,其中处理器工作时间 TA&#x3D;18分钟 T&#x3D;27分钟,如果采用多道程序设计方法,让PA、PB并行工作,假定处理器利率达到50%,另加15分钟系统开销,请问系统效率能提高多少?</p>
<p>答：单道系统下程序一个执行完再执行另一个,所以CPU执行PA和PB加起来的时间为 60+90&#x3D;150分钟</p>
<p>多道系统下PA和PB同时在内存中,当一个程序开始I&#x2F;O时,OS调用另一个执行,所以它们只占用了CPU时间18+27&#x3D;45分钟</p>
<p>又因为CPU利用率为50%,除了执行PA和PB,还需要维持OS的运行;另一方面在PA和PB间切换也花了15分钟, 因此实际的CPU运行时间为(18+27)&#x2F;50%+15&#x3D;90+15&#x3D;105分钟</p>
<p>所以系统效率提高:[(60+90)-(90+15)]&#x2F;(60+90)&#x3D;30%</p>
<hr>
<p>某单处理器系统中采用多道程序设计，现有10个进程存在，则处于“运行”，“阻塞”、“就绪”状态的进程数量最小和最大值分别可能是多少？</p>
<p>答：在一个单处理器系统中，采用多道程序设计，现有10个进程存在。在任何时刻，只能有一个进程处于“运行”状态，因为只有一个处理器。处于“阻塞”状态的进程数量最小值为0，最大值为10，因为所有进程都可能在等待某些事件发生。处于“就绪”状态的进程数量最小值为0，最大值为9，因为除了正在运行的进程外，其他所有进程都可能处于就绪状态。因此，在这个系统中，处于“运行”状态的进程数量最小值和最大值都是1；处于“阻塞”状态的进程数量最小值为0，最大值为10；处于“就绪”状态的进程数量最小值为0，最大值为9。</p>
<hr>
<p>桌上有一空盘,只允许存放一个水果。爸爸可向盘中放苹果,也可向盘中放桔子。儿子专等吃盘中的桔子,女儿专等吃盘中的苹果。规定当盘中空时一次只能放一只水果供吃者取用,请用 P、V原语实现爸爸、儿子、女儿三个并发进程的同步。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore empty = <span class="number">1</span>;</span><br><span class="line">semaphore apple = <span class="number">0</span>;</span><br><span class="line">semaphore orange = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">father</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 向盘中放苹果或桔子</span></span><br><span class="line">        <span class="keyword">if</span> (放苹果) &#123;</span><br><span class="line">            V(apple);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (放桔子) &#123;</span><br><span class="line">            V(orange);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">son</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(orange);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 从盘中取桔子</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">daughter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(apple);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 从盘中取苹果</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>桌上有一空盘，最多允许存放一只水果。爸爸只向盘中放一个苹果，妈妈只向盘中放一个桔子，儿子专等吃盘中的桔子，女儿专等吃苹果。用wait、signal操作实现爸爸、妈妈、儿子、女儿四个并发进程的同步。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore empty=<span class="number">1</span>,nutex=<span class="number">1</span>,apple=<span class="number">0</span>,orange=<span class="number">0</span>;  <span class="comment">//为四个信号量赋初值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">father</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">do</span>&#123;</span><br><span class="line">           wait(empty);    <span class="comment">//等待盘子为空</span></span><br><span class="line">           wait(metux);    <span class="comment">//等待获取对盘子的操作</span></span><br><span class="line">            爸爸向盘中放一个苹果;</span><br><span class="line">           signal(mutex);   <span class="comment">//释放对盘子的操作</span></span><br><span class="line">           signal(apple);   <span class="comment">//通知女儿可以来盘子中取苹果</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mather</span><span class="params">()</span>&#123;               <span class="comment">//与父亲进程雷同</span></span><br><span class="line">     <span class="keyword">do</span>&#123;</span><br><span class="line">           wait(empty);</span><br><span class="line">           wait(metux);</span><br><span class="line">            妈妈向盘中放一个桔子;</span><br><span class="line">           signal(mutex);</span><br><span class="line">           signal(orange);</span><br><span class="line">    &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">son</span><span class="params">()</span>&#123;                        </span><br><span class="line">     <span class="keyword">do</span>&#123;</span><br><span class="line">           wait(orange);       <span class="comment">//判断盘子中是否有桔子</span></span><br><span class="line">           wait(metux);        <span class="comment">//等待获取对盘子的操作</span></span><br><span class="line">            儿子取出盘中的桔子;</span><br><span class="line">           signal(mutex);      <span class="comment">//释放对盘子的操作</span></span><br><span class="line">           signal(empty);      <span class="comment">//盘子空了，可以继续放水果了</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">daugther</span><span class="params">()</span>&#123;               <span class="comment">//与儿子进程雷同</span></span><br><span class="line">     <span class="keyword">do</span>&#123;</span><br><span class="line">           wait(apple);</span><br><span class="line">           wait(metux);</span><br><span class="line">            女儿取出盘中的苹果;</span><br><span class="line">           signal(mutex);</span><br><span class="line">           signal(empty);</span><br><span class="line">    &#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;               <span class="comment">//四个并发进程的同步执行</span></span><br><span class="line">	cobegin</span><br><span class="line">	   <span class="title function_">father</span><span class="params">()</span>;mather();son();daugther();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>在某页式虚拟系统中,假定访问内存的时间是10ms,平均缺页中断处理为25ms,平均缺页中断率为5%,试计算在该虚存系统中,平均有效访问时间是多少?</p>
<p>答：若要访问的页面在内存中,一次访问的时间是:10ms+10ms&#x3D;20ms;如果不在内存,所花的时间是:10ms(问内存页表)+25ms(中断处理)+10ms(访问内存页表)+10ms(访问内存)&#x3D;55ms。所以平均有效访问时间为: 20ms× (1-5%)+55ms×5%&#x3D;21.75ms</p>
<hr>
<p>若是一个磁盘容量是64MB，磁盘盘块大小为1KB，若是采用显式链接的方式，需要多大的FAT表；若是用索引结构，需要用几级索引，为什么？</p>
<p>答：64MB&#x2F;1KB&#x3D;64K(块)，需16位地址标识，需对于FAT表的一表项，则占2字节，2B×64K&#x3D;128KB。</p>
<p>一个盘块可以放1KB&#x2F;2B&#x3D;512项，一级索引肯定不够，512*512&gt;64K，所以需要二级索引。</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计网期末复习之计算机网络与因特网</title>
    <url>/2023/06/20/%E8%AE%A1%E7%BD%91/1/</url>
    <content><![CDATA[<ol>
<li><p><strong>计算机网络</strong>：两台以上具有独立操作系统的计算机通过某些介质连接成的相互共享软硬件资源的集合体。</p>
</li>
<li><p>计算机网络向用户提供的最重要的两大功能:<strong>连通性、共享</strong>。</p>
</li>
<li><p>什么是Internet？</p>
</li>
</ol>
<p>​	<strong>具体构成描述</strong>：数以亿计的计算互连设备、通信链路(link)、分组(packet)交换。（硬件上描述）</p>
<p>​	<strong>服务上描述</strong>：提供网络应用基础架构、为分布式应用程序提供通信服务接口（无连接服务和面向连接服务）。</p>
<ol start="4">
<li><p>ISP是指互联网服务提供商。</p>
</li>
<li><p>协议定义了两个或多个通信实体间所交换报文的<strong>格式和顺序</strong>，以及在报文发送和&#x2F;或接收或者其他事件方面所采取的<strong>行动（响应）</strong></p>
</li>
</ol>
<p>​	协议的基本要素:</p>
<ul>
<li><p>语法：报文格式</p>
</li>
<li><p>语义：各字段的含义</p>
</li>
<li><p>同步(时序)：报文传输的先后顺序</p>
</li>
</ul>
<ol start="6">
<li>Internet标准的几个阶段：</li>
</ol>
<blockquote>
<p>因特网草案（Internet Draft）－不是RFC文档</p>
<p>建议标准（Proposed Standard） －开始成为RFC文档</p>
<p>草案标准（Draft Standard）</p>
<p>因特网标准（Internet Standard）</p>
</blockquote>
<ol start="7">
<li><p>因特网组成部分：边缘部分、核心部分</p>
</li>
<li><p>网络边缘：</p>
</li>
</ol>
<ul>
<li><p>端系统 (&#x2F;主机):运行网络应用程序、处在网络的边缘</p>
</li>
<li><p>通信模型：客户&#x2F;服务器C&#x2F;S模型（客户请求，并接收服务器提供的服务）、端对端模型peer-peer model（P2P）（所有的通信方既可以做客户机又可以做服务器）</p>
</li>
</ul>
<ol start="9">
<li>接入网（网络边缘与网络核心的连接部分称为接入网）：</li>
</ol>
<p>（1）边缘路由器：端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<p>（2）接入网：将端系统连接到其<strong>边缘路由器</strong>的物理链路，是用户连接到网络的基础设施。</p>
<p>（3）重要指标：带宽、独占&#x2F;共享</p>
<ol start="10">
<li>如何将终端系统连接到网络边缘的路由器：</li>
</ol>
<p>（1）家庭接入网络</p>
<p>（2）企业（和家庭）接入网络</p>
<p>（3）广域无线接入网络</p>
<ol start="11">
<li>家庭接入网络：</li>
</ol>
<p>（1）点对点接入</p>
<p>（2）线缆调制解调器</p>
<p>（3）光纤到户</p>
<ol start="12">
<li>企业（和家庭）接入网络  ：</li>
</ol>
<p>（1）LAN（ Ethernet 技术）</p>
<p>（2）WIFI（无线局域网技术，802.11）</p>
<ol start="13">
<li><p>广域无线接入网：3G、4G、5G</p>
</li>
<li><p>物理媒体：</p>
</li>
</ol>
<p>（1）通过传播电磁波或光脉冲来发送<strong>比特流</strong>，在物理媒体中数据传输是串行的。</p>
<p>（2）物理媒体分类：导引型媒体和非导引型媒体</p>
<p>（3）物理媒体的性能对网络的通信、速度、距离、价格以及网络中的结点数和可靠性都有很大影响</p>
<p>（4）导引型媒体（信号在固态介质中有向传播）：</p>
<ul>
<li><p>双绞线：分为屏蔽双绞线 STP（电缆的外层由铝泊包裹），非屏蔽双绞线 UTP</p>
</li>
<li><p>同轴电缆：共享介质</p>
</li>
<li><p>光纤：高速传输、传输距离远、防止电磁干扰，难以被分光窃听</p>
</li>
</ul>
<p>（5）非导引型媒体（信号在大气空间或外太空空间自由传播）：多路径衰落、盲区衰落、干扰。类型有地面微波，局域无线电 (WiFi),广域无线电（3G、4G、5G）、卫星通信。</p>
<ol start="15">
<li>端系统上因特网提供的服务</li>
</ol>
<p>（1）面向连接的服务TCP：可靠、顺序、字节流传输；流量控制；拥塞控制</p>
<p>（2）无连接服务UDP：不可靠数据传输、无流量控制、无拥塞控制</p>
<ol start="16">
<li>网络核心</li>
</ol>
<p>（1）相互连接的路由器构成的网络</p>
<p>（2）如何在这个网络中传送数据？（电路交换、分组交换）</p>
<ol start="17">
<li>电路交换</li>
</ol>
<p>（1）预先建立连接，预留资源，发送方以恒定速度发送数据</p>
<p>（2）电路和通信链路的区别</p>
<p>（3）链路带宽和一条电路的传输速率的关系</p>
<p>（4）频分多路复用和时分多路复用（会计算）</p>
<p>（5）电路交换的优缺点：电路级的性能，时延小；效率低；创建连接过程复杂</p>
<p>设文件长640kb，链路采用时隙数为24的TDM，传输速率1.536Mb&#x2F;s，主机之间创建一条端到端电路需500ms。</p>
<blockquote>
<p>每条电路的传输速率：(1.536Mb&#x2F;s) &#x2F;24&#x3D;64kb&#x2F;s</p>
<p>传输文件时间：640kb&#x2F;(64kb&#x2F;s)&#x3D;10s</p>
<p>A到B的总发送时间：10s+0.5s&#x3D;10.5s</p>
</blockquote>
<ol start="18">
<li>分组交换</li>
</ol>
<p>（1）报文：应用程序要传输的信息，包含控制或数据</p>
<p>（2）分组：报文拆分成若干的数据块，每个数据块加上头部信息，构成分组</p>
<p>（3）特点：所有分组共享网络资源、每个分组使用全部链路带宽、资源按需使用；</p>
<p>优点：适合大量的突发数据传输，资源共享、简单, 不需要建立连接 </p>
<p>缺点：过渡竞争导致分组延迟与丢失，需要可靠数据传输、拥塞控制协议</p>
<ol start="19">
<li>网络的分类：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-20_21-48-31.png"></p>
<ul>
<li><p>虚电路网络一定是面向连接的。 </p>
</li>
<li><p>数据报网络既可以提供面向连接的服务也可以提供无连接的服务。如： Internet为网络应用既提供面向连接的传输服务 (TCP)，也提供无连接的传输服务(UDP)。</p>
</li>
</ul>
<ol start="20">
<li><p>Internet主干&#x2F;ISP的结构组成：第一层ISP（国家&#x2F;国际级）、第二层ISP（区域级&#x2F;省级）、第三层ISP（城市级）、本地ISP、因特网交换点IXP。</p>
<p>一个分组可能要穿越很多网络。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-20_21-55-57.png"></p>
</li>
<li><p>分组丢失和延迟是如何产生的？分组到达输出链路的速率超过输出链路的容量、分组在缓冲区队列排队, 按序等待</p>
</li>
</ol>
<p>（1）路由器输入链路和输出链路的缓冲区容量有限</p>
<p>（2）当分组到达路由器输入链路发现缓冲区已满，则路由器只好丢弃分组</p>
<p>（3）当分组在路由器内部要转发到输出链路时，发现输出缓冲区队列已满，路由器只好丢弃分组</p>
<p>丢包率&#x3D;丢包数&#x2F;已发分组总数</p>
<ol start="22">
<li>分组延迟的4种类型</li>
</ol>
<p>（1）节点处理时延：差错检测、选择输出链路，微秒级</p>
<p>（2）排队时延：等待被发送到输出链路上的时间，取决于路由器的拥塞程度</p>
<p>（3）传输时延：R&#x3D;链路带宽 (bps)，L&#x3D;分组长度 (bits)，发送分组比特流的时间 &#x3D; L&#x2F;R</p>
<p>（4）传播时延：d &#x3D; 物理链路的长度，s &#x3D; 介质的信号传播速度，传播延迟 &#x3D; d&#x2F;s</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-20_22-07-11.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-20_22-15-37.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-20_22-15-37.png"></p>
<p>排队时延：流量强度(traffic intensity) &#x3D; La&#x2F;R，其中a为平均分组到达速率， L为分组长度， R为链路带宽 </p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_09-14-14.png"></p>
<ul>
<li>La&#x2F;R ~ 0: 分组稀疏到达,无队列,平均排队延迟极小接近于0</li>
<li>La&#x2F;R -&gt; 1: 分组猝发到达,形成队列,队列长度迅速增加,排队延迟大幅增大</li>
<li>La&#x2F;R &gt; 1: 输出队列平均位到达速率超过送走这些位的极限速率，输出队列持续增长，排队延迟趋于无穷大</li>
</ul>
<ol start="23">
<li><p>吞吐量：<strong>接收端</strong>接收到数据的比特速率 (bps )，瞬时吞吐量: 某一瞬间的吞吐量，平均吞吐量: 一段时间内的吞吐量均值。</p>
<p>瓶颈链路：在端到端路径中制约吞吐量的链路</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_09-54-56.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_09-22-05.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_09-28-45.png"></p>
</li>
<li><p>带宽：数据传输率。带宽的单位一般有两种形式：第一种是以字节为单位来计算，有Bps、KBps、MBps、GBps、TBps 等，表示单位时间（秒)内传输的字节数量·第二种是以比特为单位来计算，有bps、Kbps、Mbps、Gbps、Tbps等，表示单位时间(秒）内传输的比特数量两种带宽的换算因为一个字节是8比特，因此1B&#x2F;s&#x3D;8 bps (b&#x2F;s) .1 KB&#x2F;s&#x3D;8 Kbps (Kb&#x2F;s) 、1 MB&#x2F;s&#x3D;8 Mbps (Mb&#x2F;s)等，如此类推Bps、bps也可分别写为B&#x2F;s， b&#x2F;s</p>
</li>
<li><p>协议分层</p>
<p>（1）计算机网络体系结构分为很多层，每层完成一个特定功能，层和层之间相互协作，底层为上一层提供服务，上层使用底层提供的服务（服务模型），实现本层的功能，再为上一层提供服务。</p>
<p>（2）网络设计者以分层的方式组织协议，以及实现这些协议的网络软硬件。</p>
<p>（3）一个协议层能够用软件、硬件或者两者结合实现</p>
<p>（4）各层的所有协议称为协议栈，如因特网TCP&#x2F;IP协议栈</p>
</li>
<li><p>协议和服务的的区分</p>
<p>（1）协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务，而无法看见下面的协议。下面的协议对上面的服务用户是透明的。</p>
<p>（2）协议是“水平的”，即协议是控制两个对等实体进行通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。</p>
</li>
<li><p>ISO模型（7层）</p>
<table>
<thead>
<tr>
<th><strong>层号</strong></th>
<th><strong>层的名称</strong></th>
<th><strong>层的英文名称</strong></th>
<th><strong>层的英文缩写</strong></th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>应用层</td>
<td>Application</td>
<td>A</td>
</tr>
<tr>
<td>6</td>
<td>表示层</td>
<td>Presentation</td>
<td>P</td>
</tr>
<tr>
<td>5</td>
<td>会话层</td>
<td>Session</td>
<td>S</td>
</tr>
<tr>
<td>4</td>
<td>传输层</td>
<td>Transport</td>
<td>T</td>
</tr>
<tr>
<td>3</td>
<td>网络层</td>
<td>Network</td>
<td>N</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层</td>
<td>Data Link</td>
<td>DL</td>
</tr>
<tr>
<td>1</td>
<td>物理层</td>
<td>Physical</td>
<td>PL</td>
</tr>
</tbody></table>
<p>TCP&#x2F;IP参考模型</p>
<table>
<thead>
<tr>
<th align="center">应用层</th>
</tr>
</thead>
<tbody><tr>
<td align="center">传输层</td>
</tr>
<tr>
<td align="center">网络层</td>
</tr>
<tr>
<td align="center">网络接口层</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">应用层</th>
</tr>
</thead>
<tbody><tr>
<td align="center">运输层</td>
</tr>
<tr>
<td align="center">网络层</td>
</tr>
<tr>
<td align="center">数据链路层</td>
</tr>
<tr>
<td align="center">物理层</td>
</tr>
</tbody></table>
</li>
<li><p>网际协议栈</p>
<p>应用层application: 支持网络应用，<strong>报文</strong>传送FTP, SMTP, STTP …</p>
<p>传输层transport: 主机进程间<strong>报文段</strong>传送，TCP, UDP</p>
<p>网络层network:     主机(源目标节点)间分组（<strong>数据报</strong>）传送主要是IP协议, 路由协议 </p>
<p>链路层link:     相邻网络节点间的数据<strong>帧</strong>传送，PPP, Ethernet …</p>
<p>物理层physical:     物理介质上的<strong>比特</strong>传送</p>
</li>
<li><p>网络<strong>实体</strong>完成功能动作, <strong>对等实体</strong>交换消息</p>
<p><strong>实体</strong>: 定义自身功能的硬&#x2F;软件的集合</p>
<p><strong>对等实体</strong>: 两台计算机上同一层所属的程序、进程或实体称为该层的对等程序、对等进程或对等实体。</p>
</li>
<li><p>协议数据单元PDU</p>
<p>发方添加首部信息创建新的数据单元（封装），收方去掉首部（解封）</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_10-17-18.png"></p>
<p>每层传递的数据分为首部字段和有效载荷字段两部分。有效载荷是相邻上层传下来的数据。</p>
</li>
<li><p>常见的网络攻击：被动攻击和主动攻击(篡改、伪造消息)</p>
<p>（1）植入恶意软件（病毒、蠕虫、僵尸网络）:自我复制</p>
<p>（2）DoS攻击（弱点攻击【向目标主机上易受攻击的应用程序和操作系统发送精细的报文】、带宽洪泛【向目标主机发送大量分组】、连接洪泛【利用目标主机创建半开或全开的TCP连接】）</p>
<p>（3）嗅探分组（无线网络和以太网LAN）：数据加密</p>
<p>（4）伪装（IP哄骗）：采用端点鉴别机制</p>
<p>（5）中间人攻击（攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据；虚拟专用网(VPN)、SSL证书）</p>
</li>
</ol>
<hr>
<p>如果链路每秒传输1000个帧，每个时隙由64个比特组成，则每条电路的传输速率是64kbps。（    正确  ）（这门课中，所有的k、M、G都是指10³、10⁶、10⁹）</p>
<p>在OSI参考模型中，同系统的相邻层实体间通过(   A    )进行交互<br>A、接口     B、进程     C、程序     D、协议</p>
<p>以下有关协议和服务说法错误的是（D ）<br>A.协议是对等实体之间进行逻辑通信而定义的规则或规约的集合。<br>B.服务是指一个系统中的下层向上层提供的功能。<br>C.一个协议包括两个方面，即对上层提供服务和对协议本身的实现。<br>D.服务的关键要素是语法、语义和同步。</p>
<p>简述因特网五层协议的网络体系结构的要点和各层的主要功能。 </p>
<p>答：综合 OSI 和 TCP&#x2F;IP 的优点，采用一种原理体系结构。各层的主要功能：<br>①物理层 物理层的任务就是 透明地传送比特流。（注意：传递信息的物理媒体，如双绞线、同轴电缆、光缆等，是在物理层的下面， 当做第 0 层。） 物理层还要确定连接电缆插头的定义及连接法。<br>②数据链路层 数据链路层的任务是在两个 相邻结点间的线路上无差错地传送以帧（frame）为单位的数据。每一帧包括数据和必要的控制信息。<br>③网络层 网络层的任务就是要选择合适的路由，使发送站的运输层所传下来的分组能够正确无误地按照地址找到目的站，并交付给目的站的运输层。<br>④运输层 运输层的任务是向上一层的进行通 信的两个进程之间提供一个可靠的端到端服务，使它们看不见运输层以下的数据通信的细节。<br>⑤应用层 应用层直接为用户的应用进程提供服务。 </p>
<p>简述协议栈、实体、对等层、协议数据单元、服务访问点、客户、服务器、客户-服务器方式。 </p>
<p>答：<strong>实体</strong>(entity) 表示任何可发送或接收信息的硬件或软件进程。</p>
<p><strong>对等层</strong>:在网络体系结构中,通信双方实现同样功能的层. </p>
<p><strong>协议</strong>是控制两个对等实体进行通信的规则的集合。</p>
<p><strong>客户</strong>(client)和<strong>服务器</strong>(server)都是指通信中所涉及的两个应用进程。客户是服务的请求方，服务器是服务的提供方。客户服务器方式所描述的是进程之间服务和被服务的关系。 </p>
<p><strong>协议栈</strong>:指计算机网络体系结构采用分层模型后,每层的主要功能由对等层协议的运行来实现,因而每层可用一些主要协议来表征,几个层次画在一起很像一个栈的结构.</p>
<p><strong>协议数据单元</strong>:对等层实体进行信息交换的数据单位.</p>
<p><strong>服务访问点</strong>:在同一系统中相邻两层的实体进行交互.</p>
<p>因特网的两大组成部分（边缘部分与核心部分）的特点是什么？它们的工作方式各有什么特点？ </p>
<p>答：边缘部分：由各主机构成，用户直接进行信息处理和信息共享;低速连入核心网。核心部分：由各路由器连网，负责为边缘部分提供高速远程分组交换。</p>
<p>简述分组交换的特点。答：（1）报文分组，加首部（2）经路由器储存转发（3）在目的地组装</p>
<p>电路交换的特点：建立电路连接、通话、拆除连接</p>
<p>使用加密机制可以防范分布式拒绝服务（DDoS）攻击。 （   ×    ）加密机制可以帮助保护数据的安全性，但它并不能直接防范分布式拒绝服务（DDoS）攻击。DDoS 攻击是通过大规模互联网流量淹没目标服务器或其周边基础设施，以破坏目标服务器、服务或网络正常流量的恶意行为。</p>
<p>与排队延迟无关的属性是（  A    ）A. 链路长度 	B. 链路带宽 	C. 分组大小 	D. 分组到达数量</p>
<p>在下图所示的采用“存储-转发”方式的分组交换网络中， 所有链路的数据传输速率为100 Mbps，分组大小为1 000 B ，其中分组头大小为20 B。若主机H1向主机H2发送一个大小为980 000 B的文件，则在不考虑分组拆装时间和传播延迟的情况下，从H1发送开始到H2接收完为止，需要的时间至少是多少？ </p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_11-26-46.png"></p>
<p>解析:分组大小为1000B,其中分组头大小为20B,则分组携带的数据大小为980B,文件长度为980000B,需拆分为1000个分组,加上头部后,每个分组大小为1000B,总共需要传送的数据量大小为1MB。由于所有链路的数据传输速度相同,因此文件传输经过最短路径时所需时间最少,最短路径经过2个分组交换机。当t&#x3D;1M×8&#x2F;100Mbps&#x3D;80ms时,H1发送完最后一个比特。当H1发送完最后一个分组时,该分组需要经过2个分组交换机的转发,在2次转发完成后,所有分组均到达H2。每次转发的时间为t0&#x3D;t&#x3D;lK×8&#x2F;100Mbps&#x3D;0.08ms。所以,在不考虑分组拆装时间和传播延迟的情况下,当t&#x3D;80ms+2t0&#x3D;80.16ms时,H2接收完文件,即所需的时间至少为80.16ms。</p>
<p>主机A向主机B发送一个大小为6MB的文件，从主机A到主机B的路径上有3段链路， 其中速率分别是1Mbps, 800kbps, 2Mbps，该文件从主机A传输到主机B大概需要多久?</p>
<p>传输时延取决于链路中速率最慢的那一段，即800kbps。因此，传输时延为(6MB * 8bits&#x2F;byte) &#x2F; (800kbps) &#x3D; 60秒。</p>
<p>假定在发送主机和接收主机间只有一台分组交换机。发送主机和交换机间以及交换机和接收主机间 的传输速率分别是R1和R2。假设该交换机使用存储转发分组交换方式，发送一个长度为L的分组 的端到端总时延是什么？（忽略排队时延、传播时延和处理时延。）</p>
<p>答：L&#x2F;R1+L&#x2F;R2</p>
<p>—个长度为1000字节的分组经距离为2500km的链路传播，传播速率为2.5xl0^8m&#x2F;s并且传输速率 为2Mbps,它需要用多长时间？更为一般地，一个长度为L的分组经距离为d的链路传播，传播速率为s并且传输速率为Rbps,它需要用多长时间？</p>
<p>答：14ms，L&#x2F;R+d&#x2F;s</p>
<p>假定主机A要向主机B发送一个大文件。从主机A到主机B的路径上有3段链路，其速率分别为 R1 &#x3D; 500kbps, R2 &#x3D; 2Mbps, R3 &#x3D; 1 Mbps.</p>
<p>a.假定该网络中没有其他流量，该文件传送的吞吐量是多少？500kbps</p>
<p>b.假定该文件为4MB。用吞吐量除以文件长度，将该文件传输到主机B大致需要多长时间？(4 X 8 X 10^6)&#x2F;(500x10^3)</p>
<p>在这个习题中，我们考虑从主机A向主机B通过分组交换网发送语音（VoIP）。主机A将模拟语音 转换为传输中的64kbps数字比特流。然后主机A将这些比特分为56字节的分组。A和B之间有一条 链路：它的传输速率是2Mbps,传播时延是10ms。一旦A收集了一个分组，就将它向主机B发送。 一旦主机B接收到一个完整的分组，它将该分组的比特转换成模拟信号。从比特产生（从位于主机 A的初始模拟信号起）的时刻起，到该比特被解码（在主机B上作为模拟信号的一部分），花了多少 时间？</p>
<p>(56 X 8)&#x2F;(64 X 10^3)+(56X8)&#x2F;(2x10^6)+0.01</p>
<p>假定用户共享一条3Mbps的链路。又设每个用户传输时要求150kbps，但是每个用户仅有10%的时间传输。</p>
<p>a.当使用电路交换时，能够支持多少用户？</p>
<p>3×10^6&#x2F;(150×10^3)&#x3D;20</p>
<p>b.对于本习题的后续小题，假定使用分组交换。求出某给定用户正在传输的概率。<strong>0.1</strong></p>
<p>c.假定有120个用户。求出在任何给定时刻，实际有n个用户在同时传输的概率。（提示：使用二项式分布。） </p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/fzjh1.png"></p>
<p>d.求出有21个或更多用户同时传输的概率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/fzjh2.png"></p>
<p>假定有N个分组同时到达一条当前没有分组传输或排队的链路。每个分组长为L，链路传输速率为R。对N个分组而言.其平均排队时延是多少？</p>
<p>解：第1个分组排队时间为0，第2个分组在L&#x2F;R时间后开始传输，第n个分组在（n-1）L&#x2F;R开始传输，则<strong>平均延时</strong>为：[L&#x2F;R+2L&#x2F;R+…+(n-1）L&#x2F;R]&#x2F;n&#x3D;(n-1)L&#x2F;(2R)</p>
<p>现在假定每隔LN&#x2F;R秒有N个分组同时到达链路。一个分组的平均排队时延是多少？</p>
<p>传输N个分组需要时间&#x3D;NL&#x2F;R，此时又有N个分组到达，意味着每一批分组都不需要排队就可以接着传输，因此1个分组平均时延为（N-1）L&#x2F;（2R)</p>
<p>考虑某路由器缓存中的排队时延。令I表示流量强度；即I&#x3D; La&#x2F;R。假定排队时延的形式为IL&#x2F;R(1-I)，其中I&lt;1。 a. 写岀总时延即排队时延加上传输时延的公式。</p>
<p>总时延：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/pdcs1.png"></p>
<p>b. 以L&#x2F;R为函数画出总时延的图</p>
<p>设x&#x3D; L&#x2F;R，则总时延&#x3D;x&#x2F;(1-ax)</p>
<p>假定两台主机A和B相隔20000km，由一条直接的R&#x3D;2Mbps的链路相连。假定跨越该链路的传播速率是 2.5×10^8 m&#x2F;s。<br>a) 计算带宽——时延积</p>
<p>b) 考虑从主机A到主机B发送一个800000比特的文件。假定该文件作为一个大的报文连续发送。在任何给定的时间，在链路上具有的比特数量最大值是多少？</p>
<p>c) 给出带宽——时延积的一种解释</p>
<p>d) 在该链路上一个比特的宽度（以米计）是多少？它比一个足球场更长吗？</p>
<p>e) 根据传播速率s、带宽R 和链路m的长度，推导出一个比特宽度的一般表达式</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_18-30-40.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_18-38-00.png"></p>
<p>m&#x2F;(R*m&#x2F;s)&#x3D;s&#x2F;R</p>
<p>考虑从主机A到主机B发送一个F比特的大文件。A和B之间有两段链路（和两台交换机），并且该链路不拥塞（即没有排队时延）。主机A将该文件分为每个为S比特的报文段，并为每个报文段增加一个80比特的首部，形成L&#x3D;80+S比特的分组。每条链路的传输速率为R bps。求出从A到B移动该文件时延最小的值S。忽略传播时延。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_18-55-47.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_18-55-29.png"></p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网期末复习之应用层</title>
    <url>/2023/06/21/%E8%AE%A1%E7%BD%91/2/</url>
    <content><![CDATA[<p>1、网络应用程序部署</p>
<p>（1）部署在端系统上（2）没有应用程序软件运行在网络核心设备上</p>
<p>2、网络应用程序体系结构</p>
<p>（1）C&#x2F;S体系结构	Server：具有固定的、众所周知的IP地址；总是打开的主机；主机群集；	Client：可以间断的同服务器连接；拥有动态IP地址；客户机相互之间不直接通信</p>
<p>（2）P2P体系结构	没有总是打开的服务器；任意一对主机直接相互通信；对等方间歇连接并且可以改变IP地址；自扩展性；难以管理</p>
<p>（3）C&#x2F;S和P2P混合的体系结构	中心服务器记录对等方内容（用户注册、文件存储信息等），供用户搜索；</p>
<p>3、进程通信</p>
<p>（1）同一主机上运行的进程之间进程间通信机制进行通信，由操作系统提供。</p>
<p>（2）不同主机上运行的进程间交换报文进行通信。进程间通信利用socket发送&#x2F;接收消息实现。</p>
<p>具有P2P体系结构的应用程序既有客户进程（发起通信的进程）和服务器进程（发起通信的进程）。</p>
<p>4、如何寻址进程？</p>
<p>（1）不同主机上的进程间通信，那么每个进程必须拥有标识符（ IP地址、端口号）（2）常用网络程序的端口号：Web服务：80；邮件服务：25</p>
<p>5、常见应用的传输服务需求</p>
<table>
<thead>
<tr>
<th><strong>应用</strong></th>
<th><strong>数据丢失</strong></th>
<th><strong>带宽</strong></th>
<th><strong>时间敏感</strong></th>
</tr>
</thead>
<tbody><tr>
<td>文件传输</td>
<td>不能丢失</td>
<td>弹性</td>
<td>不</td>
</tr>
<tr>
<td>电子邮件</td>
<td>不能丢失</td>
<td>弹性</td>
<td>不</td>
</tr>
<tr>
<td>Web</td>
<td>不能丢失</td>
<td>弹性</td>
<td>不</td>
</tr>
<tr>
<td>实时音频&#x2F;视频</td>
<td>容忍丢失</td>
<td>音频: 几kbps-1Mbps</td>
<td>是,100 msec</td>
</tr>
<tr>
<td>存储音频&#x2F;视频</td>
<td>容忍丢失</td>
<td>视频:10kbps-5Mbps</td>
<td>是, 几秒</td>
</tr>
<tr>
<td>交互式游戏</td>
<td>容忍丢失</td>
<td>视频:10kbps-5Mbps</td>
<td>是, 100 msec</td>
</tr>
<tr>
<td>即时讯息</td>
<td>不能丢失</td>
<td>几 kbps 以上 ，弹性</td>
<td>是和不是</td>
</tr>
</tbody></table>
<p>6、因特网运输层提供的服务</p>
<p>（1）TCP服务：面向连接、可靠数据传输、流量控制、拥塞控制；无时延和带宽保证</p>
<p>（2）UDP服务：不提供建立连接，可靠性，流量控制，拥塞控制，时延和带宽保证。</p>
<p>面向连接：必须在建立连接前确认双方链路可达，并已准备好才开始通信，提供可靠或者不可靠的服务。</p>
<p>无连接：发送端在开始通信前不去询问接收端是否可达和是否已准备好接收数据，提供不可靠的服务。</p>
<p>7、因特网应用：应用层协议，传输协议</p>
<table>
<thead>
<tr>
<th><strong>应用</strong></th>
<th><strong>应用层协议</strong></th>
<th><strong>下面的传输协议</strong></th>
</tr>
</thead>
<tbody><tr>
<td>电子邮件</td>
<td>SMTP [RFC 2821]</td>
<td>TCP</td>
</tr>
<tr>
<td>远程终端访问</td>
<td>Telnet [RFC 854]</td>
<td>TCP</td>
</tr>
<tr>
<td>Web</td>
<td>HTTP [RFC 2616]</td>
<td>TCP</td>
</tr>
<tr>
<td>文件传输</td>
<td>FTP [RFC 959]</td>
<td>TCP</td>
</tr>
<tr>
<td>流媒体</td>
<td>通常专用(e.g. RealNetworks)</td>
<td>TCP or UDP</td>
</tr>
<tr>
<td>因特网电话</td>
<td>通常专用(e.g., Skype)</td>
<td>典型用 UDP</td>
</tr>
</tbody></table>
<p>8、网页（Web页，或称文档）由许多对象组成，每个对象被一个URL(Uniform Resource Locator统一资源定位符)寻址（<strong>协议名、主机名、路径名</strong>）。多数网页由单个基本<strong>HTML</strong>文件和若干个所引用的对象构成。</p>
<p>比如：<a href="http://www.someschool.edu/someDept/pic.gif">http://www.someschool.edu/someDept/pic.gif</a></p>
<p>9、HTTP: 超文本传输协议（Web的应用层协议）</p>
<p>（1）client&#x2F;server模式：客户端浏览器请求+ Web服务器响应</p>
<p>（2）工作过程：</p>
<ul>
<li>客户初始化一个与HTTP服务器80端口的TCP连接 (创建套接字)</li>
<li>HTTP服务器接受来自客户的TCP连接请求, 建立连接</li>
<li>Browser (HTTP client)和Web服务器 (HTTP server) 交换HTTP消息(应用层协议消息)包括HTTP请求和响应消息</li>
<li>最后结束(或叫关闭)TCP连接</li>
</ul>
<p>（3）HTTP是一个无状态的协议：HTTP服务器不维护客户先前的状态信息</p>
<p>10、HTTP持久连接和非持久连接</p>
<p><strong>非持久HTTP连接</strong>：每个TCP连接上只传送一个对象，下载多个对象需要建立多个TCP连接，HTTP&#x2F;1.0使用非持久HTTP连接</p>
<p><strong>持久HTTP连接</strong>：一个TCP连接上可以传送多个对象，HTTP&#x2F;1.1默认使用持久HTTP连接</p>
<p>例：假设该页面含有一个HTML基本文件和10个JPEG图形， 并且这11个对象位于同一台服务器上。</p>
<p>进一步假设该HTML文件的URL为：<a href="http://www.someschool.edu/someDepartment/home.index">http://www.someSchool.edu/someDepartment/home.index</a></p>
<p>(1) HTTP客户进程在端口号80发起一个到服务器 <a href="http://www.someschool.edu/">www.someSchool.edu</a> 的TCP连接，该端口号是HTTP的默认端口。在客户和服务器上分别有一个套接字与该连接相关联。</p>
<p>(2) HTTP客户经它的套接字向该服务器发送一个HTTP请求报文。请求报文中包含了路径名&#x2F;someDepartment&#x2F;home.index。</p>
<p>(3) HTTP服务器进程经它的套接字接收该请求报文，从其存储器(RAM或磁盘)中检索出对象 <a href="http://www.someschool.edu/someDepartment/home.index">www.someSchool.edu/someDepartment/home.index</a> ，在一个HTTP响应报文中封装对象，并通过其套接字向客户发送响应报文。</p>
<p>(4)HTTP服务器进程通知TCP断开该TCP连接。</p>
<p>(5)HTTP客户接收响应报文，TCP连接关闭。该报文指出封装的对象件，客户从响应报文中提取出该文件，检查该HTML文件，得到对10个JPEG图形的引用。</p>
<p>(6) 对每个引用的JPEG图形对象重复前4个步骤。</p>
<p><strong>不带流水线的持久HTTP连接</strong>：客户先前响应消息收到,才发出新的请求消息，每个引用对象经历1个RTT</p>
<p>**带流水线的持久HTTP连接 **：HTTP&#x2F;1.1默认使用客户遇到1个引用对象就发送请求消息，所有引用对象只经历1个RTT</p>
<p>11、HTTP报文格式:请求报文request, 响应报文response（常见命令和状态码）</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_13-50-36.png"></p>
<p>假设有HTTP请求报文：</p>
<p>GET &#x2F;somedir&#x2F;page.html HTTP&#x2F;1.1</p>
<p>其中，&#x2F;somedir&#x2F;page.html被称为（）URI 或Uniform Resource Identifiers 或统一资源标识符</p>
<p>HTTP&#x2F;1.0</p>
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD<ul>
<li>服务器收到请求时，用HTTP报文进行响应，但不返回请求对象</li>
</ul>
</li>
</ul>
<p>HTTP&#x2F;1.1</p>
<ul>
<li><p>GET, POST, HEAD</p>
</li>
<li><p>PUT</p>
<ul>
<li>文件在实体主体中被上载到URL字段指定的路径</li>
</ul>
</li>
<li><p>DELETE</p>
<ul>
<li>删除URL字段指定的文件</li>
</ul>
</li>
</ul>
<p><em><strong>上载表单（各字段）输入值</strong></em></p>
<p>Post方法:网页时常包含表单输入，输入值在请求报文的实体主体中被上载到服务器</p>
<p>URL方法:使用GET方法，表单(各字段)输入值被上载,以URL请求行的字段: <a href="http://www.somesite.com/animalsearch?monkeys&banana">www.somesite.com/animalsearch?monkeys&amp;banana</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_13-57-34.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_13-58-04.png"></p>
<p>12、 Cookies作用，如何实现</p>
<p>（1）Cookies: 跟踪用户，提高用户和服务器的交互性</p>
<p>（2）cookie头部行在HTTP请求消息（或响应消息）中</p>
<p>（3）cookie文件 保存在<strong>用户主机</strong>中并被<strong>用户浏览器</strong>管理</p>
<p>（4）cookie也保存在Web站点的<strong>后端数据库</strong></p>
<p>（5）应用场景：身份认证&#x2F;虚拟购物车&#x2F;推荐广告&#x2F;用户会话状态</p>
<p>（6）优点：cookies允许网站更加了解你，你可以提供名字和e-mail给网站 ，广告公司通过网站获得信息，Cookies不适合游动用户</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_14-06-53.png"></p>
<p>13、Web 缓存 (代理服务器)，如何实现，条件GET方法</p>
<p>目标:在不访问服务器的前提下满足客户端的HTTP请求。</p>
<p><strong>Web缓存&#x2F;代理服务器</strong></p>
<ul>
<li><p>用户设定浏览器通过缓存进行Web访问</p>
</li>
<li><p>浏览器向缓存&#x2F;代理服务器发送所有的HTTP请求</p>
<ul>
<li>如果所请求对象在缓存中，缓存器返回对象</li>
<li>否则缓存器向起始服务器发出请求，接收对象后转发给客户机</li>
</ul>
</li>
<li><p>缓存既充当客户端，也充当服务器</p>
</li>
<li><p>一般由ISP(Internet服务提供商)架设</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_14-13-20.png"></p>
<p>为什么需要Web缓存器?</p>
<blockquote>
<p>减少对客户机请求的响应时间</p>
<p>减少内部网络与接入链路上的通信量</p>
<p>能从整体上大大降低因特网上的Web流量</p>
</blockquote>
<p>条件GET方法</p>
<p>目的: 证实缓存器中的对象是否为最新</p>
<p>缓存器：在请求报文中包含对象最后修改时间 If-modified-since: &lt;date&gt;</p>
<p>服务器: 如果对象是最新的则响应报文中不包含对象: HTTP&#x2F;1.0 304 Not Modified</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_14-16-54.png"></p>
<p>14、用户代理user agents、邮件服务器mail servers、简单邮件传送协议和邮件接收协议的作用</p>
<p>用户代理：</p>
<ul>
<li><p>允许用户阅读,回复,转发,保存,编辑邮件消息 </p>
</li>
<li><p>发送, 接收邮件消息到&#x2F;从服务器</p>
</li>
</ul>
<p>邮件服务器 </p>
<ul>
<li>邮箱mailbox存放用户接收的邮件消息</li>
<li>外出报文队列outgoing message queue</li>
</ul>
<p>SMTP协议</p>
<ul>
<li><p>运行邮件<strong>服务器之间</strong>传递消息所使用的协议</p>
</li>
<li><p>客户端：发送消息的服务器</p>
</li>
<li><p>服务器：接收消息的服务器</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_14-17-44.png"></p>
<p>15、电子邮件协议（SMTP&#x2F;POP3、IMAP、HTTP）各自端口号</p>
<p><strong>SMTP</strong></p>
<ul>
<li>客户使用TCP来可靠传输邮件消息到服务器端口号<strong>25</strong></li>
<li>传输的3个阶段：握手 (问候)、邮件消息的传输、结束</li>
<li>发送服务器到接收服务器采用直接传送</li>
<li>使用持久连接</li>
<li>命令&#x2F;应答的交互，服务器使用<strong>CRLF.CRLF</strong> 来判断邮件消息的结束<ul>
<li>命令: ASCII文本格式</li>
<li>应答: 状态码及其短语</li>
</ul>
</li>
<li>邮件消息必须是7-bit ASCII</li>
<li>与HTTP协议比较<ul>
<li>HTTP是拉协议（把信息拉下来），SMTP是推协议（把信息送出去）</li>
<li>HTTP的每个对象封装在它各自的HTTP响应消息中发送；SMTP一个邮件内各个对象置于同一个邮件消息的多目部分发送</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_14-38-09.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_14-38-48.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_14-42-16.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_14-42-38.png"></p>
<p><strong>POP3</strong></p>
<ul>
<li><p>Post Office Protocol 邮局协议[RFC 1939]<strong>110</strong>端口号</p>
</li>
<li><p>身份认证 (代理 &lt;–&gt;服务器) </p>
<ul>
<li><p>客户命令: </p>
<ul>
<li>user username</li>
<li>pass password</li>
</ul>
</li>
<li><p>服务器响应</p>
<ul>
<li>+OK</li>
<li>-ERR</li>
</ul>
</li>
</ul>
</li>
<li><p>下载邮件消息</p>
<ul>
<li>list: 列出邮件编号</li>
<li>retr: 按编号取邮件</li>
<li>dele: 删除</li>
<li>quit</li>
</ul>
</li>
<li><p>POP3的会话是<strong>无状态的</strong></p>
</li>
</ul>
<p><strong>IMAP</strong></p>
<ul>
<li>所有邮件消息保存在一个位置: 服务器</li>
<li>允许用户利用文件夹组织管理邮件消息</li>
<li>IMAP支持跨会话(Session)的用户状态:<ul>
<li>文件夹的名字</li>
<li>邮件消息IDs和文件夹的映射</li>
</ul>
</li>
</ul>
<p>16、DNS的功能、特点</p>
<p>DNS服务器提供的功能：</p>
<ul>
<li><p>主机名到IP地址的转换</p>
</li>
<li><p>主机别名：一个主机可以有一个规范主机名和多个主机别名</p>
</li>
<li><p>邮件服务器别名</p>
</li>
<li><p>负载分配</p>
<ul>
<li>DNS实现冗余服务器：一个IP地址集合可以对应于同一个规范主机名。</li>
</ul>
</li>
</ul>
<p>DNS（Domain Name System:域名系统）特点</p>
<ul>
<li>分布式数据库：一个由分层DNS服务器实现的分布式数据库</li>
<li>应用层协议：DNS服务器实现域名转换 (域名&#x2F;地址转换)</li>
</ul>
<p>为什么不集中式DNS?</p>
<blockquote>
<p>单点故障</p>
<p>巨大访问量</p>
<p>远距离集中式数据库</p>
<p>维护</p>
<p>不可扩展!</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_15-10-46.png"></p>
<p>客户机怎样决定主机名<a href="http://www.amazon.com/">www.amazon.com</a> 的IP地址？</p>
<blockquote>
<p>客户机查询根服务器得到com DNS服务器</p>
<p>客户机查询com DNS服务器得到amazon.comDNS服务器</p>
<p>客户机查询amazon.comDNS服务器得到<a href="http://www.amazon.com/">www.amazon.com</a> 的IP地址</p>
</blockquote>
<p><strong>顶级域服务器</strong>（top-level domain servers）：负责顶级域名 com, org, net, edu, etc（用途域名或者类别域名）, 和所有国家的顶级域名 uk, fr, ca, jp.</p>
<p><strong>权威DNS服务器</strong>(authoritative DNS servers): 在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。组织机构的权威DNS服务器负责保存这些DNS记录。多数大学和公司维护它们的基本权威DNS服务器</p>
<p>本地DNS服务器(Local DNS name server)</p>
<ul>
<li>严格来说不属于该服务器的层次结构</li>
<li>每个ISP（如居民区ISP、公司、大学）都有一个本地DNS，也叫默认服务器</li>
<li>当主机发出DNS请求时，该请求被发往本地DNS服务器。起着代理的作用，转发请求到层次结构中</li>
</ul>
<p>17、DNS的查询方法</p>
<p> 问题：Cis.poly.edu的主机想获得gaia.cs.umass.edu的IP地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_15-24-12.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_15-24-20.png">假设用一个全新的浏览器（第一次启动的那种），访问百度（<a href="http://www.baidu.com/">http://www.baidu.com/</a> )，在敲入网址并按下回车之后：</p>
<p>1、<strong>获得IP地址</strong></p>
<p>（1）首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表（2）若没有命中，则继续搜索操作系统的 DNS 缓存（Linux,&#x2F;etc&#x2F;hosts; Windows, C:\WINDOWS\system32\drivers\etc\hosts）</p>
<p>（3）若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</p>
<p>（4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询       </p>
<p>本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器地址给本地服务器       </p>
<p>本地域名服务器拿到顶级域名服务器地址后，向其发起请求，获取权威域名服务器地址       </p>
<p>本地域名服务器根据权威域名服务器地址，向其发起请求，得到该域名对应的 IP 地址      </p>
<p>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p>
<p>（5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存。浏览器得到域名对应的 IP 地址，并将 IP 地址缓存（<strong>缓存时间</strong>）。</p>
<p>2、和起始服务器（或者Web缓存&#x2F;代理服务器），建立TCP连接   得到百度的IP，下一步是使用TCP协议，建立TCP连接。</p>
<p>3、向起始服务器（或者Web缓存&#x2F;代理服务器）发送请求报文，用HTTP协议请求网页内容</p>
<p>4、浏览器收到响应报文，并解析。</p>
<p>18、DNS记录，创建一个“网络乌托邦”公司，如何搭建权威服务器</p>
<p><strong>DNS</strong>: 存储资源记录(<strong>RR</strong>，Resource Records)的分布式数据库</p>
<p><strong>RR 格式: (name, value, type,ttl)</strong></p>
<p>Type&#x3D;A（Address）</p>
<ul>
<li>name &#x3D; 主机名</li>
<li>value &#x3D; IP地址</li>
</ul>
<p>Type&#x3D;CNAME（canonical）</p>
<ul>
<li><p>name &#x3D; 主机别名 </p>
<p> <a href="http://www.ibm.com/">www.ibm.com</a> 的真名为	servereast.backup2.ibm.com</p>
</li>
<li><p>value &#x3D; 真实的规范主机名</p>
</li>
</ul>
<p>Type&#x3D;NS（ name server ）</p>
<ul>
<li>name &#x3D; 域名（如foo.com） </li>
<li>value &#x3D; 该域权威名字服务器的主机名</li>
</ul>
<p>Type&#x3D;MX（mail exchange）</p>
<ul>
<li>name &#x3D;邮件服务器的主机别名</li>
<li>value &#x3D;邮件服务器的真实规范主机名</li>
</ul>
<p>例子：刚刚创建一个“网络乌托邦”公司</p>
<p>在域名管理机构(如Network Solutions)注册域名networkutopia.com</p>
<ul>
<li>需要提供你自己的基本权威DNS服务器的名字和IP地址</li>
<li>该注册登记机构将下列两条资源记录插入注册机构的DNS系统中： <ul>
<li>(networkutopia.com, dns1.networkutopia.com,NS)</li>
<li>(dns1.networkutopia.com, 212.212.212.1, A)</li>
</ul>
</li>
</ul>
<p>在权威域名解析服务器中为<a href="http://www.networkuptopia.com/">www.networkuptopia.com</a> （真实机器名web1. networkuptopia.com, IP地址212.212.212.2）加入Type A记录，为mail.networkutopia.com(真实机器名mx1.mxmail. networkuptopia.com,IP地址212.212.212.3)加入Type MX记录</p>
<ul>
<li>（ <a href="http://www.networkuptopia.com/">www.networkuptopia.com</a> , web1. networkuptopia.com,CNAME） </li>
<li>（web1. networkuptopia.com,212.212.212.2, A)</li>
<li>（ mail.networkutopia.com, mx1.mxmail. networkuptopia.com, MX）</li>
<li>（mx1.mxmail. networkuptopia.com,212.212.212.3,A）</li>
</ul>
<p>网站主机名是<a href="http://www.foo.com/">www.foo.com</a> ， 真实的规范主机名是servereast.backup1.foo.com，IP地址：112.147.11.30。邮件主机名mail.foo.com,真实的规范主机名servereast.backup2.foo.com，IP地址：112.147.11.40。在权威服务器中需要的RR？</p>
<ul>
<li>(<a href="http://www.foo.com/">www.foo.com</a> , servereast.backup1.foo.com, CNAME）</li>
<li>(servereast.backup1.foo.com ,12.147.11.30, A ）</li>
<li>(mail.foo.com, servereast.backup2.foo.com, MX ）</li>
<li>(servereast.backup2.foo.com, 112.147.11.40, A)</li>
</ul>
<p>19、DNS协议、消息</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_15-26-34.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_15-26-42.png"></p>
<p>20、DNS安全</p>
<ul>
<li><p>DDoS攻击：对根域名服务器或顶级域名服务器发起拒绝服务攻击</p>
</li>
<li><p>重定向攻击：中间人攻击、DNS中毒攻击（发送欺骗的域名解析结果给DNS服务器）</p>
</li>
<li><p>利用DNS实现DDoS攻击： DNS反弹式拒绝服务攻击(DNS reflector attacks，又称DNS amplification attacks)。伪造客户地址向大量的dns服务器发出请求，导致客户无法访问dns服务器进行域名解析。</p>
</li>
<li><p>个人用户：本机Host文件被篡改&#x2F;DNS劫持&#x2F;DNS污染</p>
</li>
</ul>
<p>21、CDN的作用和实现过程</p>
<p>挑战: 如何从海量的视频中，挑选出某些内容，采用流的方式发送给成千上万的用户？</p>
<p>选项1: 使用单点，庞大的服务器</p>
<ul>
<li><p>单点故障</p>
</li>
<li><p>单点网络拥塞</p>
</li>
<li><p>远距离用户的访问路径很长</p>
</li>
<li><p>输出链路上发送同一视频的多份重复拷贝….</p>
</li>
</ul>
<p>很显然: 这种方案<strong>不具有可扩展性</strong></p>
<p>选项2: 将多份拷贝存储在地理上分散的不同站点来提供服务（CDN）</p>
<ul>
<li>深入: 将CDN服务器部署在众多的接入网络中 <ul>
<li>靠近用户</li>
<li>Akamai首创, 使用了1700多个位置</li>
</ul>
</li>
<li>邀请做客: 在少量(例如10个)靠近接入网的关键位置(例如IXP)，建造大集群，邀请到ISP做客<ul>
<li>Limelight等使用</li>
</ul>
</li>
</ul>
<p>CDN: 将内容的拷贝存储在CDN节点中<br>用户向CDN请求内容</p>
<ul>
<li>被定向到附近的拷贝，取得内容</li>
<li>如果网络路径拥塞，则可能选择其他的拷贝</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_15-28-26.png"></p>
<hr>
<p>如果客户机请求一个html页面，在该页面包括了7个gif图片的引用，且所有对象都在一台服务器上。（1）当采用非持续连接时，客户机需要与web服务器建立（    8    ）个TCP连接。（2）使用非流水线的持久HTTP连接使用的TCP连接数为（   1     ），总共需要（ 9   ）个RTT才能完成整个网页的获取。（3）在持久的带流水线HTTP连接中，客户端最少需要使用（   3   ）个RTT才能完成整个网页的获取。</p>
<p>在浏览器和初始服务器之间使用<em>非持续连接</em>的话，一个TCP报文段是可能携带两个不同的HTTP服务请求报文的。（×）</p>
<p>两个不同的Web页面（例如，<a href="http://www.uestc.edu.cn/index.html">www.uestc.edu.cn/index.html</a> 和mail.uestc.edu.cn&#x2F;index.html）可以使用一个持久连接发送。（ ×  ）不属于同一个域名，位于同一个Web服务器上的多个页面可以通过同一条持续TCP连接发送给客户端。</p>
<p>在HTTP响应报文中的Date：首部指出了该响应中对象最后一次修改的时间。（x）响应报文中首部行的Date只记录服务器产生并且发送该响应报文的日期和时间。Last——modified才是记录了对象创建或者是最后一次修改的时间。</p>
<p>HTTP响应报文绝不会具有空的报文体。（x） head方法的响应报文是空报文体</p>
<p>以下所示HTTP报文头部的请求行或者状态行中，格式正确的是(   C     )</p>
<p>A、200 HTTP&#x2F;1.1 OK		     	</p>
<p>B、PUT HTTP&#x2F;1.0 404 NOT FOUND</p>
<p>C、GET &#x2F;star&#x2F;abc.htm HTTP&#x2F;1.1             </p>
<p>D、200 GET HTTP&#x2F;1.1 OK</p>
<p>假设用户A使用IE浏览器用基于Web的电子邮件账户向B发送邮件，B使用Foxmail作为用户代理来接收邮件，使用的协议可能是以下哪种情形? (   C    )。	</p>
<p>A、IMAP 、SMTP、POP3      </p>
<p>B、HTTP、MIME、POP3  	</p>
<p>C、HTTP、SMTP、POP3        </p>
<p>D、SMTP、SMTP、IMAP</p>
<p>假设用户A用浏览器登录电子邮箱给用户B发送邮件，同时，用户B也用浏览器登录电子邮箱接收邮件，邮件从用户A的主机到用户B的主机，使用了哪些应用层协议？如果用户A和B使用了Foxmail等邮件客户端呢？</p>
<p>用户A使用浏览器登录邮箱，使用了http协议访问发送方邮箱服务器，从发送方邮箱服务器到接收方邮箱服务器只能使用SMTP（Simple Mail Transfer Protocol）协议，用户B使用浏览器登录邮箱还是用的http协议。<strong>如果A使用了邮件客户端登录邮箱发送邮件，那么使用的是SMTP协议</strong>，用户B使用邮件客户端登录邮箱取邮件则使用的是POP3协议。<br>SMTP协议是面向ASCII编码的，那么它使用（  D    ）支持非ASCII的数据传输。	</p>
<p>A、MAIL    B、POP3    C、IMAP     D、MIME</p>
<p>SMTP协议和POP3协议分别是基于运输层的（D     ）。	</p>
<p>A、UDP协议和UDP协议   </p>
<p>B、UDP协议和TCP协议	</p>
<p>C、TCP协议和UDP协议   </p>
<p>D、TCP协议和TCP协议</p>
<p>电子邮件系统中，用户代理把邮件发往发送发邮件服务器、发送方邮件服务器把邮件发往接收方邮件服务器以及用户使用用户代理从接收方邮件服务器上读取邮件时，使用的协议可能是以下的哪种情形? (D   )	</p>
<p>A、IMAP 、SMTP、POP3 </p>
<p>B、MIME、SMTP、POP3	</p>
<p>C、SMTP、IMAP、POP3   </p>
<p>D、SMTP、SMTP、IMAP</p>
<p><strong>SMTP：</strong> 只能发送7比特 ASCII 码格式，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 <strong>POP3</strong>的特点是只要用户从服务器上读取了邮件，就把该邮件删除。 <strong>IMAP 协议</strong>中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地从任何一台机器去访问服务器上的邮件。</p>
<p>SMTP：发件人用户代理 —-发送邮件—&gt; 发送方邮件服务器 、发送方邮件服务器 —-发送邮件—&gt; 接收方邮件服务器 </p>
<p> POP3&#x2F;IMAP：接受方邮件服务器—-读取邮件—&gt;   收件人用户代理</p>
<p>在使用浏览器打开某个网页时，用户输入网址后，浏览器首先要进行( B      )。</p>
<p>A、和服务器建立TCP连接    </p>
<p>B、域名到IP地址的解析</p>
<p>C、发送UDP分组到服务器    </p>
<p>D、发出GET的HTTP命令来获得网页内容</p>
<p>Internet中域名解析依赖于由域名服务器组成的逻辑树。请问在域名解析过程中，主机上请求域名解析的软件不需要知道以下哪些信息？ (  C   )。</p>
<p>①本地域名服务器的端口号  ②本地域名服务器父结点的IP  ③域名服务器树根结点的IP</p>
<p>A、①②    B、①②③    C、②③     D、①②③</p>
<p>主机上请求域名解析的软件只需要知道本地域名服务器的IP地址和端口号，然后向本地域名服务器发送DNS查询请求。本地域名服务器会根据自己的缓存和配置，返回查询结果或者将查询请求转发给其他域名服务器（包括根域名服务器、顶级域名服务器）。</p>
<p>关于DNS描述错误的是(  D   )。</p>
<p>A、将主机名转换为IP地址</p>
<p>B、所有的DNS请求和回答报文使用的是53端口发送</p>
<p>C、在因特网上DNS功能的实现采用的是分布式、层次数据库</p>
<p>D、DNS的请求和回答报文采用的是TCP协议进行传输的</p>
<p>DNS使用UDP协议进行传输，所有的DNS请求和回答报文都使用53端口发送。</p>
<p>查询链中的DNS服务器如果不是某主机名的权威服务器，对于该主机名，它必将包含对应的两种类型记录，分别为（  C     ）。</p>
<p>A、CNAME和A    B、MX和NS      C、NS和A     D、NS和MX</p>
<p>当查询链中的DNS服务器不是某主机名的权威服务器时，它可能包含NS记录和A记录。NS记录（Name Server Record）是一种DNS记录类型，用于指定某个域名的权威服务器。例如，如果查询链中的DNS服务器不是<a href="http://www.example.com/">www.example.com</a> 的权威服务器，那么它可能包含一条NS记录，指定<a href="http://www.example.com/">www.example.com</a> 的权威服务器为dns1.example.com。A记录（Address Record）是一种DNS记录类型，用于将域名映射到IPv4地址。例如，如果查询链中的DNS服务器不是<a href="http://www.example.com/">www.example.com</a> 的权威服务器，那么它可能包含一条A记录，将<a href="http://www.example.com/">www.example.com</a> 映射到对应的IP地址。</p>
<p>HTTP 协议中，接收方如何区分首部行和数据部分（C  ）</p>
<p>A.报文中首部行长度字段 		</p>
<p>B. 报文中使用 DATA 指令指示首部行结束 </p>
<p>C. 报文中首部行结束时添加空行 	</p>
<p>D. 报文中首部行结束时增加“.”作为分隔行</p>
<p>DNS 实现的功能不包括（D ） </p>
<p>A.主机名和 IP 地址映射 	B. 别名处理 	C. 负载分配 	D. 路由选择</p>
<p>DNS并不负责路由选择，这一功能由路由器等网络设备实现。</p>
<p>假定你在浏览器中点击一条超链接获得Web页面。相关联的URL的IP地址没有缓存在本地主机上,因此必须使用DNS lookup以获得该IP地址。如果主机从DNS得到IP地址之前已经访问了n个DNS服务器；相继产生的RTT依次为RTT1、…、RTTn。进一步假定与链路相关的Web页面只包含一个对象，即由少量的HTML文本组成。令RTT0表示本地主机和包含对象的服务器之间的RTT值。假定该对象传输时间为零，则从该客户点击该超链接到它接收到该对象需要多长时间？</p>
<p><em><strong>RTT1+…+RTTn+ 2RTT0</strong></em>（解析ip地址的时间+建立tcp连接和请求得到web页面的时间）</p>
<p>参照上题,假定在同一服务器上某HTML文件引用了 8个非常小的对象。忽略发送时间，在下列情况下需要多长时间：</p>
<p>(1)没有并行TCP连接的非持续HTTP。</p>
<p><em><strong>RTT1+…+RTTn+ 18RTT0</strong></em></p>
<p>(2)配置有5个并行连接的非持续HTTP。</p>
<p><em><strong>RTT1+…+RTTn+ 6RTT0</strong></em></p>
<p>(3)持续HTTP.</p>
<p><em><strong>流水    ：RTT1+…+RTTn+ 3RTT0</strong></em></p>
<p><em><strong>非流水： RTT1+…+RTTn+ 10RTT0</strong></em></p>
<p>考虑下图,其中有一个机构的网络和因特网相连。假定对象的平均长度为850 000bits，从这个机构网的浏览器到初始服务器的平均请求率是每秒16个请求。还假定从接入链路的因特网一侧的路由器转发一个HTTP请求开始，到接收到其响应的平均时间是3秒。将总的平均响应时间建模为平均接入时延（即从因特网路由器到机构路由器的时延）和平均因特网时延之和。对于平均接入时延，使用△&#x2F;（1-△B），式中△是跨越接入链路发送一个对象的平均时间，B是对象对该接入链路的平均到达率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_21-43-05.png"></p>
<p>(1)求出总的平均响应时间。</p>
<p>(2)现在假定在这个机构LAN中安装了一个缓存器。假定未命中率为0.4,求出总的响应时间。</p>
<p>(1)由题意：总平均响应时间&#x3D;平均接入时延+平均因特网时延。<br>其中，平均因特网时延&#x3D;3秒<br>平均接入时延&#x3D;△&#x2F;(1-△B)<br>△&#x3D;850000bit&#x2F;15Mbps&#x3D;850000bit &#x2F; 15000000bit&#x2F;s&#x3D;0.0567s<br>B&#x3D;16请求&#x2F;s</p>
<p>△B&#x3D;16*0.0567≈0.907</p>
<p>平均接入时延&#x3D;0.0567&#x2F;(1-0.907)≈0.6s<br>总平均响应时延&#x3D;0.6+3&#x3D;3.6s</p>
<p>(2)未命中率0.4，所以有60%可以通过缓存器立即响应。<br>平均接入时延&#x3D;△&#x2F;(1-△B)&#x3D;0.0567&#x2F;(1-0.4*0.907)≈0.089s<br>所以总响应时间&#x3D;0.6 * 0 +(0.089+3) * 0.4 ≈ 1.24s<br>考虑一条10米短链路，某发送方经过它能够以150bps速率双向传输。假定包含数据分组是 100Kbits，仅包含控制（如ACK或握手）的分组是200bits。假定N个并行连接每个都获 得1&#x2F;N的链路带宽。现在考虑HTTP协议，并且假定每个下载对象是100Kbits，这些初始下载对象包含10个来自相同发送方的引用对象。在这种情况下，经非持续HTTP的并行实例的并行下载有意义吗？现在考虑持续HTTP。你期待这比非持续的情况有很大增益吗？评价并解释你的答案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/ed56f1012b1bd986bc93169fd8c9e25b.png"></p>
<p>每个下载的对象可以完全放入一个数据包中。令Tp表示客户端和服务器之间的单向传播延迟。传输第一个文件之后再并行传输，由于非持续HTTP需要重新建立TCP连接（三次握手），并行下载将允许10个连接共享150位&#x2F;秒的带宽，每个连接只有15个位&#x2F;秒，因此，接收所有对象所需的总时间为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_22-05-45.png"></p>
<p>现在考虑一个持久的HTTP连接，所需的总时间为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_22-05-51.png"></p>
<p>增益似乎不是很大。</p>
<p>考虑在上一个习题中引出的情况。现在假定该链路由Bob和4个其他用户所共享。Bob使用非持续HTTP的并行实例，而其他4个用户使用无并行下载的非持续HTTP。</p>
<p>a. Bob的并行连接能够帮助他更快地得到Web页面吗？</p>
<p>b. 如果所有5个用户打开5个非持续HTTP并行实例，那么Bob的并行连接仍将是有好处的吗？为什么?</p>
<p>a)是的，因为Bob有更多的连接，他可以获得更大的带宽份额。</p>
<p>b)是的，Bob 仍然需要执行并行下载；否则他将比其他四个用户获得更少的带宽。</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网期末复习之链路层</title>
    <url>/2023/06/23/%E8%AE%A1%E7%BD%91/5/</url>
    <content><![CDATA[<p><em>链路层的术语</em></p>
<ul>
<li>主机和路由器: <strong>节点</strong>(nodes)</li>
<li>沿着通信路径连接相邻节点的通信信道：<strong>链路</strong>(links)<ul>
<li>有线链路(wired links)</li>
<li>无线链路(wireless links)</li>
</ul>
</li>
<li>第二层的分组:<strong>数据帧</strong>(frame), 它是封装了的数据报</li>
</ul>
<p><strong>数据链路层</strong>的职责是<strong>将数据报从一个节点传送到与该节点直接有物理链路相连的另一个节点</strong>。</p>
<p>数据报可以在不同的链路上，通过不同的链路层协议发送：</p>
<p>e.g., Ethernet on first link, frame relay on intermediate links, 802.11 on last link</p>
<p>每个链路层协议提供不同的服务：</p>
<p>e.g., 可以提供&#x2F;也可以不提供可靠数据传输服务</p>
<p>1、链路层提供哪些服务</p>
<ul>
<li>封装成帧，链路接入：<ul>
<li>封装数据报为数据帧，增加头部，尾部信息</li>
<li>如果是共享链路，接入链路</li>
<li>在数据帧头部中，用MAC地址来标识源目的MAC地址（不同于IP地址）</li>
</ul>
</li>
<li>在相邻节点之间可靠传输数据帧</li>
<li>流量控制</li>
<li>差错检查</li>
<li>错误纠正</li>
<li>半双工和全双工：在半双工模式，链路的两个节点都可以发送数据，但是不能同时发送。</li>
</ul>
<p>链路层在主机和网络设备(路由器)上实现</p>
<ul>
<li>在主机上，链路层的主体部分是在<strong>网络适配器</strong>上实现的(称为网卡)</li>
</ul>
<p>2、三种主要差错检测技术特点，要会计算</p>
<ul>
<li><strong>奇偶校验</strong>：最基本的方法。<ul>
<li>1维奇偶校验：可以查出任意奇数个错误，但不能发现偶数个错误</li>
<li>2维奇偶校验：可以检测并纠正单个比特差错（数据或校验位中） ；能够检测(但不能纠正)分组中任意两个比特的差错</li>
</ul>
</li>
<li><strong>Internet校验和</strong>：常用于<em><strong>运输层</strong></em>。<ul>
<li>分组<strong>开销小</strong>：检查和位数比较少；</li>
<li>差错<strong>检测能力弱</strong>差错检测用软件实现</li>
</ul>
</li>
<li><strong>循环冗余检测</strong>：常用于<em><strong>链路层</strong></em>。<ul>
<li>能检测小于 r+1 位的突发差错、任何奇数个差错</li>
</ul>
</li>
</ul>
<p><strong>一比特奇偶校验</strong></p>
<p>发送方：</p>
<ul>
<li>在要发送的信息D（d位）后面附加一个奇偶校验位</li>
<li>使“1”的个数是奇数（奇校验）或偶数（偶校验）</li>
<li>一起传输发送（d+1位）。</li>
</ul>
<p>接收方：</p>
<ul>
<li>检测收到的信息（d+1位）中“1”的个数。</li>
<li>偶校验：发现奇数个“1”，至少有一个比特发生差错（奇数个比特差错）。</li>
<li>奇校验：发现偶数个“1”，至少有一个比特发生差错。</li>
</ul>
<p>可以查出任意奇数个错误，但不能发现偶数个错误（如果数据中发生了偶数个错误，那么这些错误将抵消彼此）。若比特差错概率很小，差错独立发生，一比特奇偶校验可满足要求。若差错集中一起“突发”（突发差错），一帧中未检测到的差错的概率达到50%。</p>
<p><strong>二维奇偶校验</strong></p>
<p>基本思想：</p>
<ul>
<li>将要传信息D（d比特）划分为**i行j 列(i 个组，每组j位)**；</li>
<li>对每行和每列分别计算奇偶值；</li>
<li>结果的<strong>i+j+1</strong>个奇偶比特构成了帧的差错检测比特。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_22-39-50.png"></p>
<p>要发送的数据比特10101 11110 01110，划分3组，每组5个比特。进行<strong>行、列偶</strong>校验</p>
<p>特点：</p>
<ul>
<li>可以<strong>检测并纠正单个比特差错</strong>（数据或校验位中）。</li>
<li>能够<strong>检测(但不能纠正)分组中任意两个比特的差错</strong>。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_22-40-10.png"></p>
<p><strong>Internet校验和方法</strong></p>
<p>发送方：</p>
<ul>
<li>将数据的每两个字节当作一个16位的整数，可分成若干整数；</li>
<li>将所有16 位的整数求和；</li>
<li>对得到的和逐位取反，作为检查和，放在报文段首部，一起发送。</li>
</ul>
<p>接收方：对接收到的信息 (包括检查和)按与发送方相同的方法求和。</p>
<ul>
<li>全“1”：收到的数据无差错；</li>
<li>其中有“0”：收到的数据出现差错。</li>
</ul>
<p><strong>循环冗余检测</strong></p>
<p>循环冗余检测CRC (cyclic redundancy check)编码：即<strong>多项式编码</strong>，把要发送的比特串看作为系数是0或1的一个多项式，对比特串的操作看作为多项式运算。</p>
<p>10111→ x⁴+x²+x+1</p>
<p>基本思想：设发送节点要把数据D（<strong>d 比特</strong>）发送给接收节点。发送方和接收方先共同选定一个<strong>生成多项式 G（r+1比特），最高有效位 (最左边)是1</strong>。</p>
<p><em><strong>发送方</strong></em>：</p>
<ul>
<li>计算出一个r位附加比特R，添加到D的后面产生DR（d+r 比特）</li>
<li>DR能被生成多项式G模2运算整除，一起发送。</li>
</ul>
<p><em><strong>接收方</strong></em>：</p>
<ul>
<li>用生成多项式G去除接收到的DR（d+r比特）<ul>
<li>余数非0：传输发生差错；</li>
<li>余数为0：传输正确，去掉尾部r位，得所需数据D。</li>
</ul>
</li>
</ul>
<p><em><strong>模2运算</strong></em></p>
<p><strong>加法不进位，减法不借位</strong>，即操作数按位异或 (XOR)</p>
<p>1011  XOR  0101&#x3D;1110；   1011-0101&#x3D;1110     </p>
<p>1001  XOR  1101&#x3D;0100    ；   1001-1101&#x3D;0100</p>
<p><strong>乘法和除法与二进制运算类似</strong>，其中加法或减法没有进位或借位。</p>
<p><strong>乘以2^r，即比特模式左移r 个位置</strong>。</p>
<p>D×2^r  XOR  R &#x3D; D <strong>00…00</strong>  XOR  R &#x3D; DR  (d+r 比特)</p>
<p><em><strong>计算R（CRC比特）</strong></em></p>
<ul>
<li><p>DR能被G模2运算整除：即                             </p>
<p>D×2^r  XOR  R &#x3D; nG</p>
</li>
<li><p>等式两边都用R异或，得到                             </p>
<p>D×2^r &#x3D; nG  XOR  R     </p>
</li>
<li><p>即用G来除D×2^r，余数值刚好为R。</p>
</li>
<li><p><strong>R的计算：将数据D后面添加r个0，除以给定的生成多项式G，所得余数即为R</strong>（r位）。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_09-11-07.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_09-12-39.png"></p>
<p>3、多路访问链路协议（也称多址访问协议）</p>
<p>目的：协调多个节点在共享广播信道上的传输。</p>
<p>冲突（collide）：两个以上的节点同时传输帧，使接收方收不到正确的帧（所有冲突的帧都受损丢失）。</p>
<ul>
<li><strong>信道划分协议</strong>: TDMA、FDMA、CDMA（时分，频分，码分）<ul>
<li>把信道划分为小“片” (时隙)；给节点分配专用的小“片”</li>
</ul>
</li>
<li><strong>随机访问协议</strong>: ALOHA(纯ALOHA，时隙ALOHA)、CSMA、CSMA&#x2F;CD（以太网）、CSMA&#x2F;CA（无线局域网）<ul>
<li>不划分信道，允许冲突；能从冲突中“恢复”</li>
</ul>
</li>
<li><strong>轮流协议</strong>：轮询（来自中心站）、令牌通过轮流访问信道避免冲突，要发送的节点越多轮流时间越长</li>
</ul>
<p>4、以太网CSMA&#x2F;CD的运行机制</p>
<p>(1) 适配器从网络层得到分组, 创建帧</p>
<p>(2)如果适配器侦听到信道空闲,开始传送帧。如果信道忙, 它会等到信道空闲才传送帧</p>
<p>(3)如果适配器传送整个帧时，都没有检测到其它传输, 则完成该帧的传送</p>
<p>(4)如果适配器在发送中检测到其它传送,就放弃传送，并发送一个拥塞信号</p>
<p>(5)放弃传送后，适配器进入指数回退阶段，即该帧经过n次冲突后，适配器在{0,1,2,…,2m-1}中随机选取一个K值 ，其中m&#x3D;min(n,10),然后等待K*512比特时间后,回到第2步</p>
<p>5、链路层寻址</p>
<p>每个节点有网络层地址和链路层地址。</p>
<p><strong>网络层地址</strong>：节点在网络中分配的一个唯一地址（IP地址）。用于把分组送到目的IP网络。长度为32比特（IPv4）。</p>
<p><strong>链路层地址</strong>：又叫做MAC地址或物理地址、局域网地址。</p>
<ul>
<li>用于把数据帧从一个节点传送到另一个节点(同一网络中)。</li>
</ul>
<p>MAC地址（LAN地址、物理地址）：</p>
<ul>
<li>节点“网卡”本身所带的地址（唯一）。MAC地址长度通常为6字节(48比特)，共2⁴⁸个。例如：<font color=red>1A-2F-BB-76-09-AD</font></li>
<li>6字节地址用<strong>16进制表示</strong>，每个字节表示为一对16进制数</li>
<li>网卡的MAC地址是<strong>永久的</strong>（生产时固化在其ROM里）</li>
</ul>
<p><strong>局域网中每个网卡都有唯一的局域网地址</strong></p>
<p><em><strong>MAC地址分配</strong></em></p>
<p>由专门机构IEEE管理物理地址空间</p>
<ul>
<li>负责分配六个字节中的<strong>前三个字节</strong>（高24位，<strong>地址块</strong>），后三个字节厂家自行分配。</li>
</ul>
<p><em>MAC 地址是平面结构</em></p>
<ul>
<li><strong>带有同一网卡的节点，在任何网络中都有同样的MAC地址</strong>。</li>
</ul>
<p><em>IP地址具有层次结构</em></p>
<ul>
<li>当节点移动到不同网络时，节点的IP地址发生改变。</li>
</ul>
<p><em><strong>节点的3种不同地址表示</strong></em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_09-50-28.png"></p>
<p><em>地址之间的转换</em></p>
<p>通信时，需要进行地址转换：       </p>
<p><strong>主机名→ IP地址→ MAC地址</strong></p>
<p>DNS域名系统：将<strong>主机名解析到IP地址</strong>。</p>
<ul>
<li>DNS为在因特网中任何地方的主机解析主机名。</li>
</ul>
<p>ARP地址解析协议：将<strong>IP地址解析到MAC地址</strong>。</p>
<ul>
<li>ARP只为在<strong>同一个LAN</strong>上的节点解析IP地址。</li>
</ul>
<p>6、 ARP地址解析协议（同一个子网或不同子网）</p>
<p>（1）<strong>ARP表</strong>: 局域网上的每个节点(主机、路由器)都有这个表，为某些局域网节点进行IP&#x2F;MAC地址映射：     </p>
<p><strong>&lt; IP address; MAC address; TTL&gt;</strong></p>
<p>TTL (存活时间): 地址映射将被删除的时间（通常为20分钟）</p>
<p>（2）两个主机位于同一个局域网</p>
<ul>
<li>主机A希望发送数据报给主机B<ul>
<li>B的MAC地址不在A的ARP映射表中</li>
</ul>
</li>
<li>主机A 广播 ARP查询分组, 其中包含<strong>B的IP地址</strong> <ul>
<li>目的MAC地址 &#x3D; FF-FF-FF-FF-FF-FF</li>
<li>局域网中所有节点收到ARP查询分组</li>
</ul>
</li>
<li>主机B收到ARP查询分组，返回B的MAC地址给主机A<ul>
<li>利用单播帧向A发送应答</li>
</ul>
</li>
<li>主机A在它的ARP表中缓存<strong>IP-to-MAC</strong> 地址对，直到信息 <ul>
<li>软状态：信息超时会被删除，除非有新的更新消息</li>
</ul>
</li>
</ul>
<p>（3）发送数据报到子网以外</p>
<ul>
<li><p>主机A构建IP数据报，源地址是A的IP地址，目的地址是B的IP地址。</p>
</li>
<li><p>主机A构建链路层数据帧，其中源MAC地址是A的MAC地址，目的MAC地址是第一跳路由器<strong>接口的MAC地址</strong>，封装A到B的IP数据报。</p>
</li>
<li><p>数据帧从主机A发送到路由器R</p>
</li>
<li><p>路由器R收到数据帧，抽取出数据报递交到IP层</p>
</li>
<li><p>路由器R转发数据报，源地址为A的IP地址，目的地址为B的IP地址</p>
</li>
<li><p>路由器R将该数据报封装成链路层帧，目的MAC地址为主机B的MAC地址</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_09-51-01.png">7、以太网帧格式、不可靠的无连接服务</p>
<p>到目前为止，以太网是最为著名的有线局域网技术。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_09-53-00.png"></p>
<p>发送方：发送适配器将<strong>IP数据报封装</strong>成以太网帧，并传递到<strong>物理层</strong>。</p>
<p>接收方：接收适配器从物理层收到该帧，<strong>取出IP数据报</strong>，并传递给<strong>网络层</strong>。</p>
<p><em><strong>前同步码（8字节）</strong></em></p>
<ul>
<li>前7字节是“10101010”，最后一个字节是“10101011”。</li>
<li>使接收方和发送方的<strong>时钟同步</strong>，接收方一旦收到连续的8字节前同步码，可确定有帧传过来。</li>
<li><strong>前同步码是“无效信号”，接收方收到后删除，不向上层传</strong>。</li>
<li>CRC的校验范围不包括前同步码。</li>
</ul>
<p><em><strong>源、目的MAC地址(各6字节)</strong></em></p>
<p>例，同一以太网LAN中两台主机通信。主机A向主机B发送一个IP数据报。</p>
<p>主机A适配器的MAC地址：XX-XX-XX-XX-XX-XX</p>
<p>主机B适配器的MAC地址：YY-YY-YY-YY-YY-YY</p>
<p>适配器B<strong>只接收目的地址与其MAC地址匹配或广播地址的帧</strong>，并将数据字段的内容传递给网络层。否则，丢弃该帧。</p>
<p><em><strong>类型字段：</strong></em></p>
<ul>
<li>以太网可以<strong>“多路复用”（支持）多种网络层</strong>协议（如IP协议、Novell IPX） 。通过“类型”字段区分。</li>
<li>发送方填入<strong>网络层协议</strong>“类型” 编号；接收适配器根据“类型”字段，将数据字段传递给相应的网络层协议。</li>
</ul>
<p><strong>数据字段（46～1500 字节）：携带网络层传来的IP数据报</strong></p>
<ul>
<li>以太网的最大传输单元MTU是1500字节：若IP数据报超过1500字节，必须将该数据报分段。</li>
<li>最小长度是46字节：如果IP数据报小于46字节，<strong>必须填充为46字节</strong>。接收方网络层去除填充内容。</li>
</ul>
<p><em><strong>循环冗余检测CRC(4字节)</strong></em></p>
<p>检测数据帧中是否出现<strong>比特差错（翻转）</strong>。</p>
<ul>
<li>发送主机计算CRC：范围包括目的地址、源地址、类型、数据字段的比特，结果放入帧CRC字段。</li>
<li>接收主机进行CRC校验：接收主机对收到的帧进行同样计算，并校验结果是否和CRC字段的内容相等。若<strong>计算结果不等于CRC字段的值</strong>(CRC校验失败)，该帧有差错。</li>
</ul>
<p><em><strong>以太网: 不可靠的无连接服务</strong></em></p>
<p>以太网向网络层提供的服务。</p>
<ul>
<li>无连接服务：通信时，<strong>发送方适配器不需要先和接收方适配器“握手”</strong>。</li>
<li>不可靠的服务：接收到的<strong>帧可能包含比特差错</strong>。<ul>
<li>收到正确帧，<strong>不发确认帧</strong>；</li>
<li>收到出错帧，丢弃该帧，<strong>不发否定帧</strong>。</li>
<li>发送适配器不会重发出错帧。</li>
<li>丢弃数据的恢复是通过终端<strong>传输层</strong>的可靠数据传输机制来实现的</li>
</ul>
</li>
<li>以太网的MAC协议：<strong>使用无时隙的CSMA&#x2F;CD协议（二进制指数回退）</strong></li>
</ul>
<p>8、链路层交换机如何构建转发表</p>
<p>链路层设备</p>
<ul>
<li><p>存储转发数据帧</p>
</li>
<li><p>检查达到的数据帧的MAC地址，有选择的转发数据帧到一个或多个输出链路转发帧</p>
</li>
<li><p>当数据帧被转发到一个共享网段时，使用CSMA&#x2F;CD来访问共享链路</p>
</li>
</ul>
<p>透明</p>
<ul>
<li>主机不关心是否存在交换机</li>
</ul>
<p>即插即用和自学习       </p>
<ul>
<li>交换机不需要手工配置</li>
</ul>
<p>交换机：支持多节点同时传输</p>
<ul>
<li><p>每个主机由单独的链路直接连到交换机端口</p>
</li>
<li><p>交换机可以缓存数据帧</p>
</li>
<li><p>以太网协议在每个输入链路使用，无碰撞，且可以全双工</p>
<ul>
<li>每条链路自身是一个碰撞域</li>
</ul>
</li>
<li><p>交换机： A-to-A’和B-to-B’可以同时传输，而不会发生碰撞</p>
</li>
</ul>
<p>转发表</p>
<ul>
<li>每个交换机有一个交换机转发表，其中每个条目：(主机的MAC地址，到达主机的端口，时戳)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_10-21-33.png"></p>
<p>自学习</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_10-22-39.png"></p>
<p><em><strong>交换机：数据帧的过滤&#x2F;转发</strong></em></p>
<p>当交换机收到数据帧:</p>
<ol>
<li>记录到达链路和发送主机的MAC地址</li>
<li>使用数据帧的目的MAC地址，在转发表中检索</li>
<li>如果在转发表条目中找到对应的MAC地址</li>
<li>执行{	如果 目的MAC地址对应的端口与数据帧的达到端口相同	则 丢弃该数据帧	否则 转发该数据帧到条目指定的端口}</li>
<li>否则，向除到达端口之外的所有端口转发(flood)</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_10-31-05.png"></p>
<p>问题：C发送数据帧给I——S1是怎么知道要把数据帧先转发到S4和S3的？</p>
<p>回答：<strong>泛洪和自学习</strong></p>
<p>9、三层交换含义</p>
<ul>
<li><p>传统的交换技术是在OSI网络参考模型中的第二层（即数据链路层）进行操作的，通常称做“二层交换机”。</p>
</li>
<li><p>三层交换技术能够在网络模型中的第三层实现数据包的高速转发。</p>
</li>
<li><p>简单地说，<strong>三层交换技术就是二层交换技术+三层转发技术</strong>，三层交换机就是“<strong>二层交换机+基于硬件的路由器</strong>”</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_scjhj.png"></p>
<p>一次路由，多次交换。</p>
<p>发送站点A在开始发送时，把自己的IP地址与B站的IP地址比较，判断B站是否与自己在同一子网内。</p>
<p>(1)若目的站B与发送站A在同一子网内，则进行二层的转发。</p>
<p>(2)若两个站点不在同一子网内，则发送站A要向“<strong>缺省网关</strong>”发出ARP请求，请求获得B的MAC地址。</p>
<p>(3)如果三层交换机知道B的MAC地址，则向A回复B的MAC地址。否则三层交换机根据路由信息向B站广播一个ARP请求，B站得到此ARP请求后向三层交换机回复其MAC地址，三层交换机将B站的MAC地址，三层交换机将B站的MAC地址保存到二层交换引擎的MAC地址表中，并回复给发送站A。</p>
<p>(4)A直接用B的MAC地址封装数据帧，三层交换机接收到数据后直接进行<strong>二层交换</strong>。</p>
<p>10、VLAN含义</p>
<p>利用支持VLAN的交换机，可以在一个实际的物理局域网内，定义多个虚拟的局域网。</p>
<p><strong>基于端口的VLAN</strong>:</p>
<ul>
<li>利用交换机内置的管理软件，将端口分组，使得一个单独的交换机，像多个交换机那样工作</li>
</ul>
<p><strong>跨越多个交换机的 VLAN</strong></p>
<ul>
<li>干线端口（ trunk port ）承载定义在多个物理交换机之上的VLAN间的流量</li>
<li>某一个VLAN内的流量帧，如果要跨域物理的交换机，需使用802.1q格式（带有VLAN ID 信息）802.1q协议的作用：对干线端口之间传输的帧，添加&#x2F;移除额外的头部字段</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_09-53-51.png"></p>
<hr>
<p>局域网的协议结构一般不包括（B）。</p>
<p>‏A.物理层	B.网络层	C.介质访问控制层	D.数据链路层</p>
<p>IEEE 802局域网参考模型对应OSI参考模型的数据链路层与物理层，它将数据链路层分为逻辑链路控制子层和介质访问控制子层。所以局域网的协议结构一般不包括网络层。</p>
<p>下列关于二维奇偶校验的说法，正确的是（D）。</p>
<p>A.可以检测单比特差错但无法纠正</p>
<p>B.无法检测双比特差错</p>
<p>C.可以检测和纠正双比特差错</p>
<p>D.可以检测和纠正单比特差错</p>
<p>二维奇偶校验可以检测并纠正单个比特差错，可以检测但不能纠正分组中任意两个比特的差错。</p>
<p>就交换技术而言，局域网中的以太网采用的是（A）。</p>
<p>‌A.分组交换技术</p>
<p>B.电路交换技术</p>
<p>C.报文交换技术</p>
<p>D.分组交换与电路交换结合技术</p>
<p>在路由器互联的多个局域网中，通常要求每个局域网的（D）</p>
<p>A.数据链路层协议和物理层协议都必须相同</p>
<p>B.数据链路层协议必须相同，而物理层协议可以不同</p>
<p>C.数据链路层协议可以不同，而物理层协议必须相同</p>
<p>D.数据链路层协议和物理层协议都可以不同</p>
<p>路由器是在网络层上实现多个网络互联的设备。由路由器互联的局域网中，每个局域网<strong>只要求网络层及以上高层协议相同，数据链路层与物理层协议可以是不同的</strong>。</p>
<p>设CRC生成多项式为G(x) &#x3D; x^4 + x + 1，数据帧1010 1100的CRC校验码为（D）。</p>
<p>A.110	B.011	C.1001	D.0011</p>
<p>在以太网802.3协议中规定的链路层多路访问协议是（B）。</p>
<p>‍A.时隙ALOHA</p>
<p>B.CSMA&#x2F;CD</p>
<p>C.轮询</p>
<p>D.纯ALOHA</p>
<p>CSMA&#x2F;CD（Carrier Sense Multiple Access with Collision Detection）是一种链路层多路访问协议，它被用于以太网802.3协议中。CSMA&#x2F;CD协议的工作原理是，在发送数据之前，设备会先监听信道，检测是否有其他设备正在发送数据。如果信道空闲，设备就可以开始发送数据。如果信道忙碌，设备会等待一段随机时间后再次尝试发送数据。</p>
<p>在以太网链路层中使用的差错检查技术是（D）。</p>
<p>‍A.校验和</p>
<p>B.二维奇偶校验</p>
<p>C.1比特奇偶校验</p>
<p>D.CRC循环冗余码</p>
<p>如果一台PC机A要发送数据报给另一台PC机B，如果他只知道B主机的IP地址，而不知道B主机的MAC地址，就需要通过ARP协议查询B主机的MAC地址，这时PC机A构造一个ARP查询分组，该分组的目的IP地址是B主机的IP地址，目的MAC地址是（FF-FF-FF-FF-FF-FF）。</p>
<p>解析：PC机A需要向PC机B发送数据，但它只知道PC机B的IP地址。因此，PC机A会构造一个ARP查询分组，该分组包含PC机A的IP地址和MAC地址以及PC机B的IP地址。然后，PC机A会将该分组发送到局域网中的所有设备（使用广播地址FF-FF-FF-FF-FF-FF作为目的MAC地址）。当PC机B收到该ARP查询分组时，它会检查分组中的目的IP地址是否与自己的IP地址匹配。如果匹配，PC机B就会构造一个ARP响应分组，该分组包含PC机B的IP地址和MAC地址以及PC机A的IP地址。然后，PC机B会将该分组发送回PC机A。当PC机A收到该ARP响应分组时，它就能够获得PC机B的MAC地址，并将其存储在ARP缓存中以备将来使用。这样，PC机A就能够使用PC机B的MAC地址来向其发送数据了。</p>
<p>链路层的信道类型主要分为两类：（点对点）链路和（广播）链路，其中802.11wifi使用的信道类型是（广播）链路。</p>
<p>点对点链路是指两个设备之间的直接连接，它们之间可以直接传输数据。这种类型的链路通常用于电话网络、专线网络和点对点协议（PPP）等场景。广播链路是指多个设备共享同一个信道，它们之间可以通过广播的方式传输数据。这种类型的链路通常用于局域网（LAN）和无线局域网（WLAN）等场景。802.11 Wi-Fi是一种无线局域网技术，它使用的信道类型是广播链路。在802.11 Wi-Fi网络中，多个设备可以共享同一个无线信道，并通过广播的方式进行通信。</p>
<p>载波监听多路访问&#x2F;冲突检测的原理可以概括为先听后发，（边听边发），冲突停发，随机重发。</p>
<p>在发送数据之前，设备会先监听信道，检测是否有其他设备正在发送数据。如果信道空闲，设备就可以开始发送数据。如果信道忙碌，设备会等待一段随机时间后再次尝试发送数据。在数据传输过程中，设备会持续监听信道，检测是否发生了冲突（即两个或多个设备同时发送数据）。如果发生了冲突，设备会检测到冲突并停止发送数据。然后，设备会等待一段随机时间后再次尝试发送数据。CSMA&#x2F;CD协议能够有效地减少冲突的发生，并且能够在冲突发生时快速恢复，从而提高了网络的性能。</p>
<p>在一个IP网络中负责主机IP地址与主机名称之间的转换协议称为DNS协议，负责IP地址与MAC地址之间的转换协议称为（ARP）。</p>
<p>假设结点A、B、C都连接到同一个广播局域网上。如果A向B发送IP数据报，每个封装帧都有B的MAC地址，C的适配器（会）（会&#x2F;不会）处理这些帧吗？如果会，C的适配器将会把数据帧中的IP数据报传递给C的网络层吗？（不会）（会&#x2F;不会），如果A用MAC 广播地址来发送这些帧，你的回答将有怎样的变化呢？</p>
<p>当A向B发送IP数据报时，每个封装帧都有B的MAC地址。由于A、B和C都连接到同一个广播局域网上，因此当A发送数据帧时，所有连接到该广播局域网上的设备都会接收到这些帧（这是因为广播局域网使用了广播传输方式。在广播传输方式中，当一个设备发送数据帧时，该帧会被发送到局域网中的所有设备）。<strong>C的适配器会处理这些帧，因为它需要检查每个帧的目的MAC地址，以确定该帧是否是发送给C的</strong>。如果目的MAC地址与C的MAC地址匹配，C的适配器就会把数据帧中的IP数据报传递给C的网络层。否则，C的适配器会丢弃该帧。如果A用MAC广播地址来发送这些帧，C的适配器同时处理帧并将数据报传递到网络层。</p>
<p>假设网络的拓扑结构如下图所示，如果PC1需要给PC3发送一个数据报文，假设PC1的ARP高速缓存中有路由器端口1的MAC地址，PC1发出的数据帧的源IP地址是（192.168.1.1）、目的IP地址是（192.168.2.1）、源MAC地址是（11-11-11-11-11-11）、目的MAC地址是（44-44-44-44-44-44）。PC3收到的数据帧的源IP地址是（192.168.1.1）、目的IP地址是（192.168.2.1）、源MAC地址是（55-55-55-55-55-55）、目的MAC地址是（AA-BB-CC-DD-EE-FF）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/65BD8F40248575FD537466D257525368.png"></p>
<p>注意源IP和目的IP</p>
<p>假定网络拓扑结构如下图所示，为了使网络中所有的PC机能相互通信，需要手动给路由器R1和R2添加路由表，路由器R1需要添加的路由是（192.168.4.0&#x2F;24via192.168.3.2）和（192.168.5.0&#x2F;24via192.168.3.2），R2需要添加的路由是（192.168.1.0&#x2F;24via192.168.3.1）和（192.168.2.0&#x2F;24via192.168.3.1）。（例如192.168.4.1&#x2F;24via192.168.3.3、192.168.5.1&#x2F;24via192.168.3.3、192.168.4.1&#x2F;24via192.168.3.3、192.168.5.1&#x2F;24via192.168.3.3）</p>
<p>相当于求四个主机所在计网的网络地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/2542E72D0E1CA6EEFC4520DD2F4046B4.jpg"></p>
<p>‏在某网络中标识为A到E的5个结点以星形与一台交换机连接，考虑在该网络环境中某个正在学习的交换机的运行情况。假定：该交换机表初始为空。B向E发送一个帧，此时交换机将该数据帧转发到（a,c,d,e）端口，当E收到数据帧以后，返回一个数据帧给B，则当数据帧到达交换机后，该数据帧将被转发到（b）端口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_12-58-05.png"></p>
<p>B向E发送一个帧；<strong>交换机记录B的MAC地址与到达的端口；由于交换机表为空，故向A、C、D、E、F 都发送此帧</strong>。E向B回答一个帧；<strong>交换机记录B的MAC地址与到达的端口；由于交换机表有B的MAC地址，故只向B转发</strong></p>
<p>‌有如图所示的拓扑结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_12-58-21.png"></p>
<p>①主机E向主机B发送一个IP数据报，假设所有主机的ARP缓存表和交换机转发表都是最新的，则E发出的数据帧的目的MAC地址和目的IP地址分别是（88-88-88-88-88-8）和（192.168.1.003），源MAC地址和源IP地址分别是（77-77-77-77-77-77）和（192.168.3.001）；Router2收到数据帧以后，将继续转发该数据帧，转发的数据帧的目的MAC地址和目的IP地址分别是（33-33-33-33-33-33）和（192.168.1.003），源MAC地址和源IP地址分别是（55-55-55-55-55-55）和（192.168.3.001）；Router1收到该数据帧以后将继续转发该数据帧给主机B，Router1转发的数据帧的目的MAC地址和目的IP地址分别是（11-11-11-11-11-11）和（192.168.1.003），源MAC地址和源IP地址分别是（22-22-22-22-22-22）和（192.168.3.001）。</p>
<p>②假设主机E发送IP数据报给主机F，主机E将请求路由器Router2帮助转发该数据报吗？（不会）（会&#x2F;不会），这是因为（主机E和主机F在同一个局域网内，主机E可以直接将数据帧发送到局域网中，然后由局域网中的交换机或集线器将数据帧转发给主机F）。E发出的数据帧的目的MAC地址是（99-99-99-99-99-99）。</p>
<p>③假设主机E向主机D发送IP数据报，主机E的ARP缓存表中没有主机D的MAC地址，E将执行ARP查询来发现D的MAC地址吗？（不会）（会&#x2F;不会），这是因为（主机E和主机D不在同一个局域网内，它们之间的通信需要经过路由器。主机E会将数据报发送给它的默认网关，即连接到它所在局域网的路由器，然后由路由器根据路由表将数据报转发到目标网络）。Router2收到的数据帧的目的MAC地址是（88-88-88-88-88-88）。</p>
<p>主机C发送IP数据报给主机D，C的ARP缓存不包含D的MAC地址，D的ARP缓存不包含C的MAC地址，进一步假设与C、D相连的交换机的转发表只包含D和路由器R2的表项，因此C将广播一个ARP请求报文。中间的交换机收到C的ARP请求报文，将执行的操作是（广播操作，即将该数据帧转发给除了到达端口之外的<strong>所有端口</strong>），这个请求报文会到达路由器Router2吗？（会）（会&#x2F;不会），Router2会继续转发该报文到右边的交换机吗？（不会）（会&#x2F;不会），这是因为（ARP协议只在单个局域网内有效），主机D收到ARP请求报文后，会返回一个ARP响应报文给主机C，它需要发送一个ARP请求报文来获得C的MAC地址吗？（不需要）（需要&#x2F;不需要），这是因为（D已经根据来自C的ARP请求报文的数据帧的源MAC地址知道了C的MAC地址），中间交换机收到ARP响应报文的数据帧后，将直接转发该数据帧给主机C，这是因为（交换机已经在收到C的ARP请求报文的数据帧时，通过自学习”学习”到主机C的MAC地址对应的到达端口）。</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网期末复习之套接字编程</title>
    <url>/2023/06/24/%E8%AE%A1%E7%BD%91/6/</url>
    <content><![CDATA[<p>1、字节序（大端模式、小端模式）</p>
<p>字节(Byte)</p>
<ul>
<li>传输和存储信息的最小单位。</li>
<li>各种数据类型，都是由字节构成。</li>
</ul>
<p>主机字节序(Big-Endian | Little-Endian)</p>
<ul>
<li>不同类型的机器处理数据时，会按特定的字节排列顺序读取存储器。</li>
</ul>
<p>以unsigned short类型的数据0x0002为例</p>
<p>大端模式：</p>
<ul>
<li>字节0x00放在低位地址标识的字节</li>
<li>字节0x02放在高位地址标识的字节</li>
</ul>
<blockquote>
<p>0000000000000010</p>
<p>低 	→ 	高</p>
</blockquote>
<p>小端模式:</p>
<ul>
<li>字节0x00放在高位地址标识的字节</li>
<li>字节0x02放在低位地址标识的字节</li>
</ul>
<blockquote>
<p>0000001000000000</p>
<p>低	→	高</p>
</blockquote>
<p>2、主机字节序、网络字节序，转换函数</p>
<p>网络字节顺序是TCP&#x2F;IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。</p>
<p><strong>网络字节顺序采用Big-Endian排序方式，总是从低位地址开始传输</strong>。发送数据包时，程序将主机字节序转换为网络字节序；接受收数据包时，则将网络字节序转换为主机字节序。<br>htons、ntohs、htonl、ntohl</p>
<p>主机字节序变为网络字节序</p>
<ul>
<li>uint16_t  htons(uint16_t hostshort)</li>
<li>uint32_t  htonl(uint32_t hostlong)</li>
</ul>
<p>网络字节序变为主机字节序</p>
<ul>
<li>uint16_t  ntohs(uint16_t netshort)</li>
<li>uint32_t  ntohl(uint16_t netlong)</li>
</ul>
<p>3、数据结构对齐，对齐系数</p>
<p>数据（字长）模型是编译器用来确定基本数据类型长度的，有 LP64、ILP64、LLP64、ILP32、LP32。</p>
<p>integers (I), long integers (L), and pointers (P)</p>
<ul>
<li>Linux&#x2F;Unix: LP64</li>
<li>Windows: LLP64</li>
</ul>
<p>对齐系数</p>
<ul>
<li>每个特定平台的编译器都有自己的默认“对齐系数” 。</li>
<li>通过预编译命令#pragma pack(n)，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</li>
</ul>
<p>结构体对齐规则：</p>
<p>①结构体变量的首地址能够被其<strong>最宽</strong>基本类型成员的大小所<strong>整除</strong>；</p>
<p>②结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；</p>
<p>③结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。</p>
<p>4、套接字</p>
<p><strong>主动套接字、被动套接字</strong></p>
<ul>
<li>被动：等待传入连接的套接字，如服务器套接字</li>
<li>主动：发起连接的套接字，如客户端套接字</li>
</ul>
<p><strong>端到端地址</strong></p>
<p>创建时不指定，使用时指明（TCP&#x2F;IP需要指明协议端口号和IP地址）</p>
<ul>
<li><p>TCP&#x2F;IP协议族：PF_INET</p>
</li>
<li><p>TCP&#x2F;IP地址族：AF_INET</p>
</li>
<li><p>PF是protocol family，AF是address family，TCP&#x2F;IP套接字设计者认为可能某个协议族有多种形式的地址，所以在API上把它们分开了，创建socket用PF，bind&#x2F;connect用AF。但如今一个PF只有一个AF，从来没有过例外，所以可混用</p>
</li>
</ul>
<p><strong>套接字类型</strong></p>
<ul>
<li>SOCKET_DGRAM： 双向不可靠数据报，对应UDP</li>
<li>SOCKET_STREAM：双向可靠数据流，对应TCP</li>
<li>SOCKET_RAW：低于传输层的低级协议或物理网络提供的套接字类型，可以访问内部网络接口。</li>
</ul>
<p>5、地址转换函数</p>
<ul>
<li><p>Socket 通用地址结构sockaddr</p>
<ul>
<li>Socket是传输层&#x2F;网络层编程接口，由于传输层&#x2F;网络层的各种实现不同，可能会有不同的编址方案。通用地址为了适应这种需求而定义。</li>
<li>通用地址有很大局限性，实际并不具有通用性，例如针对AF_INET6&#x2F;AF_LOCAL类型的Socket地址，sockaddr结构实际上只能标识出这个地址的类型。</li>
</ul>
</li>
<li><p>人们习惯使用 202.112.14.151 表示地址（点分十进制），但是这个本质是一个字符串而不是数值，因此在socket编程时，需要进行转换。此外还要考虑字节序的问题，为此可以使用如下一些函数：</p>
<ol>
<li><p>int inet_aton(const char *cp, struct in_addr *inp)    </p>
<p>返回：1-串有效，0-串有错</p>
<p>inet_aton函数将cp所指的字符串转换成32位的网络字节序二进制，并通过指针inp来存储。这个函数需要对字符串所指的地址进行有效性验证。但如果cp为空，函数仍然成功，但不存储任何结果。</p>
</li>
<li><p>in_addr_t inet_addr(const char *cp)    </p>
<p>返回：若成功，返回32位二进制的网络字节序地址，若有错，则返回INADDR_NONE  </p>
<p>inet_addr进行相同的转换，但不进行有效性验证，也就是说，所有232种可能的二进制值对inet_addr函数都是有效的——<strong>过时函数，不应再使用</strong></p>
</li>
<li><p>char *inet_ntoa(struct in_addr in)     </p>
<p>返回：指向点分十进制数串的指针</p>
<ul>
<li>函数inet_ntoa将32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。但由于返回值所指向的串留在静态内存中，这意味着函数是不可重入的。</li>
<li>需要注意的是这个函数是以结构为参数，而不是指针。</li>
</ul>
<p>上述三个地址转换函数都只能处理IPv4协议，而不能处理IPv6地址。在同时要处理IPv4和v6的程序中，建议使用以下两个函数。</p>
</li>
<li><p>int inet_pton(int family, const char *src, void *dst)    </p>
<p>返回：1-成功，0－输入无效，-1:出错    </p>
<p>将src指向的字符串转换成二进制地址数值放到dst中。</p>
</li>
<li><p>const char *inet_ntop(int family, const void *src, char *dst, size_t cnt)    </p>
<p>返回：指向结果的指针－－成功，NULL－出错    </p>
<p>和pton做相反的操作。</p>
<ul>
<li>family参数可以是AF_INET,也可以是AF_INET6。</li>
<li>如果长度参数cnt太小，无法容纳表达式格式结果，则返回一个空串。另外，目标指针dst调用前必须先由调用者分配空间。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_15-27-36.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_15-27-25.png"></p>
<p><em><strong>6、简单TCP循环服务器Socket编程基本步骤（服务器端和客户端）</strong></em></p>
<p>服务器端</p>
<ol>
<li>创建套接字</li>
<li>绑定套接字</li>
<li>设置套接字为监听模式，进入被动接受连接状态</li>
<li>接受请求，建立连接</li>
<li>读写数据</li>
<li>终止连接</li>
</ol>
<p>客户端</p>
<ol>
<li>创建套接字</li>
<li>与远程服务器建立连接</li>
<li>读写数据</li>
<li>终止连接</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_15-29-25.png"></p>
<p><em><strong>7、简单UDP循环服务器Socket编程基本步骤（服务器端和客户端）</strong></em></p>
<p>服务器端</p>
<ol>
<li>建立UDP套接字；</li>
<li>绑定套接字到特定地址；</li>
<li>等待并接收客户端信息；</li>
<li>处理客户端请求；</li>
<li>发送信息回客户端；</li>
<li>关闭套接字；</li>
</ol>
<p>客户端</p>
<ol>
<li>建立UDP套接字；</li>
<li>发送信息给服务器；</li>
<li>接收来自服务器的信息；</li>
<li>关闭套接字</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-24_15-29-57.png"></p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网期末复习之传输层</title>
    <url>/2023/06/21/%E8%AE%A1%E7%BD%91/3/</url>
    <content><![CDATA[<p>1、传输层：两个进程之间的<strong>逻辑通信</strong>，网络层: 两个<strong>主机</strong>之间的逻辑通信</p>
<ul>
<li>传输层协议运行在端系统 <ul>
<li><strong>发送方</strong>: 将应用程序报文分成报文段传递给网络层, </li>
<li><strong>接受方</strong>: 将报文段重新组装成报文传递到应用层</li>
</ul>
</li>
<li>传输层可以为应用提供多种协议(因特网: TCP 和 UDP)<ul>
<li>可靠按序递交 (TCP)：拥塞控制&#x2F;流量控制&#x2F;连接建立</li>
<li>不可靠的无序传递: UDP“尽力传递” IP的直接扩展</li>
<li>两种服务均不保证: 延迟&#x2F;带宽</li>
</ul>
</li>
</ul>
<p>2、多路复用&#x2F;多路分解工作原理</p>
<p>在发送主机多路复用:从多个套接字收集数据, 用首部封装数据，然后将报文段传递到网络层(多路复用）</p>
<p>在接收主机多路分解:将接收到的数据段传递到正确的套接字（多路分解）</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_08-40-33.png"></p>
<p>多路复用&#x2F;分解如何工作?（报文段头部字段实现）</p>
<ul>
<li><p>主机收到IP数据报</p>
<ul>
<li>每个数据报有<strong>源IP地址</strong>，<strong>目的IP地址</strong></li>
<li>每个数据报搬运一个报文段</li>
<li>每个报文段有源和目的端口号 （回忆: 对于特定应用程序具有周知端口号)</li>
</ul>
</li>
<li><p>主机用<strong>IP地址和端口号</strong>指明报文段属于哪个合适的套接字</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_08-40-51.png"></p>
<p>3、无连接多路分解（ UDP 套接字：目的IP地址, 目的端口号）</p>
<ul>
<li>当主机收到UDP报文段：检查报文段中的目的端口号、用<strong>端口号</strong>指示UDP报文段属于哪个套接字</li>
<li>来自不同的源IP地址且&#x2F;或源端口号的IP报文报，导向同一个的套接字</li>
<li><strong>SP 提供“返回地址”</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_08-53-15.png"></p>
<p>4、面向连接的多路分解（TCP套接字：源IP地址、源端口号、目的IP地址、目的端口号）</p>
<ul>
<li>服务器主机支持很多同时的TCP 套接字:每个套接字用4部分来表示 </li>
<li>Web服务器对每个连接的客户都有不同的套接字：非持久 HTTP 将对每个请求有一个不同的套接字</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_08-53-37.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_08-53-53.png"></p>
<p>5、 UDP用户数据报协议</p>
<p>UDP 是<strong>面向报文</strong>的</p>
<p><strong>基于Internet IP协议</strong></p>
<ul>
<li>复用&#x2F;分用</li>
<li>简单的错误校验</li>
</ul>
<p><strong>“尽最大努力”服务，报文段可能</strong>: </p>
<ul>
<li>丢失</li>
<li>会传递失序的报文到应用程序无连接</li>
<li>在UDP接收者发送者之间<strong>没有握手</strong></li>
<li>每个UDP 报文段的处理独立于其他报文段</li>
</ul>
<p>为什么有 UDP?</p>
<ul>
<li>不需要建立连接 (减少延迟)</li>
<li>简单: 在发送者接受者之间不需要连接状态</li>
<li>很小的报文段首部</li>
<li>没有拥塞控制: UDP 能够用尽可能快的速度传递</li>
</ul>
<p>**常用于流式多媒体应用：丢包容忍&#x2F;速率敏感 **<br>其他UDP应用：DNS&#x2F;SNMP&#x2F;RTP</p>
<p><strong>经UDP的可靠传输</strong> : 在应用层增加可靠性&#x2F;应用程序特定的差错恢复！</p>
<p>6、UDP报文格式（8字节）每个字段含义</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_09-11-16.png"></p>
<p>7、UDP是面向报文的传输方式</p>
<p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。即<strong>应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文</strong>。</p>
<p>思考大的视频文件如何利用UDP传输：</p>
<ul>
<li><p>将大数据分成多个小包，每个小包的大小不能超过UDP协议数据包的最大长度（一般为64KB）。</p>
</li>
<li><p>在每个小包中增加一个序列号，用于确保数据包的顺序和完整性。</p>
</li>
<li><p>在每个小包中增加一个校验和，用于检测数据包在传输过程中的错误。</p>
</li>
<li><p>接收方将收到的小包按照序列号和校验和的方式进行重组和验证，确保数据的完整性和正确性。</p>
</li>
<li><p>对于丢失的数据包，发送方需要在一定时间内进行重传，以保证数据的可靠性。</p>
</li>
</ul>
<p>9、UDP首部的<strong>校验和</strong>计算</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_09-08-11.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_09-08-35.png"></p>
<p>（1）将UDP伪头部、UDP头部和数据部分全部用16进制数表示。</p>
<p>（2）将第一个16进制数与第二个16进制数相加。求和时产生的进位必须回卷加到结果上。</p>
<p>（3）将上一步得到的16位数与第三个16进制的数相加，重复第二步，直到累加完所有的16进制数，并且得到的结果为16进制数。</p>
<p>（4）将累加最后得到的16进制数取反，得到校验和。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_09-10-17.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_09-26-04.png"></p>
<p>发送方对校验和进行了反码操作，并放入了校验和字段 发送给了接受方 等接收方对其他字段进行了二进制的加法，其中就有校验和字段，就会变成原码和反码的加法，就都变成1了，如果不是都是1的话 那就说明其中的字段和发送方的字段不一样，肯定就是错误的，就把包丢了。</p>
<p>10、可靠数据传输原理rdt1.0-rdt3.0的工作场景（no loss、lost packet、lost ack、timeout）</p>
<p>Rdt1.0: 完全可靠信道上的可靠数据传输</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_10-18-04.png"></p>
<p>Rdt2.0: 具有bit错误的信道</p>
<ul>
<li>下层信道可能让传输分组中的bit受损：利用校验和检测bit位错误</li>
<li>问题: 如何从错误中恢复<ul>
<li>确认(ACKs): 接收方明确告诉发送方分组接收正确</li>
<li>否认 (NAKs):接收方明确告诉发送方分组接收出错</li>
<li>发送方收到NAK后重发这个分组</li>
</ul>
</li>
<li>在 rdt2.0中的新机制 (在 rdt1.0中没有的)：<ul>
<li>差错检测</li>
<li>接收方反馈: 控制信息 (ACK,NAK)   rcvr-&gt;sender</li>
<li>重传</li>
</ul>
</li>
</ul>
<p>停等协议:发送方发送一个报文，然后等待接受方的响应</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_10-18-42.png"></p>
<p><strong>rdt2.0: 缺陷</strong></p>
<p>如果ACK&#x2F;NAK发生错误&#x2F;被破坏(corrupted)会怎么样？</p>
<ul>
<li>为ACK&#x2F;NAK增加校验和，检错并纠错</li>
<li>发送方收到被破坏ACK&#x2F;NAK时不知道接收方发生了什么，添加额外的控制消息</li>
<li>如果ACK&#x2F;NAK坏掉，发送方重传</li>
<li>不能简单的重传：产生重复分组</li>
</ul>
<p>如何解决重复分组问题？</p>
<ul>
<li>序列号(Sequence number): 发送方给每个分组增加序列号</li>
<li>接收方丢弃重复分组</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/rdt2.1.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_10-27-30.png"></p>
<p><strong>rdt2.2: 无NAK的消息协议</strong></p>
<p>我们真的需要两种确认消息(ACK + NAK)吗？</p>
<ul>
<li>同 rdt2.1一样的功能, 但只用 ACKs </li>
<li>如何实现？<ul>
<li>接收方通过ACK告知最后一个被正确接收的分组</li>
<li>在ACK消息中显式地加入被确认分组的序列号</li>
</ul>
</li>
<li>发送方收到重复ACK之后，采取与收到NAK消息相同的动作<ul>
<li>重传当前分组</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_10-27-48.png"></p>
<p><strong>rdt3.0: 具有出错和丢失的信道</strong></p>
<p>新假设: 下层信道还要丢失报文 (数据或者 ACKs)</p>
<p>校验和, 序号, 确认, 重发将会有帮助，但是不够</p>
<p>方法: 发送者等待“合理的”确认时间</p>
<ul>
<li>如果在这个时间内没有收到确认就<strong>重发</strong></li>
<li>如果报文（或者确认）只是延迟 (没有丢失):<ul>
<li>重发将导致重复，但是使用序号已经处理了这个问题</li>
<li>接受方必须指定被确认的报文序号</li>
</ul>
</li>
<li>要求<strong>倒计时定时器</strong>：只有在定时器超时时才触发重发</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_10-28-16.png"></p>
<p><strong>rdt3.0的性能分析</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-15-06.png"></p>
<p>流水线: 发送方允许发送多个 “在路上的”, 还没有确认的报文</p>
<ul>
<li>序号数目的范围必须增加</li>
<li>在发送方&#x2F;接收方必须有缓冲区</li>
</ul>
<p>流水线技术的两个通用形式: <em><strong>go-Back-N</strong></em>,*** 选择重传***</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_10-28-44.png"></p>
<p>11、GBN协议</p>
<p><strong>Go-Back-N(GBN)协议: 发送方</strong></p>
<ul>
<li>分组头部包含k-bit序列号</li>
<li>窗口尺寸为N，最多允许N个分组未确认</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-16-47.png"></p>
<ul>
<li>ACK(n): 确认到序列号n(包含n)的分组均已被正确接收<ul>
<li>可能收到重复ACK</li>
</ul>
</li>
<li>对第一个发送未被确认的报文定时(timer)</li>
<li>timeout(n):若超时，重传窗口中的分组n及所有更高序号的分组</li>
</ul>
<p><strong>Go-Back-N(GBN)协议: 接收方</strong></p>
<p>只有ACK: 对接收的分组总是发送具有最高按序序号的ACK</p>
<ul>
<li>可能产生冗余的ACKs</li>
<li>仅仅需要记住期望的序号值（expectedseqnum）</li>
</ul>
<p>对失序的分组: </p>
<ul>
<li>丢弃 (不缓存) -&gt; <strong>没有接收缓冲区</strong>!</li>
<li>重新确认具有按序的分组</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_12-35-57.png"></p>
<p>12、SR协议</p>
<ul>
<li>接收方分别确认已经收到的分组:必要时，缓冲报文, 最后按序提交给上层</li>
<li>发送者只重发没有收到确认的分组:对每个没有确认的报文发送者都要启动一个定时器(每个未被确认的报文都有一个定时器)</li>
<li>发送窗口:N 个连续序号&#x2F;限制被发送的未确认的分组数量</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-17-24.png"></p>
<p><strong>发送方</strong></p>
<ul>
<li>从上层收到数据 ：如果下一个可用的序号在发送方窗口内，则将数据打包并发送,启动定时器</li>
<li>超时(n)：重发分组n, 重启定时器</li>
<li>收到ACK(n)在[sendbase,sendbase+N-1]内:<ul>
<li>标记分组n被接收</li>
<li>如果n是最小的未确认分组，则增加窗口基序号到下一个未被确认的序号</li>
</ul>
</li>
</ul>
<p><strong>接收方</strong></p>
<ul>
<li><p>分组n的序号在[rcvbase, rcvbase+N-1]内</p>
<ul>
<li><p>发送ACK(n)</p>
</li>
<li><p>失序分组: 缓冲</p>
</li>
<li><p>有序分组: 交付上层 (包括已经缓冲的有序分组), 提高窗口到下一个没有接收的分组</p>
</li>
</ul>
</li>
<li><p>分组n在[rcvbase-N,rcvbase-1]内</p>
<ul>
<li>发送ACK(n)</li>
</ul>
</li>
<li><p>其他：忽略</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-18-28.png"></p>
<p>选择性重传: 两难选择</p>
<p>例子: </p>
<p>序号: 0, 1, 2, 3</p>
<p>window size&#x3D;3</p>
<p>在两种情况下接收方没有感觉到差别!</p>
<p>Q: 窗口大小和序号大小有什么关系?</p>
<p>A: 窗口小于或等于序号空间大小的一半</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-18-55.png"></p>
<p><strong>可靠数据传输机制及用途总结</strong></p>
<table>
<thead>
<tr>
<th>机制</th>
<th align="left">用途和说明</th>
</tr>
</thead>
<tbody><tr>
<td>检验和</td>
<td align="left">用于检测在一个传输分组中的比特错误。</td>
</tr>
<tr>
<td>定时器</td>
<td align="left">用于检测超时&#x2F;重传一个分组，可能因为该分组（或其ACK）在信道中丢失了。由于当一个分组被时延但未丢失（过早超时），或当一个分组已被接收方收到但从接收方到发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余拷贝。</td>
</tr>
<tr>
<td>序号</td>
<td align="left">用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使该接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余拷贝。</td>
</tr>
<tr>
<td>确认</td>
<td align="left">接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议。</td>
</tr>
<tr>
<td>否定确认</td>
<td align="left">接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常携带着未被正确接收的分组的序号。</td>
</tr>
<tr>
<td>窗口、流水线</td>
<td align="left">发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力或网络中的拥塞程度，或两者情况来进行设置。</td>
</tr>
</tbody></table>
<p>13、TCP是面向面向连接传输</p>
<ul>
<li><p>点到点:</p>
<ul>
<li>一个发送者,一个接收者</li>
</ul>
</li>
<li><p>可靠按序的字节流:</p>
<ul>
<li>没有“信息边界”</li>
</ul>
</li>
<li><p>流水线:</p>
<ul>
<li>TCP 拥塞和流量控制设置窗口大小</li>
</ul>
</li>
<li><p>收发缓冲区<br><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-19-16.png"></p>
</li>
<li><p>全双工数据:</p>
<ul>
<li>同一个连接上的双向数据流</li>
<li>MSS: 最大报文段长</li>
</ul>
</li>
<li><p>面向连接: </p>
<ul>
<li>在数据交换前握手(交换控制信息)</li>
<li>连接状态只在连接的两端中维护，在沿途节点中并不维护状态。</li>
<li>TCP连接包括：两台主机上的缓存、连接状态变量、socket等</li>
</ul>
</li>
<li><p>流量控制:</p>
<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
</ul>
<p><strong>TCP是面向字节流</strong>，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p>
<p><strong>有可能将多条数据当成一条数据进行处理</strong>，因此需要在应用层进行数据的边界管理</p>
<p>编程影响：上层可能会将多条数据当做一条数据处理。</p>
<p>特殊字符间隔： 使用此方法则必须对数据中的特殊字符进行转义，否则会造成二义</p>
<p>数据定长：规定固定长度的数据，实际数据少的则需要进行补位</p>
<p>在应用层头部定义数据长度（例如http协议，先取头部，再根据头部中的数据长度取出数据）</p>
<p>14、TCP报文格式（字段含义&#x2F;用途）</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-19-52.png"></p>
<p>15、 TCP 往返时延的估计和超时</p>
<p>设置超时</p>
<ul>
<li><p>EstimtedRTT 加上 “安全余量” </p>
</li>
<li><p>EstimatedRTT变化大 -&gt; 更大的安全余量</p>
</li>
</ul>
<p>SampleRTT 偏离 EstimatedRTT多少的估计</p>
<ul>
<li>DevRTT &#x3D; (1-β)*DevRTT +β*| SampleRTT-EstimatedRTT |    (典型地, β &#x3D; 0.25)</li>
</ul>
<p>然后设置超时时间间隔:   </p>
<p> TimeoutInterval &#x3D; EstimatedRTT + 4*DevRTT</p>
<p>设置超时</p>
<p>初始时TimeoutInterval设置为1秒</p>
<p>第一个样本RTT获得后， EstimatedRTT&#x3D;SampleRTT，DevRTT&#x3D;SampleRTT&#x2F;2，     TimeoutInterval &#x3D;EstimatedRTT + max (G, K*DevRTT) （K&#x3D;4，G是用户设置的时间粒度）</p>
<p>16、TCP可靠数据传输</p>
<p><strong>TCP 发送方事件</strong></p>
<ul>
<li><p>从应用程序接收数据:</p>
<ul>
<li>用序号创造一个报文</li>
<li>序号是报文中第一个数据字节在字节流中的位置编号</li>
<li>如果没有启动定时器，则启动定时器 （定时器是最早没有被确认的报文发送时启动的）</li>
<li>设置超时间隔: TimeOutInterval</li>
</ul>
</li>
<li><p>超时:</p>
<ul>
<li>重发导致超时的报文</li>
<li>重新开始定时器</li>
</ul>
</li>
<li><p>收到确认:</p>
<ul>
<li>如果ACK落在窗口之内，则确认对应的报文，并且滑动窗口 </li>
<li>若还有未确认的报文，重新开始定时器</li>
</ul>
</li>
</ul>
<p><strong>TCP 接收方事件</strong></p>
<table>
<thead>
<tr>
<th>接收方的事件</th>
<th>TCP 接收方行为</th>
</tr>
</thead>
<tbody><tr>
<td>期望序号的报文段按序到达. 所有在期望序号以前的报文段都被确认</td>
<td>延迟ACK. 等到 500ms看是否有下一个报文段，如果没有，发送ACK</td>
</tr>
<tr>
<td>期望序号的报文段按序到达.另一个按序报文段等待发送ACK</td>
<td>立即发送单个累积ACK, 确认两个有序的报文段</td>
</tr>
<tr>
<td>收到一个失序的报文段，高于期望的序号，检测到缝隙</td>
<td>立即发送重复 ACK, 指出期望的序号</td>
</tr>
<tr>
<td>到达的报文段部分地或者完全地填充接收数据间隔</td>
<td>立即发送 ACK, 证实缝隙低端的报文段已经收到</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-21-16.png"></p>
<p><strong>超时间隔加倍</strong></p>
<ul>
<li><p>TCP每次重传，都会把下一次的超时间隔设置为先前值的两倍。</p>
</li>
<li><p>但是当收到上层应用的数据和收到ACK两个事件中的任何一个发生时，定时器的TimeoutInterval值恢复为由近期的EstimatedRTT和DevRTT计算得到。</p>
</li>
<li><p>TimeoutInterval &#x3D;EstimatedRTT + max (G, K*DevRTT) （K&#x3D;4，G是用户设置的时间粒度）</p>
</li>
</ul>
<p><strong>快速重传</strong></p>
<ul>
<li>发送方可以在超时之前通过重复的ACK检测丢失报文段</li>
<li>发送方常常一个接一个地发送很多报文段</li>
<li>如果报文段丢失,则发送方将可能接收到很多重复的 ACKs</li>
<li>如果发送方收到4个对同样报文段的确认，则发送方认为该报文段之后的数据已经丢失。</li>
<li>启动<strong>快速重传</strong>: 在定时器超时之前重发丢失的报文段</li>
</ul>
<p>17、 TCP 流量控制机制</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-21-33.png"></p>
<p>(假设 TCP 接收方丢弃失序的报文段)</p>
<ul>
<li><p>缓冲区的剩余空间&#x3D; RcvWindow&#x3D; RcvBuffer-[LastByteRcvd - LastByteRead]</p>
</li>
<li><p>接收方在报文段接收窗口字段中通告其接收缓冲区的剩余空间</p>
</li>
<li><p>Sender限制自己已经发送的但还未收到ACK的数据不超过接收方的空闲RcvWindow尺寸</p>
</li>
<li><p>Receiver告知Sender，RcvWindow&#x3D;0,会出现什么情况？</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-22-48.png"></p>
<p>18、 TCP连接管理（序号、确认序号）</p>
<p><strong>建立连接</strong></p>
<p>回忆: TCP在交换数据报文段之前在发送方和接收方之间建立连接</p>
<p>初始化TCP 变量:</p>
<p>-序号</p>
<p>-缓冲区流控信息 (例，接收窗口)</p>
<p>客户: 连接发起者  Socket clientSocket &#x3D; new   Socket(“hostname”,”port number”); </p>
<p>服务器: 被客户联系  Socket connectionSocket &#x3D; welcomeSocket.accept();</p>
<p>三次握手：</p>
<p>Step 1: 客户发送TCP SYN报文段到服务器</p>
<p>-指定初始的序号</p>
<p>-没有数据</p>
<p>Step 2: 服务器接收SYN, 回复 SYN&#x2F;ACK 报文段</p>
<p>-服务器分配缓冲区</p>
<p>-指定服务器的初始序号</p>
<p>Step 3: 客户接收 SYN&#x2F;ACK, 回复 ACK 报文段, 可能包含数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-23-01.png"></p>
<p><strong>关闭连接</strong></p>
<p>客户关闭套接字: clientSocket.close	</p>
<p>Step 1: 客户发送 TCP FIN 控制报文段到服务器 </p>
<p>Step 2: 服务器接收 FIN, 回复 ACK. 进入半关闭连接状态； </p>
<p>Step 3: 服务器发送FIN到客户，客户接收 FIN, 回复 ACK，进入 “time wait”状态等待结束时释放连接资源</p>
<p>Step 4: 服务器接收 ACK.  连接关闭. </p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-23-12.png"></p>
<p>19、拥塞控制的方法</p>
<p>根据网路层是否为运输层拥塞控制提供了显示帮助，来区分拥塞控制方法。分为两类方法:</p>
<p>端到端拥塞控制:</p>
<ul>
<li>没有从网络中得到明确的反馈</li>
<li>从端系统观察到的丢失和延迟推断出拥塞</li>
<li>TCP采用的方法</li>
</ul>
<p>网络辅助的拥塞控制:</p>
<p>路由器给端系统提供反馈</p>
<p>单bit指示拥塞 (SNA, DECnet, TCP&#x2F;IP ECN, ATM)</p>
<p>指明发送者应该发送的速率</p>
<p>19、TCP拥塞控制（慢启动、拥塞避免、快速恢复；总结: TCP 拥塞控制）</p>
<ul>
<li><p>端到端控制 (没有网络辅助)</p>
</li>
<li><p>发送方限制发送:  LastByteSent-LastByteAcked  &lt;min( CongWin , RcvWindow )</p>
</li>
<li><p>大体上,</p>
<p>rate&#x3D;CongWin &#x2F;RTT(Bytes&#x2F;sec)，CongWin 是动态的, 感知的网络拥塞的函数</p>
</li>
<li><p>发送方如何感知拥塞 ?</p>
<ul>
<li>丢失事件 &#x3D; 超时或者 3 个重复的ACKs</li>
<li>TCP 发送方在丢失事件发生后降低发送速率 (CongWin)</li>
</ul>
</li>
<li><p>如何合理控制发送速率？</p>
<ul>
<li>AIMD（拥塞避免）</li>
<li>慢启动</li>
</ul>
</li>
</ul>
<p><strong>TCP AIMD(Additive-increase,multiplicative-decrease)</strong></p>
<p><strong>原理</strong>：发送方增加传输速率（窗口大小），谨慎地探测可用带宽，直到发生丢包事件</p>
<p><strong>方法：AIMD</strong></p>
<ul>
<li>加性递增: 每个RTT内如果没有丢失事件发生，拥塞窗口增加1个MSS（拥塞避免）</li>
<li>乘性递减: 发生丢包事件后将拥塞窗口减半</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-24-05.png"></p>
<p><strong>TCP 慢启动（slow  start）</strong></p>
<ul>
<li><p>连接开始的时候, CongWin &#x3D; 1 MSS</p>
<ul>
<li><p>Example: MSS &#x3D; 500 bytes &amp; RTT &#x3D; 200 msec</p>
</li>
<li><p>初始速率 &#x3D; 20 kbps</p>
</li>
</ul>
</li>
<li><p>有效带宽将 &gt;&gt; MSS&#x2F;RTT     </p>
<ul>
<li>希望尽快达到期待的速率，故将以2的指数方式增加速率。</li>
</ul>
</li>
<li><p>故以指数方式增加速率，直到产生丢失事件，或者达到某个阈值ssthresh</p>
</li>
</ul>
<p><strong>ssthresh（阈值）变量</strong></p>
<p>（发送<strong>丢失事件</strong>后，ssthresh设置为<strong>丢失事件</strong>事件前的 CongWin 的1&#x2F;2）</p>
<p>什么时候从指数增加变为线性增加（拥塞避免）?</p>
<ul>
<li>当CongWin达到ssthresh时。</li>
<li>每收到1个ACK, CongWin &#x3D;CongWin + (MSS&#x2F; CongWin)*MSS</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-24-39.png"></p>
<p><strong>对拥塞事件的反应</strong></p>
<ul>
<li>当超时事件发生时:<ul>
<li>CongWin 立即设置为 1个 MSS； </li>
<li>窗口开始指数增长（进入慢启动）</li>
<li>到达一个阈值后再线性增长</li>
</ul>
</li>
<li>收到三个重复的确认时：<ul>
<li>CongWin 减半+3 (Reno版) </li>
<li>然后，窗口线性增长（快速恢复）</li>
</ul>
</li>
</ul>
<p>注：上述为TCP Reno版本的内容，在TCP Tahoe版本里，无论超时还是三个重复，都直接将CongWin 置为 1个 MSS</p>
<p>怎么理解不同的丢包事件？</p>
<ul>
<li>3 个重复的 ACKs 表明网络具有传输一些数据段的能力</li>
<li>在三个重复的确认之前超时是“更加严重的警告”</li>
</ul>
<p><em>在快速恢复阶段：</em></p>
<ul>
<li>对于引起TCP进入快速恢复状态的<strong>缺失报文段</strong>，每收到一个冗余的ACK，CongWin的值增加一个MSS。</li>
<li>最终，当对丢失的报文段的一个ACK到达时，TCP在降低 CongWin（cwnd &#x3D; ssthresh）后，进入<strong>拥塞避免</strong>状态。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-24-39.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-22_11-25-51.png"></p>
<hr>
<p>UDP 报文实现差错检测时，不需要在网络上传输的部分是（A ） </p>
<p>A. 伪首部 	B. 首部 		C. 数据 		D. 校验和</p>
<p>运输层协议在端系统和路由器中都可以实现。(  ×  )</p>
<p>数据0x9876A543的十六比特因特网校验和为（ C      ）</p>
<p>A、0x3DB9	B、0x3DBA	C、0xC245	D、0xC246</p>
<p>十六比特因特网校验和是通过将数据分成16位的字，然后将这些字相加，如果有溢出则将溢出部分加到结果上，最后对结果取反得到的。对于数据0x9876A543，我们可以将其分成两个16位的字：0x9876和0xA543。将这两个字相加得到0x13DB9，由于有溢出，所以我们需要将溢出部分加到结果上，得到0x3DBA。最后对结果取反得到校验和为0xC245。</p>
<p>UDP服务器端将为每个客户的请求建立一个新的套接字。  （  ×    ）</p>
<p>TCP 中，套接字是一对一的关系。如要向 10 个客户端提供服务，那么除了负责监听的套接字外，还需要创建 10 套接字。但在 UDP 中，不管是服务器端还是客户端都只需要 1 个套接字。</p>
<p>一条线路带宽为1Mbps，往返时延为45ms，假设数据帧的大小为1000字节。若采用停等协议方式，实际的数据率大约是（  C    ）。</p>
<p>A、15Kbps  B、1.5Kbps  C、151Kbps  D、1510Kbps</p>
<p>由于带宽为1Mbps，所以发送一个1000字节的数据帧需要8ms。加上往返时延45ms，总共需要53ms才能发送一个数据帧。因此，实际的数据率为1000字节&#x2F;53ms &#x3D; 151.51Kbps。</p>
<p>在选择重传协议中，假设发送窗口和接收窗口的大小相等，如果用来表示分组序号的字段长度为8个比特，则发送方窗口长度最大为（ C ）。</p>
<p>A、32    B、64    C、128    D、256</p>
<p>在选择重传协议中，发送窗口和接收窗口的大小相等，用来表示分组序号的字段长度为8个比特，那么序号的范围为0-255。由于选择重传协议要求发送窗口的大小不能超过序号空间的一半，所以发送方窗口长度最大为256&#x2F;2&#x3D;128。</p>
<p>流水线可靠传输技术中序号的数量应该大于等于发送窗口和接收窗口之和。（√）</p>
<p>因为序号的数量决定了可以同时发送的数据帧的数量，而发送窗口和接收窗口之和决定了可以同时发送和接收的数据帧的数量。如果序号的数量小于发送窗口和接收窗口之和，那么就会出现序号重复的情况，导致数据传输出错。因此，为了保证流水线可靠传输技术的正确性，序号的数量应该大于等于发送窗口和接收窗口之和。</p>
<p>GBN回退N帧可靠传输中某一分组超时时，要重传该分组及其以后的所有分组。（√）</p>
<p>因为在GBN协议中，接收方只能按序接收数据帧，如果某一分组丢失，那么其后面的所有分组都无法被接收方正确接收。因此，当某一分组超时时，发送方需要重传该分组及其以后的所有分组，以保证数据的正确传输。</p>
<p>在选择重传（SR）协议中，发送方可能会收到落在其当前窗口之外的分组的ACK包。（√）</p>
<p>比如，如果序号为sendbase的分组发送后，接收方正确的收到了该分组，但是对其应答的ack超时，没有到，于是发送方又重发了序号为sendbase的分组。而接收方，也会再次发送ack。后到的ack就可能在窗口外。</p>
<p>能为计算机网络通信提供加密防护服务的协议是(  B  )。</p>
<p>A、ARP	B、SSL    C、SMTP     D、PPP </p>
<p>SSL协议在传输层和应用层之间，为网络通信提供安全保障。</p>
<p>ARP（Address Resolution Protocol）是一种用于将IP地址解析为物理地址的协议；SMTP（Simple Mail Transfer Protocol）是一种用于发送电子邮件的协议；PPP（Point-to-Point Protocol）是一种用于在点对点链路上进行数据传输的协议。</p>
<p>TCP是一个点对点的协议，协议双方连接的端点是应用进程端口号（ √     ）</p>
<p>TCP报头中的确认号是指（    B    ）</p>
<p>A、传输数据的第一个字节在缓冲区中的位置编号 </p>
<p>B、期待接收的下一个字节的位置编号</p>
<p>C、已连续接收的最后一个字节在缓冲区中的位置编号  </p>
<p>D、当前接收数据的序号 </p>
<p>确认号用于告诉发送方，接收方已经成功接收到了哪些数据，期待接收的下一个字节的序号是多少。这样，发送方就可以根据确认号来判断哪些数据已经被成功接收，哪些数据需要重传。</p>
<p>假设主机 A 通过一条 TCP 连接向主机 B 发送两个紧接着的 TCP 报文段。第一个 报文段的序号为 90，第二个报文段序号为 110。<br>a. 第一个报文段中有多少数据？20 bytes<br>b. 假设第一个报文段丢失而第二个报文段到达主机 B。那么在主机 B 发往主机 A 的确认报文中，确认号应该是多少？确认号 &#x3D; 90</p>
<p>假定主机A通过TCP连接向主机B发送一个序号为20的20字节报文段后，那么主机A收到的确认号不可能是（ B ）</p>
<p>A、10  B、39  C、40   D、无法确定</p>
<p>主机甲和主机乙间已建立一个TCP连接，主机甲向主机乙发送了两个连续的TCP段，分别包含300字节和500字节的有效载荷，第一个段的序列号为200，主机乙正确接收到两个段后，发送给主机甲的确认序列号是  （ D ）</p>
<p>A．500  B.700  C.800  D.1000</p>
<p>TCP协议中的确认号表示接收方期待接收的下一个字节的序号。由于主机甲发送了两个连续的TCP段，分别包含300字节和500字节的有效载荷，所以主机乙期待接收的下一个字节的序号应该是200+300+500&#x3D;1000。</p>
<p>主机甲与主机乙之间已建立一个TCP连接，主机甲向主机乙发送了3个连续的TCP段，分别包含300字节、400字节和500字节的有效载荷，第3个段的序号为900。若主机乙仅正确接收到第1和第3个段，则主机乙发送给主机甲的确认序号是（B     ）    </p>
<p>A．300      B．500      C．1200     D．1400 </p>
<p>TCP什么时候对报文段采用快速重传？ (C)</p>
<p>A、报文段的定时器过期                                      </p>
<p>B、估计往返时延过长</p>
<p>C、收到之前发出的一个报文段的三个重复ACK    </p>
<p>D、以上都不是</p>
<p>快速重传是TCP协议中的一种重传机制，它用于在收到三个或以上的冗余ACK（duplicate ACK）时快速重传丢失的数据包。当发送方收到三个重复的ACK时，它可以推断出接收方已经成功接收了之前的报文段，但是当前的报文段丢失了。因此，发送方会立即重传该报文段，而不是等待定时器过期。</p>
<p>网络上所抓到的TCP数据报文段中，有一个字段RcvWindow，其含义和作用为（ A ）</p>
<p>A、接收可用空间大小，用于流量控制       </p>
<p>B、发送可用空间大小，用于流量控制</p>
<p>C、发送可用空间大小，用于拥塞控制       </p>
<p>D、接收可用空间大小，用于拥塞控制</p>
<p>是接收方向发送方指示接收缓存可用空间的大小，主要用于发送方控制其发送窗口的大小。</p>
<p>主机甲和主机乙之间已建立一个TCP连接，TCP最大段长度为1000字节，若主机甲的当前拥塞窗口为4000字节，在主机甲向主机乙连接发送2个最大段后，成功收到主机乙发送的第一段的确认段，确认段中通告的接收窗口大小为2000字节，则此时主机甲还可以向主机乙发送的最大字节数是（A）</p>
<p>A：1000             B：2000        C：3000             D：4000</p>
<p>TCP采用序列号、确认、滑动窗口协议等机制来实现端到端节点之间可靠的数据传输。其中，滑动窗口协议规定未被确认的分组数最多为窗口的大小，且只需要重传未被确认的分组。通告的接收窗口大小为2000B，则说明此时主机乙具有一个2000B的空闲缓冲区，即此时主机乙最大还可以接收2000B的数据。由于主机乙还未对主机甲发出第2个报文段进行确认，因此这2000B的空闲缓冲区还需预留出1000B用于接收第2个报文段，即此时主机甲还可以向主机乙发送的最大字节数只有1000B。</p>
<p>主机甲向主机乙发送一个(SYN＝1，seq＝3210)的TCP段，期望与主机乙建立TCP连接，若主机乙接受该连接请求，则主机乙向主机甲发送的正确的TCP段可能是（C ）  </p>
<p>A．(SYN＝0，ACK＝0，seq＝3211，ack＝3211)    </p>
<p>B．(SYN＝1，ACK＝1，seq＝3210，ack＝3210)    </p>
<p>C．(SYN＝1，ACK＝1，seq＝3211，ack＝3211)    </p>
<p>D．(SYN＝0，ACK＝0，seq＝3210，ack＝3210)</p>
<p>TCP是面向连接的,所谓面向连接,就是当计算机双方 通信时必需先建立连接,然后数据传送,最后拆除三个过程,也就是 客户主动打开TCP传输,服务器被动打开。第一次握手:客户发送SYN &#x3D;1, seq &#x3D; x给服务器,即客户的TCP向服务器发出连接请求报文段, 其首部中的同步位SYN&#x3D;1,并选择序号seq &#x3D; x,表明传送数据时的第一个数据字节的序号是 x。第二次握手:服务器发送 SYN&#x3D; 1, ACK &#x3D;l , seq &#x3D; y, ack &#x3D; x+1给客户,即服务器的TCP收到连接请求报文段后,如同意则发回确认。服务器在确认报文段中应使 SYN&#x3D;1,使ACK&#x3D; 1,其确认号ack &#x3D; x+1,自己选择的序号seq &#x3D; y。第三次握手: 客户发送ACK&#x3D; 1, seq &#x3D; x+1, ack &#x3D; y+1给服务器,即客户收到此报 文段后向服务器给出确认, 其ACK&#x3D; 1,确认号ack &#x3D; y+1。客户的TCP 通知上层应用进程,连接已经建立。服务器的 TCP收到主机客户的确认后,也通知其上层应用进程: TCP连接已经建立。 如果ACK为0，那么数据报不包含确认信息，确认字段被省略。 SYN：用于建立连接。 目前连接还在建立阶段，乙向甲发送的TCP段是包含确认信息ack的， 则SYN&#x3D;1，ACK&#x3D;1； 至于seq，ack，乙向甲发送的seq可以随意，但是 乙向甲发送的 ack却要求是之前甲向乙发送的请求seq加1。</p>
<p>一个TCP连接总是以1KB的最大段长发送TCP段，发送方有足够多的数据要发送。当拥塞窗口为16KB时发生了超时，如果接下来的4个RTT（往返时间）时 间内的TCP段的传输都是成功的，那么当第4个RTT时间内发送的所有TCP段 都得到肯定应答时，拥塞窗口大小是多少？</p>
<p>根据慢开始算法的原则,在第4个RTT时间后,拥塞窗口为16,此时发生拥塞,拥塞窗口大小变为1KB,慢开始门限值变为8 KB。接下来3个RTT后,拥塞窗口大小变为8 KB,此时进入拥塞避免算法,当第4个RTT后,拥塞窗口加1,拥塞窗口大小变为9 KB。</p>
<p>16KB超时，阈值变为8KB，客户端从1KB开始穿（执行快开始算法）</p>
<p>1RTT 结束，1KB-&gt;2KB<br>2RTT 结束，2KB-&gt;4KB<br>3RTT 结束，4KB-&gt;8KB（到达阈值，执行拥塞避免算法）<br>4RTT 结束，8KB-&gt;9KB</p>
<p>（1）将“慢开始门限值”设置为出现超时时刻的“拥塞窗口值”的一半，也就是16KB ÷ 2 &#x3D; 8KB；</p>
<p>（2）将“拥塞窗口值”设置为1KB，重新开始“慢开始”算法。题目还给定超时后的4个RTT（往返时间）时间内的TCP段的传输都是成功，也就是说超时后又进行了以下四个轮次的传输：</p>
<p>超时后的第一个传输轮次：拥塞窗口值为1KB，进行超时后的第一个传输轮次，成功后拥塞窗口值增加到2KB；</p>
<p>超时后的第二个传输轮次：拥塞窗口值为2 KB，进行超时后的第二个传输轮次，成功后拥塞窗口值增加到4 KB；</p>
<p>超时后的第三个传输轮次：拥塞窗口值为4 KB，进行超时后的第三个传输轮次，成功后拥塞窗口值增加到8 KB；</p>
<p>超时后的第四个传输轮次：拥塞窗口值为8 KB，进行超时后的第四个传输轮次，成功后需要增加拥塞窗口的值，由于已经达到“慢开始门限值”，因此拥塞窗口的值线性加1 KB变为9 KB，之后改用“拥塞避免”算法。</p>
<p><strong>拥塞避免和慢启动</strong><br>当拥塞发生时（超时或收到重复确认），慢启动门限ssthresh被设置为当前拥塞窗口cwnd大小（题目为16）的一半，即8。同时cwnd重置为1（最大报文段长度）。新的数据被接收，则cwnd增加，规则为ssthresh之前， 慢启动，即cwnd指数增长；到达ssthresh之后， 拥塞避免，即cwnd加1。</p>
<p>TCP 可靠数据传输过程中的定时器设置，初始时定时器 T 设置为 1 秒，第 1 个样本 SampleRTT&#x3D;2 秒，获得该样本后估算 EstimatedRTT&#x3D;2 秒，偏差 DevRTT&#x3D;1 秒，第 2 个样本 SampleRTT&#x3D;1 秒，第 3 个样本 SampleRTT&#x3D;3 秒，计算收到第三个样本后 TCP 为第四个待发送分 组设定的定时器 T 的值？（要求：给出 EstimatedRTT 和 DevRTT 的均值公式和定时器 T 的计算 公式，EstimatedRTT 公式中系数是 0.125，DevRTT 公式中系数是 0.25，给出每次收到样本时均 值的变化，计算时小数保留 3 位）</p>
<p>ERTT&#x3D;（1-a）ERTT+a*SRTT<br>DRTT&#x3D;（1-b）DRTT+b*|SRTT-ERTT|<br>T&#x3D;ERTT+4*DRTT<br>收到第二个样本后：DRTT&#x3D;（1-0.25）*1+0.25*|1-2|&#x3D;1 秒 ，ERTT&#x3D;（1-0.125）*2+0.125*1&#x3D;1.875 秒<br>收到第三个样本后：DRTT&#x3D;（1-0.25）*1+0.25*|3-1.875|&#x3D;1.031 秒 ，ERTT&#x3D;（1-0.125）*1.875+0.125*3&#x3D;2.016 秒<br>定时器 T：（1 分） T&#x3D;2.016+4*1.031&#x3D;6.14 秒</p>
<p>（注：在计算DRTT时，ERTT用上一轮的）</p>
<p>在SR中，发送窗口大小不能超过序号空间的(1&#x2F;2)。</p>
<p>小于(1024)的TCP&#x2F;UDP端口号已保留与现有服务一一对应，此数字以上的端口号可自由分配。</p>
<p>设TCP拥塞窗口的当前阈值为8（单位为报文段），当拥塞窗口上升到12时收到3个重复ACK，那么下一轮传输时拥塞窗口大小为( )</p>
<p>A.8	B.9	C.6	D.4</p>
<p>在 TCP 拥塞控制中，当收到 3 个重复的 ACK 时，会触发快速重传和快速恢复算法。在快速重传和快速恢复算法中，当收到 3 个重复的 ACK 时，阈值会被设置为当前拥塞窗口大小的一半，拥塞窗口大小会被设置为阈值加上 3 个 MSS（最大报文段长度）的大小。根据题目中给出的信息，当前阈值为 8，当拥塞窗口上升到 12 时收到 3 个重复 ACK。此时，阈值会被设置为当前拥塞窗口大小的一半，即 12&#x2F;2&#x3D;6。拥塞窗口大小会被设置为阈值加上 3 个 MSS 的大小，即 6+3&#x3D;9。</p>
<p>TCP通信时，若某一方发送带有FIN标志的数据段，其含义为（C）</p>
<p>A.将断开通信双方的TCP连接</p>
<p>B.连接被重新建立</p>
<p>C.单方面释放连接，表示本方已经无数据发送，但可以接收对方数据</p>
<p>D.终止数据发送，双方都不能发送数据</p>
<p>假设使用8位校验和字段对数据0x5879B432计算Internet校验和，结果是（C）</p>
<p>A.0xB8</p>
<p>B.0x48</p>
<p>C.0x47</p>
<p>D.0xB7</p>
<p>以下哪个TCP熟知端口号是错误的（ D ）</p>
<p>A.HTTP:80</p>
<p>B.TELENT:23</p>
<p>C.SMTP:25</p>
<p>D.FTP:24</p>
<p>一般情况下,FTP使用的端口号为21和20。</p>
<p>主机甲和主机乙已建立TCP连接，甲始终以MSS&#x3D;1KB大小的段发送数据，并一直有数据发送；乙每收到一个数据段都会发出一个接收窗口为10KB的确认段。若甲在t时刻发生超时，其拥塞窗口为8KB。则从t时刻开始，不再发生超时情况下，经过10个RTT后，甲的发送窗口是多少？</p>
<p>当t时刻发生超时时，把sthresh设为8的一半，即为4，且拥塞窗口设为1KB。然后经历10个RTT后，拥塞窗口的大小依次为2、4、5、6、7、8、9、10、11、12，而发送窗口取当时的拥塞窗口和接收窗口的最小值，而接收窗口始终为10KB，所以此时的发送窗口为10KB。</p>
<blockquote>
<p>简述 TCP 拥塞控制中进入慢启动、快速恢复、拥塞避免三种状态对应的触发事件？</p>
</blockquote>
<p>慢启动状态的事件：开始传输；超时；低于阈值； </p>
<p>快速恢复的事件：三次及以上重复确认； </p>
<p>拥塞避免：高于阈值，正常收到分组确认</p>
<blockquote>
<p>假设主机A通过一条TCP连接向主机B发送一个大文件。主机A发送但未被确认的字节数不会 超过接收缓存的大小。   （  √ ）</p>
</blockquote>
<p>流量控制</p>
<blockquote>
<p>假设主机A通过TCP连接向主机B发送一个大文件。如果某个段(segment)的Seq号为 m,那下一个正常发送的段的Seq号必然为m+1（×）</p>
</blockquote>
<p>下一个正常发送的段的序列号并不一定是m+1，而是m加上前一个段中数据的字节数。例如，如果前一个段中包含512个字节的数据，那么下一个正常发送的段的序列号将是m+512。</p>
<blockquote>
<p>TCP报文段在它的首部中有一个rwnd字段。(√)</p>
</blockquote>
<p>rwnd即接收窗口（receive window），用来告知发送方，自己在该TCP连接的缓存中还有多少可用空间</p>
<blockquote>
<p>假定在一条TCP连接中最后的SampleRTT等于1秒，那么对于该连接的TimeoutInterval的当前值 必定大于等于1秒。 （ ×  ）</p>
</blockquote>
<p>Timeout Interval&#x3D;EstimatedRTT+4×DevRTT，所以TimeoutInterval数据和SampleRTT无关</p>
<blockquote>
<p>假设主机A通过一条TCP连接向主机B发送一个序号为38的4个字节的报文段。在这个相同的 报文段中，确认号必定是42。   （ ×  ）</p>
</blockquote>
<p>某些情况下（比如该报文段发送超时）接收方会发送一个重复的ACK，即确认号仍然是 38。</p>
<blockquote>
<p>考虑TCP的拥塞控制。当发送方定时器超时时，其ssthresh的值将被设置为原来值的 一半。（ x ）</p>
</blockquote>
<p>看准了，应该是ssthresh被设置为<code>当前拥塞窗口的一半</code>。</p>
<blockquote>
<p>考虑一个GBN协议，其发送方窗口为4,序号范围为1024。假设在时刻接收方期待的下一个有序分组的序号是k，且媒体不会对报文重新排序。回答以下问题：</p>
<p> a. 在t时刻，发送方窗口内的报文序号可能是多少？论证你的回答。</p>
<p>b. 在t时刻，在当前传播回发送方的所有可能报文中，ACK字段的所有可能值是多少？论证你的 回答。</p>
</blockquote>
<p>GBN协议特点：GBN协议几个特点：</p>
<ul>
<li>发送方拥有一个窗口，长度为N；</li>
<li>接收方无窗口，只接收希望接受序号的报文，对于<strong>失序到达</strong>的报文段采取的方式是直接丢弃；</li>
<li>在重传的时候，将会重传当前发送方窗口中所有未被确认的报文段。</li>
</ul>
<p>a）在t时刻，接收方起到收到的下一个分组序号为k，说明接收方已经正确接受了k之前的所有分组，对于发送方而言，我们考虑两种最极端的情况：</p>
<p>第一种情况：假设之前所有的报文都正确传输，没有任何丢失的问题，那么在这种情况下，发送方正确接收了接收方对于小于k的所有报文的ACK确认，因此窗口将会不断向后移动，序号如下图所示：</p>
<table>
<thead>
<tr>
<th>k</th>
<th>k+1</th>
<th>k+2</th>
<th>k+3</th>
</tr>
</thead>
</table>
<p>第二种情况：由已知条件我们可以得知序号为k-1的报文是发送方发送的最后一个报文，假设该报文虽然到达了接收方，但是接收方返回的ACK确认由于一些原因没有到达发送方，则窗口不会移动，在这种情况下我们再假设序号k-1位于窗口的最后一列，即如下图所示的所有序号报文都没有在发送方被确认，则得到了我们最坏的一种情况：</p>
<table>
<thead>
<tr>
<th>K-4</th>
<th>K-3</th>
<th>K-2</th>
<th>K-1</th>
</tr>
</thead>
</table>
<p>两种极端情况中间的任意一种情况都可能发生，因此发送方窗口序号可能为k-4、k-3、k-2、k-1、k、k+1、k+2、k+3。如果发送方窗口为N，则发送方窗口序号可能为[k，k+N-1]或[k-N，k-1]。</p>
<p>b）如果接收机正在等待分组k，则它已经接收（并确认）了分组k-1和在此之前的3个分组。如果发送方尚未接收到这4个ACK中的任何一个，则值为[k-4，k-1]的ACK消息可能仍在传播。ACK字段的所有可能值为k-1、k-2、k-3、k-4。如果发送方窗口为N，那么ACK字段的所有可能值为[k-N，k-1]。</p>
<blockquote>
<p>考虑从主机A向主机B传输L字节的大文件，假设MSS为536字节。</p>
<p>a. 为了使得TCP序号不至于用完，L的最大值是多少？前面讲过TCP的序号字段为4字节。</p>
<p> b. 对于你在(a)中得到的L，求出传输此文件要用多长时间？假定运输层、网络层和数据链路层首部总共为66字节，并加在每个报文段上，然后经155Mbps链路发送得到的分组。忽略流量控制和拥塞控制，使主机A能够一个接一个连续不断地发送这些报文段。</p>
</blockquote>
<p>a. 序号占用 4 字节，即 32 位。它的范围是 [0,2^32−1]，也就是说一共有 4 294 967 296 个序号。<br>L &#x3D; 2^32 &#x3D; 4294967296 byte</p>
<p>b. 报文段的数量为L&#x2F;MSS取上整。4294967296&#x2F;536 ≈ 8012999组<br>所有分组的总头部信息 &#x3D; 66 * 8012999 &#x3D; 528857934 byte<br>总数据量 4294967296 + 528857934 &#x3D; 4823825230 byte<br>所需时间 &#x3D; 4823825230 byte&#x2F;155Mbps ≈ 249秒 &#x3D; 4.15分钟</p>
<blockquote>
<p>UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节:01010011，01100110，01110100。这些8比特字节和的反码是多少?(注意到尽管UDP 和 TCP 使用 16 比特的字来计算检验和，但对于这个问题，你应该考虑8比特和。)写出所有工作过程。UDP 为什么要用该和的反码，即为什么不直接使用该和呢?使用该反码方案，接收方如何检测出差错?1比特的差错将可能检测不出来吗?2比特的差错呢?</p>
</blockquote>
<p>0101 0011 + 0110 0110 &#x3D; 1011 1001<br>1011 1001 + 0111 0100 &#x3D; 1 0010 1101（多了一位，第一位1回卷）<br>0010 1101 + 1 &#x3D; 0010 1110 取其反码，得到1101 0001。</p>
<p>运用反码相加，全1的检测对于计算机来说更加方便，速度会更快。</p>
<p>将反码1101 0001 放在检验和处，在接受方将全部的传输数据和检验和相加为1111 1111时，无差错，只要有任意一位为0，传输中就出现了差错。</p>
<p>1比特的差错一定能够检查出来，2比特的差错如果出现在同一位上，则会被忽略。</p>
<blockquote>
<p>主机A和B经一条TCP连接通信，并且主机B已经收到了来自A的最长为126字节的所有字节。 假定主机A随后向主机B发送两个紧接着的报文段。第一个和第二个报文段分别包含了 80字节和 40字节的数据。在第一个报文段中，序号是127,源端口号是302,目的地端口号是80。无论何时 主机B接收到来自主机A的报文段，它都会发送确认。</p>
<p>a)在从主机A发往B的第二个报文段中，序号、源端口号和目的端口号各是什么？ </p>
<p>b)如果第一个报文段在第二个报文段之前到达，在第一个到达报文段的确认中，确认号、源端口号和目的端口号各是什么？ </p>
<p>c)如果第二个报文段在第一个报文段之前到达，在第一个到达报文段的确认中，确认号是什么？ </p>
<p>d)假定由A发送的两个报文段按序到达B。第一个确认丢失了而第二个确认在第一个超时间隔之后到达。画出时序图，显示这些报文段和发送的所有其他报文段和确认。（假设没有其他分组丢 失。）对于图上每个报文段，标出序号和数据的字节数量；对于你增加的每个应答，标出确认号。</p>
</blockquote>
<p>a） 在从主机A到B的第二段中，序列号为207，源端口号码是302，目的地端口号是80。</p>
<p>b） 如果第一段在第二段之前到达，则在对第一段的确认中到达段，确认号为207，源端口号为80并且目的地端口号是302。</p>
<p>c） 如果第二段在第一段之前到达，则在对第一个到达的段，确认号码是127，表明它仍然是等待字节127及以后。</p>
<p>d）</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-25_11-30-33.png"></p>
<blockquote>
<p>假设TCP Reno是一个经历如上所示行为的协议，回答下列问题。在各种情况中，简要地论证你的回答。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/yskztt1.png"></p>
<p>（1）指出TCP慢启动运行时的时间间隔。</p>
<p>（2）指出TCP拥塞避免运行时的时间间隔。</p>
<p>（3）在第16个传输轮回之后，报文段的丢失是根据3个冗余ACK还是根据超时检测岀来的？</p>
<p>（4）在第22个传输轮回之后，报文段的丢失是根据3个冗余ACK还是根据超时检测出来的？</p>
<p>（5）在第1个传输轮回里，ssthresh的初始值设置为多少？</p>
<p>（6）在第18个传输轮回里，ssthresh的值设置为多少？</p>
<p>（7）在第24个传输轮回里，ssthresh的值设置为多少？</p>
<p>（8）在哪个传输轮回内发送第70个报文段？</p>
<p>（9）假定在第26个传输轮回后，通过收到3个冗余ACK检测出有分组丢失，拥塞的窗口长度和 ssthresh的值应当是多少？</p>
<p>（10）假定使用TCP Tahoe （而不是TCP Reno）,并假定在第16个传输轮回收到3个冗余ACK。在第19 个传输轮回，ssthresh和拥塞窗口长度是什么？</p>
<p>（11）再次假设使用TCP Tahoe,在第22个传输轮回有一个超时事件。从第17个传输轮回到第22个传 输轮回（包括这两个传输轮回），一共发送了多少分组？</p>
</blockquote>
<p>(1)	[1,6] and [23,26] </p>
<p>(2)	[6,16] and [17,22]</p>
<p>(3)	3个冗余ACK</p>
<p>(4)	超时</p>
<p>(5)	32</p>
<p>(6)	21（在16轮回， CongWin &#x3D; 42, ssthresh设置为当前拥塞窗口的一半）</p>
<p>(7)	14（在22轮回， CongWin &#x3D; 29,向下取整）</p>
<p>(8)	7（64-96）</p>
<p>(9)	4，7</p>
<p>(10)	21，4（拥塞窗口长度变为1，慢启动，17为1，18为2，19为4）</p>
<p>(11)	52&#x3D;1+2+4+8+16+21(第17个发了1个，第18个发了2个，第19个发了4个，第20个发了8个，第21个发了16个，第22个翻倍超过ssthresh，因此只发了21个,慢启动不能超阈值)</p>
<blockquote>
<p>主机A通过一条TCP连接向主机B发送一个很大的文件。在这条连接上，不会出现任何分组丢失和定时器超时。主机A与因特网连接链路的传输速率表示为R  bps，主机A上的进程能够以S  bps 的速率向TCP套接字发送数据，其中S &#x3D; 10 x R。假设TCP的接收缓存足够大，能够容纳整个文件，并且发送缓存只能容纳这个文件的百分之一。如何防止主机A上的进程连续地向TCP套接字以速率S  bps传送数据呢？还是用TCP流量控制呢？还是用TCP拥塞控制？或者用其他措施？阐述其理由。</p>
</blockquote>
<p>首先，由于接收方的接收缓存能容纳整个大文件，因此不会出现流量控制；并且因为在这条连接上不会出现任何分组丢失和定时器超时，因此拥塞控制机制不会遏制发送方的速率。最后，由于发送方的发送缓存会很快被填充满，因此一旦发送缓存被填充满，进程将无法继续以 S 速率向套接字发送数据，而是以 R 向套接字发送数据。</p>
<blockquote>
<p><strong>比较GBN、SR和TCP（无延时的ACK）。假设对所有3个协议的超时值足够长，使得5个连续的数据报文段及其对应的ACK能够分别由接收主机（主机B）和发送主机（主机A）收到（如果在信道中无丢失）。假设主机A向主机B发送5个数据报文段，并且第二个报文段（从A出发）丢失。最后所有5个数据报文段已经被主机B正确接收。</strong></p>
<p><strong>请问主机A总共发送了多少个报文段和主机B总共发送了多少ACK？它们的序号是多少？对于三种协议回答这个问题。</strong></p>
</blockquote>
<p>假设发送的五个数据报文段的序号分别为1、2、3、4、5.</p>
<p>GBN：A总共发送了5+4&#x3D;9个报文段，分别为1、2、3、4、5、2、3、4、5，B总共发送了4+4&#x3D;8个ACK，序号分别为1、1、1、1、2、3、4、5；</p>
<p>SR：A总共发送了5+1&#x3D;6个报文段，分别为1、2、3、4、5、2，B总共发送了4+1&#x3D;5个ACK，序号分别为1、3、4、5、2；</p>
<p>TCP：A总共发送了5+1&#x3D;6个报文段，分别为1、2、3、4、5、2，B总共发送了4+1&#x3D;5个ACK，序号分别为2、2、2、2、6.</p>
<p><strong>对于TCP，GBN，SR之间关系的总结</strong>：</p>
<p><em><strong>GBN</strong></em>：</p>
<p>发送方拥有一个窗口，长度为N；</p>
<p>接收方无窗口，只接收希望接受序号的报文，对于失序到达的报文段采取的方式是直接丢弃；</p>
<p>在重传的时候，将会重传当前发送方窗口中<strong>所有未被确认</strong>的报文段；</p>
<p>采用<strong>累计应答</strong>的方式。例如接收端返回ACK&#x3D;3，则证明报文段3以及之前的报文段都被正确接收。</p>
<p>接收端不对失序到达的分组进行缓存。</p>
<p><em><strong>SR</strong></em>：</p>
<p>发送方拥有一个窗口，长度为N；</p>
<p>接收方拥有一个窗口，长度为N，对于失序到达的报文段将会<strong>缓存</strong>下来；</p>
<p>在重传的时候，将会<strong>重传窗口中超时的单个报文</strong>，而不会重传窗口中所有的报文；</p>
<p>接收端返回ACK是当前接收成功报文段的序号，SR不采用累计应答的方式，如接收到序号为0的报文段，则ACK确认ACK&#x3D;0。</p>
<p><em><strong>TCP</strong></em>：</p>
<p>TCP使用累计应答的方式。这一点与GBN类似。</p>
<p>TCP在接收端会设置缓存，来缓存正确接收但是失序的分组，这点与SR类似。（实际上TCP RFC并没有对接收端要怎样处理失序到达的分组提出要求，但是在接收端设置缓存是实践中大家都采用的方法）</p>
<p>TCP使用<strong>快速重传</strong>机制：如果收到对于一个特定报文段的3个冗余ACK，则在超时事件发生前就会对该报文段进行重传，这大大节约了时间。</p>
<p>在重传的时候，将会重传窗口中超时的单个报文，而不会重传窗口中所有的报文；</p>
<p>接收方回复的ACK确认序号是希望接收到的下一个报文段的序号，如接收到序号为0的报文段，则ACK确认ACK&#x3D;1。</p>
<p><em><strong>补充关于选择重传的过程</strong></em>：</p>
<p><strong>窗口下界：最左边第一个窗口对应的序号</strong></p>
<p>假设发送窗口和接收窗口都为4，发送方发送0帧，接收方收到0帧，并回复0帧确认，由于0帧是接收窗口下界，于是移动窗口使得窗口下界为第一个未被接收的帧（1号帧），同时把新加入帧（4号帧）的状态置为可接收状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-25_15-56-21.png"></p>
<p>发送方发送1帧，接收方收到1帧，并回复1帧确认，由于1帧是接收窗口下界，于是移动窗口使得窗口下界为第一个未被接收的帧（2号帧），同时把新加入帧（5号帧）的状态置为可接收状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-25_15-56-30.png"></p>
<p>发送方发送2帧，但是2帧丢失，接收方未收到2帧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-25_15-56-44.png"></p>
<p>发送方发送3帧，接收方收到3帧，缓存三帧，发送ACK3：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-25_15-56-52.png"></p>
<p>发送方收到ACK0，由于窗口下限被确认，所以窗口右移一个，发送4帧，接收方收到4帧，缓存，发送ACK4：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-25_15-57-20.png"></p>
<p>发送方收到ACK1，由于窗口下界被确认，所以窗口右移1个，发送5帧，接收方接收5帧，缓存，发送ACK5：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-25_15-57-27.png"></p>
<p>发送方2帧超时未收到2帧确认，重新传2帧，这次接收方收到了，2-5帧交付（发送给上层网络层），发送ACK2：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-25_15-57-36.png"></p>
<p>发送方收到ACK3，但是无帧可发，等待，一直到ACK2到达，窗口下界被确认，窗口右移1个。</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows安装配置Redis教程</title>
    <url>/2023/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93/2/</url>
    <content><![CDATA[<p>虽然 Redis 官方网站没有提供 Windows 版的安装包，但可以通过 GitHub 来下载 Windows 版 Redis 安装包，下载地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a>。</p>
<blockquote>
<p>注意：Windows 安装包是某位民间“大神”根据 Redis 源码改造的，并非 Redis 官方网站提供。</p>
</blockquote>
<p>我们下载最新版——Redis-x64-xxx.zip压缩包到 F 盘，解压后，将文件夹重新命名为 Redis。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/7696d93c12de4195ac437fd3205f475e.png"></p>
<p>打开文件夹，内容如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/600b1aec22114cc7bf03b4a3e98774af.png"></p>
<p>打开一个 cmd 窗口 使用 cd 命令切换目录到 F:\Redis 运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure>
<p>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/23129afbc4774a3a9249eed59d5b67da.png"><br>在用户变量的Path中配置redis的路径如下（建议配置，省时间)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/d3de4a8ead2a496b813bc4b9e2b16b06.png"><br>这时候另启一个 cmd 窗口，原来的不要关闭，因为这是redis服务端。</p>
<p>切换到 redis 目录下运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>
<p>当然你也可以像我一样，任意cmd窗口运行<code>redis-cli -h 127.0.0.1 -p 6379</code>，因为我已经配置了环境变量。<br>接下来检测一下连接是否成功。<br>设置键值对:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> myKey 123</span><br></pre></td></tr></table></figure>
<p>取出键值对:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get myKey</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/5354c90c77084f63a5e6369d50bc8901.png"></p>
<p>通过检测发现安装成功，之后启动redis服务就可以直接执行<code>redis-server</code>了，客户端连接执行<code>redis-cli</code>就可以了，前提是配置了环境变量哈。</p>
<p>上述方式虽然简单快捷，但是显然不是程序员的操作，下面介绍，通过命令启动 Redis 服务端，并将 Redis 服务添加到 Windows 资源管理器，实现开机后自动启动。</p>
<ol>
<li>注册Redis服务<br>通过 cmd 命令行工具进入 Redis 安装目录，将 Redis 服务注册到 Windows 服务中，执行以下命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server.exe --service-install redis.windows.conf --loglevel verbose</span><br></pre></td></tr></table></figure>
执行完后，得到类似以下输出，说明注册成功。</li>
</ol>
<blockquote>
<p>[5520] 27 Jul 08:23:07.826 # Granting read&#x2F;write access to ‘NT AUTHORITY\NetworkService’ on: “F:\Redis” “F:\Redis&quot;<br>[5520] 27 Jul 08:23:07.826 # Redis successfully installed as a service.</p>
</blockquote>
<ol start="2">
<li>启动Redis服务<br>执行以下命令启动 Redis 服务，命令如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server --service-start</span><br></pre></td></tr></table></figure>
这样Redis 已经被添加到 Windows 服务中，因此不会再显示 Redis 服务端的相应的信息，如下图所示：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/b3aef0600ba941a1a7cde110bf78d270.png"><br>打开Redis服务，将启动类型设置为自动，即可实现开机自启动。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/ce232ff5302f4e489de6b82be4a32a50.png"></p>
<p>至此所有安装与配置全部完成。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>电大软件测试～第一次作业</title>
    <url>/2023/05/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/test1/</url>
    <content><![CDATA[<h2 id="第一次作业及参考答案"><a href="#第一次作业及参考答案" class="headerlink" title="第一次作业及参考答案"></a>第一次作业及参考答案</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>针对电子科技大学信息门户的“密码找回”界面的邮箱输入域进行验证， 采用等价划分法设计相应的测试用例，包括尽量多的无效等价类。</p>
<p>答:</p>
<p>有效等价类如下：</p>
<blockquote>
<p>(1)邮箱输入学符串格式<u>***@uestc.edu.cn</u>或<u>***@UESTC.EDU.CN</u>(*为字母或数字)</p>
</blockquote>
<p>无效等价类:</p>
<blockquote>
<p>(2)*中带有非字母或数字的其它字符</p>
<p>(3)邮箱输入的字符串中缺少‘@’字符</p>
<p>(4)邮箱输入的字符串中有两个或多个‘@’字符</p>
<p>(5)邮箱输入字符串中‘@’字符后不是标准的域名字段</p>
</blockquote>
<p>测试用例：</p>
<table>
<thead>
<tr>
<th align="left">测试用例编号</th>
<th>测试用例</th>
<th>覆盖等价类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td><a href="mailto:&#x65;&#120;&#97;&#109;&#x70;&#108;&#101;&#x40;&#x75;&#101;&#x73;&#116;&#x63;&#x2e;&#101;&#100;&#x75;&#x2e;&#99;&#x6e;">&#x65;&#120;&#97;&#109;&#x70;&#108;&#101;&#x40;&#x75;&#101;&#x73;&#116;&#x63;&#x2e;&#101;&#100;&#x75;&#x2e;&#99;&#x6e;</a></td>
<td>(1)</td>
</tr>
<tr>
<td align="left">2</td>
<td>#<a href="mailto:&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#x40;&#x75;&#101;&#115;&#116;&#x63;&#46;&#x65;&#100;&#x75;&#x2e;&#99;&#x6e;">&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#x40;&#x75;&#101;&#115;&#116;&#x63;&#46;&#x65;&#100;&#x75;&#x2e;&#99;&#x6e;</a></td>
<td>(2)</td>
</tr>
<tr>
<td align="left">3</td>
<td>exampleuestc.edu.cn</td>
<td>(3)</td>
</tr>
<tr>
<td align="left">4</td>
<td>example@@uestc.edu.cn</td>
<td>(4)</td>
</tr>
<tr>
<td align="left">5</td>
<td>example@domaincom</td>
<td>(5)</td>
</tr>
</tbody></table>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>综合运用边界值方法和等价类方法，针对三角形问题设计相应的测试用例。假定输入三个整数（a、b、c）作为边，分别满足一般三角形、等腰三角形和等边三角形。</p>
<p>1）判断一般三角形的有效等价类是什么? 判断一般三角形的无效等价类是什么?</p>
<p>2）判断等腰三角形的有效等价类是什么? 判断等腰三角形的无效等价类是什么?</p>
<p>3）判断等边三角形的有效等价类是什么? 判断等边三角形的无效等价类是什么?</p>
<p>答：</p>
<p>三角形判断条件如下：</p>
<blockquote>
<p>1)三角形的边长均大于0</p>
<p>2)构成一般三角形的条件：任意两边之和大于第三边</p>
<p>3)构成等腰三角形的条件：任意两边相等</p>
<p>4)构成等腰三角形的条件：三条边都相等</p>
</blockquote>
<p>(1)判断一般三角形的有效等价类与边界值规则设计：</p>
<blockquote>
<p>(a≥0)∧(b≥0)∧(c≥0)∧((a+b)&gt;c)∧((a+c)&gt;b)∧((b+c)&gt;a)</p>
</blockquote>
<p>判断一般三角形的无效等价类与边界值规则设计：</p>
<blockquote>
<p>①(a≥0)∧(b≥0)∧(c≥0)∧(((a+b)≤c)∨((a+c)≤b)∨((b+c)≤a))</p>
<p>②(a≤0)∨(b≤0)∨(c≤0)</p>
</blockquote>
<p>(2)判断等腰三角形的有效等价类与边界值规则设计：</p>
<blockquote>
<p>(a≥0)∧(b≥0)∧(c≥0)∧((a+b)&gt;c)∧((a+c)&gt;b)∧((b+c)&gt;a)∧((a&#x3D;b)∨(b&#x3D;c)∨(a&#x3D;c))</p>
</blockquote>
<p>判断等腰三角形的无效等价类与边界值规则设计：</p>
<blockquote>
<p>①(a!&#x3D;b)∧(b!&#x3D;c)∧(c!&#x3D;a) </p>
<p>②(a≤0)∨(b≤0)∨(c≤0)</p>
</blockquote>
<p>(3)判断等边三角形的有效等价类与边界值规则设计：</p>
<blockquote>
<p>(a≥0)∧(b≥0)∧(c≥0)∧((a+b)&gt;c)∧((a+c)&gt;b)∧((b+c)&gt;a)∧(a&#x3D;b&#x3D;c)</p>
</blockquote>
<p>判断等边三角形的无效等价类与边界值规则设计：</p>
<blockquote>
<p>①(a!&#x3D;b)</p>
<p>②(a≤0)∨(b≤0)∨(c≤0)</p>
</blockquote>
<p>测试用例</p>
<table>
<thead>
<tr>
<th>测试用例编号</th>
<th>测试用例输入(a,b,c)</th>
<th>预期结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(5,6,8)</td>
<td>一般三角形</td>
</tr>
<tr>
<td>2</td>
<td>(5,6,5)</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>3</td>
<td>(5,5,5)</td>
<td>等边三角形</td>
</tr>
<tr>
<td>4</td>
<td>(5,0,5)</td>
<td>非三角形</td>
</tr>
<tr>
<td>5</td>
<td>(2,2,5)</td>
<td>非三角形</td>
</tr>
</tbody></table>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>系统的年、月、日数据由Y、M、D单元来存储相应值，若要测试NextData（Y,M,D）函数，采用判定表方法设计相应的测试用例。</p>
<p>答：</p>
<p>被测函数功能：该程序输出为输入日期的下一个日期。</p>
<p>例如：输入为2023年4月2日，函数输出为2023年4月3日。</p>
<p>函数输入变量Y，M，D，均为正整数，并满足如下条件：</p>
<p>1）1900≤Y≤2100</p>
<p>2）1≤M≤12</p>
<p>3）1≤D≤31</p>
<p>4）能被 400 整除，或者能被4整除但不能 100 整除的部是闰年(366 天)，其余的年份均为平年(365 天)</p>
<table>
<thead>
<tr>
<th>输入参数</th>
<th>有效等价类</th>
<th>无效等价类</th>
</tr>
</thead>
<tbody><tr>
<td>Y</td>
<td>1900≤Y≤2100，Y1闰年，Y2平年</td>
<td>＜1900，＞2100，非正整数，其他符号</td>
</tr>
<tr>
<td>M</td>
<td>1≤M≤12，M1{1,3,5,7,8,10}，M2{4,6,9,11}，M3{2}，M4{12}</td>
<td>&lt;1，&gt;12，非正整数，其他符号</td>
</tr>
<tr>
<td>D</td>
<td>1≤D≤31，D1{1,27}，D2{28}，D3{29}，D4{30}，D5{31}</td>
<td>&lt;1，&gt;31，D6，非正整数，其他符号</td>
</tr>
</tbody></table>
<p><em><strong>判定表设计：</strong></em></p>
<p>结果：</p>
<p>1、year,month不变,day+1</p>
<p>2、year不变,month+1,day&#x3D;1</p>
<p>3、year+1,month&#x3D;1,day&#x3D;1</p>
<p>4、错误的输入</p>
<table>
<thead>
<tr>
<th>用例</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>Y</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
</tr>
<tr>
<td>M</td>
<td>M3</td>
<td>M3</td>
<td>M3</td>
<td>M1</td>
<td>M1</td>
<td>M1</td>
<td>M2</td>
<td>M2</td>
<td>M2</td>
<td>M4</td>
<td>M4</td>
<td>M4</td>
</tr>
<tr>
<td>D</td>
<td>D3</td>
<td>D2,D1</td>
<td>D4,D5</td>
<td>D5</td>
<td>D1,D2,D3,D4</td>
<td>D6</td>
<td>D4</td>
<td>D5,D6</td>
<td>D1,D2,D3</td>
<td>D5</td>
<td>D1,D2,D3,D4</td>
<td>D6</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>用例</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
<th>21</th>
<th>22</th>
<th>23</th>
<th>24</th>
</tr>
</thead>
<tbody><tr>
<td>Y</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
</tr>
<tr>
<td>M</td>
<td>M3</td>
<td>M3</td>
<td>M3</td>
<td>M1</td>
<td>M1</td>
<td>M1</td>
<td>M2</td>
<td>M2</td>
<td>M2</td>
<td>M4</td>
<td>M4</td>
<td>M4</td>
</tr>
<tr>
<td>D</td>
<td>D2</td>
<td>D1</td>
<td>D3,D4,D5</td>
<td>D5</td>
<td>D1,D2,D3,D4</td>
<td>D6</td>
<td>D4</td>
<td>D5,D6</td>
<td>D1,D2,D3</td>
<td>D5</td>
<td>D5</td>
<td>D6</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
</tbody></table>
<p>测试用例如下：</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>Y</th>
<th>M</th>
<th>D</th>
<th>预期输出</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2023</td>
<td>4</td>
<td>1</td>
<td>2023,4,2</td>
</tr>
<tr>
<td>2</td>
<td>2023</td>
<td>3</td>
<td>28</td>
<td>2023,3,29</td>
</tr>
<tr>
<td>3</td>
<td>2023</td>
<td>3</td>
<td>29</td>
<td>2023,3,30</td>
</tr>
<tr>
<td>4</td>
<td>2023</td>
<td>3</td>
<td>30</td>
<td>2023,3,31</td>
</tr>
<tr>
<td>5</td>
<td>2023</td>
<td>3</td>
<td>31</td>
<td>2023,4,1</td>
</tr>
<tr>
<td>6</td>
<td>2023</td>
<td>11</td>
<td>28</td>
<td>2023,11,29</td>
</tr>
<tr>
<td>7</td>
<td>2023</td>
<td>11</td>
<td>29</td>
<td>2023,11,30</td>
</tr>
<tr>
<td>8</td>
<td>2023</td>
<td>11</td>
<td>30</td>
<td>2023,12,1</td>
</tr>
<tr>
<td>9</td>
<td>2023</td>
<td>11</td>
<td>31</td>
<td>错误</td>
</tr>
<tr>
<td>10</td>
<td>2023</td>
<td>2</td>
<td>28</td>
<td>2023,3,1</td>
</tr>
<tr>
<td>11</td>
<td>2023</td>
<td>2</td>
<td>29</td>
<td>错误</td>
</tr>
<tr>
<td>12</td>
<td>2023</td>
<td>2</td>
<td>30</td>
<td>错误</td>
</tr>
<tr>
<td>13</td>
<td>2023</td>
<td>2</td>
<td>31</td>
<td>错误</td>
</tr>
<tr>
<td>14</td>
<td>2020</td>
<td>2</td>
<td>28</td>
<td>2020,2,29</td>
</tr>
<tr>
<td>15</td>
<td>2020</td>
<td>2</td>
<td>29</td>
<td>2020,3,1</td>
</tr>
<tr>
<td>16</td>
<td>2020</td>
<td>2</td>
<td>30</td>
<td>错误</td>
</tr>
<tr>
<td>17</td>
<td>2020</td>
<td>2</td>
<td>31</td>
<td>错误</td>
</tr>
<tr>
<td>18</td>
<td>2020</td>
<td>12</td>
<td>28</td>
<td>2020,12,29</td>
</tr>
<tr>
<td>19</td>
<td>2020</td>
<td>12</td>
<td>29</td>
<td>2020,12,30</td>
</tr>
<tr>
<td>20</td>
<td>2020</td>
<td>12</td>
<td>30</td>
<td>2020,12,31</td>
</tr>
<tr>
<td>21</td>
<td>2020</td>
<td>12</td>
<td>31</td>
<td>2021,1,1</td>
</tr>
</tbody></table>
<hr>
<p>个人觉得以上判定表的设计比较复杂🥺，一般很难想到这么详细，我认为下面的判定表比较容易想到🤡</p>
<table>
<thead>
<tr>
<th></th>
<th>序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>条件</td>
<td>正确输入年Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>条件</td>
<td>正确输入月M</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>条件</td>
<td>正确输入日D</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>动作</td>
<td>函数运行成功</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>动作</td>
<td>函数运行失败</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>测试用例表的话可以模仿参考答案书写✍</p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>针对某机构人员管理的业务规则需求：</p>
<p>1）年薪制员工：严重过失，扣年终风险金的4%；过失，扣年终风险金的2%。</p>
<p>2）非年薪制员工：严重过失，扣当月薪资的8%；过失，扣当月薪资的4%。</p>
<p>请绘制出因果图和判定表，并给出相应的测试用例。</p>
<p>答：</p>
<ul>
<li><p>因果分析</p>
<p>原因：</p>
<blockquote>
<p>C1：年薪制员工</p>
<p>C3：严重过失</p>
<p>C3：过失</p>
</blockquote>
<p>结果：</p>
<blockquote>
<p>e1：扣年终风险金的4%</p>
<p>e2：扣年终风险金的2%</p>
<p>e3：扣月薪资的8%</p>
<p>e4：扣月薪资的4%</p>
</blockquote>
</li>
<li><p>因果图设计</p>
<p><img src="https://s2.loli.net/2023/05/31/7xV4hjUMqRTa3ky.png" alt="3HA4ZSM3_6U1BEFKKP_2H5U.png"></p>
</li>
<li><p>判定表设计</p>
<table>
<thead>
<tr>
<th></th>
<th>序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>条件</td>
<td>C1：年薪制员工</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>条件</td>
<td>C3：严重过失</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>条件</td>
<td>C3：过失</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>结果</td>
<td>e1：扣年终风险金的4%</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>结果</td>
<td>e2：扣年终风险金的2%</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>结果</td>
<td>e3：扣月薪资的8%</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>结果</td>
<td>e4：扣月薪资的4%</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>结果</td>
<td>不操作</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>结果</td>
<td>不可能</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>有效等价类测试用例</p>
<table>
<thead>
<tr>
<th>用例</th>
<th>输入数据</th>
<th>预期输出</th>
</tr>
</thead>
<tbody><tr>
<td>TC1</td>
<td>年薪制员工，严重过失</td>
<td>扣年终风险金的4%</td>
</tr>
<tr>
<td>TC2</td>
<td>年薪制员工，过失</td>
<td>扣年终风险金的2%</td>
</tr>
<tr>
<td>TC3</td>
<td>非年薪制员工，严重过失</td>
<td>扣月薪资的8%</td>
</tr>
<tr>
<td>TC4</td>
<td>非年薪制员工，过失</td>
<td>扣月薪资的4%</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>测试一个登录页面在不同浏览器和语言下的功能正确性，其输入条件如下:</p>
<p>1）输入项（账号、密码）</p>
<p>2）浏览器（IE、chrome、FireFox、360）</p>
<p>3）语言（中文、英文）</p>
<p>请问进行完整组合的兼容性测试需要多少个测试用例？采用成对组合的兼容性测试需要多少个测试用例？给出成对组合测试用例表。</p>
<p>答：</p>
<p>完整组合测试有2x2X4x2&#x3D;32 个，成对组合测试需要8个测试用例</p>
<p>成对组合测试用例表</p>
<table>
<thead>
<tr>
<th>用例</th>
<th>账号</th>
<th>密码</th>
<th>浏览器</th>
<th>语言</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>空值</td>
<td>空值</td>
<td>IE</td>
<td>中文</td>
</tr>
<tr>
<td>2</td>
<td>空值</td>
<td>有值</td>
<td>chrome</td>
<td>英文</td>
</tr>
<tr>
<td>3</td>
<td>有值</td>
<td>空值</td>
<td>FireFox</td>
<td>中文</td>
</tr>
<tr>
<td>4</td>
<td>有值</td>
<td>有值</td>
<td>360</td>
<td>英文</td>
</tr>
<tr>
<td>5</td>
<td>空值</td>
<td>空值</td>
<td>360</td>
<td>中文</td>
</tr>
<tr>
<td>6</td>
<td>空值</td>
<td>有值</td>
<td>FireFox</td>
<td>英文</td>
</tr>
<tr>
<td>7</td>
<td>有值</td>
<td>空值</td>
<td>chrome</td>
<td>中文</td>
</tr>
<tr>
<td>8</td>
<td>有值</td>
<td>有值</td>
<td>IE</td>
<td>英文</td>
</tr>
</tbody></table>
<p><em><strong>以上内容来自老师提供的原版答案，如有错误，欢迎批评指正</strong></em>😆</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>电子科大计网期末复习之经典大题</title>
    <url>/2023/06/25/%E8%AE%A1%E7%BD%91/7/</url>
    <content><![CDATA[<blockquote>
<p>试将TCP&#x2F;IP与ISO&#x2F;OSI七层模型相比较</p>
</blockquote>
<p>相同点:</p>
<p>都是独立的协议栈的概念；层的功能大体相似。 </p>
<p>不同点:</p>
<p>①ISO&#x2F;OSI参考模型将服务、接口与协议的概念明确化，因此比 TCP／IP 具有更好的隐藏性，能够比较容易地进行替换;TCP&#x2F;IP参考模型在服务、接口与协议的区别上不很清楚。</p>
<p>②ISO&#x2F;OSI参考模型先有层的划分,后有各层协议;TCP&#x2F;IP参考模型先有协议,后有层的划分。</p>
<p>③ISO&#x2F;OSI参考模型划分为7层;TCP&#x2F;IP参考模型划分为4层，没有会话层和表示层</p>
<p>④ISO&#x2F;OSI的网络层支持无连接和面向连接的通信,传输层只支持面向连接的通信;TCP&#x2F;IP的网络层只支持无连接的通信,传输层提供无连接和面向连接的通信。</p>
<blockquote>
<p>TCP与UDP区别</p>
</blockquote>
<p>1、TCP是面向连接服务的；UDP是无连接的<br>2、TCP提供可靠的传输服务；UDP尽最大努力交付，即不保证可靠交付<br>3、TCP面向字节流；UDP是面向报文段的<br>4、UDP首部开销比较小，只有8字节，TCP最少首部为20字节，主要因为它实现的功能比较多，拥塞控制、流量控制等等。</p>
<blockquote>
<p>在使用TCP传送数据时,如果有一个确认报文段丢失了,也不一定会引起与该确认报文段对应的数据的重传。试说明理由。</p>
</blockquote>
<p>只要在超时重传到达之前，有后续的确认报文段到达，并通过批量（累积）确认对此报文段进行确认，即不需要重传。（对方还未来得及重传,就收到了对更高序号的确认,相当于对连同被丢失确认的报文段一并确认。）</p>
<blockquote>
<p>简要描述有线局域网和无线局域网在媒体访问控制协议上的异同点。</p>
</blockquote>
<p>答:<strong>CSMA&#x2F;CD载波侦听多路访问&#x2F;冲突检测协议</strong>,是一种分布式介质访问控制协议。其原理如下:</p>
<p>(1)多个站点平等的接入到共享访问介质(多路访问)。</p>
<p>(2)每个站在发送帧之前,首先要监听访问介质,只有访问介质空闲时,才允许发送帧(载波监听)。</p>
<p>(3)如果两个以上的站同时监听到访问介质空闲并发送帧,则会产生冲突现象。因此要求每个站在发送数据的同时,仍然继续监听访问介质(冲突检测)。如果出现冲突,则发送站要发送干扰信号以使所有其它主机都能接收到冲突信号。然后每一个发送站随机延时一段时间后,再次重新发送帧。</p>
<p><strong>CSMA&#x2F;CA载波侦听多路访问&#x2F;冲突避免协议</strong>工作原理如下:</p>
<p>(1)发送站在检测到介质空闲后,先发送一个请求发送帧(RTS),帧中存放了它需要占用介质的时间。</p>
<p>(2)接收站收到请求RTS后,发送准备发送帧(CTS),所有站点都会收到该帧,知道了介质会被占用一段时间。</p>
<p>(3)发送站发送数据帧。</p>
<p>(4)接收站确认所收到的数据。</p>
<p><strong>区别</strong></p>
<p>① CSMA&#x2F;CD可以一边检测冲突,一边收发数据,一旦检测到冲突,立刻停止数据收发。CSMA&#x2F;CA则是必须先检测是否有冲突,得到对端确认后,再发送数据,而不能同时进行,是根据无线网络的特点设计出来的。</p>
<p>② 两者的传输介质不同,CSMA&#x2F;CD用于总线式以太网,而CSMA&#x2F;CA则用于无线局域网。</p>
<blockquote>
<p>考虑使用32bit主机地址的数据报网络，假定一台主机具有4条线路，编号0到3，分组能被转发到链路接口，情况如下表所示：</p>
<table>
<thead>
<tr>
<th>目的地址范围</th>
<th>链路接口</th>
</tr>
</thead>
<tbody><tr>
<td>11100000 00000000 00000000 00000000 到 11100000 11111111 11111111 11111111</td>
<td>0</td>
</tr>
<tr>
<td>11100001 00000000 00000000 00000000 到 11100001 00000000 11111111 11111111</td>
<td>1</td>
</tr>
<tr>
<td>11100001 00000001 00000000 00000000 到 11100001 11111111 11111111 11111111</td>
<td>2</td>
</tr>
<tr>
<td>其它</td>
<td>3</td>
</tr>
</tbody></table>
<p>a&gt;提供一个具有4项的转发表，使用最长地址匹配，转发分组到正确的链路接口</p>
<p>b&gt;根据转发表，对下列目的地址应该转发到哪个链路接口：</p>
<p>1100100 100100001 01010001 01010101</p>
<p>11100001 00000000 11000011 00111100</p>
<p>11100001 10000000 00010001 01110111</p>
</blockquote>
<p>a)</p>
<table>
<thead>
<tr>
<th>目标网络</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>224.0.0.0&#x2F;8</td>
<td>0</td>
</tr>
<tr>
<td>225.0.0.0&#x2F;16</td>
<td>1</td>
</tr>
<tr>
<td>225.0.0.0&#x2F;8</td>
<td>2</td>
</tr>
<tr>
<td>Default</td>
<td>3</td>
</tr>
</tbody></table>
<p>注：目标网络不能只填写网络号部分，必须是完整的，否则视为错误</p>
<p>b)1100100 100100001 01010001 01010101 从3号接口走</p>
<p>11100001 00000000 11000011 00111100 从1号接口走</p>
<p>11100001 10000000 00010001 01110111 从2号接口走</p>
<blockquote>
<p>考虑在具有Q段链路的路径上发送一个包含F bit比特数据的分组。每段链路以R bit&#x2F;sec速率传输。该网络负载轻，因此没有排队时延。传播时延可忽略不计。</p>
<p>a）假定该网是一个分组交换虚电路网络。VC建链时间为ts sec，假定发送层对每个分组增加总计h比特的首部。从源到目的地发送该文件需要多长时间？</p>
<p>b）假定该网络是一个分组交换数据报网络，使用无连接服务。现在假定每个分组具有2h比特的首部。发送该分组需要多长时间？</p>
<p>c）最后，假定该网络是电路交换网。进一步假定源和目的地之间的传输速率是R bit&#x2F;s。假定ts为建链时间，h比特的首部附加在整个文件上，发送该分组需要多长时间？</p>
</blockquote>
<p>a） ts+Q（F+h）&#x2F;R</p>
<p>b） Q（F+2h）&#x2F;R</p>
<p>c） ts+（F+h）&#x2F;R</p>
<p>电路交换网络中的电路是专用的，建立电路后，源和目的地之间的传输速率是R bit&#x2F;s。这意味着，无论路径上有多少段链路，整个文件都将以R bit&#x2F;s的速率从源到目的地传输。因此，在计算传输时间时，不需要考虑Q段链路。相反，在分组交换网络中，每个分组都需要在每段链路上单独传输，所以需要考虑Q段链路。</p>
<blockquote>
<p>应用层协议能够为解决各种网络应用提供服务，试回答下面和应用层协议有关的问题：</p>
<p>1、使用HTTP协议获取网页时，为何经常会设置Web缓存（代理服务器）？</p>
<p>2、简要描述比较C&#x2F;S和P2P两种体系结构。</p>
<p>3、简要描述电子邮件的工作过程及所用到的协议的功能。</p>
</blockquote>
<p>1、Web缓存器可以减少对客户的响应时间、避免不必要的网络请求，减少服务器负载，从而能从整体上降低因特网上的web流量。</p>
<p>2、**C&#x2F;S体系结构	**</p>
<p>Server：具有固定的、众所周知的IP地址；总是打开的主机；主机群集；	</p>
<p>Client：可以间断的同服务器连接；拥有动态IP地址；客户机相互之间不直接通信</p>
<p><strong>P2P体系结构</strong>	</p>
<p>没有总是打开的服务器；任意一对主机直接相互通信；对等方间歇连接并且可以改变IP地址；自扩展性；难以管理</p>
<p>（在传统的“服务器&#x2F;客户端”应用系统中,客户端与服务器有明确的分界,而使用P2P技术实现的每个计算机节点既是客户端,也是服务器。）</p>
<p>3、当用户撰写一封电子邮件并点击发送按钮时，邮件客户端会使用SMTP（简单邮件传输协议）将邮件发送到SMTP服务器。SMTP服务器负责将邮件传输到收件人的邮件服务器。收件人的邮件服务器会将邮件存储在收件人的邮箱中。当收件人检查邮箱时，他的邮件客户端会使用POP3（邮局协议）或IMAP（互联网消息访问协议）从邮件服务器获取邮件。POP3允许用户从邮件服务器下载邮件到本地计算机，并在本地计算机上阅读和管理邮件。IMAP则允许用户在邮件服务器上直接管理邮件，支持离线阅读和多设备同步等功能。</p>
<blockquote>
<p>考虑图2所示网络。对于表明的链路费用，用Dijkstra的最短路径算法计算出从x到所有网络节点的最短路径。（给出计算步骤）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-25_21-59-23.png"></p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>步 骤</td>
<td>N’</td>
<td>D(s), P(s)</td>
<td>D(t), P(t)</td>
<td>D(u), P(u)</td>
<td>D(v), P(v)</td>
<td>D(w), P(w)</td>
<td>D(y), P(y)</td>
<td>D(z), P(z)</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>3,x</td>
<td>1,x</td>
<td>6,x</td>
<td>∞</td>
</tr>
<tr>
<td>1</td>
<td>xw</td>
<td>∞</td>
<td>∞</td>
<td>4,w</td>
<td>2,w</td>
<td></td>
<td>6,x</td>
<td>∞</td>
</tr>
<tr>
<td>2</td>
<td>xwv</td>
<td>∞</td>
<td>11,v</td>
<td>3,v</td>
<td></td>
<td></td>
<td>3,v</td>
<td>∞</td>
</tr>
<tr>
<td>3</td>
<td>xwvu</td>
<td>7,u</td>
<td>5,u</td>
<td></td>
<td></td>
<td></td>
<td>3,v</td>
<td>∞</td>
</tr>
<tr>
<td>4</td>
<td>xwvuy</td>
<td>7,u</td>
<td>5,u</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>17,y</td>
</tr>
<tr>
<td>5</td>
<td>xwvuyt</td>
<td>6,t</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7,t</td>
</tr>
<tr>
<td>6</td>
<td>xwvuyts</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7,t</td>
</tr>
<tr>
<td>7</td>
<td>xwvuytsz</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>或</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>步 骤</td>
<td>N’</td>
<td>D(s), P(s)</td>
<td>D(t), P(t)</td>
<td>D(u), P(u)</td>
<td>D(v), P(v)</td>
<td>D(w), P(w)</td>
<td>D(y), P(y)</td>
<td>D(z), P(z)</td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>3,x</td>
<td>1,x</td>
<td>6,x</td>
<td>∞</td>
</tr>
<tr>
<td>1</td>
<td>xw</td>
<td>∞</td>
<td>∞</td>
<td>4,w</td>
<td>2,w</td>
<td></td>
<td>6,x</td>
<td>∞</td>
</tr>
<tr>
<td>2</td>
<td>xwv</td>
<td>∞</td>
<td>11,v</td>
<td>3,v</td>
<td></td>
<td></td>
<td>3,v</td>
<td>∞</td>
</tr>
<tr>
<td>3</td>
<td>xwvy</td>
<td>∞</td>
<td>7,v</td>
<td>3,v</td>
<td></td>
<td></td>
<td></td>
<td>17,y</td>
</tr>
<tr>
<td>4</td>
<td>xwvyu</td>
<td>7,u</td>
<td>5,u</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>17,y</td>
</tr>
<tr>
<td>5</td>
<td>xwvyut</td>
<td>6,t</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7,t</td>
</tr>
<tr>
<td>6</td>
<td>xwvyuts</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7,t</td>
</tr>
<tr>
<td>7</td>
<td>xwvyutsz</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>浏览网页的时候，请运用TCP&#x2F;IP、DNS、HTTP、HTML、URL、MIME等术语描述浏览网页的整个逻辑过程。</p>
</blockquote>
<p>使用浏览器浏览网页的过程如下。</p>
<p>(1)在地址栏输入要访问的URL地址。</p>
<p>(2)浏览器从URL地址中，分离出要访问服务器的域名。</p>
<p>(3)浏览器调用DNS协议对分离出的域名进行解析，过程如下。<br>①首先查找本机DNS高速缓存，如果有以前访问的记录，将域名对应的IP返回给浏览器;如果没有记录，转②;<br>②向本地授权DNS服务器提交解析请求，如果解析成功，将IP提交给浏览器﹔如果本地授权DNS服务器不能解析，就将该解析请求转发给根DNS服务器，转③;<br>③若外部DNS解析成功，则将IP返回给浏览器﹔否则向浏览器报告DNS解析失败。</p>
<p>(4)浏览器使用DNS解析出的IP地址，与网页服务器建立TCP连接。</p>
<p>(5)基于建立的TCP连接，浏览器从URL中分离出要访问的网页资源在服务器上的路径信息，构造HTTP请求报文，向服务器发出请求。<br>( 6 ) 服务器根据请求网页的路径在本地查找，网页以HTML标记语言形式编写。如果找到要访问的网页，使用HTTP响应报文向浏览器传递网页数据；否则，在HTTP响应报文中给出错误信息。<br>(7）浏览器根据收到的响应报文中的状态码判断网页请求是否成功。如果请求成功，就按HTML中标记指示的格式在窗口中显示内容;如果请求失败，则在窗口中显示相应的错误信息。<br>(8 )如果访问的资源不是静态的HTML文档，而是活动网页，就需要使用MIME对非文本的内容进行处理。<br>整个访问过程的数据传输由TCP&#x2F;IP协议栈来实现。</p>
<blockquote>
<p>某一网络的一台主机产生了一个P数据报，头部长度为20字节，数据部分长度为2000字节。该数据报需要经过两个网络到达目的主机，这两个网络所允许的最大传输单位MTU分别为1500字节和576字节。请问原IP数据报到达目的主机时分成了几个IP小报文？每个报文的数据部分长度分别是多少?</p>
</blockquote>
<p>在IP层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传输单位MTU。1500-20&#x3D;1480,2000-1480&#x3D;520。所以原IP数据报经过第1个网络后分成了两个IP小报文，第一个报文的数据部分长度是1480B,第二个报文的数据部分长度是520B。<br>所有报片（除最后一个报片）的有效载荷都是8B的倍数。576-20&#x3D;556,但556不能被8整除.所以分片时的数据部分最大只能取552。第一个报文经过第2个网络后1480-552x2&#x3D;376&lt;576，变成数据长度分别为552B、552B、376B的3个P小报文;第2个报文520&lt;552，故不用分片。因此到达目的主机时，原2000B的数据被分成数据长度分别为552B、552B、376B、520B四个小报文。</p>
<blockquote>
<p>在访问网页的时候，经常会看到一些指向其他网站的链接。若用户在访问某网页的时候，发现这个网页有一个指向<a href="http://www.126.com/">www.126.com</a> 的链接。请你解释一下，当用户点击这个键按以后友生了什么事件?</p>
</blockquote>
<p>用户单击鼠标之后，发生了以下事件。<br>①浏览器分析超链接指向的页面的URL(假设URL为<a href="http://www.126.com/index.html">www.126.com/index.html</a>  ) </p>
<p>②浏览器向DNS请求解析域名<a href="http://www.126.com/">www.126.com</a> 的IP地址。</p>
<p>③域名系统DNS解析出网易服务器的P地址。</p>
<p>④浏览器利用域名系统DNS解析到的IP地址，与<a href="http://www.126.com/">www.126.com</a> 的服务器建立TCP连接。</p>
<p>⑤浏览器发出读取index.htm取文件命令的HTTP请求：GET &#x2F;index.html。</p>
<p>⑥服务器给出响应，把文件index.html返回给浏览器。</p>
<p>⑦TCP连接释放。</p>
<p>⑧浏览器对index.html文档进行解释，并把结果显示在浏览器上，供用户查看。</p>
<blockquote>
<p>假定两个主机A和B相隔10000km，由一条直接的R&#x3D;1Mb&#x2F;s的链路相连。假定跨越该链路的传播速度是2.5×108m&#x2F;s。</p>
<p>（1）计算“带宽时延”积R×tprop</p>
<p>（2）在该链路上一个比特的宽度（以m计）是多少？</p>
<p>（3）根据传播速度s、带宽R和链路m的长度，推导出比特宽度的一般表达式。</p>
</blockquote>
<p>(1)	40kb</p>
<p>(2)	10^7m&#x2F;40kb&#x3D;250m&#x2F;b</p>
<p>(3)	s&#x2F;R</p>
<blockquote>
<p>表1是某台路由器中的路由表，现该路由收到了4个数据报，其目标IP地址分别如下，请给出每个数据报的下一跳。</p>
<p>表1 路由表</p>
<table>
<thead>
<tr>
<th>网络&#x2F;掩码长度</th>
<th>下一跳点</th>
</tr>
</thead>
<tbody><tr>
<td>C4.50.0.0&#x2F;12</td>
<td>A</td>
</tr>
<tr>
<td>C4.50.0.0&#x2F;12</td>
<td>B</td>
</tr>
<tr>
<td>C4.60.0.0&#x2F;12</td>
<td>C</td>
</tr>
<tr>
<td>C4.68.0.0&#x2F;14</td>
<td>D</td>
</tr>
<tr>
<td>80.0.0.0&#x2F;1</td>
<td>E</td>
</tr>
<tr>
<td>40.0.0.0&#x2F;2</td>
<td>F</td>
</tr>
<tr>
<td>0.0.0.0&#x2F;2</td>
<td>G</td>
</tr>
</tbody></table>
<p>1）C4.5E.13.87</p>
<p>2）C4.5E.22.09</p>
<p>3）C3.41.80.02</p>
<p>4）5E.43.91.12</p>
<p>5）C4.6D.31.2E</p>
<p>6）C4.6B.31.2E</p>
</blockquote>
<p>(1)B</p>
<p>(2)A</p>
<p>(3)E</p>
<p>(4)F</p>
<p>(5)C</p>
<p>(6)D</p>
<blockquote>
<p>在选择重传协议和GBN协议中，发送方可能会收到落在其当前窗口之外的ACK报文吗？请简要证实你的结论。</p>
</blockquote>
<p>假设发送方窗口大小为3，在t0时刻发送包1、2、3；在t1时刻，接收方确认包1、2、3发送对应的ACK；在t2时刻发送方超时，再次发送包1、2、3；在t3时刻接收方接到重复数据再次发送对应的确认包；在t4时刻发送方接到接收方在t1时刻发送的确认报文，同时移动窗口到包4、5、6；在t5时刻发送方又接受到1、2、3的确认报文，这些ACK在发送方的窗口外。</p>
<blockquote>
<p>在如图所示的网络拓扑中，已知：</p>
<p>HA1和HA2分别是主机H1和主机H2的硬件地址；IP1和IP2分别是各自的IP地址；HA3～HA6分别是路由器各端口的硬件地址；IP3～IP6分别是路由器各端口的IP地址。</p>
<p>其中IP1和IP3是<strong>私有地址</strong>，其他的IP地址是<strong>公网地址</strong>，H1和H2通信。</p>
<p>通信的路径是：H1→经过R1路由转发→再经过R2路由转发→H2。</p>
<p>请填写表1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-26_13-25-40.png"></p>
</blockquote>
<table>
<thead>
<tr>
<th>IP1</th>
<th>IP2</th>
<th>HA1</th>
<th>HA3</th>
</tr>
</thead>
<tbody><tr>
<td>IP4</td>
<td>IP2</td>
<td>HA4</td>
<td>HA5</td>
</tr>
<tr>
<td>IP4</td>
<td>IP2</td>
<td>HA6</td>
<td>HA2</td>
</tr>
</tbody></table>
<blockquote>
<p>请简述集线器和网桥的异同点。</p>
</blockquote>
<p>相同点：都是局域网组网设备。</p>
<p>不同点：集线器具体实现在物理层；网桥具体实现在数据链路层。</p>
<p>集线器仅具有简单的信号整形和放大的功能；网桥则提供信号的存储&#x2F;转发、数据过滤等能力。</p>
<p>集线器仅是一种硬设备，而网桥既包括硬件又包括软件。</p>
<p>集线器仅只能互连同等速率的LAN，而网桥可支持不同速率的LAN互连。</p>
<blockquote>
<p>假定一个ISP拥有形为101.101.100.0&#x2F;23的地址块，要分配给四个单位使用，A单位需要115个IP地址，B单位需要238个地址，C单位需要50个IP地址，D单位需要29个IP地址。请提供满足四个单位需要的地址块划分（形式为a.b.c.d&#x2F;x）。</p>
</blockquote>
<p>A单位：101.101.101.0&#x2F;25 </p>
<p>B单位：101.101.100.0&#x2F;24</p>
<p>C单位：101.101.101.128&#x2F;26 </p>
<p>D单位：101.101.101.192&#x2F;26</p>
<blockquote>
<p>某一个数据通信系统采用CRC校验方式，要发送的数据f(x)的值为10010011011，生成多项式G(x)的二进制比特序列为10111，请问：</p>
<p>(1)发送方实际发出的数据f’(x)是什么？</p>
<p>(2)接收方收到的f’(x)的第三个比特由0变为1，请问接收方能否检测出该错误？是如何检测的？</p>
</blockquote>
<p>（1）100100110111100</p>
<p>（2)	能检测出来，余数不为0(新帧100100110111100再用上面选定的除数10111以“模2除法”方式去除，验证余数是否为0)</p>
<blockquote>
<p>一个CSMA／CD基带总线网长度为1000米，信号传播速度为200米／微秒，假如位于总线两端的节点，在发送数据帧时发生了冲突，试问：</p>
<p>（1）两节点间的信号传播延迟是多少？</p>
<p>（2）最多经过多长时间才能检测到冲突？</p>
</blockquote>
<p>（1）两节点间的信号传播延迟：a&#x3D;1000／200&#x3D;5微秒</p>
<p>（2）冲突检测最长时间：2a&#x3D;10微秒</p>
<blockquote>
<p>简述TCP建立连接的过程, 试用具体例子说明为什么在运输连接建立时要使用三次握手。说明如不这样做可能会出现什么情况。（画出三次握手连接建立图）</p>
</blockquote>
<p>三次握手完成两个重要功能，既要双方做好发送数据的准备工作（双方都知道彼此已准备好），也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送与确认。</p>
<p>现在把三次握手改成仅需要两次握手，死锁是可能发生的。举个例子。考虑计算机A和B 之间的通信。假定B 给A 发送一个连接请求分组，A 收到了这个分组，并发送了确认应答分组。按照两次握手的协定，A 认为连接已经成功的建立了，可以开始发送数据分组。可是，B 在A 的应答分组在传输中被丢失的情况下，将不知道A 是否已经准备好，不知道A 建议什么样的序列号用于A 到B 的交通，也不知道A 是否同意B所建议的用于B 到A交通的初始序列号，B 甚至怀疑A 是否收到自己的连接请求分组。在这种情况下，B 认为连接还未建立成功，将忽略A 发来的任何数据分组，只等待接收连接确认应答分组。而A在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-26_14-55-51.png"></p>
<blockquote>
<p>采用生成多项式 x⁶+x⁴+x+1 发送的报文到达接收方为101011000110，所接收的报文是否正确？试说明理由。（要求写出运算过程。）</p>
</blockquote>
<p>多项式 x⁶+x⁴+x+1 对应的位串是1010011，用它来除接收到的报文，若能整除则所接收报文正确。能够整除，所以收到的报文是正确的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-26_15-09-44.png"></p>
<p>由此判断接收到的报文是正确的。</p>
<blockquote>
<p>某单位分配到一个C类IP地址，其网络地址为202.33.23.0。为了使该单位的主机便于管理，拟将该单位所属主机划分为12个子网。试计算(要求写出运算过程)</p>
<p>(1)该网络的子网位占几位？</p>
<p>(2)求该单位这12个子网最多可以拥有的主机台数？</p>
<p>(3)写出子网掩码，列出每个子网的地址，任选其中1个可用的子网，写出这个子网络的网络标识，可分配给主机的地址范围和广播地址。</p>
</blockquote>
<p>(1)	C 类 IP 地址的默认子网掩码为 255.255.255.0，即前 24 位为网络位，后 8 位为主机位。由于要将该单位所属主机划分为 12 个子网，所以需要将主机位中的若干位划分为子网位。由于 2^3 &lt; 12 &lt;&#x3D; 2^4，所以需要将主机位中的前 4 位划分为子网位。因此，该网络的子网位占 4 位。</p>
<p>(2)	由于子网位占了主机位中的前 4 位，所以每个子网中剩余的主机位有 8-4&#x3D;4 位。因此，每个子网最多可以拥有的主机台数为 2^4-2&#x3D;14 台。</p>
<table>
<thead>
<tr>
<th>子网编号</th>
<th>子网地址</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>202.33.23.16</td>
</tr>
<tr>
<td>2</td>
<td>202.33.23.32</td>
</tr>
<tr>
<td>3</td>
<td>202.33.23.48</td>
</tr>
<tr>
<td>4</td>
<td>202.33.23.64</td>
</tr>
<tr>
<td>5</td>
<td>202.33.23.80</td>
</tr>
<tr>
<td>6</td>
<td>202.33.23.96</td>
</tr>
<tr>
<td>7</td>
<td>202.33.23.112</td>
</tr>
<tr>
<td>8</td>
<td>202.33.23.128</td>
</tr>
<tr>
<td>9</td>
<td>202.33.23.144</td>
</tr>
<tr>
<td>10</td>
<td>202.33.23.160</td>
</tr>
<tr>
<td>11</td>
<td>202.33.23.176</td>
</tr>
<tr>
<td>12</td>
<td>202.33.23.192</td>
</tr>
</tbody></table>
<p>选择子网1，如果选择子网0001,主机地址范围为202.33.23.17—202.33.23.30， 广播地址为：202.33.23.31。</p>
<blockquote>
<p>简述TCP&#x2F;IP的5层体系结构及各层的功能服务?</p>
</blockquote>
<p>应用层application layer:支持网络应用，报文传送</p>
<p>传输层transport layer:主机进程间报文段传送</p>
<p>网络层network layer:主机(源目标节点)间分组传送</p>
<p>链路层link layer:相邻网络节点间的数据帧传送</p>
<p>物理层physical layer:物理介质上的比特传送</p>
<blockquote>
<p>IP数据报携带5000字节数据，它下一步经由MTU为1500字节的以太网，数据报分几片?如何分片?并标明每个分片的片头中“片偏移”字段的数值</p>
</blockquote>
<table>
<thead>
<tr>
<th>片头</th>
<th>偏移</th>
<th>数据大小</th>
</tr>
</thead>
<tbody><tr>
<td>片1头（标识&#x3D;x，标志等于001，偏移0）</td>
<td>0</td>
<td>1480字节</td>
</tr>
<tr>
<td>片2头（标识&#x3D;x，标志等于001，偏移185）</td>
<td>185</td>
<td>1480字节</td>
</tr>
<tr>
<td>片3头（标识&#x3D;x，标志等于001，偏移370）</td>
<td>370</td>
<td>1480字节</td>
</tr>
<tr>
<td>片4头（标识&#x3D;x，标志等于001，偏移555）</td>
<td>555</td>
<td>560字节</td>
</tr>
</tbody></table>
<p>当一个 IP 数据报携带的数据长度超过下一跳网络的 MTU 时，就需要对数据报进行分片。在本题中，IP 数据报携带 5000 字节数据，而下一步经由 MTU 为 1500 字节的以太网，所以需要对数据报进行分片。由于 IP 头部长度为 20 字节，所以每个分片中最多可以携带 1500-20&#x3D;1480 字节的数据。因此，5000 字节的数据需要分成 5000&#x2F;1480&#x3D;3.38 个分片，即至少需要 4 个分片。</p>
<p>“片偏移”（Fragment Offset）是 IP 头部中的一个字段，它表示分片在原始数据报中的偏移量。片偏移的单位是 8 字节，即<strong>每个分片的数据长度都必须是 8 的倍数</strong>（最后一个分片除外）。前两个分片中每个分片都携带 1480 字节的数据，最后一个分片携带剩余的 1040 字节数据。每个分片都有自己的 IP 头部，其中“片偏移”字段表示该分片在原始数据报中的偏移量（以 8 字节为单位）。因此，三个分片的“片偏移”字段的数值分别为：</p>
<ul>
<li>第一个分片：0</li>
<li>第二个分片：1480&#x2F;8&#x3D;185</li>
<li>第三个分片：(1480+1480)&#x2F;8&#x3D;370</li>
<li>第四个分片：(1480+1480+1480)&#x2F;8&#x3D;555</li>
</ul>
<blockquote>
<p>简述拥塞控制与流量控制产生的原因和解决的问题。它们解决问题的根本途径是什么?</p>
</blockquote>
<p> 如果接收方的接收缓存区小和处理能力低都会造成发方的数据流“淹没”收方的接收缓冲区，使数据丢失，流量控制用来保证发送数据在任何情况下不都不“淹没”收方的接收缓冲区。</p>
<p>拥塞是分组交换网络共同的问题。产生拥塞的原因是网络中一个或多个路由器的数据报负载相对它的处理能力过重，路由器不得不将过多的数据报放在缓冲队列中进行排队处理，造成传输时延。严重情况下，路由器丢失数据报。</p>
<p>TCP流量控制和拥塞控制的根据措施是减慢源点的发送速率，即源抑制。</p>
<blockquote>
<p>什么是计算机网络协议，其基本要素有哪些?</p>
</blockquote>
<p>网络协议是指通信双方必须遵守的报文格式、规则和动作的集合<br>基本要素︰语法、语义和同步</p>
<blockquote>
<p>通常路由器处理因特网协议栈的哪些层次?2层交换机处理哪些层次?主机处理哪些层次?集线器处理哪些层次?</p>
</blockquote>
<p>路由器处理第一层到第三层</p>
<p>链路交换机处理第一层和第二层</p>
<p>主机处理所有的5层</p>
<p>集线器处理第一层</p>
<ul>
<li>路由器：路由器是一种网络层设备，它负责在不同网络之间转发数据包。因此，路由器处理因特网协议栈的网络层、数据链路层和物理层。</li>
<li>2层交换机：2层交换机是一种数据链路层设备，它负责在同一网络内转发数据帧。因此，2层交换机处理因特网协议栈的数据链路层和物理层。</li>
<li>主机：主机是一种终端设备，它需要处理因特网协议栈的所有层次，包括应用层、传输层、网络层、数据链路层和物理层。</li>
<li>集线器：集线器是一种物理层设备，它负责在物理媒介上传输比特流。因此，集线器仅处理因特网协议栈的物理层。</li>
</ul>
<blockquote>
<p>如下图所示的拓扑结构图，填写节点z的距离向量表（不考虑毒性逆转)</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-26_16-30-16.png"></p>
<p>初始化：</p>
<table>
<thead>
<tr>
<th></th>
<th>z</th>
<th>x</th>
<th>y</th>
<th>v</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>第一轮迭代：</p>
<table>
<thead>
<tr>
<th></th>
<th>z</th>
<th>x</th>
<th>y</th>
<th>v</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>第二轮迭代：</p>
<table>
<thead>
<tr>
<th></th>
<th>z</th>
<th>x</th>
<th>y</th>
<th>v</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>第三轮迭代：</p>
<table>
<thead>
<tr>
<th></th>
<th>z</th>
<th>x</th>
<th>y</th>
<th>v</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>z</th>
<th>x</th>
<th>y</th>
<th>v</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td>0</td>
<td>2</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>x</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td>y</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td>v</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>z</th>
<th>x</th>
<th>y</th>
<th>v</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td>0</td>
<td>2</td>
<td>3</td>
<td><strong>5</strong></td>
</tr>
<tr>
<td>x</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>∞</td>
</tr>
<tr>
<td>y</td>
<td>10</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>v</td>
<td><strong>5</strong></td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>z</th>
<th>x</th>
<th>y</th>
<th>v</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td>0</td>
<td>2</td>
<td>3</td>
<td><strong>4</strong></td>
</tr>
<tr>
<td>x</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>y</td>
<td>3</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>v</td>
<td><strong>5</strong></td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>z</th>
<th>x</th>
<th>y</th>
<th>v</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td>0</td>
<td>2</td>
<td>3</td>
<td><strong>4</strong></td>
</tr>
<tr>
<td>x</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>y</td>
<td>3</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>v</td>
<td><strong>4</strong></td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>（有点麻烦）</p>
<blockquote>
<p>简述HTTP使用TCP连接的不同方式?</p>
</blockquote>
<p>包括非持久HTTP连接持久HTTP连接</p>
<p>非持久HTTP连接每次请求都要建立一个TCP连接</p>
<p>持久HTTP连接所有请求都使用一个TCP连接包括带流水线方式和不带流水线方式</p>
<p>带流水线方式可以连续发送多个请求</p>
<p>不带流水线方式发送一次请求后必须等待响应后才能发送下一个请求</p>
<blockquote>
<p>CSMA对ALOHA的改进主要是什么?目的是什么?</p>
</blockquote>
<p>载波监听多点接入CSMA是从ALOHA演变出的一种协议，主要改进是增加了载波监听机制，即每个站点在发送数据前先监听信道上其他站是否在发送数据，如果监听到其他站点在发送数据，就暂不发送。</p>
<p>这一改进的目的是减少发送时的随意性和盲目性，从而避免不必要的冲突，提高系统的吞吐量。</p>
<p>（补充：纯ALOHA协议的工作原理和特点工作原理：站点只要产生帧，就立即发送到信道上；规定时间内若收到应答，表示发送成功，否则重发。）</p>
<blockquote>
<p>简述网络地址转换NAT的实现过程?</p>
</blockquote>
<p>NAT 转换器对局域网内外出的数据报进行处理，将报文中的源地址和源端口号替换为 NAT 转换器的 IP 地址和新的端口号。同时，NAT 转换器记录替换的 IP 地址和新的端口号，并将对应关系添加到 NAT 转换表中。对于进入局域网内的数据，NAT 转换器根据报文中的目的地址查找 NAT 转换表，得到对应的内部网络的 IP 地址和端口号，并用内部的 IP 地址和端口号替换数据报中的目的 IP 和目的端口号。</p>
<blockquote>
<p>TCP发现拥塞的途径是什么?</p>
</blockquote>
<p>报文段的超时重传。<br>来自ICMP的源抑制报文。<br>收到3个重复的确认而不必等到重传定时器到时。</p>
<p>（补充：ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP&#x2F;IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。）</p>
<blockquote>
<p>在停止等待协议中如果不使用编号是否可行，并说明?</p>
</blockquote>
<p>答:不可行。如果不采用编号，接收方可能会接收到重复的数据，如，发送方发送一个分维后，接收方收到该分组后发送确认，但确认丢失，此时发送方重发该分组，但接收方无法判断是否和前面的为同一分组。</p>
<blockquote>
<p>主机A向主机B连续发送了两个TCP报文段，其序号分别为70和100。简要分析并回答如下问题︰<br>(1)第一个报文段携带了多少个字节的数据?</p>
<p>(2)主机B收到第一个报文段后发回的确认中的确认号应当是多少?</p>
<p>(3)如果主机B收到第二个报文段后发回的确认中的确认号是180，试问A发送的第二个报文段中的数据有多少字节?</p>
<p>(4)如果A发送的第一个报文段丢失了，但第二个报文段到达了B。B在第二个报<br>文段到达后向A发送确认。试问这个确认号应为多少?</p>
<p>(5)假定由A发送的两个报文段按序到达B。第一个报文段的确认丢失，而第二个<br>确认在第一个超时间隔之后达到。则下一个发送报文段的序号应当是多少?</p>
</blockquote>
<p>⑴第二个报文段的开始序号是100，说明第一个报文段的序号是70到99，故第一个报文段携带了30个字节的信息。<br>(2〉由于主机已经收到了第一个报文段，即最后一个字节的序号应该是99，故下一次应当期望收到第10O号序号，故确认中的确认号是100。<br>(3）由于主机B收到第二个报文段后发回的确认中的确认号是180，说明了已经收到了第179号字节，也就说明了第二个报文段的序号是从100到179，故第二个报文段有80个字节。<br>(4）确认是接收方期望收到的字节，只要有一个没收到，都不能发送更高字节的确认，所以主机B应该发送第一个报文段的开始序号，即70。<br>(5）第一个报文段的确认丢失，而第二个确认在第一个超时间隔之后达到。说明在超时时，还没有收到第一个报文段，则需要重发第一个报文段，序号为70。</p>
<blockquote>
<p>在五层协议的网络体系结构中<br>(1)有哪些协议层次?<br>(2)在上面四层中，分别列举出一个协议例子。<br>(3）在主机、路由器、交换机和集线器这些设备中，分别实现了网络体系结构的哪<br>些层次?</p>
</blockquote>
<p>(1)应用层、运输层、网络层、数据链路层、物理层</p>
<p>(2)应用层:HTTP、DNS、FTP等<br>运输层:TCP、UDP等<br>网络层:IP、ICMP等<br>数据链路层︰CSMA&#x2F;CD、PPP等</p>
<p>(3)主机︰应用层、运输层、网络层、数据链路层、物理层</p>
<p>路由器:网络层、数据链路层、物理层</p>
<p>交换机:数据链路层、物理层</p>
<p>集线器:物理层</p>
<blockquote>
<p>如下图所示的网络，主机A与主机B间传输数据，请回答以下问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-26_18-34-59.png"></p>
<p>(1)主机A与主机B构成的网路是一种什么结构?<br>(2)主机A与主机B进行数据传输时，可能发生冲突，是哪种延迟导致的这个问题?为什么?<br>(3）简要叙述CSMA&#x2F;CD是如何克服以上问题以实现主机A与主机B间数据传输的。</p>
</blockquote>
<p>(1)总线结构<br>(2)传播延迟。因为主机A与主机B间的链路有一段距离，导致主机A与主机B都检测到空闲时，发送的数据信号在链路中由于延迟而可能发生碰撞。<br>(3)实现过程如下:<br>1)当一个节点要发送数据时，首先监听信道，看是否有载波</p>
<p>2)如果信道空闲，则发送数据</p>
<p>3)如果信道忙，则继续对信道进行监听。一旦发现空闲，便立即发送</p>
<p>4)如果在发送过程中检测到碰撞，则停止自己的正常发送，转而发送一短暂的干扰信号jam，强化冲突，使其它站点都能知道出现了冲突</p>
<p>5)发送了干扰信号后，退避随机时间，重新尝试发送</p>
<blockquote>
<p>4、考虑下图所示的网络。假定AS3和AS2正在运行其AS内部选路协议OSPF，AS1和AS4正在运行其AS内部选路协议RIP。假定AS间寻路协议使用的是eBGP和iBGP。初始化时，假定AS2和AS4之间不存在物理链路。一旦路由器1d知道了x的情况，它将一个表项(x,l)放入其转发表中。<br>⑴路由器3c、3a分别从OSPF、RIP、eBGP或iBGP中的哪个选路协议学习到了前缀x?</p>
<p>(2）对这个表项而言，l将设置成l1,还是l2? 为什么?</p>
<p>(3）现在假设AS2和AS4之间有一条物理链路，如图中的虚线所示。假定路由器1d知道经AS2以及经AS3都能够访问到x，l将设置成l1,还是l2? 为什么?</p>
<p>(4）假定有另一自治系统AS5，它位于AS2和AS4之间。路由器1d知道经AS2 AS5 AS4以及经AS3 AS4都能够访问到x，将设置成l1,还是l2? 为什么?</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-26_18-34-25.png"></p>
</blockquote>
<p>(1) 3c: eBGP ; 3a:iBGP<br>(2)l1。因为1d到网关路由器1c的路径费用值经l1比经l2小。<br>(3)l2。因为访问网络x具有相同的AS-PATH，但是ld到经l1到网关路由器1c的路径费用值比经l2到1b的路径费用值更大。也就是说1b是最近的NEXT-HOP路由器。<br>(4)l1。因为经l1比经l2有更短的AS-PATH路径。</p>
<blockquote>
<p>设有A、B、C、D四台主机，其IP地址和子网掩码如下表所示</p>
<table>
<thead>
<tr>
<th>主机</th>
<th>IP地址</th>
<th>子网掩码</th>
<th>子网地址</th>
<th>广播地址</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>192.155.12.112</td>
<td>255.255.255.224</td>
<td>192.155.12.96</td>
<td>192.155.12.127</td>
</tr>
<tr>
<td>B</td>
<td>192.155.12.120</td>
<td>255.255.255.224</td>
<td></td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>192.155.12.176</td>
<td>255.255.255.224</td>
<td></td>
<td>192.155.12.191</td>
</tr>
<tr>
<td>D</td>
<td>192.155.12.222</td>
<td>255.255.255.224</td>
<td>192.155.12.192</td>
<td></td>
</tr>
</tbody></table>
<p>完成以下问题:<br>(1)完成以上表格中的空白项;</p>
<p>(2)主机A、B、C、D这四台主机之间哪些可以直接通信?C、D是否需要通过路由器路由后才能通信?</p>
<p>(3)若新增加一台主机E，使它能够与主机D直接通信，则其IP地址的设定范围是多少?(去掉主机地址全O和全1情况)</p>
</blockquote>
<table>
<thead>
<tr>
<th>主机</th>
<th>IP地址</th>
<th>子网掩码</th>
<th>子网地址</th>
<th>广播地址</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>192.155.12.112</td>
<td>255.255.255.224</td>
<td>192.155.12.96</td>
<td>192.155.12.127</td>
</tr>
<tr>
<td>B</td>
<td>192.155.12.120</td>
<td>255.255.255.224</td>
<td>192.168.12.96</td>
<td>192.168.12.127</td>
</tr>
<tr>
<td>C</td>
<td>192.155.12.176</td>
<td>255.255.255.224</td>
<td>192.168.12.160</td>
<td>192.155.12.191</td>
</tr>
<tr>
<td>D</td>
<td>192.155.12.222</td>
<td>255.255.255.224</td>
<td>192.155.12.192</td>
<td>192.155.12.223</td>
</tr>
</tbody></table>
<p>(2)A、B之间可以直接通信(在一个子网里)，C、D之间需要经过路由器才能通信(不在一个子网里)</p>
<p>(3)192.155.12.193 —192.155.12.221</p>
<blockquote>
<p>Bob (client)请求视频:<a href="http://netcinema.com/6Y7B23V">http://netcinema.com/6Y7B23V</a> ，视频存储在CDN上，地址为<a href="http://kingcdn.com/NetC6y&B23V">http://KingCDN.com/NetC6y&amp;B23V</a> ，试写出整个逻辑过程。</p>
</blockquote>
<p>1、Bob 从netcinema.com的网页得到视频的URL<a href="http://netcinema.com/6Y7B23V">http://netcinema.com/6Y7B23V</a></p>
<p>2、通过Bob的本地DNS解析<a href="http://netcinema.com/6Y7B23V">http://netcinema.com/6Y7B23V</a>  </p>
<p>3、netcinema的 DNS返回URL:<a href="http://kingcdn.com/NetC6y&B23V">http://KingCDN.com/NetC6y&amp;B23V</a>  </p>
<p>4、由KingCDN的权威DNS解析<a href="http://kingcdn.com/NetC6y&B23V">http://KingCDN.com/NetC6y&amp;B23V</a>  ,其返回包含了视频的服务器的IP</p>
<p>5、通过HTTP，以流的方式从KINGCDN服务器取得视频</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-21_15-28-26.png"></p>
<blockquote>
<p>假设 TCP Reno 是一个经历如上所示行为的协议，回答下列问题。在各种情况中，简要地论证你的回答。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/yskztt1.png"></p>
<p>（1）指出 TCP 慢启动运行时的时间间隔。</p>
<p>（2）指出 TCP 拥塞避免运行时的时间间隔。</p>
<p>（3）在第 16 个传输轮回之后，报文段的丢失是根据 3 个冗余 ACK 还是根据超时检测岀来的？</p>
<p>（4）在第 22 个传输轮回之后，报文段的丢失是根据 3 个冗余 ACK 还是根据超时检测出来的？</p>
<p>（5）在第 1 个传输轮回里，ssthresh 的初始值设置为多少？</p>
<p>（6）在第 18 个传输轮回里，ssthresh 的值设置为多少？</p>
<p>（7）在第 24 个传输轮回里，ssthresh 的值设置为多少？</p>
<p>（8）在哪个传输轮回内发送第 70 个报文段？</p>
<p>（9）假定在第 26 个传输轮回后，通过收到 3 个冗余 ACK 检测出有分组丢失，拥塞的窗口长度和 ssthresh 的值应当是多少？</p>
<p>（10）假定使用 TCP Tahoe （而不是 TCP Reno）, 并假定在第 16 个传输轮回收到 3 个冗余 ACK。在第 19 个传输轮回，ssthresh 和拥塞窗口长度是什么？</p>
<p>（11）再次假设使用 TCP Tahoe, 在第 22 个传输轮回有一个超时事件。从第 17 个传输轮回到第 22 个传 输轮回（包括这两个传输轮回），一共发送了多少分组？</p>
</blockquote>
<p>(1) [1,6] and [23,26]</p>
<p>(2) [6,16] and [17,22]</p>
<p>(3) 3 个冗余 ACK</p>
<p>(4) 超时</p>
<p>(5) 32</p>
<p>(6) 21（在 16 轮回， CongWin &#x3D; 42, ssthresh 设置为当前拥塞窗口的一半）</p>
<p>(7) 14（在 22 轮回， CongWin &#x3D; 29, 向下取整）</p>
<p>(8) 7（64-96）</p>
<p>(9) 4，7</p>
<p>(10) 21，4（拥塞窗口长度变为 1，慢启动，17 为 1，18 为 2，19 为 4）</p>
<p>(11) 52&#x3D;1+2+4+8+16+21 (第 17 个发了 1 个，第 18 个发了 2 个，第 19 个发了 4 个，第 20 个发了 8 个，第 21 个发了 16 个，第 22 个翻倍超过 ssthresh，因此只发了 21 个，慢启动不能超阈值)</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网期末复习之网络层</title>
    <url>/2023/06/23/%E8%AE%A1%E7%BD%91/4/</url>
    <content><![CDATA[<p>1、网络层提供的功能</p>
<p>（1）报文段封装和解封（数据报）</p>
<ul>
<li>发送方主机、接收方主机、路由器</li>
</ul>
<p>（2）转发（数据平面） 	</p>
<ul>
<li>路由器根据路由表，将分组从路由器的输入端口转移到正确的路由器输出端口</li>
</ul>
<p>（3）路由(控制平面)	</p>
<ul>
<li>确定分组从发送方传输到接收方(目的主机)所经过的路径(或路由)</li>
</ul>
<p>（4)连接建立（ATM）</p>
<p>2、什么样的服务模型可以用于将数据报从发送方传输到接收方</p>
<p>（1）网络层可能提供的服务	</p>
<ul>
<li>确保交付、具有时延上界的确保交付、有序分组交付、确保最小带宽、确保最大时延抖动</li>
</ul>
<p>（2）因特网的网络层提供的服务	</p>
<ul>
<li>单一服务，即尽力而为服务；分组间的定时不能被保证；</li>
<li>分组的接收顺序与发送顺序不一定相同；传送的分组不能保证最终交付</li>
</ul>
<p>3、虚电路和数据报网络</p>
<p>任何网络中的网络层只提供两种服务之一，不会同时提供。</p>
<p>（1）虚电路网络	</p>
<ul>
<li>提供网络层的<strong>连接</strong>服务；面向连接服务在端系统及网络核心的路由器中实现；</li>
</ul>
<p>（2）数据报网络</p>
<ul>
<li>提供网络层的<strong>无连接</strong>服务；</li>
<li>路由器不需要维护端到端连接的状态，使用目的主机的地址进行分组转发；</li>
<li>对于给定的目的地址，使用<strong>最长地址前缀匹配</strong>来完成输出端口的查找；</li>
<li>一个端系统发送给另一个端系统的一批分组可能在网络中选择不同的路径，到达的顺序可能不一致；</li>
<li>特点：<ul>
<li>网络层服务模型简单；</li>
<li>端系统功能复杂：按序传送、可靠数据传输、拥塞控制与DNS名字解析</li>
<li>因特网服务模型提供的服务保证最少，对网络层的需求最小，使得链路层技术变得更加容易。</li>
</ul>
</li>
</ul>
<p>传输层：面向连接服务在网络边缘的<strong>端系统</strong>中实现。</p>
<p>网络层：面向连接服务在<strong>端系统及网络核心的路由器</strong>中实现。</p>
<p>4、路由器的两个核心功能</p>
<ul>
<li>运行路由算法&#x2F;协议(OSPF, RIP, BGP)</li>
<li>将分组从路由器的输入链路传送到正确的输出链路。</li>
</ul>
<p>5、路由器的整体结构</p>
<p><strong>输入端口</strong>：</p>
<p>线路端接模块：将一条物理链路端接到路由器的物理层；</p>
<p>数据链路处理模块：实现路由器的数据链路层功能；</p>
<p>查找与转发模块：实现查找与转发功能，以便分组通过路由器交换结构转发到适当的输出端口；如果数据报到达输入端口的速度快于输入端口将数据报转发到交换结构的速度，就会发生<strong>排队</strong>。</p>
<p><strong>选路处理器</strong>：计算转发表，给<strong>每个输入端口存放一份转发表拷贝</strong></p>
<p><strong>分布式交换</strong>：</p>
<p>（1）内存交换：选路处理器完成输入端口与输出端口之间的交换；交换速度受总线带宽的速度限制 (每个分组穿过两次总线)</p>
<p>（2）总线交换：输入端口通过一条<strong>共享总线</strong>将分组直接传送到输出端口，不需要选路处理器的干预;交换带宽受总线速率限制</p>
<p>（3）交换矩阵交换：到达输入端口的分组沿<strong>水平总线穿行</strong>，直至与所希望的<strong>输出端口的垂直总线交叉点</strong>，若该条垂直总线<strong>空闲</strong>，则分组被传送到输出端口，否则<strong>阻塞排队</strong>。</p>
<p><strong>输出端口</strong>：	</p>
<ul>
<li>取出存放在输出端口内存中的分组，并将其传输到输出链路上；	</li>
<li>当交换结构将分组交付给<strong>输出端口的速率超过输出链路速率</strong>，就需要排队与缓存管理功能。当输出端口的缓冲区溢出时，就会出现延时和丢包。</li>
</ul>
<p>6、IP 数据报格式（IPv4）</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_09-47-01.png"></p>
<p>IP数据报分片和重组</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_09-49-53.png"></p>
<p>7、IP地址</p>
<ul>
<li><p>分配给主机或路由器接口的标识符</p>
<ul>
<li>主机&#x2F;路由器与物理链路之间的边界&#x2F;连接</li>
<li>路由器有多个接口，主机可以有多个接口</li>
</ul>
</li>
<li><p>IP地址有两种：IPV4和IPV6</p>
<ul>
<li><p>IPV4：32个二进制位长（4字节），常用<strong>点分十进制</strong>表示；将4个字节中的<strong>每一个字节分别用十进制数</strong>来表示，4个十进制数之间用 “.” 分隔。</p>
<p>例如：223.1.1.1 &#x3D; 11011111 00000001 00000001 00000001</p>
<p>根据不同的取值范围，早期将<strong>IP地址分为五类</strong>。IP地址中前5位用于标识IP地址的类别，A类地址的第一位为“0”（主机号24位），B类地址的前两位为“10”（主机号16位），C类地址的前三位为“110”（主机号8位），D类地址的前四位为“1110”，E类地址的前五位为“11110”。其中，A类、B类与C类地址为基本的IP地址。</p>
</li>
<li><p>IPV6：128个二进制位长（16字节）常用<strong>冒号分隔</strong>表示</p>
</li>
</ul>
</li>
</ul>
<p>8、IP地址结构</p>
<ul>
<li><p>IP地址</p>
<table>
<thead>
<tr>
<th>网络号</th>
<th>主机号</th>
</tr>
</thead>
</table>
<p>网络号：指明主机所在网络的编号。</p>
<p>主机号：主机在网络中的编号。</p>
</li>
<li><p>IP子网（subnet）</p>
<ul>
<li>划分子网的方法是<strong>从主机号借用若干个比特作为子网号，剩下的主机位为主机号</strong>。</li>
<li>IP地址具有相同网络号的设备接口 </li>
<li><strong>不跨越路由器</strong>（第三及以上层网络设备）可以<strong>彼此物理联通</strong>的接口</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_10-03-59.png"></p>
<p>9、特殊IP地址段</p>
<p>（1）<strong>本地回环地址</strong>： 127.0.0.1-127.255.255.254，用来识别主机本身的地址。也叫做“localhost”，一般用来测试。</p>
<p>（2）<strong>私有地址</strong>（Private address）：10.x.x.x,  172.16.x.x-172.31.x.x,  192.168.x.x ，局域网所使用的地址段。</p>
<p>（3）<strong>0.0.0.0</strong>：用来标识不清楚的网络和主机</p>
<p>（4）<strong>255.255.255.255</strong>：广播地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/tsip.png"></p>
<p>分类的ip地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_11-06-44.png"></p>
<p>10、互联网中的IP地址</p>
<ul>
<li><p><strong>同一局域网上</strong>的主机或路由器的IP地址中的<strong>网络号必须相同</strong> </p>
</li>
<li><p>交换机互连的网络仍然是一个局域网，只能有一个网络号。 </p>
</li>
<li><p>路由器总是具有两个或两个以上IP地址。 </p>
</li>
<li><p>当两个路由器直接相连时，在连线两端的接口处，可以指明IP地址也可以不指明IP地址。</p>
</li>
</ul>
<p>11、子网划分</p>
<p>分类的IP地址的弱点:</p>
<ul>
<li>lP地址空间的利用率有时很低。</li>
<li>两级lP地址不够灵活。</li>
</ul>
<p>网络号相同的IP地址属于同一个网络。而网络还可以划分为若干子网（subnet）。划分子网的方法是<strong>从主机号借用若干个比特作为子网号，剩下的主机位为主机号</strong>。在同一子网中，数据帧不跨越路由器，物理上能够相互到达。</p>
<p>为什么子网号能全0或者全1：因为CIDR编址<br>为什么主机号不能全0或者全1：因为全0代表本网络，全1代表广播分组</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_11-36-15.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_11-35-30.png"></p>
<p>12、<strong>子网掩码</strong>用来确定网络地址（网络号+子网号）和主机地址的长度。子网掩码长为32位比特，其中的1对应于IP地址中的网络号和子网号，而子网掩码中的0对应于主机号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_10-19-35.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_11-43-27.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_11-49-37.png"></p>
<p>虽然两个子网掩码得到的网络地址结果一样，但是后者的主机位更多，能容纳更多主机。</p>
<p>例：某主机的IP为180.80.77.55,子网掩码为255.255.252.0,若该主机向其所在子网发送广播分组,则目的地址为（）</p>
<p>子网掩码255.255.252.0（11111111.11111111.11111100.00000000），网络号和子网号为连续的1，那么主机位为连续的0，也就是10位，然后题目要发送广播分组，所以求的是广播地址，广播地址的主机位也是全为1，所以主机180.80.77.55所在的广播地址就是 180.80.010011（11.11111111），括号里面的是主机号，主机号全为1就是广播地址，即180.80.79.255</p>
<p>有一个C类网段193.160.80.0，要将他划分6个子网，如何指定他的子网掩码？每个子网的子网号(地址)是多少？主机号(地址)是多少？</p>
<p>要划分六个子网。则需要借主机位3位。所以呢子网掩码是255.255.255.224.所以每个子网的主机数是2^5&#x3D;32.有效的主机数是32-2.全0是网络号，全1是广播地址。<br>子网1：192.168.80.33到192.168.80.62 网络号是192.168.80.32<br>子网2：192.168.80.65到192.168.80.94网络号是192.168.80.64<br>子网3：192.168.80.97到192.168.80.1276网络号是192.168.80.96<br>子网4：192.168.80.129到192.168.80.158网络号是192.168.80.128<br>子网5：192.168.80.161到192.168.80.190 网络号是192.168.80.160<br>子网6：192.168.80.193到192.168.80.222 网络号是192.168.80.192</p>
<p>注意：<strong>对某个子网来说，主机号全0的地址不能用，它被用做表示该子网的子网号；主机号全1的也不能用，它用于本子网的广播。因此每个子网所能容纳的主机数是2^N-2，N是主机号位数</strong>。</p>
<p>13、子网地址、主机地址范围、广播地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_10-19-56.png"></p>
<p>14、无分类域间路由CIDR</p>
<ul>
<li>CIDR消除了传统的A类、B类和C类地址的概念。  </li>
<li>融合子网地址与子网掩码，方便子网划分。</li>
<li>使用斜线记法，又称为CIDR记法来区分<strong>网络前缀和主机号</strong>，即在IP地址后面加上一个斜线“&#x2F;”，斜线后面用一个数字指定网络前缀的长度。  </li>
<li>CIDR将网络前缀都相同的连续的IP地址组成“CIDR地址块”。</li>
</ul>
<p>地址格式：a.b.c.d&#x2F;x，其中x为前缀长度</p>
<table>
<thead>
<tr>
<th>网络前缀</th>
<th>主机号</th>
</tr>
</thead>
</table>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_12-46-12.png"></p>
<p>15、路由聚合（route aggregation）</p>
<p>一个CIDR地址块可以表示分类IP的多个分类地址，这种地址的聚合称为路由聚合，又称为<strong>构造超网</strong>。</p>
<p>方法：将网络前缀缩短（所有网络地址取交集）。</p>
<p>划分子网是少→多</p>
<p>构成超网是多→少</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_13-00-43.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_13-33-10.png"></p>
<p>如果R1，R2，R3，都不匹配，则选R4，转发到默认路由，再转发到另外一个路由器</p>
<p>【例】某单位从 ISP 处购买了一个 IP 地址块 113.54.70.0&#x2F;24。如果该单位有 3 个部门，第 1 个 部门 100 台计算机，第 2 个和第 3 个部门各有 60 台计算机，请你为 3 个部门划分子网，并给出 各部门的网络号、子网掩码和主机可分配的 IP 地址范围。</p>
<p>部门2和部门3可对调</p>
<table>
<thead>
<tr>
<th>部门</th>
<th>网络地址</th>
<th>子网掩码</th>
<th>最小可分配IP地址</th>
<th>最大可分配IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>113.54.70.0</td>
<td>255.255.255.128</td>
<td>113.54.70.1</td>
<td>113.54.70.126</td>
</tr>
<tr>
<td>2</td>
<td>113.54.70.128</td>
<td>255.255.255.192</td>
<td>113.54.70.129</td>
<td>113.54.70.190</td>
</tr>
<tr>
<td>3</td>
<td>113.54.70.192</td>
<td>255.255.255.192</td>
<td>113.54.70.193</td>
<td>113.54.70.254</td>
</tr>
</tbody></table>
<p>其他参考答案：</p>
<table>
<thead>
<tr>
<th>部门</th>
<th>网络地址</th>
<th>子网掩码</th>
<th>最小可分配IP地址</th>
<th>最大可分配IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>113.54.70.128</td>
<td>255.255.255.128</td>
<td>113.54.70.129</td>
<td>113.54.70.254</td>
</tr>
<tr>
<td>2</td>
<td>113.54.70.0</td>
<td>255.255.255.192</td>
<td>113.54.70.1</td>
<td>113.54.70.62</td>
</tr>
<tr>
<td>3</td>
<td>113.54.70.64</td>
<td>255.255.255.192</td>
<td>113.54.70.65</td>
<td>113.54.70.126</td>
</tr>
</tbody></table>
<p>16.动态主机配置协议（DHCP）不考</p>
<p>（1）获得IP地址，还可以获得</p>
<ul>
<li>客户的第一跳路由器的地址（网关）</li>
<li>DNS服务器的IP地址或域名</li>
<li>子网掩码</li>
</ul>
<p>（2）<strong>DHCP是应用层协议</strong></p>
<ul>
<li>请求报文封装到UDP数据报中</li>
<li>IP广播</li>
<li>链路层广播 (e.g. 以太网广播)</li>
</ul>
<p>（3）报文种类</p>
<ul>
<li>主机广播 “DHCP DISCOVER” （发现报文）</li>
<li>DHCP 服务器用 “DHCP OFFER” （提供报文）进行响应</li>
<li>主机请求IP地址: “DHCP REQUEST” （请求报文）</li>
<li>DHCP 服务器分配IP地址 “DHCP ACK&#x2F;NACK” （确认报文）</li>
<li>DHCP 终止租用期”DHCP RELEASE”（终止报文）</li>
</ul>
<p>（4） DHCP 协议的工作过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_14-16-49.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_14-17-28.png"></p>
<p>17、如何实现私有网络访问互联网？（NAT）</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_11-25-03.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_14-17-40.png"></p>
<p>18、ICMP (Internet Control Message Protocol，因特网控制报文协议)</p>
<p>用于主机路由器之间彼此交流网络层信息</p>
<p>差错报告（5种）</p>
<ul>
<li>目的（主机、网络、协议、端口）不可达</li>
<li>源抑制(Source Quench) :路由器缓存已满</li>
<li>超时&#x2F;超期</li>
<li>参数问题</li>
<li>重定向:路由器收到数据报，不应该由自己转发，则向源主机发送重定向报文，重新定向到其他网关</li>
</ul>
<p>网络探询(2种）</p>
<ul>
<li>回声(Echo)请求与应答报文(Reply)：ping </li>
<li>时间戳请求与应答报文：tracerouter</li>
</ul>
<p>19、IPV6</p>
<ul>
<li>初始动机：32-bit IPv4地址空间即将用尽 </li>
<li>其他动机：快速处理&#x2F;转发数据报；支持QoS（服务质量）</li>
<li>IPv6 数据报格式 ：固定长度的 40 字节基本首部 ；不允许分片</li>
</ul>
<p>20、路由基本概念</p>
<p><strong>默认路由器</strong>：与主机直接相连的路由器，又叫<strong>第一跳路由器</strong>。每当主机发送一个分组时，都先传送给它的默认路由器。		</p>
<ul>
<li>源路由器：源主机的默认路由器。		</li>
<li>目的路由器：目的主机的默认路由器。		</li>
<li>从源主机到目的主机的选路归结为<strong>从源路由器到目的路由器的选路</strong>。</li>
</ul>
<p>	</p>
<p><strong>路由算法</strong>：是确定一个分组从源路由器到目的路由器所经路径的算法</p>
<p>路由算法的关键：在给定的一组路由器以及连接路由器的链路中，找到一条从源路由器到目的路由器的“好”路径（具有“最低费用”的路径）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_14-47-15.png"></p>
<p>21、链路状态选路算法LS和距离向量路由算法DV（必考）</p>
<p><strong>链路状态选路算法</strong></p>
<p>术语定义</p>
<ul>
<li><p>c(x,y)：表示从节点x到y的链路费用;                  </p>
<p>&#x3D; ∞ 如果不是直接邻居</p>
</li>
<li><p>D(v)：表示从源节点到目的节点v的当前路径的费用；</p>
</li>
<li><p>p(v)：表示从源节点到目的节点v的路径上的前驱节点；</p>
</li>
<li><p>N’：表示已经找到最低费用路径的节点集合。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  初始化: </span><br><span class="line">2    N&#x27; = &#123;u&#125; </span><br><span class="line">3    对所有节点v </span><br><span class="line">4      if v 临近 u </span><br><span class="line">5          then D(v) = c(u,v) </span><br><span class="line">6      else D(v) = ∞ </span><br><span class="line">7</span><br><span class="line">8   Loop </span><br><span class="line">9     找出w不在N’中使得D(w)最小 </span><br><span class="line">10    将w加入N&#x27; </span><br><span class="line">11    对于所有v临近w并不在N’中，更新D(v): </span><br><span class="line">12       D(v) = min( D(v), D(w) + c(w,v) ) </span><br><span class="line">13    /* 到v的新费用或是到v的老费用或到w加上从w到v的已知最短路费用*/ </span><br><span class="line">15  until 所有节点在 N’中 </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_15-00-59.png"></p>
<table>
<thead>
<tr>
<th>Step</th>
<th>N’</th>
<th>D(v),p(v)</th>
<th>D(w),p(w)</th>
<th>D(x),p(x)</th>
<th>D(y),p(y)</th>
<th>D(z),p(z)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>u</td>
<td>2，u</td>
<td>5，u</td>
<td>1，u</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td>1</td>
<td>ux</td>
<td>2，u</td>
<td>4，x</td>
<td></td>
<td>2，x</td>
<td>∞</td>
</tr>
<tr>
<td>2</td>
<td>uxy</td>
<td>2，u</td>
<td>3，y</td>
<td></td>
<td></td>
<td>4，y</td>
</tr>
<tr>
<td>3</td>
<td>uxyv</td>
<td></td>
<td>3，y</td>
<td></td>
<td></td>
<td>4，y</td>
</tr>
<tr>
<td>4</td>
<td>uxyvw</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>4，y</td>
</tr>
<tr>
<td>5</td>
<td>uxyvwz</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>（有两个最小就随便选一个，此答案选的y）</p>
<p>根据<strong>目的节点找出顺序和其费用以及前驱节点</strong>，可以画出源节点u到所有目的节点的最低费用路径树。根据得到的所有目的节点的完整路径，或<strong>最低费用路径树</strong>，可以生成源节点的<strong>转发表</strong>。</p>
<p><strong>转发表</strong>：存放从源节点到每个目的节点的最低费用路径上的下一跳节点。即指出对于发往某个目的节点的分组，从该节点发出后的<strong>下一个节点</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_15-23-31.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_15-27-37.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_15-28-01.png"></p>
<p><strong>距离向量路由算法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_16-03-26.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_16-02-08.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_16-03-08.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_17-00-47.png"></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_16-40-46.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_16-38-56.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_16-40-34.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_16-39-26.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_16-40-07.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_16-42-57.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_16-43-04.png"></p>
<p>22、自治系统间(Inter-AS)路由</p>
<p>(1)转发表根据AS内和AS间选路算法而配置</p>
<ul>
<li>AS域内的选路项用于目的端在域内的选路。</li>
<li>AS域内和AS域间的选路项用于目的端在域外的选路</li>
</ul>
<p>(2)在多个自治系统中选择	</p>
<ul>
<li>热土豆选路: 把分组送到两个路由器中最近的一个</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_17-39-22.png"></p>
<p>23、 OSPF: 开放式最短路径优先</p>
<ul>
<li>用链路状态算法 <ul>
<li>分发LS 分组（ OSPF通告）</li>
<li>每个路由器构造完整的网络（AS）拓扑图</li>
<li>路由器本地运行 Dijkstra算法</li>
</ul>
</li>
<li>每个路由器都广播OSPF通告，OSPF通告里为每个邻居路由器设一个表项（记录每个邻居的链路特征和费用）。</li>
<li>通告会散布到整个自治系统 (通过洪泛法) <ul>
<li>OSPF报文直接封装到IP数据报中 (不是 TCP 或 UDP）</li>
</ul>
</li>
<li>优点：<ul>
<li>安全: 所有OSPF 消息需要认证 (防止恶意入侵) </li>
<li>允许多个相同开销的路径 (在 RIP中只有一条路径)</li>
<li>对于每个链路, 有多个消费尺度用于不同的服务类型TOS (例如在尽力转发时卫星链路代价设置为 “低” ，而对实时应用设置为高)</li>
<li>单播和多播综合支持: 多播 OSPF (MOSPF) 使用和 OSPF同样的链路数据库</li>
<li>OSPF支持对大规模AS分层</li>
</ul>
</li>
</ul>
<p>24、 Internet 域间选路: BGP</p>
<ul>
<li>BGP (Border Gateway Protocol)：事实上的标准域间路由协议，将Internet “粘合”为一个整体的关键</li>
<li>BGP 为每个 AS 提供了一种手段:</li>
<li>eBGP：从相邻AS获取子网可达信息</li>
<li>iBGP：向该AS内部的所有路由器传播这些子网的可达信息</li>
<li>基于该可达信息和AS策略，决定到达子网的“好”路由</li>
<li>允许一个子网向Internet的其他部分通告它的存在 “I am here”</li>
<li>路径属性<ul>
<li>AS-PATH: 包含了前缀的通告已经通告过的那些AS,如 AS 67 AS 17 </li>
<li>NEXT-HOP: 指出到达下一个AS的具体AS间边界路由器（可能存在多条从当前AS到达下一个AS的链路）</li>
</ul>
</li>
<li>BGP 路由选择<ul>
<li>当网关路由器接收到路由通告时，使用输入策略来决定接收&#x2F;舍弃该通告。e.g., 从不将流量路由到AS x </li>
<li>路由器可能知道到相同前缀的多条路由，路由器基于以下准则选择（排除规则，应用排除规则直到有一条留下）<ul>
<li>本地偏好值属性: 具有最高偏好值的路由被选择</li>
<li>最短AS-PATH的路由</li>
<li>最靠近 NEXT-HOP路由器的路由 : 热土豆路由</li>
<li>其他标准</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_17-44-53.png"></p>
<p>25、SDN的流表(flow table)、控制平面&#x2F;数据平面、openflow</p>
<p>SDN的核心思想是建立一个通用转发体系  </p>
<ul>
<li>每个交换设备包含一个流表(flow table). 流表由一个逻辑上中心化的控制器（远程控制器）来计算和分发</li>
<li>首部字段值：入分组与之匹配，匹配不上分组被丢弃或发往远程控制器。首部字段包括链路层、网络层、传输层首部字段。</li>
<li>计数器：分组与流表项匹配时更新。包含已经匹配分组数量，以及上次更新以来的时间</li>
<li>动作：分组匹配表项时的动作（转发、丢弃、复制、分发到多个端口）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_17-45-11.png"></p>
<p>SDN体系结构及特征</p>
<p><em>特征</em></p>
<ul>
<li>基于流的转发：基于<strong>首部字段值</strong>进行转发</li>
<li>数据平面与控制平面分离：数据平面网络交换机组成，控制平面由服务器和管理流表软件构成。</li>
<li>网络控制功能：位于数据平面交换机外部，包括SDN控制器和若干网络控制程序。</li>
<li>可编程的网络：调用API定义和控制网络设备的数据平面。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_17-45-36.png"></p>
<p>SDN控制器的组件</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_17-45-49.png"></p>
<hr>
<p>在英特网中，IP数据报的传输需要经由源主机和中途路由器到达目的主机，下面说法正确的是（  D  ）。</p>
<p>A、源主机和中途路由器都知道IP数据报到达目的主机需要经过的完整路径。</p>
<p>B、源主机知道IP数据报到达目的主机需要经过的完整路径，而中途路由器不知道。</p>
<p>C、源主机不知道IP数据报到达目的主机需要经过的完整路径，而中途路由器知道。</p>
<p>D、源主机和中途路由器都不知道IP数据报到达目的主机需要经过的完整路径。</p>
<p>对于 IP 网络，是采用数据报方式，因此对于源主机和中途路由器都不会知道数据报经过的完整路径，<strong>路由器仅知道到达目的地址的下一跳地址</strong>，主机仅知道到达本地网络的路径，到达其他网络的数据报均转发到网关的地址，也就是路由器，因此源主机和中途路由器都不知道 IP 数据报到达目的主机需要经过的完整路径。</p>
<p>采用（     C    ）的交换结构可以并行发送多个分组。</p>
<p>A、经内存交换        B、经总线交换     C、经互联网络交换    D、以上都可以 </p>
<p><strong>经内存交换</strong>. 分组从输入端口处被复制到处理器内存中. 处理器从其首部中提取目的地址, 在转发表中找出适当的输出端口, 并把该分组复制到该输出端口的缓存中.</p>
<p><strong>经总线交换</strong>. 分组从输入端口经过总线发送到所有输出端口, 只有与该分组匹配的输出端口会把分组留下来.</p>
<p><strong>经互联网络交换</strong>. 交换机由2N条总线组成互联网络, 连接N个输入口和N个输出口. 通过控制网络中的交点使分组到达对应的输出端口. 这种纵横式网络能够并行发送多个分组.</p>
<p>在一个高性能的路由器中，转发表的影子副本保存在（    A   ）中，以避免集中式处理的瓶颈。</p>
<p>A、输入端口     B、输出端口     C、交换结构     D、以上都有</p>
<p>假设一个路由器有N个有同样线路速度的输入端口和N个有同样线路速度的输出端口，并且，输出端口的线路速度至少是输入端口的线路速度的N倍。同时假定交换结构的速率至少是输入的线路速度的N倍，则（  A     ）。</p>
<p>A、在路由器中不会有排队时延        </p>
<p> B、排队会发生在交换结构</p>
<p>C、排队会发生在输入端口                </p>
<p>D、排队会发生在输出端口</p>
<p>提示：考虑最坏情况：N个输入端口的分组通过交换结构被传到同一个输出端口上，输出端口同样不会发生排队。</p>
<p>路由器中发现TTL值为0的分组，将进行的处理是（ D   ）。</p>
<p>A、返回发送方   B、继续转发   C、本地提交  D、丢弃 </p>
<p><strong>TTL:(Time To Live)生存时间;指定数据包被路由器丢弃之前允许通过的网段数量</strong>。TTL是由发送主机设置的,以防止数据包不断在IP互联网络上永不终止地循环。转发IP数据包时,要求路由器至少将TTL减小1。当路由器发现TTL值为0的分组时则丢弃该分组。</p>
<p>假定主机A向主机B发送一个封装在IP数据报中的TCP报文段，当主机B接收到该数据报后，它的网络层将通过（   D  ）字段的信息，知道它应该将封装在该IP数据报中的报文段递交给运算层的TCP协议，而不是UDP协议的。</p>
<p>A、端口号    B、服务类型    C、区分服务     D、上层协议</p>
<p>IP协议的首部中有上层协议字段。</p>
<p>IP数据报中的检验和字段检验的范围是（ B    ）</p>
<p>A、整个IP数据报        </p>
<p>B、仅检查数据报首部   </p>
<p>C、仅检查数据部分     </p>
<p>D、根据网络情况的不同而不同</p>
<p>IP数据报中的检验和字段只检查IP数据报的首部，不包括数据部分。在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置为0，用反码算术运算把所有16位字相加，将得到的和的反码写入检验和字段。</p>
<p>一个UDP数据报的数据部分长度为8192字节，那么通过MTU为1500字节的链路来传输该UDP数据报时，最后一个分片的数据长度是（ C    ）。</p>
<p>A、1500   B、1480   C、800  D、600</p>
<p>UDP头部长为8字节，因此该UDP数据报总长度为8200字节，以太网帧的最大数据域为1500，再减去20的IP头部，得到每个IP分片的最大数据域长度应该是1480，则最后一个数据分片的长度应该是(8200-5×1480&#x3D;)800字节。</p>
<p>假定一个应用程序每秒中产生160字节的数据块，每个数据块封装入一个TCP报文段，然后再封装入IP数据报中。每个数据报中应用层数据的比例是（   D   ）？   </p>
<p>A.20%     B.40%   C. 60%    D.80%</p>
<p>一个TCP的头部长度是20字节,一个IP头部的长度是20字节,再加上160字节的数据,一个IP数据报的总长度为200字节,其中应用层数据占80%。</p>
<p>下列地址中，属于单播地址的是（ B    ）</p>
<p>A、10.3.2.255&#x2F;24          </p>
<p>B.172.31.129.255&#x2F;18</p>
<p>C、192.168.24.59&#x2F;30     </p>
<p>D、224.100.57.211 </p>
<p>解析：选项A“10.3.2.232&#x2F;24”所表示的子网掩码是(11111111 11111111 11111111 00000000)，其表示主机部分的二进制数形式是11111111，由此可知10.3.2.255&#x2F;24是子网10.3.2.0的一个广播地址。 选项B“172.31.129.255&#x2F;18”，其中172.31.129.255的二进制数形式是(10100100 00011111 1000000 111111111)，由于子网掩码是(11111111 11111111 11000000 00000000)，其表示主机部分的二进制数形式是000001 11111111，由此可知172.31.129.255&#x2F;18是一个单播IP地址。 选项C“192.168.24.59&#x2F;30”，其中192.168.24.59的二进制数形式是(11000000 10101000 00011000 00111011)，由于子网掩码是(11111111 11111111 11111111 11111100)，其表示主机部分的二进制数形式是11，由此可知192.168.24.59&#x2F;30属于192.168.24.56子网的广播地址。 选项D“224.100.57.211”是一个组播地址(D类IP地址，前四位1110)。</p>
<p>ISP分配给某公司的地址块为199.34.76.64&#x2F;28，则该公司可用于分配的地址数是（ B ）A、8    B、14  C、16   D、30</p>
<p>设有4台主机①、②、③和④，都处在一个物理网络中，它们的IP地址分别为：192.155.28.112、192.155.28.120、192.155.28.135和192.155.28.202，子网掩码都是255.255.255.224,这4台主机中可以直接通信的主机有（  ）。  </p>
<p> A、①②③④    B、①③④  C、②③④   D、①② </p>
<p>子网掩码255.255.255.224的二进制表示为11111111.11111111.11111111.11100000，这意味着网络前缀长度为27位。因此，可以计算出每台主机所在的子网：</p>
<ul>
<li>192.155.28.112的子网地址为192.155.28.96</li>
<li>192.155.28.120的子网地址为192.155.28.96</li>
<li>192.155.28.135的子网地址为192.155.28.128</li>
<li>192.155.28.202的子网地址为192.155.28.192</li>
</ul>
<p>根据以上计算结果，可以得出主机①和主机②在同一个子网中，它们之间可以直接通信。而主机③和主机④分别位于不同的子网中，它们之间不能直接通信。因此，正确答案是D、①②。</p>
<p>某接口IP地址为172.16.7.131&#x2F;26，该IP地址所在网络的广播地址是（  C  ）</p>
<p>A、172.16.7.255    B、172.16.7.129  C、172.16.7.191   D、172.16.7.252</p>
<p>对分片后的数据报进行重组的是（A ）。</p>
<p>A.目的端系统  B.中间主机 C.核心路由器  D.下一跳路由器</p>
<p>数据报被分片后，每个分片都将被尽力而为地独立传输到目的地，期间可能会经过不同的路径，因此，分片的重组工作只能在目的端系统进行。</p>
<p>路由表错误和软件故障都可能使得网络中形成数据传输环路，解决该问题的方法是（C）A.报文分片   B.增加校验和  C.设定寿命   D.增加选项字段</p>
<p>解决该问题的方法是设定寿命（TTL）字段。TTL是IP数据包中的一个字段，它指定了数据包可以经过的最大路由器数。当数据包到达一个路由器时，该路由器会将TTL减1。如果TTL减为0，则该数据包被丢弃。这样可以确保数据包不会在网络中无限循环。</p>
<p>路由器中计算路由信息的是（D ）</p>
<p>A.输入队列       B.输出队列     C.交换结构    D.路由选择处理机</p>
<p>路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。</p>
<p>在虚电路网络中，分组交换涉及虚电路的建立，每个分组交换知道经过它的VC号。（√）</p>
<blockquote>
<p><strong>一条虚电路(VC)的组成如下:</strong></p>
<p><strong>①源和目的主机之间的路径(即一系列链路和路由器);</strong></p>
<p><strong>②VC 号，沿着该路径的每段链路一个号码;</strong></p>
<p><strong>③沿着该路径的每台路由器中的转发表表项。</strong></p>
<p>属于一条虚电路的分组将在它的首部携带一个 VC 号。因为一条虚电路在每条链路上可能具有不同的VC号，所以每台中间路由器必须用一个新的VC号替代每个传输分组的VC号。 这个新的 VC 号从转发表中获得。</p>
</blockquote>
<p>在数据报网络中，每个分组携带有目的地主机的地址。（√）</p>
<p>在同一个IP网络中，每台主机的IP地址的网络部分都是相同的。（√）</p>
<p>关于IP提供的服务，下列说法中正确的是（C）</p>
<p>A.IP提供可靠的数据报传送服务，因此数据报传送可以受到保障</p>
<p>B.IP提供不可靠的数据报传送服务，因此它可以随意丢弃数据报</p>
<p>C.IP提供不可靠的数据报传送服务，因此数据报传送不能受到保障</p>
<p>D.IP提供可靠的数据传送服务，因此它不能随意丢弃报文</p>
<p>‎在以下几个IP地址中，（C）是一个内部IP地址‏</p>
<p>A.202.13.0.1</p>
<p>B.202.113.0.1</p>
<p>C.192.168.0.1</p>
<p>D.1.1.0.1</p>
<p>把网络192.134.11.0划分为多个子网（子网掩码是255.255.255.128），则全部的子网中可用的主机地址总数是（B）</p>
<p>A.128	B.252	C.12	D.254</p>
<p>c类地址，申请了一位来划分子网，每个子网2^7-2&#x3D;126个主机地址</p>
<p>为了解决IP地址耗尽的问题，可以采用以下的一些措施，其中治本的是（D）</p>
<p>A.采用无类别编址CIDR</p>
<p>B.采用网络地址转换NAT</p>
<p>C.划分子网</p>
<p>D.采用IPv6</p>
<p>下列属于域间路由协议的是（）</p>
<p>‍A.RIP	B.BGP	C.IP	D.OSPF</p>
<p>RIP和OSPF是域内路由选择协议，而BGP是域间路由选择协议，其着眼点不在于发现和计算路由，而在于控制路由的传播和选择最佳路由。</p>
<p>IPv6不具有的特性是（D）</p>
<p>‎A.具有优先级标识</p>
<p>B.固定的首部长度</p>
<p>C.更大的IP地址空间</p>
<p>D.可以进行分片</p>
<p>考虑如图1示的网络。</p>
<p>‌a.假定网络是一个数据报网络。显示路由器A中的转发表，其中所有指向主机H3的流量通过接口3转发。</p>
<p>‌b.假定网络是一个数据报网络。你能写出路由器A中的转发表吗?其中所有从H1指向主机H3的流量通过接口3转发，而所有从H2指向主机H3的流量通过接口4转发。(提示：这是一个技巧问题。)</p>
<p>‌c.现在假定网络是虚电路网络，在H1和H3之间有一个进行中的呼叫，H2和H3之间有另一个进行中的呼叫。写出路由器A中的转发表，其中所有从H1指向主机H3的流量通过接口3转发，而所有H2指向主机H3的流量通过接口4转发。</p>
<p>‌d.假设场景与(c)中相同，写出在结点B、C和D中的转发表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_19-51-24.png"></p>
<p>a）通过接口3转发发送到主机H3的数据，路由器A的转发表为: </p>
<table>
<thead>
<tr>
<th>目的地址</th>
<th>输出接口</th>
</tr>
</thead>
<tbody><tr>
<td>H3</td>
<td>3</td>
</tr>
</tbody></table>
<p> b) 在数据报网络中，路由器的转发表是根据目的地址来转发分组的，而不是根据源地址。因此，无法仅根据源地址来确定分组的转发接口。所以，无法写出路由器A中的转发表，使得所有从H1指向主机H3的流量通过接口3转发，而所有从H2指向主机H3的流量通过接口4转发。</p>
<p>c) 一种可能的配置为: </p>
<table>
<thead>
<tr>
<th>接入端口</th>
<th>进入的VC号</th>
<th>输出端口</th>
<th>输出VC号</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>12</td>
<td>3</td>
<td>22</td>
</tr>
<tr>
<td>2</td>
<td>63</td>
<td>4</td>
<td>18</td>
</tr>
</tbody></table>
<p>d)一种可能的配置为:</p>
<p>路由器B:</p>
<table>
<thead>
<tr>
<th>接入端口</th>
<th>进入的VC号</th>
<th>输出端口</th>
<th>输出VC号</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>22</td>
<td>2</td>
<td>24</td>
</tr>
</tbody></table>
<p>路由器C:</p>
<table>
<thead>
<tr>
<th>接入端口</th>
<th>进入的VC号</th>
<th>输出端口</th>
<th>输出VC号</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>18</td>
<td>2</td>
<td>50</td>
</tr>
</tbody></table>
<p>路由器D:</p>
<table>
<thead>
<tr>
<th>接入端口</th>
<th>进入的VC号</th>
<th>输出端口</th>
<th>输出VC号</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>24</td>
<td>3</td>
<td>70</td>
</tr>
<tr>
<td>2</td>
<td>50</td>
<td>3</td>
<td>76</td>
</tr>
</tbody></table>
<p>考虑使用8比特主机地址的某数据报网络。假定一台路由器使用最长前缀匹配并具有如下表所示的转发表，对这4个接口中的每个，给出响应的目的主机地址的范围和在该范围中的地址数量。</p>
<table>
<thead>
<tr>
<th>Prefix Match</th>
<th>Interface</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>0</td>
</tr>
<tr>
<td>010</td>
<td>1</td>
</tr>
<tr>
<td>011</td>
<td>2</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>目的主机地址范围</th>
<th>链路接口</th>
</tr>
</thead>
<tbody><tr>
<td>00000000-00111111</td>
<td>0</td>
</tr>
<tr>
<td>01000000-01011111</td>
<td>1</td>
</tr>
<tr>
<td>01100000-01111111</td>
<td>2</td>
</tr>
<tr>
<td>10000000-10111111</td>
<td>2</td>
</tr>
<tr>
<td>11000000-11111111</td>
<td>3</td>
</tr>
</tbody></table>
<p>对于接口0的地址数量为: 2^6&#x3D;64。</p>
<p>对于接口1的地址数量为: 2^5&#x3D;32。</p>
<p>对于接口2的地址数量为: 2^6+2^5&#x3D;64+32&#x3D;96</p>
<p>对于接口3的地址数量为: 2^5&#x3D;32。</p>
<p>基于Dijkstra算法计算路由器A的算法表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-23_20-11-51.png"></p>
<table>
<thead>
<tr>
<th>Step</th>
<th>N’</th>
<th>D(B),p(B)</th>
<th>D(C),p(C)</th>
<th>D(D),p(D)</th>
<th>D(E),p(E)</th>
<th>D(F),p(F)</th>
<th>D(G),p(G)</th>
<th>D(H),p(H)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>4,A</td>
<td>∞</td>
<td>∞</td>
<td>1,A</td>
<td>3,A</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td>1</td>
<td>AE</td>
<td>4,A</td>
<td>∞</td>
<td>∞</td>
<td></td>
<td>3,A</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td>2</td>
<td>AEF</td>
<td>4,A</td>
<td>∞</td>
<td>8,F</td>
<td></td>
<td></td>
<td>6,F</td>
<td>∞</td>
</tr>
<tr>
<td>3</td>
<td>AEFB</td>
<td></td>
<td>7,B</td>
<td>8,F</td>
<td></td>
<td></td>
<td>5,B</td>
<td>∞</td>
</tr>
<tr>
<td>4</td>
<td>AEFBG</td>
<td></td>
<td>6,G</td>
<td>8,F</td>
<td></td>
<td></td>
<td></td>
<td>7,G</td>
</tr>
<tr>
<td>5</td>
<td>AEFBGC</td>
<td></td>
<td></td>
<td>8,F</td>
<td></td>
<td></td>
<td></td>
<td>7,G</td>
</tr>
<tr>
<td>6</td>
<td>AEFBGCH</td>
<td></td>
<td></td>
<td>8,F</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>AEFBGCHD</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>NAT违背了计算机网络分层模型的思想, 伪首部说明TCP、IP协议没有严格分层。 （  √     ）</p>
</blockquote>
<p>NAT（网络地址转换）是一种在IP层对IP地址进行转换的技术，它允许私有网络中的主机使用私有IP地址与公网上的主机通信。然而，NAT需要在IP层对IP地址进行转换，同时还需要在传输层对传输层协议（如TCP和UDP）的端口号进行转换。这意味着NAT需要同时处理IP层和传输层的信息，从而违背了计算机网络分层模型的思想。</p>
<p>伪首部是TCP和UDP校验和计算中使用的一个数据结构。它包含了一些来自IP层的信息，如源IP地址和目的IP地址。这意味着TCP和UDP协议需要访问IP层的信息来计算校验和，说明TCP和IP协议之间没有严格分层。</p>
<blockquote>
<p>ICMP 协议不具备的功能是（D ）</p>
<p>A.向源主机发送网络不可达报文   </p>
<p>B.向路由器发送回送请求报文</p>
<p>C.进行时间戳请求   </p>
<p>D.获取主机 IP 地址</p>
</blockquote>
<p>ICMP 协议中包括差错报文和询问报文等多种报文，ABC 三项，描述的是 ICMP 报文。D 项，中获取主机 IP 地址是采用DHCP 协议。</p>
<blockquote>
<p>ICMP和DHCP 在 TCP／IP 协议族中属于（ ）协议。</p>
<p>A.网络层、应用层   B.网络层、网络层  C、网络层、传输层   D、传输层、网络层</p>
</blockquote>
<p>ICMP是一种网络层协议，它用于在IP主机和路由器之间传递控制消息，以帮助诊断网络中的问题。例如，当路由器无法将分组转发到目的地时，它可以使用ICMP向源主机发送“目的地不可达”消息。</p>
<p>DHCP是一种应用层协议，它用于动态分配IP地址和其他网络配置信息。当计算机连接到网络时，它可以使用DHCP从DHCP服务器获取一个IP地址和其他相关信息，如子网掩码、默认网关和DNS服务器地址。</p>
<blockquote>
<p>ICMP协议是（C）：</p>
<p>A、运行于TCP之上  B、运行于UDP之上  C、直接运行于IP之上  D、以上都不正确</p>
</blockquote>
<blockquote>
<p>假定一个IPV6的路由器希望发送一个数据报到另一个IPV6路由器，但他们之间的连接是由一些IPV4的路由器构成。如果这两台路由器之间使用隧道技术，则（B）</p>
<p>A、发送IPV6的路由器会有一个或多个IPV6分片，每个分片都不会大于IPV4的最大数据报大小</p>
<p>B、发送IPV6的路由器创建一个IPV6的数据报，并把它放在一个IPV4数据报的数据字段中</p>
<p>C、发送IPV6的路由器创建一个IPV4的数据报，并把它放在一个IPV6数据报的数据字段中</p>
<p>D、以上答案都不正确</p>
</blockquote>
<p>当两个IPv6路由器之间的连接由一些IPv4路由器构成时，可以使用隧道技术来传输IPv6数据报。在这种情况下，发送IPv6的路由器会创建一个IPv6数据报，并将其封装在一个IPv4数据报的数据字段中。这样，IPv4路由器就可以将封装后的数据报作为普通的IPv4数据报进行转发。当封装后的数据报到达目的IPv6路由器时，目的路由器会将IPv6数据报从IPv4数据报中解封装，并进行处理。</p>
<blockquote>
<p>假定你办公室的计算机已经配置了IP地址，但现在你要将你的电脑移动到走廊尽头的另一个办公室。如果移动后，你的计算机仍连接到同样的IP网络，那么你将不需要重新配置IP地址。(√)</p>
</blockquote>
<blockquote>
<p>内部网关协议包括：（ D）。</p>
<p>A．OSPF 和 IGP    B．OSPF 和 EGP  C．RIP 和 BGP  D．OSPF 和 RIP</p>
</blockquote>
<p>内部网关协议（Interior Gateway Protocol，IGP）是一类用于在自治系统内部路由信息交换的协议。常见的内部网关协议包括OSPF（开放最短路径优先）和RIP（路由信息协议）。与之相对应的是外部网关协议（Exterior Gateway Protocol，EGP），它用于在自治系统之间交换路由信息，常见的外部网关协议包括BGP（边界网关协议）。</p>
<blockquote>
<p> RIP 协议和 OSPF 协议分别使用（A ）协议进行传输。</p>
<p>A．UDP 和 IP    B．TCP 和 UDP   C．TCP 和 IP   D．都是用 IP</p>
</blockquote>
<p>RIP协议使用UDP（用户数据报协议）进行传输，它将路由信息封装在UDP数据报中，并通过IP（网际协议）进行传输。OSPF协议则直接使用IP协议进行传输，它将路由信息封装在IP数据报中进行传输。</p>
<blockquote>
<p>关于BGP，说法不正确的是（B） </p>
<p>A．BGP是一种路径矢量协议。 </p>
<p>B．BGP通过UDP发布路由信息 </p>
<p>C．BGP支持路由汇聚功能        </p>
<p>D．BGP能够检测路由寻环 </p>
</blockquote>
<p>BGP并不通过UDP发布路由信息，而是使用TCP（传输控制协议）进行传输。BGP将路由信息封装在TCP段中进行传输。</p>
<blockquote>
<p> 当BGP 路由器从eBGP 邻居收到一条新路由时，下列说法正确的是（C ） </p>
<p>A. 立即发送给BGP 邻居 </p>
<p>B. 查看路由表中有无该路由的记录，如果没有，则向BGP 邻居发送该路由 </p>
<p>C. 与保存的已发送的路由信息比较，如果未发送过，则向BGP 邻居发送 </p>
<p>D. 与保存的已发送的路由信息比较，如果已发送过，则不发送</p>
</blockquote>
<p>当BGP路由器从eBGP邻居收到一条新路由时，它会将该路由与保存的已发送的路由信息进行比较。如果该路由未发送过，则BGP路由器会向其BGP邻居发送该路由。这样，BGP路由器就能够避免重复发送相同的路由信息。</p>
<blockquote>
<p>BGP协议是一种基于链路状态的路由协议，因此它能够避免路由环路。( ×)</p>
</blockquote>
<p>BGP并不是一种基于链路状态的路由协议，而是一种路径矢量协议。在路径矢量协议中，每个路由器维护一个包含整个网络拓扑信息的路由表，并根据该信息计算到达目的地的最佳路径。尽管BGP能够避免路由环路，但这并不是因为它是一种基于链路状态的路由协议。</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>电大软件测试～第三次作业</title>
    <url>/2023/06/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/test3/</url>
    <content><![CDATA[<h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>采用JUnit软件测试框架进行测试程序编程，实现对下面java程序进行单元测试，找出其中缺陷。然后修改缺陷，直到通过单元测试，给出测试程序脚本和运行结果界面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getMax</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get_max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= y) </span><br><span class="line">		max = x;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		max = y;</span><br><span class="line">	<span class="keyword">if</span> (z &gt;= x)</span><br><span class="line">		max = z;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<p>测试程序脚本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> junit.framework.TestCase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getMaxTest</span> <span class="keyword">extends</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       getMax Max=<span class="keyword">new</span> <span class="title class_">getMax</span>();</span><br><span class="line">       <span class="type">int</span> max= Max.get_max(<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>);</span><br><span class="line">       Assert.assertEquals(<span class="number">9</span>,max);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Before</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下是运行结果，发现代码有缺陷：z如果比x大，但比y小，程序会输出z，而实际情况是y最大。</p>
<p><a href="https://imgse.com/i/p9zYRRP"><img src="https://s1.ax1x.com/2023/06/01/p9zYRRP.png" alt="p9zYRRP.png" border="0" /></a></p>
<p>修改缺陷，以下是修改后的源程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getMax</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get_max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= y) </span><br><span class="line">		max = x;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		max = y;</span><br><span class="line">	<span class="keyword">if</span> (z &gt;= max)</span><br><span class="line">		max = z;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>其实就是将其中一个x改成max</strong></em></p>
<p>以下是单元测试通过的界面：</p>
<p><a href="https://imgse.com/i/p9zYoZQ"><img src="https://s1.ax1x.com/2023/06/01/p9zYoZQ.png" alt="p9zYoZQ.png" border="0" /></a></p>
<p>缺陷修改成功。</p>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>采用Postman接口测试软件对百度百科<a href="https://baike.baidu.com/">https://baike.baidu.com/</a>搜索引擎进行接口测试。如对词条“软件工程”返回页面内容进行测试验证，给出请求参数设置、Tests脚本、Body响应结果、Test Results结果说明及运行界面。</p>
<hr>
<p>以下是笔者的分析过程：</p>
<p>​	在百度百科页面搜索软件工程，得到的网址如下：</p>
<p><a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/25279?fromModule=lemma_search-box">https://baike.baidu.com/item/软件工程/25279?fromModule=lemma_search-box</a></p>
<p>如果是常规的get请求（大多数项目开发者会这样设置)，在url里面应该有<u>?word&#x3D;软件工程</u>的字符串（不一定是word这个单词，举这个例子表示形如这个url），但是该链接并不如此。</p>
<p>​	于是猜测是post请求，F12打开开发者工具对输入框进行分析，发现它在form表单里，初步断定是post请求，但是这个表单不是向当前网址提交的，表单的action属性是&#x2F;seach&#x2F;word，所以请求的url应该是其对应的绝对路径（还得拐个弯🥺），为<a href="https://baike.baidu.com/search/word">https://baike.baidu.com/search/word</a></p>
<p><a href="https://imgse.com/i/p9zUnPA"><img src="https://s1.ax1x.com/2023/06/01/p9zUnPA.png" alt="p9zUnPA.png" border="0" /></a></p>
<p><a href="https://imgse.com/i/p9zalWR"><img src="https://s1.ax1x.com/2023/06/01/p9zalWR.png" alt="p9zalWR.png" border="0"></a></p>
<p>​	还要注意到表单的method是GET方法，于是我大胆的猜测get方法也可以，经过postman测试，用get方法向<a href="https://baike.baidu.com/search">https://baike.baidu.com/search</a>也可以达到预期目标。</p>
<p><a href="https://imgse.com/i/p9za3S1"><img src="https://s1.ax1x.com/2023/06/01/p9za3S1.png" alt="p9za3S1.png" border="0"></a></p>
<hr>
<p>答：</p>
<p>请求参数设置</p>
<blockquote>
<p>URL：<a href="https://baike.baidu.com/search/word">https://baike.baidu.com/search/word</a></p>
<p>Method: post</p>
<p>Body：</p>
<p>​	键：word	值：软件工程</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>URL：<a href="https://baike.baidu.com/search">https://baike.baidu.com/search</a></p>
<p>Method：GET</p>
<p>参数：</p>
<p>​	键：word	值：软件工程</p>
</blockquote>
<p>Tests脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;Status code is 200&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">status</span>(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;Response body is not empty&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">body</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;The response contains the word &#x27;软件工程&#x27;&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">response</span>.<span class="title function_">text</span>()).<span class="property">to</span>.<span class="title function_">include</span>(<span class="string">&quot;软件工程&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Body响应结果</p>
<p>把你操作界面的body复制下来就可以啦~内容有很多（毕竟是百度的程序员😎）</p>
<p>Test Results结果</p>
<p><a href="https://imgse.com/i/p9za5pn"><img src="https://s1.ax1x.com/2023/06/01/p9za5pn.png" alt="p9za5pn.png" border="0"></a></p>
<blockquote>
<p>可以看到Status code is 200，Response body is not empty，The response contains the word ‘软件工程’，三次测试全部通过。</p>
</blockquote>
<p>运行界面</p>
<p><a href="https://imgse.com/i/p9zaIlq"><img src="https://s1.ax1x.com/2023/06/01/p9zaIlq.png" alt="p9zaIlq.png" border="0"></a></p>
<p>但是为了图方便感觉用get直接向<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">https://baike.baidu.com/item/软件工程</a>发请求也得行（这样子就少了很多分析啦~)</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>电大软件测试～第二次作业</title>
    <url>/2023/05/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/test2/</url>
    <content><![CDATA[<h2 id="第二次作业及参考答案"><a href="#第二次作业及参考答案" class="headerlink" title="第二次作业及参考答案"></a>第二次作业及参考答案</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p> 在一个客户信息查询界面中，输入条件有“姓名”、“身份证号”、“手机”，采用正交表方式设计该界面查询功能的测试用例。</p>
<p>答：</p>
<p>针对本测试有3个输入条件，每个输入有2种取值情况，可以选择L₄(2³)正交表，其正交表值如下表所示：</p>
<table>
<thead>
<tr>
<th>实验数\列号</th>
<th>姓名</th>
<th>身份证号</th>
<th>手机</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>测试用例：</p>
<table>
<thead>
<tr>
<th>测试用例&#x2F;查询条件</th>
<th>姓名</th>
<th>身份证号</th>
<th>手机</th>
</tr>
</thead>
<tbody><tr>
<td>测试用例1</td>
<td>填写</td>
<td>填写</td>
<td>填写</td>
</tr>
<tr>
<td>测试用例2</td>
<td>填写</td>
<td>空</td>
<td>空</td>
</tr>
<tr>
<td>测试用例3</td>
<td>空</td>
<td>填写</td>
<td>空</td>
</tr>
<tr>
<td>测试用例4</td>
<td>空</td>
<td>空</td>
<td>填写</td>
</tr>
</tbody></table>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>根据如下图所示的程序流程图，分别使用语句覆盖测试、判定覆盖测试、条件覆盖测试和路径覆盖测试进行测试用例设计。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/YaGS6fzEgLuwdKp.png"></p>
<p>答：</p>
<p><em><strong>1）语句覆盖</strong></em></p>
<p>设计测试用例，使得被测试程序中的每条可执行语句至少被执行一次。其测试用例表如下所示。</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖语句</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>X&gt;0 AND Y&gt;10;Y&#x3D;Y&#x2F;X;X&lt;-10 OR Y&lt;0</td>
</tr>
<tr>
<td>2</td>
<td>(X,Y)&#x3D;(0,-1)</td>
<td>(X,Y)&#x3D;(0,1)</td>
<td>X&gt;0 AND Y&gt;10;X&lt;-10 OR Y&lt;0;Y&#x3D;-(Y+X)</td>
</tr>
</tbody></table>
<p><em><strong>2）判定覆盖</strong></em></p>
<p>设计测试用例,使得被测试程序中的每个判断的”真”、”假”分支至少被执行一次。设X&gt;0 AND Y&gt;10为判定条件M，X&lt;-10 OR Y&lt;0为判定条件N。<br>设计的判定覆盖测试用例如下表所示。</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖判定条件</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>M为真，N为假</td>
</tr>
<tr>
<td>2</td>
<td>(X,Y)&#x3D;(0,-1)</td>
<td>(X,Y)&#x3D;(0,1)</td>
<td>M为假，N为真</td>
</tr>
</tbody></table>
<p><em><strong>3）条件覆盖</strong></em></p>
<p>设计测试用例,使得被测试程序中分支判断语句中每个条件的可能值至少被满足一次。<br>设</p>
<blockquote>
<p>条件X&gt;0:<br>取真时为T1，取假时为F1<br>条件Y&gt;10:<br>取真时为T2，取假时为F2<br>条件x&lt;-10:<br>取真时为T3，取假时为F3<br>条件Y&lt;0:<br>取真时为T4,取假时为 F4</p>
</blockquote>
<p>设计的条件覆盖测试用例如下表所示。</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖条件</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(X,Y)&#x3D;(1,-1)</td>
<td>(X,Y)&#x3D;(1,0)</td>
<td>T1，F2，F3，T4</td>
</tr>
<tr>
<td>2</td>
<td>(X,Y)&#x3D;(-11,11)</td>
<td>(X,Y)&#x3D;(-11,0)</td>
<td>F1，T2，T3，F4</td>
</tr>
</tbody></table>
<p><em><strong>4）基本路径覆盖</strong></em></p>
<p>设计测试用例,使得被测试程序中的基本路径至少被覆盖一次。依据该程序控制流图计算环路复杂度&#x3D;3（判断节点数目+1）,因此,该程序的基本路径有3条。</p>
<p>设计的基本路径覆盖测试用例如下表所示</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖路径</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(X,Y)&#x3D;(0,0)</td>
<td>(X,Y)&#x3D;(0,0)</td>
<td>ace</td>
</tr>
<tr>
<td>2</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>abce</td>
</tr>
<tr>
<td>3</td>
<td>(X,Y)&#x3D;(-11,1)</td>
<td>(X,Y)&#x3D;(-11,10)</td>
<td>acde</td>
</tr>
<tr>
<td>4</td>
<td>不存在</td>
<td>不存在</td>
<td>abcde</td>
</tr>
</tbody></table>
<p>但是看这篇文章<a href="https://blog.csdn.net/dickdick111/article/details/90478058?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%8E%AF%E5%BD%A2%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-90478058.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187"> 软件测试——程序控制流图，McCabe环形复杂度_根据程序画出控制流图_Dic0k的博客-CSDN博客</a>，按照它的逻辑，环形复杂度应该有5条。（很奇怪）</p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>针对如下样本程序，分析该程序逻辑覆盖测试方法中的语句覆盖、判定覆盖、条件覆盖和基本路径覆盖，并说明哪种方法覆盖率高？为什么？</p>
<p>被测样本程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;start main function:path a...&quot;</span>);</span><br><span class="line">  <span class="type">int</span> A=<span class="number">0</span>,B=<span class="number">0</span>,X=<span class="number">0</span>;</span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">  System.out.println(<span class="string">&quot;输入A：&quot;</span>);  A = s.nextInt();</span><br><span class="line">  System.out.println(<span class="string">&quot;输入B=&quot;</span>);  B = s.nextInt();</span><br><span class="line">  System.out.println(<span class="string">&quot;输入X=&quot;</span>);  X = s.nextInt();</span><br><span class="line">  s.close();  </span><br><span class="line">  <span class="keyword">if</span> (A&gt;<span class="number">1</span> &amp;&amp; B==<span class="number">0</span>) &#123;</span><br><span class="line">	X=X/A;</span><br><span class="line">	System.out.println(<span class="string">&quot;path c&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;path b&quot;</span>);  &#125;</span><br><span class="line">  <span class="keyword">if</span> (A==<span class="number">2</span> || X&gt;<span class="number">1</span>) &#123;</span><br><span class="line">	X=X+<span class="number">1</span>;</span><br><span class="line">	System.out.println(<span class="string">&quot;path e&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;path d&quot;</span>);  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;end main function.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	答：</p>
<p>​	<u><em><strong>注：以下答案只参考了标准答案的一部分</strong></em></u></p>
<p><img src="https://s2.loli.net/2023/05/31/P7NxLnZ9QhsHmyW.png" alt="VF1D1EJ2__LKYS_1_GPGJ5W.png"></p>
<ol>
<li><p>语句覆盖测试</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖路径</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(A,B,X)&#x3D;(2,0,2)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path c，path e，end main function.</td>
<td>ace</td>
</tr>
<tr>
<td>2</td>
<td>(A,B,X)&#x3D;(0,1,1)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path b，path d，end main function.</td>
<td>abd</td>
</tr>
</tbody></table>
</li>
<li><p>判定覆盖测试</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖路径</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(A,B,X)&#x3D;(2,0,2)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path c，path e，end main function.</td>
<td>ace</td>
</tr>
<tr>
<td>2</td>
<td>(A,B,X)&#x3D;(0,1,1)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path b，path d，end main function.</td>
<td>abd</td>
</tr>
</tbody></table>
</li>
<li><p>条件覆盖测试</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖路径</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(A,B,X)&#x3D;(2,0,2)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path c，path e，end main function.</td>
<td>ace</td>
</tr>
<tr>
<td>2</td>
<td>(A,B,X)&#x3D;(0,1,1)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path b，path d，end main function.</td>
<td>abd</td>
</tr>
</tbody></table>
</li>
<li><p>基本路径覆盖测试</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖路径</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(A,B,X)&#x3D;(2,0,2)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path c，path e，end main function.</td>
<td>ace</td>
</tr>
<tr>
<td>2</td>
<td>(A,B,X)&#x3D;(0,1,1)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path b，path d，end main function.</td>
<td>abd</td>
</tr>
<tr>
<td>3</td>
<td>(A,B,X)&#x3D;(0,1,2)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path b，path e，end main function.</td>
<td>abe</td>
</tr>
</tbody></table>
</li>
</ol>
<p>综上所述，基本路径覆盖测试用的测试用例最多，覆盖的路径也最多，故基本路径覆盖的覆盖率最高。</p>
<p><em><strong>注：<a href="https://blog.csdn.net/The_Azur/article/details/117936347">环形复杂度必定是基本路径个数的上限。</a></strong></em></p>
<p><img src="https://s2.loli.net/2023/05/31/HtDjYwSso3WKVFn.png" alt="Snipaste_2023-05-31_21-48-19.png"></p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>使用PMD代码分析工具针对如下被测程序，找出该程序存在的潜在缺陷，给出结果界面截图，并说明各个缺陷出现的原因。</p>
<p>被测样本程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;start main function:path a...&quot;</span>);</span><br><span class="line">  <span class="type">int</span> A=<span class="number">0</span>,B=<span class="number">0</span>,X=<span class="number">0</span>;</span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">  System.out.println(<span class="string">&quot;输入A：&quot;</span>);  A = s.nextInt();</span><br><span class="line">  System.out.println(<span class="string">&quot;输入B=&quot;</span>);  B = s.nextInt();</span><br><span class="line">  System.out.println(<span class="string">&quot;输入X=&quot;</span>);  X = s.nextInt();</span><br><span class="line">  s.close();  </span><br><span class="line">  <span class="keyword">if</span> (A&gt;<span class="number">1</span> &amp;&amp; B==<span class="number">0</span>) &#123;</span><br><span class="line">	X=X/A;</span><br><span class="line">	System.out.println(<span class="string">&quot;path c&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;path b&quot;</span>);  &#125;</span><br><span class="line">  <span class="keyword">if</span> (A==<span class="number">2</span> || X&gt;<span class="number">1</span>) &#123;</span><br><span class="line">	X=X+<span class="number">1</span>;</span><br><span class="line">	System.out.println(<span class="string">&quot;path e&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;path d&quot;</span>);  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;end main function.&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<p><u><em><strong>注：以下答案只参考了标准答案的一部分</strong></em></u></p>
<p><a href="https://smms.app/image/5I4amZs2cXEldHv" target="_blank"><img src="https://s2.loli.net/2023/05/31/5I4amZs2cXEldHv.jpg" alt="Z__LBIY38___C`L5GCFZSVF.jpg"></a></p>
<p>以下是可能的缺陷（感觉每个人做出来都不一样哈哈哈哈😆）：</p>
<blockquote>
<p>（1）VariableNamingConventions：</p>
<p>​		①变量应以小写字符开头，’A’’B’’X’均以大写字符开头</p>
<p>（2）UseUtilityClass：</p>
<p>​		①所有方法都是静态的，可以考虑使用实用工具类，或添加一个私		有构造函数，或使类抽象来屏蔽这个警告</p>
<p>（3）LocalVariableCouldBeFinal：</p>
<p>​		①局部变量’s’可以声明为final</p>
<p>（4）LocalVaraiableNamingConventions：</p>
<p>​		①局部变量名’A’’B’’X’不匹配’[a-z][a-zA-Z0-9]*’</p>
<p>（5）MethodArgumentCouldBeFinal：</p>
<p>​		①参数’args’未赋值，可以声明为final</p>
<p>（6）CommentRequired：</p>
<p>​		①类注释是必需的</p>
<p>​		②公共方法和构造函数的注释是必需的</p>
<p>（7）OneDeclarationPerLine：</p>
<p>​		①int A&#x3D;0,B&#x3D;0,X&#x3D;0; 每个声明为一行，可以增强代码的可读性</p>
<p>（8）UnusedAssignment：</p>
<p>​		①变量’B’的初始化式从未使用（后被重写）</p>
<p>​		②变量’A’的初始化式从未使用（后被覆盖）</p>
<p>​		③变量’X’的初始化式从未使用（后被覆盖）</p>
<p>​		④ X&#x3D;X+1; 赋给变量’X’的值从未使用过</p>
<p>（9）SystemPrintln：</p>
<p>​		①使用System.out.println</p>
<p>（10）ShortVariable：</p>
<p>​		① Scanner s &#x3D; new Scanner(System.in); 避免使用像s这样名字较		短的变量</p>
<p>​		②避免使用短名称的变量：如A,B,X</p>
<p>（11）DataflowAnomalyAnalysis：</p>
<p>​		①发现变量’A’的’DD’异常</p>
<p>​			int A&#x3D;0,B&#x3D;0,X&#x3D;0;</p>
<p>​			Scanner s &#x3D; new Scanner(System.in);</p>
<p>​		    System.out.println(“输入A：”);A &#x3D; s.nextInt();</p>
<p>​		②发现变量’X’的’DU’异常</p>
<p>​		X&#x3D;X+1;</p>
<p>​		System.out.println(“path e”);</p>
<p>​	} else {</p>
<p>​		System.out.println(“path d”);  }</p>
<p>​		System.out.println(“end main function.”);</p>
<p>​	}</p>
<p>​		③发现变量’X’的’DD’异常</p>
<p>​		int A&#x3D;0,B&#x3D;0,X&#x3D;0;</p>
<p> ​		Scanner s &#x3D; new Scanner(System.in);</p>
<p>​		System.out.println(“输入A：”);  A &#x3D; s.nextInt();</p>
<p>​		 System.out.println(“输入B&#x3D;”);  B &#x3D; s.nextInt();</p>
<p>​        System.out.println(“输入X&#x3D;”);  X &#x3D; s.nextInt();</p>
<p>​		④发现变量’B’的’DD’异常</p>
<p>​		int A&#x3D;0,B&#x3D;0,X&#x3D;0;</p>
<p>​	Scanner s &#x3D; new Scanner(System.in);</p>
<p>​	System.out.println(“输入A：”);  A &#x3D; s.nextInt();</p>
<p>​	System.out.println(“输入B&#x3D;”);  B &#x3D; s.nextInt();</p>
<p>（12）CloseResource：</p>
<p>​		①Scanner s &#x3D; new Scanner(System.in); 确保像InputStream对象		这样的资源在使用后被关闭</p>
</blockquote>
<p>我感觉第四题应该不会考🙂</p>
<p><em><strong>声明：除特殊标注外（综合考虑其他同学的答案），答案均为老师原版答案</strong></em></p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试临考总结</title>
    <url>/2023/06/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/test4/</url>
    <content><![CDATA[<p>由于老师明确说不考概念记忆题😆，并且从我们这届开始改版全部是大题😤，所以就不要背那么多干巴巴的知识点啦~，但是一些必要的概念还是得大致知道啥意思吧，以下内容都基于老师发的PPT(●’◡’●)</p>
<h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><p><strong>软件测试(Software Testing）</strong>是一种检测软件的正确性、完整性、安全性和评估其质量的活动过程。换句话说，软件测试是一种以发现程序错误、衡量软件质量为目的，并对其是否满足用户需求进行评估的活动过程。</p>
<p><strong>软件质量保证（Software Quality Assurance，SQA）</strong>是指通过对软件产品进行有计划的评审与审计，来确保软件开发按照产品质量过程标准实施项目的管理活动。</p>
<p>软件质量保证与软件测试的关系：</p>
<blockquote>
<p>SQA指导软件测试的计划与执行，监督测试工作结果的客观性、准确性与有效性，并协助软件测试的工作流程改进。</p>
<p>软件测试是SQA工作落实的重要手段，它为SQA提供所需的质量数据，作为软件质量评价的客观依据。</p>
<p>SQA是一项<em><strong>软件质量管理性工作</strong></em>，侧重于对软件开发流程进行评审与监控。</p>
<p>软件测试是一项<em><strong>技术性工作</strong></em>，侧重于对软件质量特性进行检测与验证。</p>
</blockquote>
<p><strong>测试驱动开发(Test-Driven Development，简称TDD）</strong>是一种不同于传统软件开发流程的过程模型。它要求在编写某个功能的代码之前先编写测试代码，然后编写功能代码，通过测试来推动整个软件开发工作的进行。</p>
<p>下面哪项活动不是软件测试范畴</p>
<p>A．需求文档评审	B.设计评审	C.代码测试	D.过程评审</p>
<blockquote>
<p>过程评审是质量保证活动的一部分，用于评估软件开发过程是否符合既定标准和流程。</p>
</blockquote>
<p>编程完成后才进行测试存在哪些问题?</p>
<blockquote>
<p>测试的时间很有限，很难达到测试的覆盖率要求和测试的质量要求。同时，假如在项目开发的后期，发现一些软件需求阶段和概要设计阶段的错误和问题，修改这些缺陷导致的成本将是非常高的。</p>
</blockquote>
<h2 id="第二章-软件测试基本概念"><a href="#第二章-软件测试基本概念" class="headerlink" title="第二章 软件测试基本概念"></a>第二章 <strong>软件测试基本概念</strong></h2><p><strong>缺陷</strong>(Defect)是指欠缺或不够完备的地方。因为缺陷是相对质量要求而存在的，任何违背了质量要求、违背了客户的意愿，不能满足用户的要求，都可以认为是缺陷。</p>
<p>IEEE STD729关于<strong>软件质量</strong>定义:软件产品或服务满足用户需求的程度。</p>
<blockquote>
<p>①软件缺陷在开发早期出现的概率大，在早期进行缺陷修复的成本低。</p>
<p>②软件在开发后期出现缺陷的概率小，但修复成本高。</p>
<p>③软件测试工作应尽早开展。</p>
</blockquote>
<p><a href="https://smms.app/image/Oc54oYf2KPN81hg" target="_blank"><img src="https://s2.loli.net/2023/06/02/Oc54oYf2KPN81hg.png" ></a></p>
<p>在代码审查中，静态测试可发现如下编程缺陷:</p>
<blockquote>
<p>变量在初始化前使用、变量声明后未使用、变量在两次赋值之间从未使用</p>
<p>数组访问越界</p>
<p>存在不可到达代码</p>
<p>循环中无条件分支</p>
<p>接口参数类型或数目不匹配</p>
<p>空指针或指针类型错误</p>
<p>存在未被调用的函数和过程</p>
</blockquote>
<p>案例一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)attributeList.length();i++)&#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果把判断条件放在for语句内，每一次判断都要重新计算length， 浪费资源</p>
<p>正确代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tmp_iListLength=attributeList.length()</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=O;i&lt;tmp_iListLength; i++)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i ;</span><br><span class="line">...</span><br><span class="line">printf(<span class="string">&quot;i= %d \n&quot;</span>,i) ;</span><br></pre></td></tr></table></figure>

<p>正确代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span> ;</span><br><span class="line">printf (<span class="string">&quot;i= %d \n&quot;</span>,i) ;</span><br></pre></td></tr></table></figure>

<p>案例三</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> array[] = <span class="literal">null</span>; <span class="comment">//声明数组</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//为数组开辟空间，大小为3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= array.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;array[&quot;</span> + i + <span class="string">&quot;]=&quot;</span> + array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺陷应该是数组下标可能越界</p>
<p>个人修改的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> array[] = <span class="literal">null</span>; <span class="comment">//声明数组</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//为数组开辟空间，大小为3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;array[&quot;</span> + i + <span class="string">&quot;]=&quot;</span> + array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例四</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**********计算开始***********&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">// 定义整型变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">//定义整型变量</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> args[<span class="number">0</span>];  <span class="comment">// 接收第一个参数</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> args[<span class="number">1</span>];  <span class="comment">// 接收第二个参数</span></span><br><span class="line">            i = Integer.parseInt(str1);<span class="comment">//将第一个参数由字符串变为整型</span></span><br><span class="line">            j = Integer.parseInt(str2);<span class="comment">//将第二个参数由字符串变为整型</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i / j;           <span class="comment">//进行除法计算</span></span><br><span class="line">            System.out.println(<span class="string">&quot;两个数字相除的结果:&quot;</span> + temp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;<span class="comment">// 捕获算术异常System.out.println(&quot;出现异常了: &quot; + e);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;**********计算结束***********&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的缺陷：</p>
<blockquote>
<ul>
<li>在try块中，使用args数组来接收命令行参数。然而，没有对args数组的长度进行检查或验证。如果没有传递足够的参数，将会导致ArrayIndexOutOfBoundsException(数组索引越界异常)。</li>
<li>在try块中，将args数组的元素作为字符串参数传递给parseInt()方法进行整数转换。然而，如果传递的参数无法解析为整数，将会导致NumberFormatException(数字格式异常)。</li>
<li>在catch块中，捕获了ArithmeticException异常，但是该异常只能捕获除以0导致的算术异常。如果出现其他类型的异常，将无法被捕获和处理。</li>
</ul>
</blockquote>
<p>正确代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;********** 计算开始 ***********&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;缺少必要的参数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i / j;</span><br><span class="line">            System.out.println(<span class="string">&quot;两个数字相除的结果: &quot;</span> + temp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数格式错误: &quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为0: &quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数错误: &quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;********** 计算结束 ***********&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态测试是通过运行被测软件程序，观察该程序在运行过程中的系统行为、变量结果、内存、堆栈等运行数据，来判断软件系统是否存在缺陷的测试活动。<br>动态测试可发现的主要缺陷:</p>
<blockquote>
<p>程序逻辑错误</p>
<p>异常输入的功能失效</p>
<p>空指针使用</p>
<p>内存没有及时释放关闭的对象资源</p>
<p>Session失效</p>
<p>没有处理在空输入时点取Enter键情况</p>
</blockquote>
<p>案例一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name; <span class="comment">// 声明姓名属性</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">// 声明年龄属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tell</span><span class="params">()</span> &#123; <span class="comment">// 取得信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名: &quot;</span> + name + <span class="string">&quot;，年龄: &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明对象</span></span><br><span class="line">        per.name = <span class="string">&quot;张三&quot;</span>; <span class="comment">// 为姓名赋值</span></span><br><span class="line">        per.age = <span class="number">30</span>; <span class="comment">// 为年龄赋值</span></span><br><span class="line">        per.print(); <span class="comment">// 调用方法，打印信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在ClassDemo类的main方法中，创建了一个Person对象per，但没有实际实例化该对象，而是将其初始化为null。这意味着per对象没有被正确地创建和初始化，因此在尝试为per对象的name和age属性赋值时会导致NullPointerException(空指针异常)。<br>在Person类的tell()方法中，打印信息的语句使用了per.print()，但实际上应该调用的是per.tell()，因为tell()方法是定义在Person类的。</p>
</blockquote>
<p>案例二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream os=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    os=<span class="keyword">new</span> <span class="title class_">OutputStream</span>();</span><br><span class="line">      <span class="comment">//Do something with os here.</span></span><br><span class="line">    os.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(os!=<span class="literal">null</span>)</span><br><span class="line">         os.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream os=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    os=<span class="keyword">new</span> <span class="title class_">OutputStream</span>();</span><br><span class="line">      <span class="comment">//Do something with os here.</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(os!=<span class="literal">null</span>)</span><br><span class="line">     os.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的代码使用了 <code>finally</code> 块来确保在无论是否发生异常的情况下都能关闭输出流。</p>
<p><strong>软件验证（(verification）</strong>是指在开发软件过程中，检验软件是否已正确地实现了产品规格说明书所定义的系统功能和特性。<br><strong>软件确认(validation）</strong>是指在开发软件完成后，检查软件产品是否符合用户的真实需求。</p>
<blockquote>
<p>验证:我们正确地构造了产品吗?</p>
<p>确认:我们构造了正确的产品吗?</p>
</blockquote>
<p><em><strong>黑盒测试</strong></em>是指在测试中，把程序看作一个不能打开的黑盒子。在完全不考虑程序内部结构和内部特性的情况下，对程序功能进行测试，检查程序功能是否按照需求规格说明进行有效实现、是否能适当地接收输入数据而产生正确的输出信息。</p>
<p>黑盒测试是从用户观点出发开展的测试，其目的是尽可能发现软件的外部行为错误。黑盒测试常用于发现以下缺陷:</p>
<blockquote>
<p>检测软件是否有错误的功能或有功能遗漏<br>不能正确地接收输入数据、输出错误的结果<br>功能操作不够方便<br>界面出错、扭曲或不美观<br>安装过程中出现问题，安装步骤不清晰、不灵活<br>系统初始化存在问题</p>
</blockquote>
<p><em><strong>白盒测试</strong></em>是指在了解被测程序内部逻辑结构情况下，对该程序的内部变量、逻辑结构、运行路径进行测试，检验被测程序的内部动作或运行功能是否符合设计规格要求。</p>
<p>白盒测试常用于发现以下缺陷:</p>
<blockquote>
<p>程序逻辑错误<br>程序状态异常<br>程序路径无法跳转<br>变量遗漏初始化</p>
</blockquote>
<p><em><strong>单元测试</strong></em></p>
<blockquote>
<p>单元测试针对软件程序中的<strong>最小功能单元代码</strong>（类、函数、模块或组件)进行测试。<br>主要采用白盒测试方法，从程序的内部结构出发设计测试用例，检查单元程序已实现功能与设计规格是否一致、以及编码中是否存在逻辑错误。<br>单元测试一般由编程人员和测试人员共同完成，而以开发人员为主。通常需要编写<strong>驱动模块</strong>和<strong>桩模块</strong>。<br>单元测试还采用代码评审方法（走读、静态分析、评审）检查程序错误，代码评审可以发现程序**50%～70%**代码的缺陷。</p>
</blockquote>
<p><strong>集成测试</strong>（也称组装测试、联合测试）是一种在单元测试的基础上，将若干单元模块按照设计要求组装起来所进行的测试，其目标是发现模块接口相关问题。</p>
<p><strong>系统测试</strong>是在集成测试之后，在系统层面所进行的功能特性测试和非功能特性测试。</p>
<p><strong>验收测试</strong>是在软件提交用户前，在实际用户环境中，验证软件系统功能、性能及其它特性是否符合用户需求。</p>
<ul>
<li>α测试——软件公司在其产品推向市场前，采用实际运行环境和真实数据在软件公司内部进行的验收测试。</li>
<li>β测试——软件公司在其产品推向市场前，还需要在公司外部用户中进行试用测试。通过收集试用户的反馈意见，对该版本软件进行修正与完善，最终得到正式发布的版本。</li>
</ul>
<h2 id="第三章-软件测试方法"><a href="#第三章-软件测试方法" class="headerlink" title="第三章 软件测试方法"></a>第三章 软件测试方法</h2><h3 id="基于直觉和经验的方法"><a href="#基于直觉和经验的方法" class="headerlink" title="基于直觉和经验的方法"></a>基于直觉和经验的方法</h3><blockquote>
<p><strong>Ad-hoc测试方法</strong>强调测试人员更多根据自己的专业经验，不受测试用例约束，放开思路、灵活地进行各种测试。<br><strong>ALAC ( Act-like-a-customer，像客户那样做</strong>）测试方法是一种基于客户使用产品的经验知识进行系统测试，其出发点是应用帕累托(Pareto）二八法则进行重点测试。<br><strong>错误推测法</strong>是测试者根据自己的工作经验、专业知识和直觉来来推测出软件中可能存在的各种错误，从而对被测软件采用针对性的测试。</p>
</blockquote>
<h3 id="基于输入域方法（数据驱动测试）"><a href="#基于输入域方法（数据驱动测试）" class="headerlink" title="基于输入域方法（数据驱动测试）"></a>基于输入域方法（数据驱动测试）</h3><p><em><strong>等价类划分法：</strong></em></p>
<p>一个程序P有两个整型输入变量I1、I2，输出变量为Out,其计算函数为Out&#x3D;P(l1,I2)，假定在字长32位计算机上运行。所有输入数据组合有多少?	<em><strong>2³²x 2³²&#x3D;2⁶⁴</strong></em></p>
<p>例：采购收货单报表系统，要求用户输入处理报表的日期。假定日期限定在2000年1月1日到2023年12月30日。请设计“日期”输入数据验证的等价类。</p>
<blockquote>
<p>有效日期的等价类:2000年1月1日到2023年12月30日的日期值<br>无效日期的等价类:小于2000年1月1日的日期值<br>无效日期的等价类:大于2023年12月30日的日期值</p>
</blockquote>
<p>例：采购收货单报表系统，对于商品数量输入数据，应为大于0的整数，才能符合业务要求。请设计“数量”输入数据验证的等价类。</p>
<blockquote>
<p>有效“数量”字段输入等价类:大于0的整数。<br>无效“数量”字段输入等价类:小于等于0的整数。</p>
</blockquote>
<p>例：航班计划系统，对于某航班设定是否为往返航班，其输入数据应采用布尔数值，才能符合业务要求。请设计“来回程”输入数据验证的等价类。</p>
<blockquote>
<p>有效的“来回程”字段数据输入等价类:真&#x2F;假布尔值。<br>无效的“来回程”字段数据输入等价类:其它任何值。</p>
</blockquote>
<p>例：对于计算器软件的加法运算功能进行测试。请设计“+”功能测试的等价类。</p>
<blockquote>
<p>有效的数据输入等价类:整型数值<br>有效的数据输入等价类:实数数值<br>有效的数据输入等价类:负数数值<br>无效的数据输入等价类:非数字符号</p>
</blockquote>
<p>例:四川地税发票查询页面的发票金额字段输入检查功能测试。</p>
<blockquote>
<p>有效的“发票金额”字段数据输入等价类:大于0的数值数据。<br>无效的“发票金额”字段数据输入等价类:非数值数据。<br>无效的“发票金额”字段数据输入等价类:小于等于0的数值</p>
</blockquote>
<p><em><strong>边界值分析法</strong></em>就是在某个输入变量范围的边界上，输入一些特定数据，分析验证系统功能是否正常运行的测试方法。</p>
<p>例：酒店预订系统业务规定客户最多可提前20天预订酒店客房。请按边界值分析法设计酒店搜索功能的测试用例。</p>
<blockquote>
<p>假定客人在2023-3-12进行订房操作，预订后面10到20天内入住客房，其测试边界值可设置为:2023-3-21、2023-3-31、2023-4-1</p>
</blockquote>
<p>等价类划分法和边界值分析法仅适用于单因素（单变量）输入的数据测试。</p>
<h3 id="基于组合及其优化方法（多变量）"><a href="#基于组合及其优化方法（多变量）" class="headerlink" title="基于组合及其优化方法（多变量）"></a>基于组合及其优化方法（多变量）</h3><p><strong>判定表方法</strong>是一种借助表格方式完成多条件输入组合下测试用例设计，达至完全覆盖输出结果的测试方法。其表格组成样式如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>条件</td>
<td>正确输入年Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>条件</td>
<td>正确输入月M</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>条件</td>
<td>正确输入日D</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>动作</td>
<td>函数运行成功</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>动作</td>
<td>函数运行失败</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p><strong>因果图法</strong>是一种利用图解法分析输入的各种组合情况，从而设计测试用例的形式化方法。它适合于检查程序输入、输出错误，还能判定程序规范中的二义性、不完全性等错误。</p>
<p>因果图PPT上面举了好几页例子，肯定很重要哒~</p>
<p><img src="https://s2.loli.net/2023/06/02/WxI9MwjJepmurfE.png" alt="Snipaste_2023-06-02_15-46-16.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/jCuF49rsNHEm1a5.png" alt="Snipaste_2023-06-02_15-46-38.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/GqM7ES6sPwaBRKt.png" alt="Snipaste_2023-06-02_15-46-47.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/1QmJtbZgpjdr5x7.png" alt="Snipaste_2023-06-02_15-46-56.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/t8moTlbkVwfOLN3.png" alt="Snipaste_2023-06-02_15-47-10.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/L9t3abT6hHxMXNJ.png" alt="Snipaste_2023-06-02_15-48-36.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/2n1okyQVmwI9RrF.png" alt="Snipaste_2023-06-02_15-49-01.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/NWK8wLlgq2Q5AEB.png" alt="Snipaste_2023-06-02_15-50-08.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/CiUFqs6Q2tdLbj4.png" alt="Snipaste_2023-06-02_15-50-14.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/YUzawnXV9oFRgex.png" alt="Snipaste_2023-06-02_15-50-20.png"></p>
<p>当有多个输入变量、每个变量又有多个取值。若要执行全覆盖组合测试，其工作量非常大。为了有效地减少测试组合数，可以采用<strong>成对组合测试方法</strong>，其基本思想是每两个输入变量所有取值组合形成不同测试用例。</p>
<p>例：</p>
<p>测试一个登录页面在不同浏览器和语言下的功能正确性，其输入条件如下:</p>
<p>1）输入项（账号、密码）</p>
<p>2）浏览器（IE、chrome、FireFox、360）</p>
<p>3）语言（中文、英文）</p>
<p>成对组合测试用例表</p>
<table>
<thead>
<tr>
<th>用例</th>
<th>账号</th>
<th>密码</th>
<th>浏览器</th>
<th>语言</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>空值</td>
<td>空值</td>
<td>IE</td>
<td>中文</td>
</tr>
<tr>
<td>2</td>
<td>空值</td>
<td>有值</td>
<td>chrome</td>
<td>英文</td>
</tr>
<tr>
<td>3</td>
<td>有值</td>
<td>空值</td>
<td>FireFox</td>
<td>中文</td>
</tr>
<tr>
<td>4</td>
<td>有值</td>
<td>有值</td>
<td>360</td>
<td>英文</td>
</tr>
<tr>
<td>5</td>
<td>空值</td>
<td>空值</td>
<td>360</td>
<td>中文</td>
</tr>
<tr>
<td>6</td>
<td>空值</td>
<td>有值</td>
<td>FireFox</td>
<td>英文</td>
</tr>
<tr>
<td>7</td>
<td>有值</td>
<td>空值</td>
<td>chrome</td>
<td>中文</td>
</tr>
<tr>
<td>8</td>
<td>有值</td>
<td>有值</td>
<td>IE</td>
<td>英文</td>
</tr>
</tbody></table>
<p><strong>正交实验测试法</strong>是一种依据伽罗华(Galois)理论，从大量实验数据中挑选适量的、具有代表性的数据进行实验，以达到降低实验成本的方法。</p>
<p>正交表构成</p>
<blockquote>
<p>行数:正交表中的行个数，即实验的次数，也是我们通过正交实验法设计的测试用例个数。行数(即&gt;测试用例次数)&#x3D;∑(每列水平数-1)+1</p>
<p>因素数:正交表中列的个数，即测试功能点的因子数。</p>
<p>水平数:任何单个因素能够取值的个数。正交表中包含值为从0到“水平数-1”或从1到“水平数”。即要测试功能点的输入取值数。</p>
<p>L代表正交表，它是运用数学理论在拉丁方和正交拉丁方基础上构造的规格化数据表格，常用的有L₈(2⁷)、L₉(3⁴)、L₁₆(4⁵)等。</p>
</blockquote>
<p>正交表特性</p>
<blockquote>
<p>1)每一列中各数字出现的次数都一样多;<br>2)任何两列所构成的各有序数对出现的次数都一样多。<br>例如在两水平正交表中，任何两列(同一横行内）有序对子共有4种:(1，1)、 (1，2)、(2，1)、 (2，2)。每种对数出现次数相等。在三水平情况下，任何两列(同一横行内）有序对共有9种，1.1、1.2、1.3、<br>2.1、2.2、2.3、<br>3.1、3.2、3.3，且每对出现数也均相等。</p>
</blockquote>
<p> 在一个客户信息查询界面中，输入条件有“姓名”、“身份证号”、“手机”，采用正交表方式设计该界面查询功能的测试用例。</p>
<p>针对本测试有3个输入条件，每个输入有2种取值情况，可以选择L₄(2³)正交表，其正交表值如下表所示：</p>
<table>
<thead>
<tr>
<th>实验数\列号</th>
<th>姓名</th>
<th>身份证号</th>
<th>手机</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>测试用例：</p>
<table>
<thead>
<tr>
<th>测试用例&#x2F;查询条件</th>
<th>姓名</th>
<th>身份证号</th>
<th>手机</th>
</tr>
</thead>
<tbody><tr>
<td>测试用例1</td>
<td>填写</td>
<td>填写</td>
<td>填写</td>
</tr>
<tr>
<td>测试用例2</td>
<td>填写</td>
<td>空</td>
<td>空</td>
</tr>
<tr>
<td>测试用例3</td>
<td>空</td>
<td>填写</td>
<td>空</td>
</tr>
<tr>
<td>测试用例4</td>
<td>空</td>
<td>空</td>
<td>填写</td>
</tr>
</tbody></table>
<h3 id="基于逻辑覆盖方法"><a href="#基于逻辑覆盖方法" class="headerlink" title="基于逻辑覆盖方法"></a>基于逻辑覆盖方法</h3><p><strong>语句覆盖法</strong>的基本思想是设计若干测试用例，使得被测程序中的每个可执行语句至少被执行一次。如果是顺序结构，就是让测试从头执行到尾。如果有分支、条件和循环，则需要执行足够的测试用例覆盖全部语句。</p>
<p><strong>语句覆盖测试能解决的问题</strong>:发现程序中一些永远不能被执行的语句缺陷，但不能发现程序中语句逻辑错误。</p>
<p>语句覆盖测试即使覆盖了程序中每个语句，但并不一定测试覆盖所有分支。试图覆盖程序中所有路径的测试方法称为<strong>路径覆盖</strong>。路径测试的最简单形式就是<strong>判定覆盖测试</strong>。<br><strong>判定覆盖测试基本思想</strong>:设计若干用例，运行被测程序，使得程序中每个判断语句的取真分支和取假分支至少执行一次，即判断真假值均可被满足。一个判定往往代表程序的一个分支，所以判定覆盖测试也称为<strong>分支覆盖测试</strong>。</p>
<p>判定覆盖测试能发现程序中一些永远不能被执行的分支缺陷，可以发现部分逻辑缺陷。</p>
<p><strong>条件覆盖</strong>的基本思想是设计若干测试用例，使其对被测程序进行测试，使每个判断中每个条件的可能取值至少满足一次。</p>
<p>符合条件覆盖的测试用例并不一定满足判定覆盖要求，反之，符合判定覆盖的测试用例也不一定满足条件覆盖要求。因此，需要找出符合两者的测试用例交集，该方法称为<strong>判定-条件覆盖</strong>。</p>
<p><strong>条件组合覆盖</strong>的基本思想是设计足够的测试用例，使得判断中每个条件的所有取值情况至少出现一次，并且每个判断本身的判定结果也至少出现一次。条件组合测试不一定能覆盖所有路径。</p>
<p><strong>基本路径覆盖</strong>就是设计测试用例，覆盖程序中所有可能的基本分支路径。<br>基本路径覆盖局限:不能保证覆盖所有条件组合</p>
<p>基本路径覆盖测试用例设计步骤:</p>
<blockquote>
<p>依据代码绘制流程图<br>确定流程图的环路复杂度<br>确定各个独立路径的基本集合<br>设计测试用例覆盖每条基本路径</p>
</blockquote>
<p>计算环路复杂度：</p>
<blockquote>
<p>（1）流图中的区域数等于环形复杂度。<br>（2）流图G的环形复杂度V(G)&#x3D;E-N+2，其中，E是流图中边的条数，N是结点数。<br>（3）流图G的环形复杂度V(G)&#x3D;P+1，其中，P是流图中判定结点的数目。</p>
</blockquote>
<h2 id="第四章-测试流程和规范"><a href="#第四章-测试流程和规范" class="headerlink" title="第四章  测试流程和规范"></a>第四章  测试流程和规范</h2><p>软件测试过程：</p>
<p>软件工程角度<br>需求评审→设计评审→单元测试→集成测试→系统测试→验收测试</p>
<p>项目管理角度<br>测试计划→测试设计→执行与监控→结果分析与评估→项目总结</p>
<p><strong>敏捷测试</strong>（自动化测试）是一种遵从敏捷软件开发原则，支持敏捷软件开发实现质量控制的测试实践。<br><strong>TMap</strong> (Test Management Approach，测试管理方法)是一种业务驱动的、基于风险策略的、结构化的测试管理方法，其目标是尽早地发现缺陷，以最小的成本、有效地、彻底地完成测试任务，以减少软件发布后的支持成本。</p>
<p><strong>基于脚本测试</strong>(Scripted Testing，ST），无论是手工测试，还是自动化测试，都需要先设计用例，生成测试脚本，然后执行脚本实施测试。<br><strong>探索式测试</strong>(Exploratory Testing，ET），不需要设计用例，一边思考，一边测试。<br><em><strong>在敏捷测试中，则主要采用探索式测试，基于脚本测试则作为补充</strong></em>;而在传统测试中，主要采用基于脚本测试，探索式测试作为补充。</p>
<h2 id="第五章-单元测试与集成测试"><a href="#第五章-单元测试与集成测试" class="headerlink" title="第五章 单元测试与集成测试"></a>第五章 单元测试与集成测试</h2><p><strong>单元静态测试</strong>是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。主要采用互查、走查、评审方法进行测试，也可通过代码缺陷扫描工具进行分析处理。</p>
<p>代码示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过用户UI界面输入的用户名，传递到Action层，进行用户角色识别操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request HttpServletRequest对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 用户角色，如管理员/普通用户/...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserRole</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userRole</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">&quot;schadmin&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 这是系统初始化时默认的管理员账号，如果是，则进行以下验证操作...      </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非系统初始化的账号，进行以下验证操作...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> userRole;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>userName可能会出现空指针情况</p>
<p>修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过用户UI界面输入的用户名，传递到Action层，进行用户角色识别操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request HttpServletRequest对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 用户角色，如管理员/普通用户/...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserRole</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userRole</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;schadmin&quot;</span>.equals(userName)) &#123;</span><br><span class="line">        <span class="comment">// 这是系统初始化时默认的管理员账号，如果是，则进行以下验证操作...      </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非系统初始化的账号，进行以下验证操作...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> userRole;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过用户输入的年龄，转换为数值型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request HttpServletRequest对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer 用户年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserAge</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userAge</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userAge&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (userAge != <span class="literal">null</span>) &#123;</span><br><span class="line">        age = Integer.parseInt(userAge);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>userAge可能不是字符型数字。</p>
<p>建议写一个Util工具类，实现一些常见的数据转换方法，以供调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入的字符串转换为整型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intStr String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIntValue</span><span class="params">(String intStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parseInt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isNumeric(intStr)) &#123;</span><br><span class="line">        parseInt = Integer.parseInt(intStr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parseInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设电话号码字符串设计的标准格式为: 国家编码-区位号码-电话号码-分机号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> strPhoneNumber String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 电话号码 (如: 例子中的2313222)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPhoneNumber</span><span class="params">(String strPhoneNumber)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strPhoneNumber == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(strPhoneNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String[] arrPhone = strPhoneNumber.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arrPhone[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能出现数组越界错误。</p>
<p>修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPhoneNumber</span><span class="params">(String strPhoneNumber)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strPhoneNumber == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(strPhoneNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String[] arrPhone = strPhoneNumber.split(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arrPhone.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrPhone[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeString</span><span class="params">(File file, String writeContent, String encoding)</span> <span class="keyword">throws</span> FileOperatorException &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        fos.write(writeContent.getBytes(encoding));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileOperatorException</span>(ex);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeString</span><span class="params">(File file, String writeContent, String encoding)</span> <span class="keyword">throws</span> FileOperatorException &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        fos.write(writeContent.getBytes(encoding));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileOperatorException</span>(ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">//如果没有finally下面的段语句，就无法释放文件资源</span></span><br><span class="line">         <span class="keyword">if</span> (fos != <span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileOperatorException</span>(e);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了确保代码在运行可靠、功能正确并且能够有良好的性能响应，仅仅进行静态测试是不够的，必须将该单元代码运行起来，验证代码业务逻辑合理性，并了解单元代码的实际表现，即对单元代码进行<strong>动态测试</strong>。</p>
<p>动态测试实现原理</p>
<blockquote>
<p>驱动程序(Driver)<br>被测单元(Unit)<br>桩程序(Stub)</p>
</blockquote>
<p>桩模块和驱动模块的概念搞不清楚，那么下面来介绍这两个概念： </p>
<blockquote>
<p>　　假设现在项目组把任务分给了7个人，每个人负责实现一个模块。你负责的是B模块，你很优秀，第一个完成了编码工作，现在需要开展单元测试工作，先分析结构图：<br>　　1、由于B模块不是最顶层模块，所以它一定不包含main函数(A模块包含main函数)，也就不能独立运行。<br>　　2、B模块调用了D模块和E模块，而目前D模块和E模块都还没有开发好，那么想让B模块通过编译器的编译也是不可能的。<br>　　那么怎样才能测试B模块呢?需要做：<br>　　1、写两个模块Sd和Se分别代替D模块和E模块(函数名、返回值、传递的参数相同)，这样B模块就可以通过编译了。Sd模块和Se模块就是桩模块。<br>　　2、写一个模块Da用来代替A模块，里面包含main函数，可以在main函数中调用B模块，让B模块运行起来。Da模块就是驱动模块。<br>　　桩模块的使命除了使得程序能够编译通过之外，还需要模拟返回被代替的模块的各种可能返回值(什么时候返回什么值需要根据测试用例的情况来决定)。<br>　　驱动模块的使命就是根据测试用例的设计去调用被测试模块，并且判断被测试模块的返回值是否与测试用例的预期结果相符</p>
</blockquote>
<p>集成测试模式:</p>
<blockquote>
<p><strong>非渐增式集成测试</strong><br>先分别测试每个模块，再把所有模块按设计要求组装在一起，然后再进行集成程序的测试。<br><strong>渐增式集成测试</strong><br>把下一个待测试的模块同已经测试好的模块结合起来进行测试，测试完以后再把下一个待测试模块结合进来测试。</p>
</blockquote>
<p><a href="https://smms.app/image/rnOYwCVIDNeBuol" target="_blank"><img src="https://s2.loli.net/2023/06/02/rnOYwCVIDNeBuol.png" alt="HU3PI_3`VKVH_46F9W_GL_4.png"></a></p>
<p><img src="https://s2.loli.net/2023/06/02/qkVeM75SoWYvXg4.png" alt="E_Y5_DZ_B7D_8_Y_B__R_Q8.png"></p>
<p>以上两种测试模式都属于渐增式集成测试。</p>
<p>针对叶节点模块进行单元测试，下面哪项不是必须的?<br>A.测试数据	B.被测单元	C.驱动程序	D.桩程序</p>
<blockquote>
<p>然而，对于叶节点模块的单元测试而言，通常不需要使用桩程序。叶节点模块是指在软件系统中没有其他依赖的最底层模块，也被称为叶子节点或叶子模块。由于它们不依赖其他模块或外部系统，所以不需要模拟或替代任何外部依赖项的行为。</p>
</blockquote>
<h2 id="第六章-系统测试"><a href="#第六章-系统测试" class="headerlink" title="第六章 系统测试"></a>第六章 系统测试</h2><p><strong>功能测试</strong>就是对软件系统的各功能进行验证，根据系统功能需求，逐项测试系统功能是否达到用户要求。</p>
<p><strong>回归测试</strong>是指修改了源代码后，重新进行系统功能测试以确认修改没有引入新的错误或导致其他代码产生错误（<strong>回归缺陷</strong>）。</p>
<p><strong>性能测试</strong>是一种为了发现系统性能问题或获取系统性能相关指标而进行的测试。一般在真实环境、特定负载条件下，通过测试工具模拟实际软件系统的运行及其操作，同时监控性能各项指标，最后对测试结果进行分析来确定系统的性能状况。</p>
<p>常见系统性能问题</p>
<blockquote>
<p>资源耗尽:CPU使用率达到100%<br>资源泄露:内存泄露导致资源耗尽<br>资源瓶颈:缺少可用线程、DB连接资源</p>
</blockquote>
<p><strong>负载测试</strong>（Load Test）：负载测试是一种性能测试，指数据在超负荷环境中运行，程序是否能够承担。 关注点：how much</p>
<p><strong>压力测试</strong>（Stress Test）： 压力测试（又叫强度测试）也是一种性能测试，它在系统资源特别低的情况下软件系统运行情况，目的是找到系统在哪里失效以及如何失效的地方。</p>
<p><strong>容量测试</strong>(Volume Test)：确定系统可处理同时在线的最大用户数 关注点：how much（而不是how fast） 容量测试，通常和数据库有关，容量和负载的区别在于：容量关注的是大容量，而不需要关注使用中的实际表现。</p>
<p>其中，容量测试、负载测试、压力测试的英文解释为：</p>
<blockquote>
<p>Volume Testing &#x3D; Large amounts of data<br>Load Testing &#x3D; Large amount of users<br>Stress Testing &#x3D; Too many users, too much data, too little time and too little room</p>
</blockquote>
<p>假设一个业务系统有1万个注册用户，每天有1半用户会在上班时间（8小时)访问该系统，平均在线时间为1个小时。那么访问该系统的上班时间平均每分钟在线用户数为多少?<br>5000×60&#x2F;(8×60)&#x3D;625</p>
<p><img src="https://s2.loli.net/2023/06/02/TSQZBrG6hRD1NCn.png" alt="Y_TBOAQ0UR1TJ27T2@S4SQY.png"></p>
<p><strong>容错性测试</strong>是检查系统容错能力，即系统在异常条件下自身是否具有防护性的措施或者某种灾难性恢复的手段。</p>
<p><strong>兼容性测试</strong>是指测试软件在特定的硬件平台上、不同的应用软件之间、不同的操纵系统平台上、不同的网络等环境中是否能够很友好的运行。</p>
<p><strong>软件可靠性</strong>是指软件系统在规定时间内及规定环境条件下，完成特定功能的能力。</p>
<p>软件可靠性评估：<br>MTTF (Mean Time To Failure)——系统平均无故障时间</p>
<p>MTTR (Mean Time To Recover)——故障平均修复时间</p>
<p>可用性度量&#x3D; MTTF &#x2F; (MTTF+MTTR）<br>例:如果系统每运行100个时间单位，会有1个时间单位无法提供服务，其系统的可用性是99%。</p>
<p>下面哪项不是系统性能降低的原因?<br>A．资源耗尽	<em><strong>B．响应时间慢</strong></em>	C．内存泄漏	D．网络拥挤</p>
<h2 id="第七章-验收测试"><a href="#第七章-验收测试" class="headerlink" title="第七章 验收测试"></a>第七章 验收测试</h2><p><strong>验收测试</strong>是在软件产品完成了系统测试之后、产品发布之前所进行的软件测试活动，它是软件测试的最后一个阶段，也称<strong>交付测试</strong>。</p>
<p>有些内容在第二章说到啦！</p>
<h2 id="第八章-软件本地化测试"><a href="#第八章-软件本地化测试" class="headerlink" title="第八章 软件本地化测试"></a>第八章 软件本地化测试</h2><p><strong>软件本地化</strong>是指将某软件产品的用户界面、文档资料、在线帮助等从其源语言向目标语言进行转化，使之适应目标语言及文化的处理过程。</p>
<p><strong>软件国际化</strong>是指为保证所开发软件产品能适应国际市场需要，通过特定的系统架构设计、代码编程技术支持软件能在不同语言、不同文化的国家及地区使用，使其在进行本地化时不需要修改软件的程序代码。</p>
<p><strong>软件本地化测试</strong>是根据软件本地化开发完成后，设计测试用例，并利用这些测试用例去运行被测试软件，以发现软件程序缺陷的过程。（含<strong>翻译验证</strong>）</p>
<h2 id="第九章-测试自动化及其框架"><a href="#第九章-测试自动化及其框架" class="headerlink" title="第九章 测试自动化及其框架"></a>第九章 测试自动化及其框架</h2><p><strong>自动化测试</strong>是指采用测试工具实现程序驱动替代人驱动所开展的软件测试活动。测试自动化除包括自动化测试之外，还包括测试辅助工作的自动化。</p>
<p>自动化测试不能完成下面哪项质量指标测试?</p>
<p>A.正确性	B.可靠性	C.性能效率 	D.易用性</p>
<p>自动化测试可以用于测试正确性、可靠性和性能效率等质量指标，但对于易用性的测试则相对有限。易用性通常涉及到用户界面的可操作性、用户体验和用户友好性等方面，这些特征难以完全通过自动化测试来覆盖和评估。易用性测试通常需要人工参与，通过用户实际操作和反馈来评估系统的易用性。</p>
<p><strong>JUnit</strong>是一种白盒测试工具，因为它主要用于单元测试，可以直接访问和测试代码的内部结构和逻辑。它通常用于Java开发环境中，用于测试Java应用程序的各个单元和模块。<strong>UFT</strong>（Unified Functional Testing）是一种黑盒测试工具，用于功能测试和自动化测试。它主要用于测试应用程序的外部行为和用户界面，而不需要了解应用程序的内部实现。<br><strong>Load Runner</strong>是一种性能测试工具，用于测试应用程序在负载和压力条件下的性能表现。它通常用于模拟多个用户同时访问应用程序，以评估其性能和可靠性。<br><strong>Selenium</strong>是一种自动化测试工具，主要用于Web应用程序的功能测试和回归测试。它可以模拟用户操作和交互，并对应用程序的用户界面进行测试。由于它主要关注应用程序的外部行为，因此它也被归类为黑盒测试工具。</p>
<h2 id="第十章-测试需求分析与测试计划"><a href="#第十章-测试需求分析与测试计划" class="headerlink" title="第十章 测试需求分析与测试计划"></a>第十章 测试需求分析与测试计划</h2><p>功能测试范围</p>
<blockquote>
<p>页面链接:页面是否存在、页面是否正确跳转<br>控件功能:按钮功能是否正确、列表内容是否正确、光标位置移动是否顺序正确<br>输入文本框:数据格式、数据类型、数据长度是否检查<br>Web图形测试:图片文字提示是否正确、图片链接是否正确、图片在不同分辨率下显示是否正确<br>表单测试:请求是否响应、脚本是否正确执行</p>
</blockquote>
<p>非功能测试范围。</p>
<blockquote>
<p>性能测试——响应时间、吞吐量等<br>安全测试——用户验证、授权访问、数据安全等<br>容错测试——部件损坏后系统仍正常运行能力<br>兼容性测试——硬件兼容性、操作系统兼容性、浏览器兼容性·可伸缩性测试——增加容量的能力<br>可用性测试——正常运行时间&#x2F;总运行时间</p>
</blockquote>
<h2 id="第十一章-软件质量保证"><a href="#第十一章-软件质量保证" class="headerlink" title="第十一章 软件质量保证"></a>第十一章 软件质量保证</h2><p><strong>软件度量</strong>是根据一定规则对软件项目、软件过程、软件产品进行数据定义、数据收集及量化处理，其目的是为了清晰地理解、预测、评估、控制和改善软件质量。</p>
<p><img src="https://s2.loli.net/2023/06/02/sZKupSB7FxJXjwI.png" alt="NK38BB~K_`__MF0`3SH_VC9.png"></p>
<p><a href="https://smms.app/image/VIRA859hNGcTP1H" target="_blank"><img src="https://s2.loli.net/2023/06/02/VIRA859hNGcTP1H.png" alt="_RF_ABD_90`8@LYLXYP4R@A.png"></a></p>
<p><a href="https://smms.app/image/1rZ85Mps9dmJN3z" target="_blank"><img src="https://s2.loli.net/2023/06/02/1rZ85Mps9dmJN3z.png" alt="_Q1DGL`_SUS_P_RW~_TX6_N.png"></a></p>
<p>再举个上机考试考的题吧，细思也不是不能出大题：</p>
<p>针对如下Java程序进行单元测试，找出该程序的缺陷。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对传入参数telCode（电话号码）进行处理，从中提取该电话号码的座机号码，并将其输出返回。 </span></span><br><span class="line"><span class="comment"> * 例如，输入电话号码为“86,28,83202112”， 返回值应为“83202112” */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getPhoneNo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getPhoneNumber</span><span class="params">(String telCode)</span> &#123; </span><br><span class="line">	  <span class="keyword">if</span> (telCode == <span class="literal">null</span> ) &#123; </span><br><span class="line">	    <span class="keyword">return</span> <span class="string">&quot;输入了空字符串&quot;</span>;&#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">		String localPhone[] = telCode.split(<span class="string">&quot;,&quot;</span>); </span><br><span class="line">		<span class="keyword">return</span> localPhone[<span class="number">2</span>]; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设计单元测试用例表，在该表中填写测试用例的输入数据和预期结果数据。</p>
<table>
<thead>
<tr>
<th>用例</th>
<th>telCode值</th>
<th>预期结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>86,28,83202112</td>
<td>83202112</td>
</tr>
<tr>
<td>2</td>
<td>Null</td>
<td>输入了空字符串</td>
</tr>
<tr>
<td>3</td>
<td>空格</td>
<td>输入电话号码格式错误</td>
</tr>
<tr>
<td>4</td>
<td>86,83202112</td>
<td>输入电话号码格式错误</td>
</tr>
<tr>
<td>5</td>
<td>86,28,83202112%</td>
<td>输入电话号码格式错误</td>
</tr>
</tbody></table>
<p>缺陷如下：</p>
<ol>
<li><p>电话号码为空时无法提示输入了空字符串。</p>
</li>
<li><p>电话号码输入为空格，或者其位数不符合要求，该程序报错而无法继续运行，应该提示输入电话号码格式错误。</p>
</li>
<li><p>当电话号码含有非法字符，该程序没有提示输入了非法字符，而是继续输出了非法字符，应该提示输入电话号码格式错误才对。</p>
</li>
</ol>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getPhoneNoTest_83202112</span> &#123;</span><br><span class="line">    getPhoneNo getPhoneNo=<span class="keyword">new</span> <span class="title class_">getPhoneNo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNo1</span><span class="params">()</span> &#123;</span><br><span class="line">        String expectedResult=<span class="string">&quot;83202112&quot;</span>;</span><br><span class="line">        assertEquals(expectedResult,getPhoneNo.getPhoneNumber(<span class="string">&quot;86,28,83202112&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNo2</span><span class="params">()</span> &#123;</span><br><span class="line">        String expectedResult=<span class="string">&quot;输入了空字符串&quot;</span>;</span><br><span class="line">        assertEquals(expectedResult,getPhoneNo.getPhoneNumber(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNo3</span><span class="params">()</span> &#123;</span><br><span class="line">        String expectedResult=<span class="string">&quot;输入电话号码格式错误&quot;</span>;</span><br><span class="line">        assertEquals(expectedResult,getPhoneNo.getPhoneNumber(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNo4</span><span class="params">()</span> &#123;</span><br><span class="line">        String expectedResult=<span class="string">&quot;输入电话号码格式错误&quot;</span>;</span><br><span class="line">        assertEquals(expectedResult,getPhoneNo.getPhoneNumber(<span class="string">&quot;86,83202112&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNo5</span><span class="params">()</span> &#123;</span><br><span class="line">        String expectedResult=<span class="string">&quot;输入电话号码格式错误&quot;</span>;</span><br><span class="line">        assertEquals(expectedResult,getPhoneNo.getPhoneNumber(<span class="string">&quot;86,28,83202112%&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的源程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getPhoneNo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhoneNumber</span><span class="params">(String telCode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (telCode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;输入了空字符串&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String localPhone[] = telCode.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (localPhone.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;输入电话号码格式错误&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> localPhone[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; phoneNumber.length(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> phoneNumber.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> ||c &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;输入电话号码格式错误&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> phoneNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库期末复习</title>
    <url>/2023/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93/db1/</url>
    <content><![CDATA[<h2 id="第一章数据库系统概论"><a href="#第一章数据库系统概论" class="headerlink" title="第一章	数据库系统概论"></a>第一章	数据库系统概论</h2><ul>
<li><p>在数据库管理系统的层次结构中，下面哪个层次负责对数据文件进行操作访问?<br>A.操作界面层	B.语言翻译处理层	C.数据存取层	<strong>D.数据存储层</strong></p>
<p>  根据处理对象的不同，数据库管理系统的层次结构由外至内依次为应用层、语言翻译处理层、数据存取层、数据存储层。</p>
<p>  (1)应用层：是数据库管理系统与终端用户和应用程序的界面，负责处理各种数据库应用，如使用结构化查询语言<a href="https://baike.baidu.com/item/SQL?fromModule=lemma_inlink">SQL</a>发出的事务请求或嵌入通用的<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink">程序设计语言</a>的应用程序对<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93?fromModule=lemma_inlink">数据库</a>的请求。</p>
<p>  (2)语言处理层：由DDL编译器、DML编译器、DCL编译器、查询器等组成，负责完成对<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink">数据库语言</a>的各类语句进行词法分析、<a href="https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90?fromModule=lemma_inlink">语法分析</a>和<a href="https://baike.baidu.com/item/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90?fromModule=lemma_inlink">语义分析</a>，生成可执行的代码。此外，还负责进行授权检验、视图转换、完整性检查、查询优化等。</p>
<p>  (3)数据存取层：将上层的集合操作转换为对<strong>记录</strong>的操作，包括扫描、排序、查找、插入、删除、修改等，完成数据的存取、路径的维护以及并发控制等任务。</p>
<p>  (4)数据存储层：由文件管理器和缓冲区管理器组成，负责完成数据的页面存储和系统的缓冲区管理等任务，包括打开和关闭文件、读写页面、读写缓冲区、页面淘汰、内外存交换以及外层管理等。</p>
</li>
<li><p>在数据库领域技术中，下面哪种技术可以实现数据集成?<br>A.数据库技术	<strong>B.数据仓库技术</strong>	C.数据挖掘技术	D.商业智能技术</p>
<p>数据仓库 (Data Warehouse) 简称DW，存储大量数据的集成中心。数据仓库的目的是构建面向分析的集成化数据环境，为企业提供决策支持（Decision-Support）。它为企业提供一定的BI（商业智能）能力，指导业务流程改进、监视时间、成本、质量以及控制。数据库挖掘可建立在数据仓库基础上进行数据分析处理。</p>
</li>
<li><p>下面哪种数据库系统应用结构适合银行业务系统?<br>A.集中式结构    B.客户&#x2F;服务器结构	<strong>C.分布式结构</strong>	D.以上结构都可以<br>  分布式数据库的应用场景主要特征是海量并发，所以理论说，业务规模越大，使用分布式数据库的需求也就越迫切。</p>
</li>
<li><p>MySql——应用广泛的开源<strong>关系</strong>数据库管理系统，<em>不是企业级DBMS</em>，PostgreSQL——技术领先的开源<strong>对象-关系</strong>数据库管理系统</p>
</li>
<li><p>下面哪个程序实现PostgreSQL服务器起停控制？pg_ctl</p>
<blockquote>
<p>初始化数据库<br>pg_ctl init<br>启动数据库<br>pg_ctl start<br>关闭数据库<br>pg_ctl stop<br>重启数据库<br>pg_ctl restart </p>
</blockquote>
</li>
<li><p>下面哪类数据库是功能最强大的数据库?<br>A.MySQL	B.PostgreSQL	<strong>C.Oracle Database</strong>	D.SQL Server<br>Oracle Database——甲骨文公司推出的企业级数据库管理系统</p>
</li>
<li><p>SQLite数据库可以在手机中运行</p>
</li>
<li><p>用户程序可以直接访问数据库文件吗？<br>用户程序通常不能直接访问数据库文件。一般来说，用户程序需要通过应用程序向数据库管理系统（DBMS）发送请求，然后由DBMS解析请求并从数据库中检索所需的数据，最后将数据返回给应用程序，以便用户可以使用它们。这样做可以保证数据的安全性和完整性。</p>
</li>
<li><p>NOSQL数据库适用于存储非结构化或半结构化数据的场景。</p>
</li>
<li><p><strong>元数据</strong>（<strong>Metadata</strong>），又称<strong>中介数据</strong>、<strong>中继数据</strong>，为描述<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370?fromModule=lemma_inlink">数据</a>的数据（data about data），主要是描述数据<a href="https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7/1405051?fromModule=lemma_inlink">属性</a>（property）的<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF/111163?fromModule=lemma_inlink">信息</a>，用来支持如指示存储位置、<a href="https://baike.baidu.com/item/%E5%8E%86%E5%8F%B2/360?fromModule=lemma_inlink">历史</a>数据、<a href="https://baike.baidu.com/item/%E8%B5%84%E6%BA%90/9089683?fromModule=lemma_inlink">资源</a>查找、文件记录等功能。业务规则数据在数据库中也是一种元数据。正确</p>
</li>
<li><p>下面哪类数据库应用系统需要使用数据分析处理技术？决策支持</p>
</li>
<li><p>记录（Record）<br>表中的每一行称为一个<strong>记录</strong>，它由若干个字段组成．<br>字段（Field）<br>也称域．表中的每一列称为一个<strong>字段</strong>．每个字段都有相应的描述信息，如数据类型、数据宽度等</p>
</li>
</ul>
<h2 id="第二章数据库关系模型"><a href="#第二章数据库关系模型" class="headerlink" title="第二章	数据库关系模型"></a>第二章	数据库关系模型</h2><p>实体完整性是指关系表的属性组成必须是完整的。错误！！</p>
<p>自然连接是一种等值连接。正确！！</p>
<p>代理键是为了唯一标识关系的不同元组，需要在表单或报表中显示出来。错误！！</p>
<p>关系表：</p>
<blockquote>
<p>表中每行存储实体的一个实例数据表中每列包含实体的一项属性数据表中单元格只能存储单个值<br>不允许有重复的行<br>不允许有重复的列列<br>顺序可任意<br>行顺序可任意</p>
</blockquote>
<p>笛卡尔积：</p>
<p><a href="https://smms.app/image/IGhF634XaVM19PY" target="_blank"><img src="https://s2.loli.net/2023/06/03/IGhF634XaVM19PY.png" ></a></p>
<p>在关系中，可以用来唯一标识元组的属性列，称为<strong>键</strong>(Key)，其它属性列都为非键列。</p>
<p><strong>复合键</strong>(Compound Key)——是指关系中用来唯一标识元组的多列作为键。(学号,课程编号)就是一组复合键。</p>
<p><strong>候选键</strong>(Candidate Key)——关系中可能有多个列均适合作为键，将其中每个都称为候选键。</p>
<p><strong>主键</strong>(Primary key)是关系表中最有代表性的一个候选键。每个关系表中只能定义一个主键。</p>
<p>主键的作用：</p>
<blockquote>
<p>唯一标识关系表的每行（元组)<br>与关联表的外键建立联系，实现关系表之间连接<br>数据库文件使用主键值来组织关系表的数据存储<br>数据库使用主键索引快速检索数据</p>
</blockquote>
<p><strong>代理键</strong>——采用DBMS自动生成的数字序列作为关系表的主键。<br>代理键有什么用途?<br>由DBMS自动生成的数字序列作为主键，可替代复合主键，以便获得更高性能的数据访	问操作处理。</p>
<p>关系模式语句中主键表示方法:关系名（<u>主键属性</u>，属性2，，属性x)</p>
<p><a href="https://smms.app/image/Aipa9Wvl3EJYZHb" target="_blank"><img src="https://s2.loli.net/2023/06/03/Aipa9Wvl3EJYZHb.png" ></a></p>
<p><strong>关系模型</strong>(Relation Model)——是一种基于二维表结构存储数据实体及实体间联系的数据模型。</p>
<p>集合运算操作包括<strong>选择</strong>(select)、<strong>投影</strong>（project)、<strong>连接</strong>（join) 、<strong>交</strong>(intersection）、<strong>并</strong>(union)、<strong>差</strong>(difference）等。<br>专门关系操作包括数据行<strong>插入</strong>(Insert) 、<strong>修改</strong>(Update）、<strong>删除</strong>(Delete）操作。</p>
<p><a href="https://smms.app/image/iPBg21lY8NzprSx" target="_blank"><img src="https://s2.loli.net/2023/06/03/iPBg21lY8NzprSx.png" ></a></p>
<p>以下是老师给的答案，有些许小错误，提供个思路就可以啦~</p>
<p><a href="https://smms.app/image/oT586hL2t3Zcj7f" target="_blank"><img src="https://s2.loli.net/2023/06/03/oT586hL2t3Zcj7f.png" ></a></p>
<p>关系模型完整性是指在关系数据模型中对关系实施的完整性约束。</p>
<p>完整性约束作用:</p>
<blockquote>
<p>消除关系表的元组重复存储</p>
<p>保持关联表的数据一致性</p>
<p>实现业务数据规则</p>
</blockquote>
<p>关系模型完整性约束分类:</p>
<ul>
<li>实体完整性约束</li>
</ul>
<p><strong>实体完整性</strong>是指在关系表中实施的<strong>主键取值约束</strong>，以保证关系表中的每个元组可以被唯	一标识。</p>
<p>实体完整性约束规则:</p>
<p>①每个关系表中的主键属性列都<strong>不允许为空值</strong>(NULL)，否则就不可能标识实体。</p>
<p>②现实世界中的实体是靠主键来标识，<strong>主键取值应该唯一</strong>，并区分关系表中的每个元组。</p>
<ul>
<li>参照完整性约束</li>
</ul>
<p>参照完整性是指关系表之间需要遵守的数据约束，以保证关系之间关联列的数据一致性。</p>
<p><strong>参照完整性</strong>约束规则:若关系R中的外键F与关系S中的主键K相关联，则R中外键F值必须与S中主键K值一致。</p>
<p>外键(Foreign key)——在关联的两个关系中，它们具有一个或多个相同属性。若关联列在第一个关系中作为主键，则在第二个关系中作为外键。</p>
<ul>
<li>用户自定义完整性约束</li>
</ul>
<p><strong>用户自定义完整性</strong>是指用户根据具体业务对数据处理规则要求所定义的数据约束。</p>
<p>用户可以定义如下类型的完整性约束:</p>
<blockquote>
<p>定义列的数据类型与取值范围</p>
<p>定义列的缺省值</p>
<p>定义列是否允许取空值</p>
<p>定义列取值唯一性</p>
<p>定义列之间的数据依赖性</p>
</blockquote>
<p>从关系的数学定义来看，关系是各个域的笛卡尔集合。(×)</p>
<p>应该是子集</p>
<ol>
<li><p>关系模型由三个部分组成：数据结构，操作集合和完整性约束。</p>
<p>(1)关系数据结构:在关系模型中,现实世界的实体以及实体间的各种联系均用单一的结构类型即关系来表示。</p>
<p>(2)关系操作集合:关系模型中常用的关系操作包括查询操作和插入、删除、修改操作。</p>
<p>(3)关系完整性约束:关系模型中有实体完整性约束、参照完整性约束和用户定义的完整性约束三类约束。</p>
</li>
<li><p>在关系模型中，对关系有几种基本的数据操作方式，包括选择，投影，连接，除法等。这些操作可以用来查询、更新和控制关系数据。</p>
</li>
<li><p>关系数据查询中的选择运算是从关系中选择满足特定条件的元组。投影运算是从关系中选择特定属性列。连接运算是根据两个关系中共同属性的值相等来组合两个关系中的元组。</p>
</li>
<li><p>θ连接(内连接)是指在两个关系上执行一个比较运算符θ的连接操作。θ为“&#x3D;”的连接运算称为等值连接，自然连接是一种特殊的等值连接（两个关系中进行比较的分量必须是相同的属性组），它在连接后自动删除重复的列。</p>
</li>
<li><p>左外连接返回左表中所有记录和右表中匹配记录；如果右表中没有匹配记录，则结果为NULL。右外连接返回右表中所有记录和左表中匹配记录；如果左表中没有匹配记录，则结果为NULL。全外连接返回左表和右表中所有记录；如果其中一个表没有匹配记录，则结果为NULL。</p>
</li>
</ol>
<h2 id="第三章数据库操作SQL语言"><a href="#第三章数据库操作SQL语言" class="headerlink" title="第三章	数据库操作SQL语言"></a>第三章	数据库操作SQL语言</h2><ul>
<li><p>SQL语言是一种标准的数据库操作语言，可以支持所有数据库访问操作（错）</p>
<p>  主流的关系型数据库管理系统均支持SQL标准语言实现数据库操作</p>
</li>
<li><p>下面哪种数据类型不是PostgreSQL支持的数据类型?<br>A.json	B.line	C. macaddr	<strong>D. String</strong><br>  PostgreSQL支持<code>json</code>，<code>line</code>和<code>macaddr</code>数据类型。但是，它不支持名为<code>String</code>的数据类型。在PostgreSQL中，可以使用<code>text</code>或<code>varchar</code>数据类型来存储字串。</p>
</li>
</ul>
<h3 id="数据定义语句（DDL）"><a href="#数据定义语句（DDL）" class="headerlink" title="数据定义语句（DDL）"></a>数据定义语句（DDL）</h3><p>创建数据库：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> databse CourseDB;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> CourseDB <span class="keyword">rename</span> <span class="keyword">to</span> courseDB;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> courseDB;</span><br></pre></td></tr></table></figure>

<p>定义基本表 CREATE  TABLE</p>
<p>CREATE  TABLE 表名();</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(n)</td>
<td>长度为 n 的字符型</td>
</tr>
<tr>
<td>VARCHAR(n)</td>
<td>最大长度为 n 的变长字符型</td>
</tr>
<tr>
<td>NUMBER(n)</td>
<td>长度为 n 的数字型</td>
</tr>
<tr>
<td>lNT</td>
<td>长整型(4B)</td>
</tr>
<tr>
<td>SMALLlNT</td>
<td>短整型(2B)</td>
</tr>
<tr>
<td>BlGlNT</td>
<td>大整型(8B)</td>
</tr>
<tr>
<td>FLOAT(n)</td>
<td>精度至少为 n 位数字的浮点数</td>
</tr>
<tr>
<td>DATE</td>
<td>日期， 格式为 YYYY-MM-DD</td>
</tr>
<tr>
<td>TlME</td>
<td>时间， 格式为 HH:MM:SS</td>
</tr>
</tbody></table>
<p><strong>列级完整性约束条件</strong></p>
<blockquote>
<p>PRlMARY KEY	&#x2F;&#x2F;主码:当只有一个主码时，可直接在对应的属性列标注<br>NOT NULL	&#x2F;&#x2F;非空:表示该属性列不能取空值<br>UNlQUE	&#x2F;&#x2F;唯一值: 表示该属性列只能取唯一值<br>CHECK(条件) 	   &#x2F;&#x2F;检查:  检查该列是否满足某个条件，如 CHECK(某属性&gt;20)</p>
</blockquote>
<p>列完整约束</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span>  Course</span><br><span class="line">( CourseID  	<span class="type">char</span>(<span class="number">4</span>)      <span class="keyword">PRIMARY  Key</span>,</span><br><span class="line">  CourseName  	<span class="type">varchar</span>(<span class="number">20</span>)  <span class="keyword">NOT</span>  <span class="keyword">NULL</span>  <span class="keyword">UNIQUE</span>,</span><br><span class="line">  CourseType  	<span class="type">varchar</span>(<span class="number">10</span>)  <span class="keyword">NULL</span> <span class="keyword">CHECK</span>(CourseType <span class="keyword">IN</span>(<span class="string">&#x27;基础课&#x27;</span>,<span class="string">&#x27;专业课&#x27;</span>,<span class="string">&#x27;选修课&#x27;</span>)),</span><br><span class="line">  TestMethod  	<span class="type">char</span>(<span class="number">4</span>)      <span class="keyword">NOT</span>  <span class="keyword">NULL</span>  <span class="keyword">DEFAULT</span>  <span class="string">&#x27;闭卷考试&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>复合主键</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span>  Plan</span><br><span class="line">( CourseID  	<span class="type">char</span>(<span class="number">4</span>)  	<span class="keyword">NOT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">  TeacherID  	<span class="type">char</span>(<span class="number">4</span>)  	<span class="keyword">NOT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span>	CoursePlan_PK	<span class="keyword">PRIMARY Key</span>(CourseID,TeacherID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>使用表约束定义主键的优点:便于定义复合主键，可命名主键约束，便于定义代理键。</p>
<p>代理键</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span>  Plan</span><br><span class="line">( CoursePlanID	<span class="type">serial</span>		<span class="keyword">NOT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span>	CoursePlan_PK	<span class="keyword">PRIMARY Key</span>(CoursePlanID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>外键,级联删除</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span>  Register</span><br><span class="line">( CourseRegID  	<span class="type">serial</span>	<span class="keyword">NOT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">  CoursePlanID  	<span class="type">Int</span>  		<span class="keyword">NOT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">  StudentID  	<span class="type">char</span>(<span class="number">13</span>),</span><br><span class="line">  Note  		<span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span>	CourseRegID_PK	<span class="keyword">PRIMARY Key</span>(CourseRegID),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span>	CoursePlanID_FK	<span class="keyword">FOREIGN Key</span>(CoursePlanID)</span><br><span class="line">	<span class="keyword">REFERENCES</span>  Plan(CoursePlanID)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>表修改</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="type">name</span>&gt; <span class="keyword">add</span> &lt;columnName&gt; &lt;<span class="keyword">type</span>&gt; &lt;<span class="keyword">constraint</span>&gt;;</span><br></pre></td></tr></table></figure>

<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>&lt;表名&gt; <span class="keyword">DROP</span>  <span class="keyword">COLUMN</span> &lt;列名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>&lt;表名&gt; <span class="keyword">DROP</span>  <span class="keyword">CONSTRAINT</span> &lt;列名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新表名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">RENAME</span> &lt;原列名&gt; <span class="keyword">TO</span> &lt;新列名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">ALTER</span>  <span class="keyword">COLUMN</span> &lt;列名&gt; <span class="keyword">TYPE</span>&lt;新的数据类型&gt;;</span><br></pre></td></tr></table></figure>

<p>索引作用:支持对数据库表中数据快速查找，其原理类似图书目录，可以快速定位章节内容。</p>
<p>索引优点:</p>
<blockquote>
<p>可快速连接关联表<br>减少分组和排序时间<br>提高关系表数据检索速度</p>
</blockquote>
<p>索引局限:</p>
<blockquote>
<p>索引会占用额外存储空间<br>创建和维护索引都需要较大时间开销											<br>数据操纵因维护索引带来系统性能开销</p>
</blockquote>
<p>创建索引<br>例:在学生信息表Student中，为出生日期Birthday列创建索引，以便支持按出生日期快	速查询学生信息。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> Birthday_Idx <span class="keyword">ON</span> STUDENT (Birthday) ;</span><br></pre></td></tr></table></figure>

<p>修改索引<br>例在学生信息表Student中，将原索引Birthday_ldx更名为Bday_ldx，其索引修改SQL	语句如下</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> Birthday_Idx <span class="keyword">RENAME</span> T0 Bday_ldx ;</span><br></pre></td></tr></table></figure>

<p>删除索引</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">INDEX</span> bday_idx;</span><br></pre></td></tr></table></figure>

<h3 id="数据操纵语句（DML）"><a href="#数据操纵语句（DML）" class="headerlink" title="数据操纵语句（DML）"></a>数据操纵语句（DML）</h3><p>插入</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Student <span class="keyword">VALUES</span>(<span class="string">&#x27;2017220101105&#x27;</span>,<span class="string">&#x27;赵东&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1999-04-23&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>, <span class="string">&#x27;liuyin@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>更新</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  Student</span><br><span class="line"><span class="keyword">SET</span>  Email=<span class="string">&#x27;zhaodong@163.com&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span>   StudentName=<span class="string">&#x27;赵东&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span>  STUDENT</span><br><span class="line"><span class="keyword">WHERE</span>   StudentName=<span class="string">&#x27;赵东&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>清空</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> STUDENT;</span><br></pre></td></tr></table></figure>

<h3 id="数据查询语句（DQL）"><a href="#数据查询语句（DQL）" class="headerlink" title="数据查询语句（DQL）"></a>数据查询语句（DQL）</h3><p>先分组再排序！！！</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>]  &lt;目标列&gt;[，&lt;目标列&gt;…]</span><br><span class="line">[ <span class="keyword">INTO</span> &lt;新表&gt; ]</span><br><span class="line"><span class="keyword">FROM</span>  &lt;表名|视图名&gt;[，&lt;表名|视图名&gt;…]</span><br><span class="line">[ <span class="keyword">WHERE</span>  &lt;条件表达式&gt; ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;列名&gt; [<span class="keyword">HAVING</span> &lt;条件表达式&gt; ]]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span>  &lt;列名&gt; [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ] ];</span><br></pre></td></tr></table></figure>

<p>1）使用BETWEEN..AND关键词来限定列值范围，还可以使用关键词LIKE与通配符来限定查询条件。<br>2)使用通配符来限定字符串数据范围。下划线（_）通配符用于代表一个未指定的字符。百分号(%）通配符用于代表一个或多个未指定的字符。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT</span><br><span class="line"><span class="keyword">WHERE</span> BirthDay <span class="keyword">BETWEEN</span> <span class="string">&#x27;2000-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2000-12-30&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> Email <span class="keyword">LIKE</span> <span class="string">&#x27;%@163.com &#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p><a href="https://smms.app/image/oiIjqcgDLa6Vud7" target="_blank"><img src="https://s2.loli.net/2023/06/03/oiIjqcgDLa6Vud7.png" ></a></p>
<p><a href="https://smms.app/image/GOKjh5RsYXb16uA" target="_blank"><img src="https://s2.loli.net/2023/06/03/GOKjh5RsYXb16uA.png" ></a></p>
<p>例1:若要统计Student表中的学生人数，在SELECT语句中可以使用COUNT )函数来计算，其查询SQL语句如下:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> COUNT(*) <span class="keyword">AS</span> 学生人数 <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>

<p>例2:找出STUDENT表中年龄最大和年龄最小的学生出生日期，其查询SQL语句如下:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Min (Birthday) <span class="keyword">AS</span> 最大年龄,Max (Birthday) <span class="keyword">AS</span> 最小年龄 <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>

<p>分组：</p>
<p>having 是对于 group by 的列的条件约束,除了group外,列名称不能和聚合函数一起用</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Major  <span class="keyword">AS</span> 专业,  COUNT（StudentID） <span class="keyword">AS</span> 学生人数</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span>  StudentGender=’男’</span><br><span class="line"><span class="keyword">GROUP</span>  <span class="keyword">BY</span>  Major</span><br><span class="line"><span class="keyword">HAVING</span>  COUNT(*)&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>子查询：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  TeacherID,  TeacherName,  TeacherTitle</span><br><span class="line"><span class="keyword">FROM</span>  Teacher</span><br><span class="line"><span class="keyword">WHERE</span>  CollegeID  <span class="keyword">IN</span></span><br><span class="line">        (<span class="keyword">SELECT</span>  CollegeID  </span><br><span class="line">     <span class="keyword">FROM</span>  College</span><br><span class="line">     <span class="keyword">WHERE</span>  CollegeName=’计算机学院’);</span><br></pre></td></tr></table></figure>

<p>多表关联查询：</p>
<p>在选课管理系统数据库中，希望获得各个学院的教师信息列表，包括学院名称、教师编号、教师姓名、教师性别、职称等信息。要求按学院名称、教师编号分别排序输出，其查询SQL语句如下：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  B.CollegeName <span class="keyword">AS</span> 学院名称,  A.TeacherID  <span class="keyword">AS</span> 编号, A.TeacherName  <span class="keyword">AS</span> 姓名,  A.TeacherGender  <span class="keyword">AS</span> 性别,  A. TeacherTitle  <span class="keyword">AS</span> 职称</span><br><span class="line"><span class="keyword">FROM</span>  Teacher  <span class="keyword">AS</span>  A，College  <span class="keyword">AS</span>  B</span><br><span class="line"><span class="keyword">WHERE</span>  A.CollegeID=B.CollegeID </span><br><span class="line"><span class="keyword">ORDER</span>  <span class="keyword">BY</span>  B.CollegeName, A.TeacherID;</span><br></pre></td></tr></table></figure>

<p>在选课管理数据库中，希望查询所有开设课程的学生选课情况，包括课程名称、任课教师、选课学生人数。这需要关联课程信息表COURSE、教师信息表TEACHER、开课计划表PLAN、选课注册信息表REGISTER。其连接查询的SQL语句如下：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> C.CourseName <span class="keyword">AS</span> 课程名称, T.TeacherName <span class="keyword">AS</span> 教师, </span><br><span class="line">  COUNT (R.CoursePlanID)  <span class="keyword">AS</span> 选课人数</span><br><span class="line"><span class="keyword">FROM</span>  COURSE  <span class="keyword">AS</span>  C  <span class="keyword">JOIN</span>  PLAN  <span class="keyword">AS</span>  P  <span class="keyword">ON</span>  C.CourseID=P.CourseID </span><br><span class="line">  <span class="keyword">JOIN</span>  TEACHER  <span class="keyword">AS</span>  T  <span class="keyword">ON</span>  P.TeacherID=T.TeacherID</span><br><span class="line">  <span class="keyword">JOIN</span>  REGISTER  <span class="keyword">AS</span>  R  <span class="keyword">ON</span>  P.CoursePlanID=R.CoursePlanID</span><br><span class="line"><span class="keyword">GROUP</span>  <span class="keyword">BY</span> C.CourseName, T.TeacherName;</span><br></pre></td></tr></table></figure>

<p>在上面的内连接查询中，只能找出有学生注册的课程名称和选课人数，但不能找出没有学生注册的课程名称。<br>在SQL应用中，有时候也希望输出那些不满足连接条件的元组数据。这时，可使用JOIN–ON外连接方式实现。其实现方式有三种形式，具体如下:</p>
<blockquote>
<p><strong>LEFT JOIN</strong>:左外连接，即使没有与右表关联列值匹配，也从左表返回所<br>有的行。<br><strong>RIGHT JOIN</strong>:右外连接，即使没有与左表关联列值匹配，也从右表返回<br>所有的行。<br><strong>FULL JOIN</strong>:全外连接，同时进行左连接和右连接，就返回所有行。</a></p>
</blockquote>
<p>对A表和B表进行关联查询，哪种连接可以使B表中不匹配的元组数据可以出现在结果集中?<br>A. left join	<strong>B. right join</strong>	C. full join	D. inner join</p>
<p>在选课管理系统数据库中，希望能查询所有开设课程的学生选课情况，包括课程名称、任课教师、选课学生人数。这需要关联课程信息表COURSE、开课计划表CPLAN、教师信息表TEACHER、选课注册信息表REGISTER。若使用左外连接查询，该JOIN–ON连接查询的SQL语句如下:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> C.CourseName <span class="keyword">AS</span> 课程名称, T.TeacherName <span class="keyword">AS</span> 教师, </span><br><span class="line">COUNT  (R.CoursePlanID)  <span class="keyword">AS</span> 选课人数</span><br><span class="line"><span class="keyword">FROM</span>  COURSE  <span class="keyword">AS</span>  C  <span class="keyword">JOIN</span>  PLAN  <span class="keyword">AS</span>  P  </span><br><span class="line"><span class="keyword">ON</span>  C.CourseID=P.CourseID </span><br><span class="line"><span class="keyword">JOIN</span>  TEACHER  <span class="keyword">AS</span>  T  <span class="keyword">ON</span>  P.TeacherID=T.TeacherID</span><br><span class="line"><span class="keyword">LEFT  JOIN</span>  REGISTER  <span class="keyword">AS</span>  R  <span class="keyword">ON</span>  P.CoursePlanID=R.CoursePlanID</span><br><span class="line"><span class="keyword">GROUP</span>  <span class="keyword">BY</span> C.CourseName, T.TeacherName;</span><br></pre></td></tr></table></figure>

<h3 id="数据控制语句（DCL）"><a href="#数据控制语句（DCL）" class="headerlink" title="数据控制语句（DCL）"></a>数据控制语句（DCL）</h3><p>授予，收回，拒绝权限</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>  <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span>  <span class="keyword">ON</span>  REGISTER  <span class="keyword">TO</span>  RoleS;</span><br><span class="line"><span class="keyword">REVOKE</span>  <span class="keyword">DELETE</span>  <span class="keyword">ON</span>  REGISTER  <span class="keyword">FROM</span>  RoleS;</span><br><span class="line">DENY  <span class="keyword">DELETE</span>  <span class="keyword">ON</span>  TEACHER  <span class="keyword">TO</span>  RoleT;</span><br></pre></td></tr></table></figure>

<p>视图是一个虚拟的表，它是从一个或几个基本表（或视图）导出的表。它包含行和列，就像一个真实的表一样。视图本身并不包含任何数据，它只包含映射到基表的一个查询语句。当基表数据发生变化时，视图数据也随之变化。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以提交数据，就像这些来自于某个单一的表一样。数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。</p>
<p>视图的优点：</p>
<blockquote>
<ol>
<li>使用视图简化复杂SQL查询操作</li>
<li>使用视图提高数据访问安全性</li>
<li>提供一定程度的数据逻辑独立性通过视图，可提供一定程度的数据逻辑独立性。当数据表结构发生改变，只要视图结构不变，应用程序可以不作修改。</li>
<li>集中展示用户所感兴趣的特定数据通过视图，可以将部分用户不关心的数据进行过滤，仅仅提供他们所感兴趣的数据。</li>
</ol>
</blockquote>
<p>创建视图</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span>  BasicCourseView  <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span>  CourseName,  CourseCredit,  CoursePeriod,  TestMethod</span><br><span class="line"><span class="keyword">FROM</span>    COURSE</span><br><span class="line"><span class="keyword">WHERE</span>  CourseType=‘基础课’;</span><br></pre></td></tr></table></figure>

<p>查询视图：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BasicTeacherInfoView <span class="keyword">ORDER</span> <span class="keyword">BY</span> 所属学院,教师姓名;</span><br></pre></td></tr></table></figure>

<p>删除视图：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span>&lt;视图名&gt;;</span><br></pre></td></tr></table></figure>

<p>下面哪项不是SQL语言的特性?<br>A.对数据库进行操作<br>B.实现控制逻辑编程<br>C.数据库游标操作<br>D.数据库事务操作</p>
<p><code>实现控制逻辑编程</code> 不是 SQL 语言的特性。SQL 语言是一种用于管理关系数据库的语言，它可以用来对数据库进行操作、数据库游标操作和数据库事务操作。但它不是一种通用的编程语言，不能用来实现控制逻辑编程。</p>
<p><strong>NUMERIC</strong>数据类型是一种精确数字数据类型，其精度在算术运算后保留到最小有效位，numeric是标准sql的数据类型，格式是numeric(m，n）。numeric(a，b)函数有两个参数，前面一个为总的位数，后面一个参数是小数点后的位数，例如numeric（5，2）是总位数为5，小数点后为2位的数，也就是说这个字段的整数位最大是3位。</p>
<p>在数据库中，使用更多索引可以加快数据库处理速度。（x）<br><em><strong>索引可以加快查询速度，但不能加快处理速度</strong></em></p>
<p><a href="https://smms.app/image/cGdF3HSLoqhszr2" target="_blank"><img src="https://s2.loli.net/2023/06/03/cGdF3HSLoqhszr2.png" alt="image.png"></a></p>
<p>针对视图 <code>Create view stuView as select * from student;</code> 可以进行 <code>D.以上均可</code> 操作访问。这个视图定义了一个查询语句，它从 <code>student</code> 表中选择所有列和所有行。因此，可以对这个视图执行 <code>SELECT</code>、<code>INSERT INTO</code> 和 <code>DELETE</code> 操作。<br>针对视图 <code>Create view stuView as select stuname, major from student;</code> 可以进行 <code>A. Select</code>,<code>C. delete</code> 操作访问。这个视图定义了一个查询语句，它从 <code>student</code> 表中选择 <code>stuname</code> 和 <code>major</code> 列。由于这个视图只包含部分列，因此不能对其执行 <code>INSERT INTO</code> 操作。</p>
<h2 id="第四章-数据库设计与实现"><a href="#第四章-数据库设计与实现" class="headerlink" title="第四章 数据库设计与实现"></a>第四章 数据库设计与实现</h2><p><strong>概念数据模型</strong>（Concept Data Model，CDM）是一种<strong>面向用户</strong>的系统数据模型，它用来描述现实世界的系统概念化数据结构。使数据库设计人员在系统设计的初始阶段，摆脱计算机系统及DBMS的具体技术问题，集中精力分析业务数据以及数据之间的联系等，描述系统的数据对象及其组成关系。 </p>
<p><strong>逻辑数据模型</strong> (Logic Data Model，LDM)是在概念数据模型基础上，从系统设计角度描述系统的数据对象组成及其关联结构，并考虑这些数据对象符合数据库对象的逻辑表示。 </p>
<p><strong>物理数据模型</strong>（Physical Data Model，PDM）是在逻辑数据模型基础上，针对具体DBMS所设计的数据模型。它用于描述系统数据模型在具体DBMS中的数据对象组织、<strong>存储方式</strong>、<strong>索引方式</strong>、访问路径等实现信息。（面向编程人员）</p>
<p>在E-R模型中，基本元素包括实体、属性、标识符和联系。</p>
<p><strong>实体</strong>(Entity)是指问题域中存在的人、事、物、地点等客观事物在逻辑层面的数据抽象。它用于描述事物的数据对象，如客户、交易、产品、订单等。</p>
<p><strong>属性</strong>是指描述实体特征的数据项。每个实体都具有1个或多个属性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_13-51-33.png"></p>
<p>实体联系的实例数量称为<strong>基数</strong>(Cardinality) 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_14-19-51.png"></p>
<p><strong>联系</strong>：实体间的联系，关联的实体数目称为联系度数</p>
<p>实体联系类型</p>
<ul>
<li>数量关系：1：1、1：N、M：N</li>
<li>必要性：可选，强制。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_14-20-21.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_14-21-28.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_14-22-01.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_14-22-12.png"></p>
<p>在E-R模型中，根据弱实体在语义上对强实体依赖程度的不同，弱实体又分为<strong>标识符依赖弱实体</strong>和<strong>非标识符依赖弱实体</strong>两类。如果弱实体的标识符中包含了所依赖实体的标识符，则该弱实体称为标识符依赖弱实体。</p>
<p>当使用关系数据库时，物理数据模型（PDM）即为关系模型。CDM&#x2F;LDM到PDM的转换其实就是E-R模型图到关系模型的转换。<br>E-R模型图到关系模型转换原理:</p>
<blockquote>
<p>将每一个实体转换成一个关系表，实体属性转换为关系表的列，实体标识符转换为关系表的主键或外键。将实体之间的联系转化为关系表之间的参照完整性约束。</p>
</blockquote>
<p>1:1实体联系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-30-41.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-31-07.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-31-22.png"></p>
<p>当带有实体继承联系的E-R模型图转换关系模型时，首先父实体和子实体都各自转换为表，其属性均转换为表的列。在处理实体继承联系转换时，将父表中的主键放置到子表中，既做主键又做外键。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-39-02.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-40-14.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-40-27.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/cdm.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/ldm.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/pdm.png">数据库规范化设计目的：</p>
<ul>
<li>减少数据库中的冗余数据，尽量使同一数据在数据库中仅保存一份，有效降低维护数据一致性的工作量。</li>
<li>设计合理的表间依赖关系和约束关系，便于实现数据完整性和一致性。</li>
<li>设计合理的数据库结构，便于系统对数据高效访问处理。</li>
</ul>
<p><strong>完全函数依赖与部分函数依赖</strong></p>
<p>例1：对于关系R（<u>X</u>,<u> Y</u>, N, O, P），其中（<u>X</u>,<u> Y</u>）为复合主键，若其它属性N,O,P都完整依赖于该复合主键，则称关系R为完全函数依赖。反之，其它属性N,O,P仅依赖于X，或仅依赖于Y，则称R为部分函数依赖。</p>
<p><strong>函数传递依赖</strong></p>
<p>例2：对于关系R（<u>X</u>, N, O, P），其中X为主键，若属性N依赖于X，而X不依赖于N，属性O依赖于N。则属性O函数传递依赖于X。</p>
<p><strong>多值函数依赖</strong></p>
<p>例3：对于教学关系R（课程, 教师, 课程参考书），一门课程可以有多个任课教师，也可以有多本参考书；每个任课教师可以任意选择他的参考书。该关系存在多值函数依赖。</p>
<p>如果X、Y是1:1的联系，则X↔Y。<br>如学号联系电话，即知道了学号，就可以在表中确定其联系电话;同样地，知道了联系电话，也可以在表中确定其学号。</p>
<p>如果X，Y是n :1的联系，则X→Y。<br>如学号-班号，即知道了学号，就可以在表中确定其班号;相反地，如果知道了班号，却无法确定学号。</p>
<p>如果X、Y是m : n的联系，则X和Y不存在函数依赖关系。<br>如学号和课程号没有函数依赖关系。即知道了学号，无法在表中确定课程号;同样地，如果知道了课程号，也无法确定学号。</p>
<p><strong>关系规范化范式</strong>：将一个有异常访问的关系分解成结构良好的关系的过程，使这些关系有最小冗余或没有冗余。</p>
<p>一般在我们设计关系型数据库的时候，<strong>最多考虑到BCNF就够</strong>。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。</p>
<p><em>关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。</em></p>
<ul>
<li><p>第一范式：关系表中属性不可再细分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/670f90e0d6a186d12a2a4545aea3ecd3.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/fcb526f0fae9df53625b573a822010e5.png"></p>
</li>
<li><p>第二范式：消除部分函数依赖，满足第一范式。</p>
<p>对于关系R（<u>X</u>,<u> Y</u>, N, O, P），其中（<u>X</u>,<u> Y</u>）为复合主键，N,O,P这三个非键属性都不存在只依赖A或只依赖B情况，则该关系满足第2范式,反之,不满足第2范式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/18eb762805d229aedb0c0046fceba05f.png"></p>
<p>对于<strong>（学号，课名） → 姓名</strong>，有 <strong>学号 → 姓名</strong>，存在部分函数依赖。<br>对于<strong>（学号，课名） → 系名</strong>，有 <strong>学号 → 系名</strong>，存在部分函数依赖。<br>对于<strong>（学号，课名） → 系主任</strong>，有 <strong>学号 → 系主任</strong>，存在部分函数依赖。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/0f18dc0ff9021cf8a32473f18065b11f.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/0dee50526984e0c559f2b29b4bff492f.png"></p>
</li>
<li><p>第三范式：切断属性传递依赖，满足第二范式。</p>
<p>接下来我们看看上表中的设计，是否符合3NF的要求。</p>
<p>对于<strong>选课</strong>表，主码为（学号，课名），主属性为<strong>学号</strong>和<strong>课名，</strong>非主属性只有一个，为分数，不可能存在传递函数依赖，所以<strong>选课</strong>表的设计，符合3NF的要求。</p>
<p>对于<strong>学生</strong>表，主码为<strong>学号</strong>，主属性为<strong>学号</strong>，非主属性为<strong>姓名</strong>、<strong>系名</strong>和<strong>系主任</strong>。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性<strong>系主任</strong>对于码<strong>学号</strong>的传递函数依赖，所以<strong>学生</strong>表的设计，不符合3NF的要求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/81582f29379da3cbd33f483e3978b701.jpg"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/ebb592146a8c9226463de96b70780c2b.png"></p>
</li>
<li><p>巴斯-科德范式(BCNF)：所有属性函数依赖的决定因子都是候选键。在3NF基础上，任何<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%B1%9E%E6%80%A7/120103?fromModule=lemma_inlink">主属性</a>不能对主键子集依赖（在3NF基础上消除主属性对主码子集的依赖）</p>
<p>举例：</p>
<ol>
<li>某公司有若干个仓库；</li>
<li>每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；</li>
<li>一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。</li>
</ol>
<p>那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？</p>
<p>答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量<br>主属性：仓库名、管理员、物品名<br>非主属性：数量<br>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p>
<p>但是存在主属性【仓库名】对于码（管理员，物品名）的部分函数依赖。</p>
<p>解决办法就是要在 3NF 的基础上消除<strong>主属性</strong>对于码的部分与传递函数依赖。</p>
<p>仓库（仓库名，管理员）<br>库存（仓库名，物品名，数量）</p>
</li>
<li><p>第四范式：消除多值函数依赖，满足巴斯-科德范式</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_21-43-16.png"></p>
</li>
</ul>
<p>关系的规范化程度依次提升:1NF→2NF →3NF→BCNF→ 4NF<br>关系的规范化程度越高，关系数据库存储的冗余数据就越少，可消除的数据访问异常就越多。不过关系的规范化程度越高，分解出来的关系表就越多，但在数据查询访问时，需关联更多关系表，其数据库处理效率会降低。</p>
<p>综合例题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-43-30.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-43-41.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-43-49.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-43-59.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-44-09.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-44-15.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-44-21.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-44-28.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-44-37.png">所谓<strong>逆规范化</strong>，就是适当降低规范化范式约束，不再要求一个关系表必须达到很高的规范化程度，而是允许适当的数据冗余性，以获取数据访问性能。<br>逆规范化处理的基本方法:<br>(1)增加冗余列或派生列<br>(2)多个关系表合并为一个关系表</p>
<p>在E-R模型中，一个实体的其他关联实体数量称为什么？联系度数</p>
<p>在E-R模型图中，在定义一个实体时，必须指定它的标识符。 错误！！</p>
<h2 id="第五章-数据库管理"><a href="#第五章-数据库管理" class="headerlink" title="第五章 数据库管理"></a>第五章 数据库管理</h2><p>数据库管理概论</p>
<p>是指为保证数据库系统的正常运行和服务质量必须进行的系统管理工作。</p>
<p>为什么需要数据库管理?</p>
<ul>
<li>数据库系统随规模增大,系统会变得异常复杂</li>
<li>多用户数据库应用带来数据库访问复杂性</li>
<li>数据安全和数据隐私对机构和用户都非常重要</li>
<li>数据库系统随数据量增加和使用时间增长其性能会降低</li>
<li>系统遭遇意外事件，数据库损坏或数据丢失</li>
</ul>
<p>数据库管理目标</p>
<ul>
<li>保障数据库系统正常稳定运行</li>
<li>充分发挥数据库系统的软硬件处理能力</li>
<li>确保数据库系统安全和用户数据隐私性</li>
<li>有效管理数据库用户及其角色权限</li>
<li>解决数据库系统性能优化、系统故障与数据损坏等问题</li>
<li>最大程度地发挥数据库对其所属机构的作用</li>
</ul>
<p>在数据库中，<strong>事务</strong>(Transaction）是指针对<strong>单个业务处理功能</strong>的一组数据库访问操作，要求它们要么都成功执行，要么都不执行。在数据库系统中，<em><strong>事务是DBMS执行的最小任务单元。同时，事务也是DBMS最小的故障恢复任务单元和并发控制任务单元。</strong></em></p>
<p>事务<strong>ACID</strong>特性:</p>
<blockquote>
<p><strong>原子性</strong>（Atomicity):事务所有操作在数据库中要么全部执行，要么全部不执行。<br><strong>一致性</strong>(Consistency) :事务多次执行，其结果应一致。<br><strong>隔离性</strong>（lsolation):事务与事务之间隔离，并发执行透明。<br><strong>持续性</strong>(Durability ) :事务完成后，数据改变必须是永久的。</p>
</blockquote>
<p>事务SQL</p>
<ul>
<li>BEGIN 或 START TRANSACTION ；事务开始语句</li>
<li>ROLLBACK ；事务回滚语句</li>
<li>COMMIT ；事务提交语句</li>
<li>SAVEPOINT ；事务保存点语句</li>
</ul>
<p><a href="https://imgse.com/i/pCP9sAg"><img src="https://s1.ax1x.com/2023/06/05/pCP9sAg.png" alt="pCP9sAg.png" border="0" /></a><br>例：在选课管理数据库CurriculaDB中，使用事务程序实现对学院信息表College的数据插入，其事务SQL程序如下：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> college( collegeID, collegename)<span class="keyword">VALUES</span> (<span class="string">&#x27;004&#x27;</span>, <span class="string">&#x27;外语学院&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> college( collegeID, collegename)<span class="keyword">VALUES</span> (<span class="string">&#x27;005&#x27;</span>, <span class="string">&#x27;数学学院&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> college( collegeID, collegename)<span class="keyword">VALUES</span> (<span class="string">&#x27;006&#x27;</span>, <span class="string">&#x27;临床医学院&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>在事务过程中禁止使用的SQL语句：</p>
<blockquote>
<p>创建数据库 CREATE  DATABASE<br>修改数据库 ALTER  DATABASE<br>删除数据库 DROP  DATABASE<br>恢复数据库 RESTORE  DATABASE<br>加载数据库 LOAD  DATABASE<br>备份日志文件 BACKUP  LOG<br>恢复日志文件 RESTORE  LOG<br>授权操作 GRANT</p>
</blockquote>
<p>若用户没有显式地定义事务时，DBMS按默认事务方式处理，<strong>即每执行一个SQL语句将自动构成一个事务</strong>。若将多条SQL语句定义为一个事务时，才使用专门的事务SQL语句显式地定义事务。</p>
<p>为什么需要并发控制？</p>
<p>当多个事务程序在DBMS系统中同时运行时，可能会出现对一些共享数据同时进行访问操作，如一些事务修改数据，另一些事务读取数据。这些并发的共享数据操作，如果在DBMS中没有一定的约束控制情况下，可能会带来<strong>数据不一致性</strong>或<strong>事务程序死锁</strong>问题。因此，在多个事务并发运行时，必须进行并发控制处理。</p>
<p>并发控制–事务调度</p>
<p>目的</p>
<ul>
<li>支持并发事务处理，使更多用户并行操作，提高系统的并发访问能力。</li>
<li>保证一个事务工作不会对另一个事务工作产生不合理的影响。</li>
</ul>
<p>并发控制需解决的问题：</p>
<ul>
<li>丢失更新数据：对共享数据进行非锁定资源的读写操作。</li>
<li>脏数据读取：事务读取一个被取消持久化的共享数据。（事务读到的数据最后被回滚了，读到的是假数据）</li>
<li>不可重复读取：指一个事务对一个共享数据重复多次读取，但前后读取的数据不一致。（修改或删除）</li>
<li>幻像读取：后一次读比前一次读多了一些记录（插入）</li>
</ul>
<p><strong>并发事务调度</strong>就是控制多个事务的<strong>数据操作语句按照恰当的顺序访问共享数据</strong>，使这些事务执行之后，避免造成数据的不一致性，即解决“丢失更新数据”、“不可重复读”、“脏数据读”等问题。</p>
<p><strong>事务调度策略</strong></p>
<p>例：银行客户A的账户当前余款为1000元，客户B的账户当前余款为1500元。现在有两个事务T1和T2，其中T1事务将从客户A转账200元到客户B，T2事务也将从客户A转账400元到客户B。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-18-05.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-18-14.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-18-31.png"></p>
<p>在事务并发执行中，只有当事务中数据操作调度顺序的执行结果与事务串行执行结果一样时，该并发事务调度才能保证数据操作的正确性和一致性。符合这样效果的调度称为<strong>可串行化调度</strong>。<br>DBMS并发事务调度目标：使并发事务调度实现的处理结果与串行化调度处理结果<strong>一致</strong>。</p>
<p>锁</p>
<ul>
<li><strong>排它锁定</strong>(Lock-X)——锁定后，<strong>不允许</strong>其它事务对共享数据再加锁</li>
<li><strong>共享锁定</strong>(Lock-S)——锁定后，只允许其它事务对共享数据<strong>添加读取锁</strong></li>
</ul>
<p>资源锁定粒度</p>
<ul>
<li>数据库——粒度最大</li>
<li>表——粒度较大</li>
<li>页面——粒度中等</li>
<li>行——粒度小</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-28-05.png"></p>
<p>加锁协议</p>
<p><strong>一级加锁协议</strong>：任何事务在修改共享数据对象之前，必须对该数据执行排它锁定指令，直到该事务处理完成，才进行解锁指令执行。</p>
<p>特点：使用一级加锁协议，可<strong>避免出现更新丢失</strong>问题。但不能解决“不可重复读取”、“脏读”等数据不一致问题。</p>
<p>例：某航班剩余机票数据A的当前值为100张。现有分别来自不同售票点的两个并发事务T1和T2，其中T1事务将售出1张机票，T2事务将售出2张机票。以下分别给出它们在不加锁和按一级加锁协议的并发事务调度执行情况，见下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-37-29.png"></p>
<p><strong>二级加锁协议</strong>：在一级加锁协议基础上，针对并发事务的共享数据读操作，<strong>必须对该数据执行共享锁定指令</strong>，<strong>读完数据后即刻释放共享锁定</strong>。</p>
<p>特点：该加锁协议不但可以防止“丢失更新”的数据不一致性问题，还可防止出现<strong>脏读数据</strong>问题。但有可能会出现“不可重复读取”的数据不一致问题。</p>
<p>例：某航班剩余机票数据A的当前值为100张。现有分别来自不同售票点的两个并发事务T1和T2，其中T1事务将售出1张机票，T2事务进行机票空余数查询。以下分别给出它们在按一级加锁协议执行和按二级加锁协议的事务调度执行情况，见下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-39-03.png"></p>
<p><strong>三级加锁协议</strong>：在一级加锁协议基础上，当并发事务对共享数据进行读操作，必须对该数据执行共享锁定指令，直到该<strong>事务处理结束才释放共享锁定</strong>。</p>
<p>特点：该加锁协议不但可以防止“丢失更新”、“脏读”的数据不一致性问题，还可防止出现“不可重复读取”的数据一致性问题。</p>
<p>例：某航班剩余机票数据A的当前值为100张。现有分别来自不同售票点的两个并发事务T1和T2，其中T1事务将售出1张机票，T2事务进行机票空余数查询。以下分别给出它们在按二级加锁协议执行和按三级加锁协议的并发事务调度执行情况，见下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-39-19.png"></p>
<p>不同级别锁协议比较</p>
<table>
<thead>
<tr>
<th align="left"><strong>加锁协议级别</strong></th>
<th align="left"><strong>排它锁</strong></th>
<th align="left"><strong>共享锁</strong></th>
<th align="left"><strong>不丢失更新</strong></th>
<th align="left"><strong>不脏读</strong></th>
<th align="left"><strong>可重复读</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>一级</strong></td>
<td align="left">全程加锁</td>
<td align="left">不加</td>
<td align="left">是</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left"><strong>二级</strong></td>
<td align="left">全程加锁</td>
<td align="left">开始时加锁，读完数据释放锁定</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left"><strong>三级</strong></td>
<td align="left">全程加锁</td>
<td align="left">全程加锁</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>保证并发事务可串行化的一个协议是：<strong>二阶段锁定协议</strong></p>
<p>二阶段锁定协议规定每个事务必须分两个阶段提出加锁和解锁申请:</p>
<blockquote>
<p>增长阶段，事务只能获得锁，但不能释放锁。</p>
<p>缩减阶段，事务只能释放锁，但不能获得新锁。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-58-44.png"></p>
<p>在基于锁机制的并发事务执行中，如果这些事务同时锁定两个以及以上资源时，可能会出现彼此都不能继续执行的状态，即<strong>事务死锁</strong>状态。</p>
<p>例 两个事务T1和T2，它们都需要加锁访问数据库表Table1和Table2，其事务程序见图6-20a所示。当这两个事务程序调度执行时，只要不是按可串行化调度执行，则它们在执行时会出现死锁状态，见图6-20b所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_21-01-25.png"></p>
<p>死锁出现的必要条件</p>
<ul>
<li><p>互斥条件</p>
</li>
<li><p>请求和保持条件</p>
</li>
<li><p>不剥夺条件</p>
</li>
<li><p>环路等待条件</p>
</li>
</ul>
<p>防范死锁的策略</p>
<ul>
<li><p>允许事务一次发出当前所需全部资源的锁定，使用完成后，再释放给其它事务使用。</p>
</li>
<li><p>规定所有应用程序锁定资源的顺序必须完全相同。</p>
</li>
</ul>
<p>解决死锁的办法：当发生死锁时，回滚其中的一个事务，并取消它对数据库所做的改动。<br><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_21-03-36.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_21-10-46.png"></p>
<p>例：创建一个新用户，其账号名字为“userA”，密码为“123456”。该用户具有登录权限(Login）和角色继承权限（Inherit）系统权限，但它不是超级用户(SuperUser)，不具有创建数据库权限（CreateDB)、创建角色权限（CreateRole）、数据库复制权限（Replication) ,此外数据库连接数(Connection Limit）不受限。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> &quot;userA&quot; <span class="keyword">WITH</span></span><br><span class="line">	<span class="keyword">LOGIN</span> <span class="comment">--登录权限</span></span><br><span class="line">	<span class="keyword">NOSUPERUSER</span> <span class="comment">--不是超级用户</span></span><br><span class="line">	<span class="keyword">NOCREATEDB</span> <span class="comment">--不能创建数据库</span></span><br><span class="line">	<span class="keyword">NOCREATEROLE</span> <span class="comment">--没有创建角色权限</span></span><br><span class="line">	<span class="keyword">INHERIT</span> <span class="comment">--继承系统权限</span></span><br><span class="line">	<span class="keyword">NOREPLICATION</span> <span class="comment">--没有数据库复制权限</span></span><br><span class="line">	<span class="keyword">CONNECTION</span> <span class="keyword">LIMIT</span> <span class="number">-1</span> <span class="comment">--数据库连接数不受限</span></span><br><span class="line">	<span class="keyword">PASSWORD</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>修改删除用户：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span>  &lt;用户名&gt;  [ [ <span class="keyword">WITH</span> ] <span class="keyword">option</span> [ ... ] ];  	<span class="comment">--修改用户的属性</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span>  &lt;用户名&gt;  <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新用户名&gt;;  		<span class="comment">--修改用户的名称</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span>  &lt;用户名&gt;  <span class="keyword">SET</span> &lt;参数项&gt; &#123; <span class="keyword">TO</span> | = &#125; &#123; <span class="keyword">value</span> | <span class="keyword">DEFAULT</span> &#125;;												<span class="comment">--修改用户的参数值  </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span>  &lt;用户名&gt;  <span class="keyword">RESET</span> &lt;参数项&gt;;			<span class="comment">--重置用户参数值</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> userA;</span><br></pre></td></tr></table></figure>

<p>例：修改用户“userA”的账号密码为“gres123”。同时也限制该用户的数据库连接数为10。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> &quot;userA&quot; </span><br><span class="line">	<span class="keyword">CONNECTION</span> <span class="keyword">LIMIT</span> <span class="number">10</span></span><br><span class="line">	<span class="keyword">PASSWORD</span> <span class="string">&#x27;gres123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在DBMS中，为了方便对众多用户及其权限进行管理，通常将一组具有相同权限的用户定义为<strong>角色</strong>(Role)。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt; [ [ <span class="keyword">WITH</span> ] <span class="keyword">option</span> [ ... ] ]; 	 <span class="comment">--创建角色</span></span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt;  [ [ <span class="keyword">WITH</span> ] <span class="keyword">option</span> [ ... ] ]; 	 <span class="comment">--修改角色属性</span></span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt;  <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新角色名&gt;; 		 <span class="comment">--修改角色名称 </span></span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt;  <span class="keyword">SET</span> &lt;参数项&gt; &#123; <span class="keyword">TO</span> | = &#125; &#123; <span class="keyword">value</span> | <span class="keyword">DEFAULT</span> &#125;; </span><br><span class="line">									 <span class="comment">--修改角色参数值</span></span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt;  <span class="keyword">RESET</span> &lt;参数项&gt;;			 <span class="comment">--复位角色参数值</span></span><br><span class="line"><span class="keyword">DROP</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt;;						 <span class="comment">--删除指定角色</span></span><br></pre></td></tr></table></figure>

<p>例 ：在工程项目管理系统中，假定需要在ProjectDB数据库内创建经理角色Role_Manager。该角色具有登录权限（Login）和角色继承权限（Inherit）系统权限，但它不是超级用户（SuperUser），不具有创建数据库权限（CreateDB）、创建角色权限（CreateRole）、数据库复制权限（Replication），此外数据库连接数（Connection Limit）不受限。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">ROLE</span>  &quot;Role_Manager&quot;  <span class="keyword">WITH</span></span><br><span class="line"> <span class="keyword">LOGIN</span></span><br><span class="line"> <span class="keyword">NOSUPERUSER</span></span><br><span class="line"> <span class="keyword">NOCREATEDB</span></span><br><span class="line"> <span class="keyword">NOCREATEROLE</span></span><br><span class="line"> <span class="keyword">INHERIT</span></span><br><span class="line"> <span class="keyword">NOREPLICATION</span></span><br><span class="line"> <span class="keyword">CONNECTION</span> <span class="keyword">LIMIT</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>角色权限授予</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>  <span class="keyword">ON</span>  Department  <span class="keyword">TO</span> &quot;Role_Manager&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_21-26-06.png"></p>
<p><strong>数据库备份方法</strong>：</p>
<ul>
<li>完全数据库备份</li>
<li>差异数据库备份</li>
<li>事务日志备份</li>
<li>文件备份</li>
</ul>
<p>下面哪种备份文件是恢复数据库到故障点时刻状态必不可少的?</p>
<p>A．数据库完整备份文件	B．数据库差异备份文件</p>
<p><strong>C．事务日志备份文件</strong>	D．数据库文件备份</p>
<p>C. 事务日志备份文件是恢复数据库到故障点时刻状态必不可少的。事务日志是数据库管理系统用来记录数据库中的所有修改操作的文件。在进行数据库恢复时，事务日志记录的变更可以被用来重做或者撤销，从而将数据库恢复到某个指定的时间点或者事务点的状态。因此，事务日志备份文件非常重要，是进行数据库恢复的必要条件。A. 数据库完整备份文件包含整个数据库的所有数据，但是无法恢复到某个指定的时间点或者事务点的状。B. 数据库差异备份文件只包含自上次完整备份或差异备份以来发生的数据变更，也无法恢复到某个指定的时间点或者事务点的状态，因此也不一定是恢复到故障点时刻状态必不可少的。D. 数据库文件备份只是将数据库文件复制到另一个位置，也无法恢复到某个指定的时间点或者事务点的状态。</p>
<p>对于意外事件导致数据库系统损坏，最可靠的技术手段是<br>A.数据库备份与恢复<br>B.采用双机容错技术<br>C.进行访问权限控制<br>D.<strong>系统异地容灾</strong></p>
<p>在数据库系统安全模型中，哪种安全管理手段是DBMS系统提供的数据库安全访问机制?</p>
<p>A.用户身份认证<br>B.<strong>用户存取权限控制</strong><br>C.文件安全访问<br>D.数据加密存储</p>
<p>哪种数据库备份方式可以支持系统连续运行?</p>
<p>A.冷备份<br>B.<strong>热备份</strong><br>C.完整备份<br>D.差异备份</p>
<p>热备份可以支持系统连续运行。热备份是一种在系统运行时备份数据库的方法，备份期间数据库可以继续提供服务，不会中断用户对数据库的访问。在热备份期间，DBMS系统会将数据库的活动日志记录下来，并将备份与日志进行同步，以确保备份的数据与源数据库保持一致。热备份可以保证数据库系统的连续性和高可用性。相对而言，冷备份是在系统停止运行时备份数据库的方法，需要停止数据库服务，将数据库系统完全关闭，进行备份操作，备份期间数据库无法提供服务。冷备份会导致数据库系统的停机时间较长，并且备份数据与源数据库之间存在时间差，无法实时保持同步。完整备份和差异备份都是备份数据的方式，完整备份是将整个数据库备份，差异备份是只备份自上次备份后发生更改的数据，但它们并不能支持数据库系统的连续运行，需要在备份期间停止数据库服务。</p>
<p>在哪个粒度上对共享数据进行加锁访问，系统并发访问性能最好？行！</p>
<p>DBMS系统可自动恢复哪类数据？事务故障的数据错误</p>
<h2 id="第六章-数据库应用编程"><a href="#第六章-数据库应用编程" class="headerlink" title="第六章 数据库应用编程"></a>第六章 数据库应用编程</h2><p>开放式数据库互连（Open DataBase Connectivity）实现了应用程序对多种不同DBMS的数据库的访问，实现了数据库连接方式的变革。</p>
<p>ODBC定义了一套基于SQL的，公共的，与数据库无关的API，从而使得应用程序与数据库管理系统之间在逻辑上独立，使应用程序与数据库无关性</p>
<p>ODBC应用程序接口(ODBCAPI)是一种使用ODBC技术实现应用程序与数据库互连的标准接口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_22-26-31.png"></p>
<p>应用程序使用ODBC访问数据库的步骤：</p>
<blockquote>
<p>在ODBC驱动管理器中注册一个数据源;<br>根据数据源提供的数据库位置、数据库名称及驱动程序等信息，驱动管理器建立起ODBC与具体数据库的联系;<br>应用程序使用数据源建立与相应数据库的连接;<br>应用程序通过驱动程序管理器与数据库管理系统交换信息;<br>数据库管理系统执行完相应的SQL操作后，将结果通过驱动程序管理器返回给应用程序。</p>
</blockquote>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_22-26-52.png"></p>
<p>(1）加载驱动<br>加载JDBC驱动是通过调用方法:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span>.forName(&quot;驱动名字&quot;)</span><br></pre></td></tr></table></figure>

<p>例PostgreSQL数据库驱动程序加载语句:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span>.forName (&quot;org.postgresql.Driver&quot;)</span><br></pre></td></tr></table></figure>

<p>(2）建立连接<br>调用DriverManager. getConnection(String urI)方法建立数据库连接。</p>
<p>例：PostgreSQL数据库连接程序:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">String URL = &quot;jdbc: postgresql://localhost:5432/testdb&quot;;</span><br><span class="line">String userName = &quot;myuser &quot;;</span><br><span class="line">String <span class="keyword">passWord</span> = &quot;sa&quot;;</span><br><span class="line"><span class="keyword">connection</span> conn =</span><br><span class="line">DriverManager. getConnection(URL, userName, <span class="keyword">passWord</span>);</span><br></pre></td></tr></table></figure>

<p>(3)创建Statement对象<br>采用Connection对象的createStatement()方法创建Statement对象。其语句如下:<br>Statement stmt &#x3D; conn. createStatement () ;<br>(4）执行SQL语句<br>在创建Statement对象后，就可以调用Statement对象的executeQuery()、executeUpdate()方法执行SQL语句。</p>
<ul>
<li>executeQuery()用于执行select语句</li>
<li>executeUpdate()用于执行update、 insert、 delete语句</li>
</ul>
<p>例:Statement对象的SQL执行</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Statement</span> stmt = conn.createStatement() ;</span><br><span class="line">String <span class="keyword">sql</span> = &quot;INSERT INTO public.student (sid,sname,gender,birthday,major,phone)&quot; + &quot;VALUES (&#x27;2017001&#x27;，&#x27;张山&#x27;,&#x27;男&#x27;,&#x27;1998-10-10&#x27;,&#x27;软件工程&#x27;,&#x27;13602810001&#x27;)&quot;;</span><br><span class="line">stmt.executeUpdate(<span class="keyword">sql</span>) ;</span><br></pre></td></tr></table></figure>

<p>(5)ResultSet结果集<br>ResultSet对象作为结果集，它存放了执行SQL语句的返回结果数据。通过getXXX方法可以对结果集中的记录数据进行访问。<br>ResultSet中若包含了多行结果数据，可以使用记录指针访问它们。指针所指向的数据行叫做当前数据行。移动指针可以访问其他行，这需要使用ResultSet的next()方法。<br>示例代码如下:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">rs = stmt.executeQuery (<span class="keyword">sql</span>) ;</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;//依次取出数据</span><br><span class="line">	String <span class="type">name</span> = rs.getString(&quot;name&quot;) ; //取出<span class="type">name</span>列的内容</span><br><span class="line">	<span class="type">int</span> age = rs.getlnt(&quot;age&quot;) ; //取出age列的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(6）关闭连接<br>作为一种好的编程风格，在不需要ResultSet对象、Statement对象和Connection对象时，应该显式地关闭它们。关闭这些对象的方法为:close() ;<br>示例:</p>
<blockquote>
<p>rs.close();关闭结果集对象</p>
<p>stmt.close();关闭执行对象</p>
<p>conn.close();关闭连接对象</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_10-03-38.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_10-03-52.png"></p>
<p>Servlet是用Java语言编写的服务器端小程序，驻留在web服务器中运行，它扩展了web服务器的动态处理功能。</p>
<blockquote>
<p>1.客户机将HTTP请求发送给Web服务器</p>
<p>2.Web 服务器将该请求转发给Servlet</p>
<p>3.Servlet处理该请求</p>
<p>4.Servlet将响应发送给Web 服务器</p>
<p>5.Web服务器将响应转发给客户机</p>
</blockquote>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程(Stored Procedure）是数据库中的一种对象;由一组完成特定数据处理功能的SQL语句和过程语句组成的程序;它被编译后，存储在数据库中;外部程序可以调用数据库的存储过程执行。</p>
<p>PostgreSQL使用CREATE FUNCTION命令创建存储过程。(10版本后可以用CREATE PRECEDURE)</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR REPLACE</span> ] <span class="keyword">FUNCTION</span>/<span class="keyword">PROCEDURE</span>  <span class="type">name</span></span><br><span class="line">    ( [ [ argmode ] [ argname ] argtype [ &#123; <span class="keyword">DEFAULT</span> | = &#125; default_expr ] [, ...] ] )</span><br><span class="line">    [ <span class="keyword">RETURNS</span> retype | <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span> ( <span class="built_in">column_name</span>  column_type [, ...] ) ]</span><br><span class="line"><span class="keyword">AS</span> $$<span class="language-java">         <span class="comment">//$$</span></span>用于声明存储过程的实际代码的开始</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">        <span class="comment">-- 声明段</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">--函数体语句</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$<span class="language-ruby"> <span class="variable constant_">LANGUAGE</span> lang_name;  <span class="regexp">//</span><span class="variable">$$</span></span> 表明代码的结束, <span class="keyword">LANGUAGE</span>后面指明所用的编程语言</span><br></pre></td></tr></table></figure>

<p>（1）name：要创建的存储过程名；<br>（2）OR REPLACE ：覆盖同名的存储过程；<br>（3）argmode：存储过程参数的模式可以为IN、OUT或INOUT，缺省值是IN。<br>（4）argname：形式参数的名字。<br>（5）RETURNS：返回值；RETURNS TABLE：返回二维表</p>
<p>例：创建一个名为countRecords()的过程函数统计STUDENT表的记录数。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR REPLACE</span> <span class="keyword">FUNCTION</span> countRecords ()  </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">integer</span> <span class="keyword">AS</span> $$<span class="language-pgsql">  </span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">declare</span>  </span></span><br><span class="line"><span class="language-pgsql">    count <span class="type">integer</span>;  </span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">BEGIN</span>  </span></span><br><span class="line"><span class="language-pgsql">   <span class="keyword">SELECT</span> count(*) <span class="keyword">into</span> count <span class="keyword">FROM</span> STUDENT;  </span></span><br><span class="line"><span class="language-pgsql">   <span class="keyword">RETURN</span> count;  </span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">END</span>;  </span></span><br><span class="line"><span class="language-pgsql">$$</span> <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>练习:创建一个increment(i)的过程函数计算自增值。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR REPLACE</span> <span class="keyword">FUNCTION</span> <span class="keyword">increment</span>(i integer)</span><br><span class="line">RETURNS integer AS $$</span><br><span class="line">BEGIN</span><br><span class="line">	RETURN i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$<span class="language-pgsql"><span class="keyword">LANGUAGE</span> plpgsql;</span></span><br></pre></td></tr></table></figure>

<p>例：创建一个名为add_data (a, b，c）的存储过程实现a+b相加运算，并将结果放入c。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR REPLACE</span> <span class="keyword">PROCEDURE</span> add_data(a <span class="type">integer</span>,b <span class="type">integer</span>,<span class="keyword">inout</span> c <span class="type">integer</span>)<span class="keyword">AS</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">Begin</span></span></span><br><span class="line"><span class="language-pgsql">	c=a+b;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">End</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span><span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>练习:创建一个increment_pro(i)的存储过程计算自增值。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR REPLACE</span> <span class="keyword">PROCEDURE</span> increment_pro(<span class="keyword">inout</span> i <span class="type">integer</span>)<span class="keyword">AS</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">BEGIN</span></span></span><br><span class="line"><span class="language-pgsql">	i=i+<span class="number">1</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">Return</span>;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">END</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span><span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>如果程序员需要调用<strong>函数</strong>执行，其调用方式如下:<br>select  函数名(参数);<br>或者:select * from 函数名(参数);</p>
<p>如果需要调用<strong>存储过程</strong>执行，其调用方式如下:<br>CALL存储过程名（参数)</p>
<p>删除存储过程<br>DROP FUNCTION [ IF EXISTS ] name ( [ [ argmode ] [ argname ] argtype [, …] ] ) [ CASCADE | RESTRICT ]<br>主要参数：<br>（1）IF EXISTS：如果指定的存储过程不存在，那么发出提示信息。<br>（2）name ：现存的存储过程名称。<br>（3）argmode：参数的模式：IN(缺省), OUT, INOUT, VARIADIC。请注意，实际并不注明OUT参数，因为判断存储过程的身份只需要输入参数。<br>（4）argname：参数的名字。请注意，实际上并不注明参数的名字，因为判断函数的身份只需要输入参数的数据类型。<br>（5）argtype：如果有的话，是存储过程参数的类型。<br>（6）CASCADE：级联删除依赖于存储过程的对象(如触发器)。<br>（7）RESTRICT：如果有任何依赖对象存在，则拒绝删除该函数；这个是缺省值。</p>
<p>删除前面定义的函数testExec()</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> testExec();</span><br></pre></td></tr></table></figure>

<p>例删除前面定义的存储过程maintenance()</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> maintenance();</span><br></pre></td></tr></table></figure>

<h3 id="PL-pgSQL基本语法"><a href="#PL-pgSQL基本语法" class="headerlink" title="PL&#x2F;pgSQL基本语法"></a>PL&#x2F;pgSQL基本语法</h3><p>变量声明的语法如下：<br> declare<br>     变量名  变量类型；<br>如果声明变量为记录类型，变量声明格式为： variable_name RECORD;<br>注：RECORD不是真正的数据类型，只是一个占位符。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> </span><br><span class="line">	count intger;</span><br><span class="line">    rec <span class="type">RECORD</span>;</span><br></pre></td></tr></table></figure>

<p>条件语句<br>在PL&#x2F;pgSQL中有以下三种形式的条件语句<br>1)IF-THEN </p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> <span class="type">boolean</span>-expression <span class="keyword">THEN</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>; </span><br></pre></td></tr></table></figure>

<p>2)IF-THEN-ELSE</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> <span class="type">boolean</span>-expression <span class="keyword">THEN</span></span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">Statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br></pre></td></tr></table></figure>

<p> 3)IF-THEN-ELSIF-ELSE</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> <span class="type">boolean</span>-expression <span class="keyword">THEN</span></span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">ELSIF</span> <span class="type">boolean</span>-expression <span class="keyword">THEN</span></span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">ELSIF</span> <span class="type">boolean</span>-expression <span class="keyword">THEN</span></span><br><span class="line">     statements</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>; </span><br></pre></td></tr></table></figure>

<p>循环语句<br>1)LOOP 语句</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOOP</span></span><br><span class="line"> statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span> [ label ];</span><br></pre></td></tr></table></figure>

<p>2)EXIT</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOOP</span></span><br><span class="line">	count=count+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">EXIT</span> <span class="keyword">WHEN</span> count &gt;<span class="number">100</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure>

<p>3)CONTINUE</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOOP</span></span><br><span class="line"> 	count=count+<span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">EXIT</span> <span class="keyword">WHEN</span> count &gt; <span class="number">100</span>;</span><br><span class="line"> 	<span class="keyword">CONTINUE</span> <span class="keyword">WHEN</span> count &lt; <span class="number">50</span>;</span><br><span class="line"> 	count=count+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>; </span><br></pre></td></tr></table></figure>

<p> 4)WHILE</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHILE</span> amount_owed &gt; <span class="number">0</span> <span class="keyword">AND</span>  balance &gt; <span class="number">0</span> <span class="keyword">LOOP</span></span><br><span class="line">    <span class="comment">--do something</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure>

<p>5)FOR</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.<span class="number">.10</span> <span class="keyword">LOOP</span></span><br><span class="line">	<span class="keyword">RAISE</span> <span class="keyword">NOTICE</span> <span class="string">&#x27;i IS %&#x27;</span>,i;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"><span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="keyword">REVERSE</span> <span class="number">10.</span>.<span class="number">.1</span>  <span class="keyword">LOOP</span></span><br><span class="line">      <span class="comment">--do something</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure>

<p>遍历查询结果集</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> record_or_row <span class="keyword">IN</span> query <span class="keyword">LOOP</span></span><br><span class="line">     statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span> ;</span><br></pre></td></tr></table></figure>

<p>FOR循环可以遍历命令的结果并操作相应的数据，例如：</p>
<p>编写函数实现对学生表Student的查询结果集数据输出</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> Out_Record() <span class="keyword">returns</span> <span class="type">RECORD</span> <span class="keyword">as</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">declare</span> </span></span><br><span class="line"><span class="language-pgsql">	rec <span class="type">RECORD</span>;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">FOR</span> rec <span class="keyword">IN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">LOOP</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">raise</span> <span class="keyword">notice</span> <span class="string">&#x27;学生数据: %,%&#x27;</span>,rec.studentID,rec.studentName; </span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">return</span> rec;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">end</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span> <span class="keyword">language</span> plpgsql;</span><br></pre></td></tr></table></figure>

<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是特殊类型的存储过程，其过程程序由事件(如INSERT、UPDATE、DELETE操作等）触发而自动执行。</p>
<p>触发器用途:可以实现比约束更复杂的数据完整性，经常用于加强数据的完整性约束和	业务规则。</p>
<p>触发器特点</p>
<ul>
<li>与数据库对象相关:在表或视图上执行DML、DDL操作，其定义的事件触发<br>过程程序执行。</li>
<li>DML事件触发:由执行INSERT、DELETE、UPDATE操作时触发。</li>
<li>DDL事件触发:由执行CRETE、ALTER、DROP、SELECT INTO操作时触发。</li>
</ul>
<p>按DML操作语句分类: INSERT触发器、DELETE触发器、UPDATE触发器<br>按触发器执行次数分类:</p>
<blockquote>
<p>(1）语句级触发器:由关键字FOR EACH STATEMENT声明，在触发器作用的表上执行一条SQL语句时，该触发器程序只执行一次，即使是修改了零行数据的SQL，也会导致相应的触发器执行。FOR EACH STATEMENT为默认值。</p>
<p>(2）行级触发器:由关键字FOR EACH ROW标记的触发器，当触发器所在表中数据发生变化时，每变化一行就会执行一次触发器程序。</p>
</blockquote>
<p>例：学生成绩表上定义了行级DELETE触发器。如果该表删除了20条记录，则将导致DELETE触发器程序被执行20次。</p>
<p>按触发的时间分类:</p>
<blockquote>
<p>(1）BEFORE触发器:在触发事件之前执行触发器程序。<br>(2）AFTER触发器:在触发事件之后执行触发器程序。<br>(3）INSTEAD OF触发器:当触发事件发生后，执行触发器中指定的过程程序，而不是执行产生触发事件的SQL语句。</p>
</blockquote>
<p>触发器相关的特殊变量</p>
<p>1）NEW 数据类型是RECORD。对于行级触发器，它存有INSERT或UPDATE操作产生的新的数据行。对于语句级触发器，它的值是NULL。</p>
<p>2）OLD 数据类型是RECORD。对于行级触发器，它存有被UPDATE或DELETE操作修改或删除的旧的数据行。对于语句级触发器，它的值是NULL。</p>
<p>3）TG_OP 数据类型是text；是值为INSERT、UPDATE、DELETE 的一个字符串，它说明触发器是为哪个操作引发。</p>
<p>创建触发器的基本语法</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TRIGGER</span>  触发器名   </span><br><span class="line">    &#123; <span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span> | <span class="keyword">INSTEAD</span> <span class="keyword">OF</span> &#125;</span><br><span class="line">     <span class="keyword">ON</span> 表名</span><br><span class="line">     [ <span class="keyword">FOR</span> [ <span class="keyword">EACH</span> ] &#123; <span class="keyword">ROW</span> | <span class="keyword">STATEMENT</span> &#125; ]</span><br><span class="line">     <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> 存储过程名 ( 参数列表 )</span><br></pre></td></tr></table></figure>

<p>（1）指明所定义的触发器名<br>（2） BEFORE | AFTER | INSTEAD OF  指明触发器被触发的时间<br>（3） ON 表名 指明触发器所依附的表<br>（4） FOR  EACH  { ROW | STATEMENT }  指明触发器是行级还是列级<br>（5） EXECUTE PROCEDURE 存储过程名 ( 参数列表 )  指明触发时所执行的存储过程</p>
<p>创建触发器的基本步骤</p>
<p>（1）检查数据库中将要创建的触发器所依附的表或视图是否存在，如果不存在，必须首先创建该表或视图。</p>
<p>（2）创建触发器被触发时所要执行的触发器函数，该函数的类型必须是Trigger型，是触发器的执行函数。</p>
<p>（3）创建触发器，定义触发器依附的表，触发器被触发执行的时间，触发器是行级触发器还是语句级触发器，触发器执行需要满足的条件。</p>
<p>为了审计Grade表的课程成绩修改，创建audit_score表记录Grade表的成绩变化，其表结构如下:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> audit_score( </span><br><span class="line">    changeID <span class="type">serial</span> <span class="keyword">not</span> <span class="keyword">null</span>,						<span class="comment">--修改序列号</span></span><br><span class="line">	username <span class="type">character</span>(<span class="number">20</span>),							<span class="comment">--操作用户</span></span><br><span class="line">	sid	<span class="type">character</span>(<span class="number">13</span>),								<span class="comment">--学号</span></span><br><span class="line">	cid	<span class="type">character</span>(<span class="number">4</span>),								<span class="comment">--课程编号</span></span><br><span class="line">	updatetime <span class="type">text</span>,								<span class="comment">--修改的时间</span></span><br><span class="line">	oldscore <span class="type">int</span>,									<span class="comment">--修改前的成绩</span></span><br><span class="line">	newscore <span class="type">int</span>,									<span class="comment">--修改后的成绩</span></span><br><span class="line">	<span class="keyword">constraint</span> changeID_PK <span class="keyword">primary key</span> (changeID)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建触发器函数</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or replace</span> <span class="keyword">function</span> score_audit() </span><br><span class="line"><span class="keyword">returns</span> <span class="type">trigger</span> <span class="keyword">as</span> $score_audit$</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">TG_OP</span> == <span class="string">&#x27;DELETE&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> audit_score(username,sid,cid,updatetime,oldscore)</span><br><span class="line">		<span class="keyword">select</span> <span class="keyword">user</span>,<span class="built_in">old</span>.studentid,<span class="built_in">old</span>.couseid,now(),<span class="built_in">old</span>.score;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">old</span>;</span><br><span class="line">	<span class="keyword">elsif</span> (<span class="built_in">TG_OP</span> == <span class="string">&#x27;UPDATE&#x27;</span>) <span class="keyword">then</span> </span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> audit_score(username,sid,cid,updatetime,oldscore,newscore)</span><br><span class="line">		<span class="keyword">select</span> <span class="keyword">user</span>,<span class="built_in">old</span>.studentid,<span class="built_in">old</span>.couseid,now(),<span class="built_in">old</span>.score,<span class="built_in">new</span>.score</span><br><span class="line">		<span class="keyword">where</span> <span class="built_in">old</span>.studentid = <span class="built_in">new</span>.sid <span class="keyword">and</span> <span class="built_in">old</span>.courseid = <span class="built_in">new</span>.cid;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span>;</span><br><span class="line">	<span class="keyword">elsif</span> (<span class="built_in">TG_OP</span> == <span class="string">&#x27;INSERT&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> audit_score(username,sid,cid,updatetime,oldscore,newscore)</span><br><span class="line">		<span class="keyword">select</span> <span class="keyword">user</span>,<span class="built_in">new</span>.studentid,<span class="built_in">new</span>.courseid,now(),<span class="keyword">null</span>,<span class="built_in">new</span>.score;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span>;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$score_audit$ <span class="keyword">language</span> plpgsql</span><br></pre></td></tr></table></figure>

<p>创建触发器</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> score_audit_triger</span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">OR</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> grade</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> score_audit();</span><br></pre></td></tr></table></figure>

<p>练习:在如下雇员表emp中被插入或更新一行数据时，触发函数程序将当前用户名和时间标记在该数据行中,并且检查雇员的姓名以及薪水是否为空，若为空，输出警示信息。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">	emplD <span class="type">char</span>(<span class="number">3</span>) <span class="keyword">primary key</span>,</span><br><span class="line">    empname <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	salary <span class="type">integer</span>,</span><br><span class="line">	last_date <span class="type">timestamp</span>,</span><br><span class="line">    last_user <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>1.触发器函数程序</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> emp_stamp ()<span class="keyword">RETURNS</span> <span class="type">trigger</span> <span class="keyword">AS</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">BEGIN</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="comment">--检查给出了empname以及salary</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">IF</span> <span class="built_in">NEW</span>.empname <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span></span><br><span class="line"><span class="language-pgsql">			<span class="keyword">RAISE</span> <span class="keyword">EXCEPTION</span> <span class="string">&#x27;雇员名不能为空&#x27;</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">END</span> <span class="keyword">IF</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">IF</span> <span class="built_in">NEW</span>.salary <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span></span><br><span class="line"><span class="language-pgsql">			<span class="keyword">RAISE</span> <span class="keyword">EXCEPTION</span> <span class="string">&#x27;%薪水不能为空&#x27;</span>,<span class="built_in">NEW</span>.empname;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">END</span> <span class="keyword">IF</span>;</span></span><br><span class="line"><span class="language-pgsql">			<span class="comment">--记住谁在什么时候改变了工资单</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="built_in">NEW</span>.last_date := <span class="built_in">current_timestamp</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="built_in">NEW</span>.last_user := <span class="built_in">current_user</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">RETURN</span> <span class="built_in">NEW</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">END</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span> <span class="keyword">LANGUAGE</span> plpgsql ;</span><br></pre></td></tr></table></figure>

<p>2.触发器定义程序</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> emp_stamp</span><br><span class="line"><span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> emp</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> emp_stamp();</span><br></pre></td></tr></table></figure>

<p>触发器修改</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TRIGGER</span> <span class="type">name</span> <span class="keyword">ON</span> <span class="built_in">table_name</span> <span class="keyword">RENAME</span> <span class="keyword">TO</span> new_name</span><br></pre></td></tr></table></figure>

<p>主要参数说明：<br>（1）name：现有触发器的名称。<br>（2）table_name：该触发器作用的表名字。<br>（3）new_name：触发器的新名字。</p>
<p>例如：将上述定义的触发器改名为score_audit_trig</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TRIGGER</span> score_audit_trigger <span class="keyword">ON</span> stu_score  <span class="keyword">RENAME</span> <span class="keyword">TO</span> score_audit_trig;</span><br></pre></td></tr></table></figure>

<p>触发器删除</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [ <span class="keyword">IF</span> <span class="keyword">EXISTS</span> ] <span class="type">name</span> <span class="keyword">ON</span> <span class="built_in">table_name</span> [ <span class="keyword">CASCADE</span> | <span class="keyword">RESTRICT</span> ]</span><br></pre></td></tr></table></figure>
<p>主要参数说明：</p>
<blockquote>
<p>（1）IF EXISTS：如果指定的触发器不存在，那么发出提示而不是抛出错误。<br>（2）name：要删除的触发器名。<br>（3）table_name：触发器定义所依附的表的名称。<br>（5）CASCADE：级联删除依赖此触发器的对象。<br>（6）RESTRICT：如果有依赖对象存在，那么拒绝删除。该参数缺省是拒绝删除。</p>
</blockquote>
<p> 例如：将上述触发器score_audit_trig删除，同时<em>级联删除</em>依赖触发器的对象。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> score_audit_trig <span class="keyword">ON</span> grade <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure>

<h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><ul>
<li>游标（Cursor）是一种临时的数据库对象；</li>
<li>用来存放从数据库表中查询返回的数据记录；</li>
<li>提供了从结果集中提取并分别处理每一条记录的机制；</li>
<li>游标总是与一条SQL查询语句相关联；</li>
<li>游标包括：SQL语言的查询结果，指向特定记录的指针。</li>
</ul>
<p>声明游标</p>
<blockquote>
<p>使用refcursor关键词定义的游标变量</p>
<p>使用游标声明语句定义游标<br>游标名	CURSOR [ ( arguments ) ] FOR query</p>
</blockquote>
<p>例：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Declare</span></span><br><span class="line">curs	<span class="type">refcursor</span>;</span><br><span class="line">curStudent <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student;</span><br><span class="line">curStudentOne <span class="keyword">CURSOR</span> (key <span class="type">integer</span>)  <span class="keyword">IS</span> </span><br><span class="line">            <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> SID = key;</span><br></pre></td></tr></table></figure>

<p>打开游标<br>（1）OPEN FOR:<br>打开未绑定的游标变量，其query查询语句是返回记录的SELECT语句。例如： </p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> curVars1 <span class="keyword">FOR</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> SID = mykey;</span><br></pre></td></tr></table></figure>

<p>（2）OPEN FOR EXECUTE</p>
<p>打开未绑定的游标变量。EXECUTE将动态执行查询字符串。例如：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> curVars1 <span class="keyword">FOR</span> <span class="keyword">EXECUTE</span> <span class="string">&#x27;SELECT * FROM &#x27;</span> || quote_ident(<span class="meta">$1</span>);</span><br></pre></td></tr></table></figure>

<p>​    注意：$1是指由存储过程传递的第1个参数。<br>（3）打开绑定游标<br>仅适用于绑定的游标变量，只有当该变量在声明时包含接收参数，才能以传递参数的形式打开该游标，参数将传入到游标声明的查询语句中，例如：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> curStudent;</span><br><span class="line"><span class="keyword">OPEN</span> curStudentOne (<span class="string">&#x27;20160230302001&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>使用游标提取值<br>FETCH命令从游标中读取当前指针所指向记录的数据到目标中。可通过PL&#x2F;pgSQL内置的系统变量FOUND来判断读取是否成功。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> curVars1 <span class="keyword">INTO</span> rowvar;  <span class="comment">--rowvar为行变量</span></span><br><span class="line"><span class="keyword">FETCH</span> curStudent <span class="keyword">INTO</span> SID, Sname, sex;</span><br></pre></td></tr></table></figure>

<p>​    –请注意：游标的属性列必须与 目标列的数量一致，并且类型兼容。<br>关闭游标<br>当游标数据不再需要时，需要关闭游标，以释放其占有的系统资源，主要是释放游标数据所占用的内存资源</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> cursorName; </span><br></pre></td></tr></table></figure>

<p>需要注意：当游标被关闭后，如果需要再次读取游标的数据，需要重新使用open打开游标，这时游标重新查询返回新的结果。</p>
<p>例：在函数中使用游标查询student表的学号、学生姓名和性别。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or replace</span> <span class="keyword">function</span> cursorDemo()</span><br><span class="line"><span class="keyword">returns</span> <span class="type">boolean</span> <span class="keyword">as</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">declare</span></span></span><br><span class="line"><span class="language-pgsql">	unbound_refcursor <span class="type">refcursor</span>;</span></span><br><span class="line"><span class="language-pgsql">	vsid <span class="type">varchar</span>;</span></span><br><span class="line"><span class="language-pgsql">	vsname <span class="type">varchar</span>;</span></span><br><span class="line"><span class="language-pgsql">	vsgender <span class="type">varchar</span>;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">begin</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">open</span> unbound_refcursor <span class="keyword">for</span> <span class="keyword">execute</span> <span class="string">&#x27;select sid,sname,sex from 	student&#x27;</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">loop</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">fetch</span> unbound_refcursor <span class="keyword">into</span> vsid,vsname,vsgender;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">if</span> <span class="built_in">found</span> <span class="keyword">then</span></span></span><br><span class="line"><span class="language-pgsql">			<span class="keyword">raise</span> <span class="keyword">notice</span> <span class="string">&#x27;%,%,%&#x27;</span>,vsid,vsname,vsgender;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">else</span></span></span><br><span class="line"><span class="language-pgsql">			<span class="keyword">exit</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">end</span> <span class="keyword">if</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">end</span> <span class="keyword">loop</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">close</span> unbound_refcursor;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">raise</span> <span class="keyword">notice</span> <span class="string">&#x27;取数据循环结束...&#x27;</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">return</span> <span class="keyword">true</span>;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">end</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span> <span class="keyword">language</span> plpgsql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cursorDemo();</span><br></pre></td></tr></table></figure>

<p>例：编写带参数的游标函数，从成绩表中查询分数大于某给定值的学号和课程号。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or replace</span> <span class="keyword">function</span> cusorGrade(myscore <span class="type">int</span>)<span class="keyword">returns</span> <span class="type">void</span> <span class="keyword">as</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">declare</span></span></span><br><span class="line"><span class="language-pgsql">		vstuscore Grade<span class="meta">%ROWTYPE</span>;		<span class="comment">--声明与表Grade结构相同的行变量</span></span></span><br><span class="line"><span class="language-pgsql">		vstucursor <span class="keyword">cursor</span>(invalue <span class="type">int</span>)</span></span><br><span class="line"><span class="language-pgsql">			<span class="keyword">for</span> <span class="keyword">select</span> courseid,studentid,grade <span class="keyword">from</span> Grade <span class="keyword">where</span> 	grade&gt;=invalue <span class="keyword">order</span> <span class="keyword">by</span></span></span><br><span class="line"><span class="language-pgsql">studentid;								<span class="comment">--声明带有输入参数的游标</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">begin</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">open</span> vstucursor (myscore);			<span class="comment">--打开带有参数的游标</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">loop</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">fetch</span> vstucursor <span class="keyword">into</span> vstuscore;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">exit</span> <span class="keyword">when</span> <span class="keyword">not</span> <span class="built_in">found</span> ;			<span class="comment">--假如没有检索到记录，结束循环处理</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">raise</span> <span class="keyword">notice</span> <span class="string">&#x27;%,%,%&#x27;</span>, vstuscore.studentid,vstuscore.courseid,vstuscore.grade;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">end</span> <span class="keyword">loop</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">close</span> vstucursor ;				<span class="comment">--关闭游标</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">end</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span> <span class="keyword">language</span> plpgsql;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>存储过程和触发器的区别有:存储过程可以采用输入参数而触发器不可以</p>
</li>
<li><p>HTML语句和JSP语句都是下载到浏览器端来执行。X</p>
<p>  凡是使用到了java中的语言部分，一般都是在服务器端执行，解析后返回客户端形成标准的html</p>
</li>
</ul>
<p>Java嵌入SQL语句执行后，返回结果存储在什么对象中：ResultSet</p>
<p>Java嵌入SQL语句，能传递动态参数执行SQL语句查询的是什么接口：PreparedStatement</p>
<p>Java嵌入SQL语句，能调用执行存储过程的是什么接口：CallableStatement</p>
<p>从游标中读取数据，使用什么命令：fetch</p>
<h2 id="第七章-NoSQL数据库技术"><a href="#第七章-NoSQL数据库技术" class="headerlink" title="第七章 NoSQL数据库技术"></a>第七章 NoSQL数据库技术</h2><p>关系数据库局限</p>
<blockquote>
<p>不能直接管理非结构化数据</p>
<p>受单机服务器限制难以支持数据库高并发读写访问</p>
<p>受磁盘容量限制不能满足海量数据的高效存储和处理</p>
<p>难以实现分布式数据库的高扩展性、高可用性</p>
</blockquote>
<p><strong>大数据</strong>(big data)，指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合。</p>
<h3 id="5V特征"><a href="#5V特征" class="headerlink" title="5V特征"></a>5V特征</h3><ul>
<li>大量(Volume)</li>
<li>高速性(Velocity)</li>
<li>多样性（(Variety)</li>
<li>真实性(Veracity)</li>
<li>低价值(Value)</li>
</ul>
<p>(Not only SQL Database，<strong>NoSQL</strong>）是指一类非关系型、开源代码、具有水平扩展能力的分布式数据库。</p>
<p>NoSQL数据库的公共特性:</p>
<blockquote>
<p>支持非结构化数据存储，不用预先定义模式<br>分布式集群架构，无共享结构<br>弹性可扩展，可动态增减数据库结点数据分区存储，各分区结点并发访问<br>结点之间数据异步复制，实现最终数据一致性<br>数据处理遵循BASE特性原则</p>
</blockquote>
<h3 id="BASE特性"><a href="#BASE特性" class="headerlink" title="BASE特性"></a>BASE特性</h3><p>Basically Available（<strong>基本可用</strong>），允许数据库系统某些节点出现故障，其余节点能够继续运行，一直提供服务。<br>Soft state(<strong>软状态</strong>），允许数据库系统副本节点之间存在暂时的数据不一致，经过纠错处理，系统数据最终保持一致态。<br>Eventual Consistency(<strong>最终一致性</strong>），系统数据在某个时刻达到最终一致性。</p>
<p>分布式数据库一致性</p>
<blockquote>
<p>强一致性:无论更新操作在哪一个副本执行，数据复制必须同步完成。</p>
<p>弱一致性:数据更新后，其数据复制是异步完成，需要经过一定时间才能达到不同数据库结点数据一致。</p>
<p>最终一致性:弱一致性的一种特例，保证用户最终能够读取到更新数据。</p>
</blockquote>
<p>NoSQL数据库典型类型：<br><strong>键值数据库</strong>、<strong>图数据库</strong>、<strong>列式数据库</strong>、<strong>文档数据库</strong>。</p>
<p>NoSQL数据库与关系数据库比较</p>
<blockquote>
<p>NoSQL数据库采用非结构化数据存储模型，关系数据库采用结构化数据存储模型<br>NoSQL数据库采用分布式部署，关系数据库一般采用集中式部署<br>NoSQL数据库编程遵循BASE原则，关系数据库编程遵循ACID事务原则<br>NoSQL数据库没有统一的数据操作标准，关系数据库遵循SQL数据操作标准<br>NoSQL数据库支持海量数据存储，关系数据库数据存储受限于TB级</p>
</blockquote>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p><strong>一致性</strong>(Consistency） :不同结点数据库保持一致<br><strong>可用性</strong>(Availability) ：数据访问请求随时可满足<br><strong>分区容忍性</strong>(PartitionTolerance) ：当出现故障结点，系统仍能响应数据访问请求</p>
<p>CAP定理法则:</p>
<p>一个分布式系统不可能同时满足一致性(C:Consistency)、可用性(A: Availability)）和分区容错性(P:Partition tolerance)这三个基本需求，最多只能同时满足其中两项。</p>
<p>CA——放弃分区容错性，保证一致性和可用性，即传统的单机数据库处理方式。<br>AP——放弃强一致性，追求分区容错性和可用性，这是很多分布式系统设计时的选择。例如，一些电商系统采用此方案。<br>CP——放弃可用性，追求一致性和分区容错性。例如，很多NoSQL系统采用这种方案。</p>
<h3 id="四种NoSQL"><a href="#四种NoSQL" class="headerlink" title="四种NoSQL"></a>四种NoSQL</h3><p><strong>列存储数据库</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_14-03-31.png"></p>
<p>关系数据库:按行存储，每行数据存放在一个磁盘数据块</p>
<p>列存储数据库:按列存储，每列数据放到一个数据块中</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_14-03-42.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_14-04-53.png"></p>
<p><strong>键值数据库</strong>(Key-Value Database）是一种按照键值数据表结构组织存储数据的内存数据库。代表<strong>Redis</strong>。</p>
<p><strong>文档数据库</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_14-05-22.png"></p>
<p><strong>图形数据库</strong></p>
<p>代表：Neo4j图形数据库</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_14-05-37.png"></p>
<p><strong>NoSQL数据库的四大分类表格分析</strong></p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">Examples举例</th>
<th align="center">典型应用场景</th>
<th align="center">数据模型</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">键值（key-value）</td>
<td align="center">Redis</td>
<td align="center">内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td>
<td align="center">Key 指向 Value 的键值对，通常用hash table来实现</td>
<td align="center">查找速度快</td>
<td align="center">数据无结构化，通常只被当作字符串或者二进制数据</td>
</tr>
<tr>
<td align="center">列存储数据库</td>
<td align="center">Cassandra, HBase</td>
<td align="center">分布式的文件系统</td>
<td align="center">以列簇式存储，将同一列数据存在一起</td>
<td align="center">查找速度快，可扩展性强，更容易进行分布式扩展</td>
<td align="center">功能相对局限</td>
</tr>
<tr>
<td align="center">文档型数据库</td>
<td align="center">CouchDB, MongoDB</td>
<td align="center">Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td>
<td align="center">Key-Value对应的键值对，Value为结构化数据</td>
<td align="center">数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td>
<td align="center">查询性能不高，而且缺乏统一的查询语法。</td>
</tr>
<tr>
<td align="center">图形(Graph)数据库</td>
<td align="center">Neo4J</td>
<td align="center">社交网络，推荐系统等。专注于构建关系图谱</td>
<td align="center">图结构</td>
<td align="center">利用图结构相关算法。比如最短路径寻址，N度关系查找等</td>
<td align="center">很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。</td>
</tr>
</tbody></table>
<p>以下哪一项不是NoSQL的共同特征?(D)</p>
<p>A．分区 B．异步复制	C. BASE	D.CAP</p>
<p>在Neo4J集群中，数据的写入是通过主服务器来完成的，数据的读取可以通过集群中的任意一个Neo4J实例来完成。正确！！</p>
<p><strong>数据库系统面临的挑战</strong>：数据库高并发读写需求；海量数据的高效存储和处理；数据库高扩展性和高可用性需求；数据库在大数据处理方面的要求</p>
<p>以下哪一项不是大数据的特征？高密集价值数据。（是的有：高速产生、规模巨大，多样性）</p>
<p>HBASE中表和区域的关系可以是什么：1：N</p>
<p>以下哪一项不是MongoDB保留数据库：system，（是的有：local、admin、config）</p>
<p>CAP是在分布式环境下设计和部署系统时的3个核心需求。正确！！</p>
<p>Redis复制主要包括RDB复制和AOF复制。正确！！</p>
<p>HBASE中的区域和表的关系是随着数据的增加动态变化的。正确！！</p>
<p>MongoDB的分片是将一个集合的数据分别存储在不同的节点上减轻单机压力。错误</p>
<p>Neo4j的数据物理存储主要分为节点、关系、节点或关系上属性这三类数据存储。！错误</p>
<p>NoSQL数据库分类的依据是对数据的操作方式。错误</p>
<p>Redis数据库的底层实现是字典，对于数据库的增删改查操作都是通过对字典进行操作来实现的。正确！！</p>
<p>HBASE中表定义中要说明行健和表中包含的列族，列不用定义。正确！！</p>
<p>MongoDB复杂文档模型设计可以使用内嵌和引用的方法来解决。正确！！</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
