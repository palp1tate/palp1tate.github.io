<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习go的准备工作</title>
    <url>/2023/06/01/Go/1/</url>
    <content><![CDATA[<h2 id="一-golang环境配置"><a href="#一-golang环境配置" class="headerlink" title="一.golang环境配置"></a>一.golang环境配置</h2><ol>
<li><p><strong>下载SDK</strong></p>
<p>由于我用的是goland专业版，可以直接在上面下载Go SDK，很方便也不需要解压</p>
<p>也可以去官网安装，<strong><a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></strong></p>
<p><em><strong>🤡其实sdk和下文Gopath路径简洁一点更加方便~</strong></em></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f0639cd12d544b5a19868c934ad34b4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512213759389.png"></p>
</li>
<li><p><strong>将go的bin路径添加至Path环境变量中</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5390cc87df4744d9950fa570b1b99604~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512214558987.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e1571d984c048b9bdbcadf2ac0cd68d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512214829533.png"></p>
</li>
<li><p><strong>新建工作目录go_workspace，测试环境</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2001ee1accac4628b96c8515a23edd46~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512215418478.png"></p>
<p>​	在该目录里创建test.txt文件，代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8a01a5064104a60b490755a1b2f0fd2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512215631547"></p>
<p>​	将文件后缀名改为go</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0031456c4f894df5b7e1810e74d56e09~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512215705515"></p>
<p>​	打开命令行，进入go_workspace的目录</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0af7b34cb1224a6dab550296b0f3ae83~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512220156250.png"></p>
<p>​	输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run test.go</span></span><br></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0af7b34cb1224a6dab550296b0f3ae83~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512220740795"></p>
<p>​	输出Hello world!，证明环境配置成功</p>
<ol start="4">
<li><p><strong>设置模块代理</strong></p>
<p>如果访问 github 速度比较慢，建议配置 go mod proxy，下载第三方依赖包的速度可以大大加快</p>
</li>
</ol>
<blockquote>
<ol>
<li>打开“开始”并搜索“env” </li>
<li>选择“编辑系统环境变量” </li>
<li>点击“环境变量…”按钮 </li>
<li>在“&lt;**你的用户名**&gt; 的用户变量”章节下（上半部分）</li>
<li>点击“新建…”按钮</li>
<li>选择“变量名”输入框并输入“GO111MODULE” </li>
<li>选择“变量值”输入框并输入“on” </li>
<li>点击“确定”按钮 </li>
<li>点击“新建…”按钮 </li>
<li>选择“变量名”输入框并输入“GOPROXY” </li>
<li>选择“变量值”输入框并输入“<a href="https://goproxy.cn”/">https://goproxy.cn”</a> </li>
<li>点击“确定”按钮</li>
</ol>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2906b6d25e1743d08166f72c5fb8abdc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230513094942468"></p>
<p>或者打开终端并执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">env</span> -w GO111MODULE=on</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span></span><br></pre></td></tr></table></figure>

<p>如果不放心配置是否准确，当然也可以命令行输入go env检验</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7da62670712f41b487dfefbaa7be4a70~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230513100243945"></p>
<p><em><strong>当然还可以设置自托管go模块代理</strong></em>，参照<a href="https://goproxy.cn/">https://goproxy.cn/</a></p>
<p>​	以下列出自托管go模块代理的一些好处：</p>
<ul>
<li>在没有网络连接的情况下使用代码，因为代码和依赖项都在本地存储。</li>
<li>更好地控制你的代码和依赖项，因为它们都在本地存储。</li>
<li>更好地保护你的代码和依赖项，因为它们不会被外部访问。</li>
<li>更快地构建和测试代码，因为它们不需要从远程服务器下载依赖项。</li>
</ul>
</li>
</ol>
<h2 id="二-goland配置"><a href="#二-goland配置" class="headerlink" title="二.goland配置"></a>二.goland配置</h2><p><strong>系统变量</strong>中新建GOROOT和GOPATH，GOROOT为go的安装路径（Go语言安装目录），GOPATH为go_workspace的路径</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/922f246f49bc482f805f451d9fcd1120~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512223852340.png"></p>
<p>并将<strong>用户变量</strong>中的GOPATH改为go_workspace的路径</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3ba81f6e9403eadd02764531eb944~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512224220984.png"></p>
<p>命令行输入go env，配置成功</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3da83af8fa14d5e95df99a62efabccf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230512224355670.png"></p>
<p>新建go工程，GOROOT为go语言安装目录</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/309a90dc08704cb096f68bd1ba1003fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230513082400448.png"></p>
<p>新建main目录，创建test.go文件，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右键并单击运行</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e97edf2697f44c9ac6989f149b432a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230513084354777.png"></p>
<p>输出Hello world！配置成功</p>
<h2 id="三-goland常用快捷键"><a href="#三-goland常用快捷键" class="headerlink" title="三.goland常用快捷键"></a>三.goland常用快捷键</h2><p>文件相关快捷键：</p>
<blockquote>
<p>CTRL+E，打开最近浏览过的文件。<br>CTRL+SHIFT+E，打开最近更改的文件。<br>CTRL+N，可以快速打开struct结构体。<br>CTRL+SHIFT+N，可以快速打开文件。</p>
</blockquote>
<p>代码格式化：</p>
<blockquote>
<p>CTRL+ALT+T，可以把代码包在一个块内，例如if{…}else{…}。<br>CTRL+ALT+L，格式化代码。<br>CTRL+空格，代码提示。<br>CTRL+&#x2F;，单行注释。CTRL+SHIFT+&#x2F;，进行多行注释。<br>CTRL+B，快速打开光标处的结构体或方法（跳转到定义处）。<br>CTRL+“+&#x2F;-”，可以将当前方法进行展开或折叠。</p>
</blockquote>
<p>查找和定位:</p>
<blockquote>
<p>CTRL+R，替换文本。<br>CTRL+F，查找文本。<br>CTRL+SHIFT+F，进行全局查找。<br>CTRL+G，快速定位到某行。</p>
</blockquote>
<p>代码编辑:</p>
<blockquote>
<p>ALT+Q，可以看到当前方法的声明。<br>CTRL+Backspace，按单词进行删除。<br>SHIFT+ENTER，可以向下插入新行，即使光标在当前行的中间。<br>CTRL+X，删除当前光标所在行。<br>CTRL+D，复制当前光标所在行。<br>ALT+SHIFT+UP&#x2F;DOWN，可以将光标所在行的代码上下移动。<br>CTRL+SHIFT+U，可以将选中内容进行大小写转化。</p>
</blockquote>
<p>原文链接：<a href="https://juejin.cn/post/7232459954580947000">Windows系统下golang和goland详细配置|青训营笔记 - 掘金 (juejin.cn)</a></p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>补充函数与字符串</title>
    <url>/2023/06/08/Go/11/</url>
    <content><![CDATA[<p>补充关于闭包，递归，匿名函数，回调函数，strings包、strconv包的使用。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>go语言支持函数式编程：<br>支持将一个函数作为另一个函数的参数，也支持将一个函数作为另一个函数的返回值。</p>
<p>闭包(closure)：<br> 一个外层函数中，有内层函数，该内层函数中，会操作外层函数的局部变量(外层函数中的参数，或者外层函数中直接定义的变量)，并且该外层函数的返回值就是这个内层函数。这个内层函数和外层函数的局部变量，统称为闭包结构。</p>
<p>局部变量的生命周期会发生改变，正常的局部变量随着函数调用而创建，随着函数的结束而销毁。<br>但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁，因为内层函数还要继续使用。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    res1 := increment()      <span class="comment">//res1 = fun</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, res1) <span class="comment">//func() int</span></span><br><span class="line">    fmt.Println(res1)</span><br><span class="line">    v1 := res1()</span><br><span class="line">    fmt.Println(v1) <span class="comment">//1</span></span><br><span class="line">    v2 := res1()</span><br><span class="line">    fmt.Println(v2) <span class="comment">//2</span></span><br><span class="line">    fmt.Println(res1())</span><br><span class="line">    fmt.Println(res1())</span><br><span class="line">    fmt.Println(res1())</span><br><span class="line">    fmt.Println(res1())</span><br><span class="line"></span><br><span class="line">    res2 := increment()</span><br><span class="line">    fmt.Println(res2)</span><br><span class="line">    v3 := res2()</span><br><span class="line">    fmt.Println(v3) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(res2())</span><br><span class="line"></span><br><span class="line">    fmt.Println(res1())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="comment">//外层函数</span></span><br><span class="line">    <span class="comment">//1.定义了一个局部变量</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">//2.定义了一个匿名函数，给变量自增并返回</span></span><br><span class="line">    fun := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="comment">//内层函数</span></span><br><span class="line">       i++</span><br><span class="line">       <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.返回该匿名函数</span></span><br><span class="line">    <span class="keyword">return</span> fun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func() int</span><br><span class="line">0xdbfd60</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">0xdbfd40</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归函数(recursion)：一个函数自己调用自己，就叫做递归函数。<br>一个函数自己调用自己，就叫做递归调用，一个递归函数一定要有出口，否则会陷入死循环。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	sum := getSum(<span class="number">5</span>)</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line"></span><br><span class="line">	res := getFibonacci(<span class="number">12</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFibonacci</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getFibonacci(n<span class="number">-1</span>) + getFibonacci(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;**********&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getSum(n<span class="number">-1</span>) + n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**********</span><br><span class="line">**********</span><br><span class="line">**********</span><br><span class="line">**********</span><br><span class="line">**********</span><br><span class="line">15</span><br><span class="line">144</span><br></pre></td></tr></table></figure>

<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>匿名：没有名字<br>匿名函数：没有名字的函数。</p>
<p>定义一个匿名函数，直接进行调用。通常只能使用一次。也可以使用匿名函数赋值给某个函数变量，那么就可以调用多次了。</p>
<p>匿名函数：<br>Go语言是支持函数式编程：</p>
<p>将匿名函数作为另一个函数的参数，回调函数<br>将匿名函数作为另一个函数的返回值，可以形成闭包结构。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fun1()</span><br><span class="line">	fun1()</span><br><span class="line">	fun2 := fun1</span><br><span class="line">	fun2()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名函数</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;我是一个匿名函数。。&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	fun3 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;我也是一个匿名函数。。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fun3()</span><br><span class="line">	fun3()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义带参数的匿名函数</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(a, b)</span><br><span class="line">	&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义带返回值的匿名函数</span></span><br><span class="line">	res1 := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b</span><br><span class="line">	&#125;(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">//匿名函数调用了，将执行结果给res1</span></span><br><span class="line">	fmt.Println(res1)</span><br><span class="line"></span><br><span class="line">	res2 := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b</span><br><span class="line">	&#125; <span class="comment">//将匿名函数的值，赋值给res2</span></span><br><span class="line">	fmt.Println(res2)</span><br><span class="line"></span><br><span class="line">	fmt.Println(res2(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是fun1()函数。。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是fun1()函数。。</span><br><span class="line">我是fun1()函数。。</span><br><span class="line">我是fun1()函数。。</span><br><span class="line">我是一个匿名函数。。</span><br><span class="line">我也是一个匿名函数。。</span><br><span class="line">我也是一个匿名函数。。</span><br><span class="line">1 2</span><br><span class="line">30</span><br><span class="line">0x63e160</span><br><span class="line">300</span><br></pre></td></tr></table></figure>

<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>高阶函数：<br>根据go语言的数据类型的特点，可以将一个函数作为另一个函数的参数。</p>
<p>fun1(),fun2()<br>将fun1函数作为了fun2这个函数的参数。</p>
<p>fun2函数：就叫高阶函数<br>接收了一个函数作为参数的函数，高阶函数</p>
<p>fun1函数：回调函数<br>作为另一个函数的参数的函数，叫做回调函数。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//设计一个函数，用于求两个整数的加减乘除运算</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, add)  <span class="comment">//func(int, int) int</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, oper) <span class="comment">//func(int, int, func(int, int) int) int</span></span><br><span class="line"></span><br><span class="line">	res1 := add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(res1)</span><br><span class="line"></span><br><span class="line">	res2 := oper(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">	fmt.Println(res2)</span><br><span class="line"></span><br><span class="line">	res3 := oper(<span class="number">5</span>, <span class="number">2</span>, sub)</span><br><span class="line">	fmt.Println(res3)</span><br><span class="line"></span><br><span class="line">	fun1 := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a * b</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res4 := oper(<span class="number">10</span>, <span class="number">4</span>, fun1)</span><br><span class="line">	fmt.Println(res4)</span><br><span class="line"></span><br><span class="line">	res5 := oper(<span class="number">100</span>, <span class="number">8</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;除数不能为零&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a / b</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(res5)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oper</span><span class="params">(a, b <span class="type">int</span>, fun <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Println(a, b, fun) <span class="comment">//打印3个参数</span></span><br><span class="line">	res := fun(a, b)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func(int, int) int</span><br><span class="line">func(int, int, func(int, int) int) int</span><br><span class="line">3</span><br><span class="line">10 20 0xb8fc20</span><br><span class="line">30</span><br><span class="line">5 2 0xb8fc40</span><br><span class="line">3</span><br><span class="line">10 4 0xb8fc60</span><br><span class="line">40</span><br><span class="line">100 8 0xb8fc80</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Go中的字符串是一个字节的切片。<br>可以通过将其内容封装在“”中来创建字符串。Go中的字符串是Unicode兼容的，并且是UTF-8编码的。</p>
<p>字符串是一些字节的集合。理解为一个字符的序列。<br>每个字符都有固定的位置(索引，下标，index：从0开始，到长度减1)<br>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.定义字符串</span></span><br><span class="line">	s1 := <span class="string">&quot;hello中国&quot;</span></span><br><span class="line">	s2 := <span class="string">`hello world`</span></span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.字符串的长度：返回的是字节的个数</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s1))</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s2))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.获取某个字节</span></span><br><span class="line">	fmt.Println(s2[<span class="number">0</span>]) <span class="comment">//获取字符串中的第一个字节</span></span><br><span class="line">	a := <span class="string">&#x27;h&#x27;</span></span><br><span class="line">	b := <span class="number">104</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%c,%c,%c\n&quot;</span>, s2[<span class="number">0</span>], a, b)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.字符串的遍历</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s2); i++ &#123;</span><br><span class="line">		<span class="comment">//fmt.Println(s2[i])</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%c\t&quot;</span>, s2[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//for range</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">		<span class="comment">//fmt.Println(i,v)</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%c&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.字符串是字节的集合</span></span><br><span class="line">	slice1 := []<span class="type">byte</span>&#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>&#125;</span><br><span class="line">	s3 := <span class="type">string</span>(slice1) <span class="comment">//根据一个字节切片，构建字符串</span></span><br><span class="line">	fmt.Println(s3)</span><br><span class="line"></span><br><span class="line">	s4 := <span class="string">&quot;abcdef&quot;</span></span><br><span class="line">	slice2 := []<span class="type">byte</span>(s4) <span class="comment">//根据字符串，获取对应的字节切片</span></span><br><span class="line">	fmt.Println(slice2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6.字符串不能修改</span></span><br><span class="line">	fmt.Println(s4)</span><br><span class="line">	<span class="comment">//s4[2] = &#x27;B&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello中国</span><br><span class="line">hello world</span><br><span class="line">11</span><br><span class="line">11</span><br><span class="line">104</span><br><span class="line">h,h,h</span><br><span class="line">h       e       l       l       o               w       o       r       l      d</span><br><span class="line">hello world</span><br><span class="line">ABCDE</span><br><span class="line">[97 98 99 100 101 102]</span><br><span class="line">abcdef</span><br></pre></td></tr></table></figure>

<h2 id="strings包"><a href="#strings包" class="headerlink" title="strings包"></a>strings包</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="string">&quot;helloworld&quot;</span></span><br><span class="line">	<span class="comment">//1.是否包含指定的内容--&gt;bool</span></span><br><span class="line">	fmt.Println(strings.Contains(s1, <span class="string">&quot;abc&quot;</span>))</span><br><span class="line">	<span class="comment">//2.是否包含chars中任意的一个字符即可</span></span><br><span class="line">	fmt.Println(strings.ContainsAny(s1, <span class="string">&quot;abcd&quot;</span>))</span><br><span class="line">	<span class="comment">//3.统计substr在s中出现的次数</span></span><br><span class="line">	fmt.Println(strings.Count(s1, <span class="string">&quot;lloo&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.以xxx前缀开头，以xxx后缀结尾</span></span><br><span class="line">	s2 := <span class="string">&quot;20230525课堂笔记.txt&quot;</span></span><br><span class="line">	<span class="keyword">if</span> strings.HasPrefix(s2, <span class="string">&quot;202305&quot;</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;23年5月的文件。。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> strings.HasSuffix(s2, <span class="string">&quot;.txt&quot;</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文本文档。。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//索引</span></span><br><span class="line">	<span class="comment">//helloworld</span></span><br><span class="line">	fmt.Println(strings.Index(s1, <span class="string">&quot;lloo&quot;</span>))     <span class="comment">//查找substr在s中的位置，如果不存在就返回-1</span></span><br><span class="line">	fmt.Println(strings.IndexAny(s1, <span class="string">&quot;abcdh&quot;</span>)) <span class="comment">//查找chars中任意的一个字符，出现在s中的位置</span></span><br><span class="line">	fmt.Println(strings.LastIndex(s1, <span class="string">&quot;l&quot;</span>))    <span class="comment">//查找substr在s中最后一次出现的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串的拼接</span></span><br><span class="line">	ss1 := []<span class="type">string</span>&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;ruby&quot;</span>&#125;</span><br><span class="line">	s3 := strings.Join(ss1, <span class="string">&quot;-&quot;</span>)</span><br><span class="line">	fmt.Println(s3)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//切割</span></span><br><span class="line">	s4 := <span class="string">&quot;123,4563,aaa,49595,45&quot;</span></span><br><span class="line">	ss2 := strings.Split(s4, <span class="string">&quot;,&quot;</span>)	<span class="comment">//数组</span></span><br><span class="line">	<span class="comment">//fmt.Println(ss2)</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ss2); i++ &#123;</span><br><span class="line">		fmt.Println(ss2[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重复，自己拼接自己count次</span></span><br><span class="line">	s5 := strings.Repeat(<span class="string">&quot;hello&quot;</span>, <span class="number">5</span>)</span><br><span class="line">	fmt.Println(s5)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line">	<span class="comment">//helloworld</span></span><br><span class="line">	s6 := strings.Replace(s1, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">	fmt.Println(s6)</span><br><span class="line">	<span class="comment">//fmt.Println(strings.Repeat(&quot;hello&quot;,5))</span></span><br><span class="line"></span><br><span class="line">	s7 := <span class="string">&quot;heLLo WOrlD**123..&quot;</span></span><br><span class="line">	fmt.Println(strings.ToLower(s7))</span><br><span class="line">	fmt.Println(strings.ToUpper(s7))</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		截取子串：</span></span><br><span class="line"><span class="comment">		substring(start,end)--&gt;substr</span></span><br><span class="line"><span class="comment">		str[start:end]--&gt;substr</span></span><br><span class="line"><span class="comment">			包含start，不包含end下标</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	s8 := s1[:<span class="number">5</span>]</span><br><span class="line">	fmt.Println(s8)</span><br><span class="line">	fmt.Println(s1[<span class="number">5</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">0</span><br><span class="line">23年5月的文件。。</span><br><span class="line">文本文档。。</span><br><span class="line">-1</span><br><span class="line">0</span><br><span class="line">8</span><br><span class="line">abc-world-hello-ruby</span><br><span class="line">123</span><br><span class="line">4563</span><br><span class="line">aaa</span><br><span class="line">49595</span><br><span class="line">45</span><br><span class="line">hellohellohellohellohello</span><br><span class="line">he**owor*d</span><br><span class="line">hello world**123..</span><br><span class="line">HELLO WORLD**123..</span><br><span class="line">helloworld</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<h2 id="strconv包"><a href="#strconv包" class="headerlink" title="strconv包"></a>strconv包</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.bool类型</span></span><br><span class="line">	s1 := <span class="string">&quot;true&quot;</span></span><br><span class="line">	b1, err := strconv.ParseBool(s1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%t\n&quot;</span>, b1, b1)	<span class="comment">//%t是bool类型</span></span><br><span class="line"></span><br><span class="line">	ss1 := strconv.FormatBool(b1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%s\n&quot;</span>, ss1, ss1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.整数</span></span><br><span class="line">	s2 := <span class="string">&quot;100&quot;</span></span><br><span class="line">	i2, err := strconv.ParseInt(s2, <span class="number">2</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%d\n&quot;</span>, i2, i2)</span><br><span class="line"></span><br><span class="line">	ss2 := strconv.FormatInt(i2, <span class="number">10</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%s\n&quot;</span>, ss2, ss2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//itoa(),atoi()</span></span><br><span class="line">	i3, err := strconv.Atoi(<span class="string">&quot;-42&quot;</span>) <span class="comment">//转为int类型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%d\n&quot;</span>, i3, i3)</span><br><span class="line">	ss3 := strconv.Itoa(<span class="number">-42</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%s\n&quot;</span>, ss3, ss3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool,true</span><br><span class="line">string,true</span><br><span class="line">int64,4</span><br><span class="line">string,4</span><br><span class="line">int,-42</span><br><span class="line">string,-42</span><br></pre></td></tr></table></figure>

<p>“strconv”用于进行字符串和基本类型之间的转换。在main函数中，首先演示了布尔类型的转换。使用strconv.ParseBool函数将s1转换为bool类型的变量b1。如果转换过程中出现错误，则会打印错误信息并返回。否则，使用fmt.Printf函数输出b1的类型和值。接下来，使用strconv.FormatBool函数将b1转换为字符串类型的变量ss1，演示了整数类型的转换，使用strconv.ParseInt函数将s2按照二进制解析为int64类型的变量i2。使用strconv.FormatInt函数将i2按照十进制转换为字符串类型的变量ss2，使用strconv.Atoi函数将字符串”-42”转换为int类型的变量i3，使用strconv.Itoa函数将整数-42转换为字符串类型的变量ss3。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>type关键字与错误处理</title>
    <url>/2023/06/09/Go/12/</url>
    <content><![CDATA[<h1 id="type关键字"><a href="#type关键字" class="headerlink" title="type关键字"></a>type关键字</h1><p>type：用于类型定义和类型别名</p>
<ul>
<li>类型定义：type 类型名 Type</li>
<li>类型别名：type  类型名 &#x3D; Type</li>
</ul>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i1 myint</span><br><span class="line">	<span class="keyword">var</span> i2 = <span class="number">100</span> <span class="comment">//int</span></span><br><span class="line">	i1 = <span class="number">200</span></span><br><span class="line">	fmt.Println(i1, i2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> name mystr</span><br><span class="line">	name = <span class="string">&quot;王二狗&quot;</span></span><br><span class="line">	<span class="keyword">var</span> s1 <span class="type">string</span></span><br><span class="line">	s1 = <span class="string">&quot;李小花&quot;</span></span><br><span class="line">	fmt.Println(name, s1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//i1 = i2 //cannot use i2 (type int) as type myint in assignment</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//name = s1 //cannot use s1 (type string) as type mystr in assignment</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%T,%T,%T\n&quot;</span>, i1, i2, name, s1) <span class="comment">//main.myint,int,main.mystr,string</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;----------------------------------&quot;</span>)</span><br><span class="line">	res1 := fun1()</span><br><span class="line">	fmt.Println(res1(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;----------------------------------&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> i3 myint2</span><br><span class="line">	i3 = <span class="number">1000</span></span><br><span class="line">	fmt.Println(i3)</span><br><span class="line">	i3 = i2</span><br><span class="line">	fmt.Println(i3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%T,%T\n&quot;</span>, i1, i2, i3) <span class="comment">//main.myint,int,int</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义一个新的类型</span></span><br><span class="line"><span class="keyword">type</span> myint <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> mystr <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义函数类型</span></span><br><span class="line"><span class="keyword">type</span> myfun <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span> myfun &#123; <span class="comment">//fun1()函数的返回值是myfun类型</span></span><br><span class="line">	fun := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		s := strconv.Itoa(a) + strconv.Itoa(b)</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.类型别名</span></span><br><span class="line"><span class="keyword">type</span> myint2 = <span class="type">int</span> <span class="comment">//不是重新定义新的数据类型，只是给int起别名，和int可以通用</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 100</span><br><span class="line">王二狗 李小花</span><br><span class="line">main.myint,int,main.mystr,string</span><br><span class="line">----------------------------------</span><br><span class="line">1020</span><br><span class="line">----------------------------------</span><br><span class="line">1000</span><br><span class="line">100</span><br><span class="line">main.myint,int,int</span><br></pre></td></tr></table></figure>

<p>尽管类型别名可以方便地使用现有类型，但它们不会创建一个新的类型。因此，无法在类型别名上定义新方法。只有在本地类型上才能定义新方法。</p>
<p>错误代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyDuration = time.Duration</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyDuration)</span></span> SimpleSet() &#123; <span class="comment">//cannot define new methods on non-local type time.Duration</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要么在time包下定义新方法，要么建一个新的命名类型，而不是使用类型别名。</p>
<p>修正：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyDuration time.Duration</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyDuration)</span></span> SimpleSet() &#123;</span><br><span class="line">	<span class="comment">// 在这里实现SimpleSet方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在这里使用MyDuration类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在结构体成员嵌入时使用别名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> show() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Person---&gt;&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// People 类型别名</span></span><br><span class="line"><span class="keyword">type</span> People = Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span></span> show2() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;People---&gt;&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//嵌入两个结构体</span></span><br><span class="line">	Person</span><br><span class="line">	People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s Student</span><br><span class="line">	<span class="comment">//s.name = &quot;王二狗&quot; //ambiguous selector s.name</span></span><br><span class="line">	s.Person.name = <span class="string">&quot;王二狗&quot;</span></span><br><span class="line">	<span class="comment">//s.show() //ambiguous selector s.show</span></span><br><span class="line">	s.Person.show()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%T\n&quot;</span>, s.Person, s.People) <span class="comment">//main.Person,main.Person</span></span><br><span class="line"></span><br><span class="line">	s.People.name = <span class="string">&quot;李小花&quot;</span></span><br><span class="line">	s.People.show2()</span><br><span class="line"></span><br><span class="line">	s.Person.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person---&gt; 王二狗</span><br><span class="line">main.Person,main.Person</span><br><span class="line">People---&gt; 李小花</span><br><span class="line">Person---&gt; 王二狗</span><br></pre></td></tr></table></figure>

<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。Go语言没有提供像Java、c#语言中的try…catch异常处理方式，而是通过函数返回值逐层往上抛。这种设计，鼓励工程师在代码中显式的检查错误，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端,让代码啰嗦。</p>
<h2 id="什么是错误"><a href="#什么是错误" class="headerlink" title="什么是错误"></a>什么是错误</h2><p>错误是什么?<br>错误指的是可能出现问题的地方出现了问题。比如打开一个文件时失败，这种情况在人们的意料之中。<br>而异常指的是不应该出现问题的地方出现了问题。比如引用了空指针，这种情况在人们的意料之外。可见，错误是业务过程的一部分,而异常不是。<br>Go中的错误也是一种类型。错误用内置的error类型表示。就像其他类型的，如int，float64。错误值可以存储在变量中，从函数中返回，等等。</p>
<h2 id="演示错误"><a href="#演示错误" class="headerlink" title="演示错误"></a>演示错误</h2><p>让我们从一个示例程序开始,这个程序尝试打开一个不存在的文件。</p>
<p>示例代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//log.Fatal(err)</span></span><br><span class="line">		fmt.Println(err) <span class="comment">//open test.txt: no such file or directory</span></span><br><span class="line">		<span class="keyword">if</span> ins, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;1.Op:&quot;</span>, ins.Op)</span><br><span class="line">			fmt.Println(<span class="string">&quot;2.Path:&quot;</span>, ins.Path)</span><br><span class="line">			fmt.Println(<span class="string">&quot;3.Err:&quot;</span>, ins.Err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(f.Name(), <span class="string">&quot;打开文件成功。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open test.txt: The system cannot find the file specified.</span><br><span class="line">1.Op: open</span><br><span class="line">2.Path: test.txt</span><br><span class="line">3.Err: The system cannot find the file specified.</span><br></pre></td></tr></table></figure>

<p>这行代码尝试将错误值 <code>err</code> 转换为 <code>*os.PathError</code> 类型，并将结果存储在变量 <code>ins</code> 中。这是一个类型断言的示例，它检查错误类型是否是 <code>*os.PathError</code>，并且返回一个布尔值 <code>ok</code> 表示是否成功进行了类型转换。如果类型断言成功，这些代码将打印 <code>*os.PathError</code> 类型的特定字段信息。<code>Op</code> 字段表示操作类型，<code>Path</code> 字段表示操作的路径，<code>Err</code> 字段表示底层错误。</p>
<h2 id="自定义函数返回错误"><a href="#自定义函数返回错误" class="headerlink" title="自定义函数返回错误"></a>自定义函数返回错误</h2><p>error：内置的数据类型，内置的接口<br>定义方法：Error() string</p>
<p>使用go语言提供好的包：<br>errors包下的函数：New()，创建一个error对象，fmt包下的Errorf()函数：<br>func Errorf(format string, a …interface{}) error</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1.创建一个error数据</span></span><br><span class="line">	err1 := errors.New(<span class="string">&quot;自己创建玩的。。&quot;</span>)</span><br><span class="line">	fmt.Println(err1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, err1) <span class="comment">//*errors.errorString</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.另一个创建error的方法</span></span><br><span class="line">	err2 := fmt.Errorf(<span class="string">&quot;错误的信息码:%d&quot;</span>, <span class="number">100</span>)</span><br><span class="line">	fmt.Println(err2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, err2)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">	err3 := checkAge(<span class="number">-30</span>)</span><br><span class="line">	<span class="keyword">if</span> err3 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err3)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;程序。。。go on。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计一个函数：验证年龄是否合法，如果为负数，就返回一个error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkAge</span><span class="params">(age <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> age &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">//返回error对象</span></span><br><span class="line">		<span class="comment">//return errors.New(&quot;年龄不合法&quot;)</span></span><br><span class="line">		err := fmt.Errorf(<span class="string">&quot;您给定的年龄是：%d,不合法&quot;</span>, age)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;年龄是：&quot;</span>, age)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自己创建玩的。。</span><br><span class="line">*errors.errorString</span><br><span class="line">错误的信息码:100</span><br><span class="line">*errors.errorString</span><br><span class="line">-----------------</span><br><span class="line">您给定的年龄是：-30,不合法</span><br></pre></td></tr></table></figure>

<h2 id="错误的类型表示"><a href="#错误的类型表示" class="headerlink" title="错误的类型表示"></a>错误的类型表示</h2><ol>
<li></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ins, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;1.Op:&quot;</span>, ins.Op)</span><br><span class="line">			fmt.Println(<span class="string">&quot;2.Path:&quot;</span>, ins.Path)</span><br><span class="line">			fmt.Println(<span class="string">&quot;3.Err:&quot;</span>, ins.Err)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获得更多信息的第二种方法是断言底层类型，并通过调用struct类型的方法获取更多信息。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	addr, err := net.LookupHost(<span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	<span class="keyword">if</span> ins, ok := err.(*net.DNSError); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> ins.Timeout() &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;操作超时。。&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ins.Temporary() &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;临时性错误。。&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;通常错误。。&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">[182.61.200.6 182.61.200.7]</span><br></pre></td></tr></table></figure>

<p>3.直接比较<br>获得更多关于错误的详细信息的第三种方法是直接与类型错误的变量进行比较。让我们通过一个例子来理解这个问题。<br>filepath包的Glob函数用于返回与模式匹配的所有文件的名称。当模式出现错误时，该函数将返回一个错误ErrBadPattern。<br>在filepath包中定义了ErrBadPattern，如下所述:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrBadPattern = errors.New(<span class="string">&quot;syntax error in pattern&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>errors.New()用于创建新的错误。<br>当模式出现错误时,由Glob函数返回ErrBadPattern。</p>
<p>让我们写一个小程序来检查这个错误:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	files, err := filepath.Glob(<span class="string">&quot;[&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err == filepath.ErrBadPattern &#123;</span><br><span class="line">		fmt.Println(err) <span class="comment">//syntax error in pattern</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;files:&quot;</span>, files)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax error in pattern</span><br></pre></td></tr></table></figure>

<p>记住永远不要忽略一个错误。忽视错误会招致麻烦。</p>
<h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	radius := <span class="number">-3.0</span></span><br><span class="line">	area, err := circleArea(radius)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">if</span> err, ok := err.(*areaError); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;半径是：%.2f\n&quot;</span>, err.radius)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;圆形的面积是：&quot;</span>, area)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义一个结构体，表示错误的类型</span></span><br><span class="line"><span class="keyword">type</span> areaError <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg    <span class="type">string</span></span><br><span class="line">	radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.实现error接口，就是实现Error()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;error：半径，%.2f，%s&quot;</span>, e.radius, e.msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleArea</span><span class="params">(radius <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, &amp;areaError&#123;<span class="string">&quot;半径是非法的&quot;</span>, radius&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> math.Pi * radius * radius, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error：半径，-3.00，半径是非法的</span><br><span class="line">半径是：-3.00</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	length, width := <span class="number">-6.7</span>, <span class="number">-9.1</span></span><br><span class="line">	area, err := rectArea(length, width)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">if</span> err, ok := err.(*areaError); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> err.legnthNegative() &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;error：长度，%.2f，小于零\n&quot;</span>, err.length)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err.widthNegative() &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;error：宽度，%.2f，小于零\n&quot;</span>, err.width)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;矩形的面积是：&quot;</span>, area)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> areaError <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg    <span class="type">string</span>  <span class="comment">//错误的描述</span></span><br><span class="line">	length <span class="type">float64</span> <span class="comment">//发生错误的时候，矩形的长度</span></span><br><span class="line">	width  <span class="type">float64</span> <span class="comment">//发生错误的时候，矩形的宽度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> legnthNegative() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.length &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> widthNegative() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.width &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectArea</span><span class="params">(length, width <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	msg := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">if</span> length &lt; <span class="number">0</span> &#123;</span><br><span class="line">		msg = <span class="string">&quot;长度小于零&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> width &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			msg = <span class="string">&quot;宽度小于零&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			msg += <span class="string">&quot;，宽度也小于零&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> msg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, &amp;areaError&#123;msg, length, width&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length * width, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">长度小于零，宽度也小于零</span><br><span class="line">error：长度，-6.70，小于零</span><br><span class="line">error：宽度，-9.10，小于零</span><br></pre></td></tr></table></figure>

<h2 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h2><p>Golang中引入两个内置函数panic和recover来触发和终止异常处理流程，同时引入关键字defer来延迟执行defer后面的函数。<br>一直等到包含defer语句的函数执行完毕时，延迟函数(defer后的函数）才会被执行，而不管包含defer语句的函数是通过return的正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。<br>当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生:函数停止执行，调用延迟执行函数等。如果一路在延迟函数中没有recover函数的调用，则会到达该协程的起点，该协程结束，然后终止其他所有协程,包括主协程(类似于C语言中的主线程,该协程ID为1)。<br><strong>panic</strong>:</p>
<ol>
<li><p>内建函数</p>
</li>
<li><p>假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表,按照defer的逆序执行</p>
</li>
<li><p>返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行，这里的defer有点类似 try-catch-finally中的finally</p>
</li>
<li><p>直到goroutine整个退出，并报告错误</p>
</li>
</ol>
<p><strong>recover</strong>:</p>
<ol>
<li>内建函数</li>
<li>用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为</li>
<li>一般的调用建议<br>a).在defer函数中，通过recover来终止一个gojroutine的panicking过程，从而恢复正常代码的执行<br>b).可以获取通过panic传递的error</li>
</ol>
<p><em><strong>简单来讲: go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理</strong></em>。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg := <span class="built_in">recover</span>(); msg != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(msg, <span class="string">&quot;程序恢复啦。。。&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	funA()</span><br><span class="line">	<span class="keyword">defer</span> myprint(<span class="string">&quot;defer main：3.....&quot;</span>)</span><br><span class="line">	funB()</span><br><span class="line">	<span class="keyword">defer</span> myprint(<span class="string">&quot;defer main：4.....&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;main..over。。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myprint</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funA</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是一个函数funA()....&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funB</span><span class="params">()</span></span> &#123; <span class="comment">//外围函数</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;我是函数funB()...&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> myprint(<span class="string">&quot;defer funB()：1.....&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;i:&quot;</span>, i)</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">			<span class="comment">//让程序中断</span></span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;funB函数，恐慌了&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="comment">//当外围函数的代码中发生了运行恐慌，只有其中所有的已经defer的函数全部都执行完毕后，该运行恐慌才会真正被扩展至调用处。</span></span><br><span class="line">	<span class="keyword">defer</span> myprint(<span class="string">&quot;defer funB()：2.....&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是一个函数funA()....</span><br><span class="line">我是函数funB()...</span><br><span class="line">i: 1</span><br><span class="line">i: 2</span><br><span class="line">i: 3</span><br><span class="line">i: 4</span><br><span class="line">i: 5</span><br><span class="line">defer funB()：1.....</span><br><span class="line">defer main：3.....</span><br><span class="line">funB函数，恐慌了 程序恢复啦。。。</span><br></pre></td></tr></table></figure>

<p>由于恐慌发生在循环内部，之后的语句将不会执行。然而，之前已经被<code>defer</code>关键字延迟执行的<code>myprint</code>函数仍然会执行。因此，”defer funB()：1…..”会被输出。funB函数的执行完毕后，恐慌会被传播到调用处，也就是<code>main</code>函数中的匿名函数。在这个匿名函数中，我们通过<code>recover</code>函数检测到了恐慌，所以会输出恐慌信息：”funB函数，恐慌了”，并打印”程序恢复啦。。。”。</p>
<p>错误和异常从Golang机制上讲，就是error和panic的区别。很多其他语言也一样,<br>比C++&#x2F;Java,没有error有errno，没有panic但有throw。<br>Golang错误和异常是可以互相转换的:<br>1．错误转异常，比如程序逻辑上尝试请求某个URL，最多尝试三次，尝试三次的过程中请求失败是错误，尝试完第三次还不成功的话，失败就被提升为异常了。<br>2．异常转错误，比如panic触发的异常被recover恢复后，将返回值中error类型的变量进行赋值，以便上层函数继续走错误处理流程。</p>
<p>什么情况下用错误表达，什么情况下用异常表达，就得有一套规则，否则很容易出现一切皆错误或一切皆异常的情况。<br>以下给出异常处理的作用域(场景)∶</p>
<blockquote>
<p>1．空指针引用<br>2．下标越界<br>3．除数为0<br>4．不应该出现的分支，比如default<br>5．输入不应该引起函数错误</p>
</blockquote>
<p>其他场景我们使用错误处理，这使得我们的函数接口很精炼。对于异常，我们可以选择在一个合适的上游去recover，并打印堆栈信息，使得部署后的程序不会终止。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>方法与接口</title>
    <url>/2023/06/06/Go/10/</url>
    <content><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="什么是方法"><a href="#什么是方法" class="headerlink" title="什么是方法"></a>什么是方法</h2><p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。</p>
<p>方法只是一个函数，它带有一个特殊的接收器类型，它是在func关键字和方法名之间编写的。接收器可以是struct类型或非struct类型。接收方可以在方法内部访问。</p>
<h2 id="方法的语法"><a href="#方法的语法" class="headerlink" title="方法的语法"></a>方法的语法</h2><p>定义方法的语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Type)</span></span> methodName(parameter list)(<span class="keyword">return</span> list) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(parameter list)</span></span>(<span class="keyword">return</span> list)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name     <span class="type">string</span></span><br><span class="line">    salary   <span class="type">int</span></span><br><span class="line">    currency <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> displaySalary() method has Employee as the receiver type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> displaySalary() &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;Salary of %s is %s%d&quot;</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp1 := Employee &#123;</span><br><span class="line">        name:     <span class="string">&quot;Sam Adolf&quot;</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">&quot;$&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    emp1.displaySalary() <span class="comment">//Calling displaySalary() method of Employee type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以定义相同的方法名</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">	r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">	c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">	c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, r1.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, r2.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of c1 is: &quot;</span>, c1.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of c2 is: &quot;</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Area of r1 is:  24</span><br><span class="line">Area of r2 is:  36</span><br><span class="line">Area of c1 is:  314.1592653589793</span><br><span class="line">Area of c2 is:  1963.4954084936207</span><br></pre></td></tr></table></figure>

<ul>
<li>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</li>
<li>method里面可以访问接收者的字段</li>
<li>调用method通过.访问，就像struct里面访问字段一样</li>
</ul>
<h2 id="方法和函数"><a href="#方法和函数" class="headerlink" title="方法和函数"></a>方法和函数</h2><p>既然我们已经有了函数，为什么还要使用方法？</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name     <span class="type">string</span></span><br><span class="line">    salary   <span class="type">int</span></span><br><span class="line">    currency <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> displaySalary() method converted to function with Employee as parameter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">displaySalary</span><span class="params">(e Employee)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;Salary of %s is %s%d&quot;</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp1 := Employee&#123;</span><br><span class="line">        name:     <span class="string">&quot;Sam Adolf&quot;</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">&quot;$&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    displaySalary(emp1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的程序中，displaySalary方法被转换为一个函数，而Employee struct作为参数传递给它。这个程序也产生了相同的输出：Salary of Sam Adolf is $5000.。</p>
</blockquote>
<p>为什么我们可以用函数来写相同的程序呢?有以下几个原因</p>
<ol>
<li>Go不是一种纯粹面向对象的编程语言，它不支持类。因此，类型的方法是一种实现类似于类的行为的方法。</li>
<li>相同名称的方法可以在不同的类型上定义，而具有相同名称的函数是不允许的。假设我们有一个正方形和圆形的结构。可以在正方形和圆形上定义一个名为Area的方法。</li>
</ol>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p>
<p>Go 语言中变量可以在三个地方声明：</p>
<ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<p><strong>局部变量</strong></p>
<p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。</p>
<p><strong>全局变量</strong></p>
<p>在函数体外声明的变量称之为全局变量，首字母大写全局变量可以在整个包甚至外部包（被导出后）使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> g <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化参数 */</span></span><br><span class="line">   a = <span class="number">10</span></span><br><span class="line">   b = <span class="number">20</span></span><br><span class="line">   g = a + b</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;结果： a = %d, b = %d and g = %d\n&quot;</span>, a, b, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结果： a = 10, b = 20 and g = 30</span><br></pre></td></tr></table></figure>

<p><strong>形式参数</strong></p>
<p>形式参数会作为函数的局部变量来使用</p>
<p><strong>指针作为接收者</strong></p>
<p>若不是以指针作为接收者，实际只是获取了一个copy，而不能真正改变接收者的中的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> SetColor(c Color) &#123;</span><br><span class="line">	b.color = c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> setVal() &#123;</span><br><span class="line">	r.height = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := Rectangle&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s := p</span><br><span class="line">	p.setVal()</span><br><span class="line">	fmt.Println(p.height, s.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 2</span><br></pre></td></tr></table></figure>

<p>如果没有那个*，则值就是<code>2 2</code></p>
<h2 id="method继承"><a href="#method继承" class="headerlink" title="method继承"></a>method继承</h2><p>method是可以继承的，如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">	age   <span class="type">int</span></span><br><span class="line">	phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Hi, I am Mark you can call me on <span class="number">222</span><span class="number">-222</span>-YYYY</span><br><span class="line">Hi, I am Sam you can call me on <span class="number">111</span><span class="number">-888</span>-XXXX</span><br></pre></td></tr></table></figure>

<h2 id="method重写"><a href="#method重写" class="headerlink" title="method重写"></a>method重写</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">	age   <span class="type">int</span></span><br><span class="line">	phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">		e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi, I am Mark you can call me on 222-222-YYYY</span><br><span class="line">Hi, I am Sam, I work at Golang Inc. Call me on 111-888-XXXX</span><br></pre></td></tr></table></figure>

<ul>
<li>方法是可以继承和重写的</li>
<li>存在继承关系时，按照就近原则，进行调用</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p>面向对象世界中的接口的一般定义是“接口定义对象的行为”。它表示让指定对象应该做什么。实现这种行为的方法(实现细节)是针对对象的。</p>
<p>在Go中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。它与OOP非常相似。接口指定了类型应该具有的方法，类型决定了如何实现这些方法。</p>
<blockquote>
<p> 它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口</p>
<p> 接口定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了该接口。</p>
</blockquote>
<h2 id="接口的定义语法"><a href="#接口的定义语法" class="headerlink" title="接口的定义语法"></a>接口的定义语法</h2><p>定义接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span></span> method_name1() [return_type] &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span></span> method_namen() [return_type] &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>NokiaPhone</code>结构体实现了<code>Phone</code>接口中的方法，因此可以将其赋值给<code>phone</code>。</p>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">I am Nokia, I can call you!</span><br><span class="line">I am iPhone, I can call you!</span><br></pre></td></tr></table></figure>

<ul>
<li>interface可以被任意的对象实现</li>
<li>一个对象可以实现任意多个interface</li>
<li>任意的类型都实现了空interface(我们这样定义：interface{})，也就是包含0个method的interface</li>
</ul>
<h2 id="interface值"><a href="#interface值" class="headerlink" title="interface值"></a>interface值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">	age   <span class="type">int</span></span><br><span class="line">	phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="type">string</span></span><br><span class="line">	loan   <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human   <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="type">string</span></span><br><span class="line">	money   <span class="type">float32</span></span><br><span class="line">&#125; <span class="comment">//Human实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> SayHi() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125; <span class="comment">//Human实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;La la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125; <span class="comment">//Employee重写Human的SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> SayHi() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">		e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface Men被Human,Student和Employee实现</span></span><br><span class="line"><span class="comment">// 因为这三个类型都实现了这两个方法</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">	SayHi()</span><br><span class="line">	Sing(lyrics <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mike := Student&#123;Human&#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-XXX&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>, <span class="number">0.00</span>&#125;</span><br><span class="line">	paul := Student&#123;Human&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">26</span>, <span class="string">&quot;111-222-XXX&quot;</span>&#125;, <span class="string">&quot;Harvard&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">36</span>, <span class="string">&quot;444-222-XXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc.&quot;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">	Tom := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">36</span>, <span class="string">&quot;444-222-XXX&quot;</span>&#125;, <span class="string">&quot;Things Ltd.&quot;</span>, <span class="number">5000</span>&#125;</span><br><span class="line">	<span class="comment">//定义Men类型的变量i</span></span><br><span class="line">	<span class="keyword">var</span> i Men</span><br><span class="line">	<span class="comment">//i能存储Student</span></span><br><span class="line">	i = mike</span><br><span class="line">	fmt.Println(<span class="string">&quot;This is Mike, a Student:&quot;</span>)</span><br><span class="line">	i.SayHi()</span><br><span class="line">	i.Sing(<span class="string">&quot;November rain&quot;</span>)</span><br><span class="line">	<span class="comment">//i也能存储Employee</span></span><br><span class="line">	i = Tom</span><br><span class="line">	fmt.Println(<span class="string">&quot;This is Tom, an Employee:&quot;</span>)</span><br><span class="line">	i.SayHi()</span><br><span class="line">	i.Sing(<span class="string">&quot;Born to be wild&quot;</span>)</span><br><span class="line">	<span class="comment">//定义了slice Men</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Let&#x27;s use a slice of Men and see what happens&quot;</span>)</span><br><span class="line">	x := <span class="built_in">make</span>([]Men, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">//T这三个都是不同类型的元素，但是他们实现了interface同一个接口</span></span><br><span class="line">	x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = paul, sam, mike</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> x &#123;</span><br><span class="line">		value.SayHi()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is Mike, a Student:</span><br><span class="line">Hi, I am Mike you can call me on 222-222-XXX</span><br><span class="line">La la la la... November rain</span><br><span class="line">This is Tom, an Employee:</span><br><span class="line">Hi, I am Sam, I work at Things Ltd.. Call me on 444-222-XXX</span><br><span class="line">La la la la... Born to be wild</span><br><span class="line">Let&#x27;s use a slice of Men and see what happens</span><br><span class="line">Hi, I am Paul you can call me on 111-222-XXX</span><br><span class="line">Hi, I am Sam, I work at Golang Inc.. Call me on 444-222-XXX</span><br><span class="line">Hi, I am Mike you can call me on 222-222-XXX</span><br></pre></td></tr></table></figure>

<p>那么interface里面到底能存什么值呢？如果我们定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，我们定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值</p>
<blockquote>
<p>当然，使用指针的方式，也是可以的</p>
<p>但是，接口对象不能调用实现对象的属性</p>
</blockquote>
<p><strong>interface函数参数</strong></p>
<p>interface的变量可以持有任意实现该interface类型的对象，这给我们编写函数(包括method)提供了一些额外的思考，我们是不是可以通过定义interface参数，让函数接受各种类型的参数</p>
<p><strong>嵌入interface</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">interface</span> &#123;</span><br><span class="line">	Len()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">interface</span> &#123;</span><br><span class="line">	Human</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Test)</span></span> Len() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s Student</span><br><span class="line">	s = <span class="built_in">new</span>(Test)</span><br><span class="line">	s.Len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了一个<code>Student</code>接口，它通过嵌套<code>Human</code>接口，继承了<code>Human</code>接口中的方法。在<code>Test</code>结构体上定义了一个指针接收者的<code>Len</code>方法。该方法实现了<code>Human</code>接口中的<code>Len</code>方法。通过<code>s.Len()</code>调用了<code>Test</code>结构体中实现的<code>Len</code>方法，并输出”成功”。这样，通过接口的嵌套，我们可以在一个接口中组合多个其他接口，并且实现了嵌套接口的方法的结构体也被认为是实现了嵌套接口。这样可以实现接口的扩展和复用。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	M <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Something <span class="keyword">interface</span> &#123;</span><br><span class="line">	Get()</span><br><span class="line">	Post()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> Get() &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> Post() &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;test&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	test.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Get() &#123;</span><br><span class="line">	<span class="comment">//new(test.Controller).Get()</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Post() &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> something test.Something</span><br><span class="line">	something = <span class="built_in">new</span>(T)</span><br><span class="line">	<span class="keyword">var</span> t T</span><br><span class="line">	t.M = <span class="number">1</span></span><br><span class="line">	<span class="comment">//	t.Controller.M = 1</span></span><br><span class="line">	something.Get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller实现了所有的Something接口方法，当结构体T中调用Controller结构体的时候，T就相当于Java中的继承，T继承了Controller，因此，T可以不用重写所有的Something接口中的方法，因为父构造器已经实现了接口。</p>
<p>如果Controller没有实现Something接口方法，则T要调用Something中方法，就要实现其所有方法。</p>
<p>如果<code>something = new(test.Controller)</code>则调用的是Controller中的Get方法，T可以使用Controller结构体中定义的变量</p>
<p>总之，接口对象不能调用接口实现对象的属性</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>文件详细操作</title>
    <url>/2023/06/11/Go/14/</url>
    <content><![CDATA[<h1 id="File文件操作"><a href="#File文件操作" class="headerlink" title="File文件操作"></a>File文件操作</h1><p>首先，file类是在os包中的，封装了底层的文件描述符和相关信息，同时封装了Read和Write的实现</p>
<h2 id="FileInfo接口"><a href="#FileInfo接口" class="headerlink" title="FileInfo接口"></a>FileInfo接口</h2><p>FileInfo接口中定义了File信息相关的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="type">string</span>       <span class="comment">// base name of the file 文件名.扩展名 1.txt</span></span><br><span class="line">	Size() <span class="type">int64</span>        <span class="comment">// 文件大小，字节数 12540</span></span><br><span class="line">	Mode() FileMode     <span class="comment">// 文件权限 -rw-rw-rw-</span></span><br><span class="line">	ModTime() time.Time <span class="comment">// 修改时间 2018-04-13 16:30:53 +0800 CST</span></span><br><span class="line">	IsDir() <span class="type">bool</span>        <span class="comment">// 是否文件夹</span></span><br><span class="line">	Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 基础数据源接口(can return nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileInfo, err := os.Stat(<span class="string">&quot;main/1.md&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err :&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, fileInfo)</span><br><span class="line">	<span class="comment">//文件名</span></span><br><span class="line">	fmt.Println(fileInfo.Name())</span><br><span class="line">	<span class="comment">//文件大小</span></span><br><span class="line">	fmt.Println(fileInfo.Size())</span><br><span class="line">	<span class="comment">//是否是目录</span></span><br><span class="line">	fmt.Println(fileInfo.IsDir()) <span class="comment">//IsDirectory</span></span><br><span class="line">	<span class="comment">//修改时间</span></span><br><span class="line">	fmt.Println(fileInfo.ModTime())</span><br><span class="line">	<span class="comment">//权限</span></span><br><span class="line">	fmt.Println(fileInfo.Mode()) <span class="comment">//-rw-r--r--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*os.fileStat</span><br><span class="line">1.md</span><br><span class="line">47</span><br><span class="line">false</span><br><span class="line">2023-06-10 21:30:41.7576415 +0800 CST</span><br><span class="line">-rw-rw-rw-</span><br></pre></td></tr></table></figure>

<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>至于操作权限perm，除非创建文件时才需要指定，不需要创建新文件时可以将其设定为０。虽然go语言给perm权限设定了很多的常量，但是习惯上也可以直接使用数字，如0666(具体含义和Unix系统的一致)。</p>
<p>权限控制：</p>
<p>linux 下有2种文件权限表示方式，即“符号表示”和“八进制表示”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）符号表示方式:</span><br><span class="line"></span><br><span class="line">-      ---         ---        ---</span><br><span class="line"></span><br><span class="line">type   owner       group      others</span><br><span class="line">文件的权限是这样子分配的 读 写 可执行 分别对应的是 r w x 如果没有那一个权限，用 - 代替</span><br><span class="line">(-文件 d目录 |连接符号)</span><br><span class="line">例如：-rwxr-xr-x</span><br><span class="line"></span><br><span class="line">（2）八进制表示方式：	</span><br><span class="line">r ——&gt; 004</span><br><span class="line">w ——&gt; 002</span><br><span class="line">x ——&gt; 001</span><br><span class="line">- ——&gt; 000</span><br><span class="line"></span><br><span class="line">0755</span><br><span class="line">0777（owner，group，others都是可读可写可执行）</span><br><span class="line">0555</span><br><span class="line">0444</span><br><span class="line">0666</span><br></pre></td></tr></table></figure>

<h2 id="打开模式"><a href="#打开模式" class="headerlink" title="打开模式"></a>打开模式</h2><p>文件打开模式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="type">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line">    O_WRONLY <span class="type">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line">    O_RDWR   <span class="type">int</span> = syscall.O_RDWR   <span class="comment">// 读写模式打开文件</span></span><br><span class="line">    O_APPEND <span class="type">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line">    O_CREATE <span class="type">int</span> = syscall.O_CREAT  <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line">    O_EXCL   <span class="type">int</span> = syscall.O_EXCL   <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line">    O_SYNC   <span class="type">int</span> = syscall.O_SYNC   <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">    O_TRUNC  <span class="type">int</span> = syscall.O_TRUNC  <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="File操作"><a href="#File操作" class="headerlink" title="File操作"></a>File操作</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> File</span><br><span class="line"><span class="comment">//File代表一个打开的文件对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于I/O；对应的文件描述符具有O_RDWR模式。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (file *File, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">uintptr</span>, name <span class="type">string</span>)</span></span> *File</span><br><span class="line"><span class="comment">//NewFile使用给出的Unix文件描述符和名称创建一个文件。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span></span> (r *File, w *File, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Pipe返回一对关联的文件对象。从r的读取将返回写入w的数据。本函数会返回两个文件对象和可能的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Name() <span class="type">string</span></span><br><span class="line"><span class="comment">//Name方法返回（提供给Open/Create等方法的）文件名称。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Stat() (fi FileInfo, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Stat返回描述文件f的FileInfo类型值。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Fd() <span class="type">uintptr</span></span><br><span class="line"><span class="comment">//Fd返回与文件f对应的整数类型的Unix文件描述符。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Chdir() <span class="type">error</span></span><br><span class="line"><span class="comment">//Chdir将当前工作目录修改为f，f必须是一个目录。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Chmod(mode FileMode) <span class="type">error</span></span><br><span class="line"><span class="comment">//Chmod修改文件的模式。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Chown(uid, gid <span class="type">int</span>) <span class="type">error</span></span><br><span class="line"><span class="comment">//Chown修改文件的用户ID和组ID。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Close() <span class="type">error</span></span><br><span class="line"><span class="comment">//Close关闭文件f，使文件不能用于读写。它返回可能出现的错误。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.路径</span></span><br><span class="line">	fileName1 := <span class="string">&quot;C:\\GolandProjects\\GoProject1\\main\\1.md&quot;</span></span><br><span class="line">	fileName2 := <span class="string">&quot;main/1.md&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否是绝对路径</span></span><br><span class="line">	fmt.Println(filepath.IsAbs(fileName1)) <span class="comment">//true</span></span><br><span class="line">	fmt.Println(filepath.IsAbs(fileName2)) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//转化为绝对路径</span></span><br><span class="line">	<span class="comment">//fmt.Println(filepath.Abs(fileName1))</span></span><br><span class="line">	<span class="comment">//fmt.Println(filepath.Abs(fileName2)) // C:\GolandProjects\GoProject1\main\1.md &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.获取目录</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;获取父目录：&quot;, filepath.Join(fileName1, &quot;..&quot;))</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;获取父目录：&quot;, filepath.Dir(fileName1))</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;获取当前目录：&quot;, filepath.Join(fileName1, &quot;.&quot;))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.创建目录</span></span><br><span class="line">	err := os.Mkdir(<span class="string">&quot;main/app&quot;</span>, os.ModePerm) <span class="comment">//权限0777</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件夹创建成功。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//err := os.MkdirAll(&quot;main/a/b/c&quot;, os.ModePerm)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err:&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;多层文件夹创建成功&quot;)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.创建文件:Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）</span></span><br><span class="line">	<span class="comment">//file1, err := os.Create(fileName1)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err：&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(file1)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//file2, err := os.Create(fileName2) //创建相对路径的文件，是以当前工程为参照的</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err :&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(file2)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.打开文件：</span></span><br><span class="line">	<span class="comment">//file3, err := os.Open(fileName1) //只读的</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err:&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(file3)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		第一个参数：文件名称</span></span><br><span class="line"><span class="comment">		第二个参数：文件的打开方式</span></span><br><span class="line"><span class="comment">			const (</span></span><br><span class="line"><span class="comment">		// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.</span></span><br><span class="line"><span class="comment">			O_RDONLY int = syscall.O_RDONLY // open the file read-only.</span></span><br><span class="line"><span class="comment">			O_WRONLY int = syscall.O_WRONLY // open the file write-only.</span></span><br><span class="line"><span class="comment">			O_RDWR   int = syscall.O_RDWR   // open the file read-write.</span></span><br><span class="line"><span class="comment">			// The remaining values may be or&#x27;ed in to control behavior.</span></span><br><span class="line"><span class="comment">			O_APPEND int = syscall.O_APPEND // append data to the file when writing.</span></span><br><span class="line"><span class="comment">			O_CREATE int = syscall.O_CREAT  // create a new file if none exists.</span></span><br><span class="line"><span class="comment">			O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.</span></span><br><span class="line"><span class="comment">			O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.</span></span><br><span class="line"><span class="comment">			O_TRUNC  int = syscall.O_TRUNC  // truncate regular writable file when opened.</span></span><br><span class="line"><span class="comment">		)</span></span><br><span class="line"><span class="comment">		第三个参数：文件的权限：文件不存在创建文件，需要指定权限</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//file4, err := os.OpenFile(fileName1, os.O_RDONLY|os.O_WRONLY, os.ModePerm)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err:&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(file4)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//5关闭文件，</span></span><br><span class="line">	<span class="comment">//err := file4.Close()</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//6.删除文件或文件夹：</span></span><br><span class="line">	<span class="comment">//删除文件(该方法也可以删除空目录)</span></span><br><span class="line">	<span class="comment">//err := os.Remove(&quot;main/1.md&quot;)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err:&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;删除文件成功。。&quot;)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除目录</span></span><br><span class="line">	<span class="comment">//err := os.RemoveAll(&quot;main/a/b/c&quot;)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(&quot;err:&quot;, err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(&quot;删除目录成功。。</span></span><br></pre></td></tr></table></figure>

<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>文件的操作函数和方法的介绍：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Readdir(n <span class="type">int</span>) (fi []FileInfo, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Readdir读取目录f的内容，返回一个有n个成员的[]FileInfo，这些FileInfo是被Lstat返回的，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。如果n&gt;0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。如果n&lt;=0，Readdir函数返回目录中剩余所有文件对象的FileInfo构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的FileInfo构成的切片和该错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Readdirnames(n <span class="type">int</span>) (names []<span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Readdir读取目录f的内容，返回一个有n个成员的[]string，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。如果n&gt;0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。如果n&lt;=0，Readdir函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Truncate(size <span class="type">int64</span>) <span class="type">error</span></span><br><span class="line"><span class="comment">//Truncate改变文件的大小，它不会改变I/O的当前位置。 如果截断文件，多出的部分就会被丢弃。如果出错，错误底层类型是*PathError。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Read方法从f中读取最多len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取0个字节且返回值err为io.EOF。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> ReadAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//ReadAt从指定的位置（相对于文件开始位置）读取len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。当n&lt;len(b)时，本方法总是会返回错误；如果是因为到达文件结尾，返回值err会是io.EOF。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Write向文件中写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> WriteString(s <span class="type">string</span>) (ret <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//WriteString类似Write，但接受一个字符串参数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> WriteAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//WriteAt在指定的位置（相对于文件开始位置）写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (ret <span class="type">int64</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Seek设置下一次读/写的位置。offset为相对偏移量，而whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Sync() (err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//Sync递交文件的当前内容进行稳定的存储。一般来说，这表示将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="I-x2F-O操作"><a href="#I-x2F-O操作" class="headerlink" title="I&#x2F;O操作"></a>I&#x2F;O操作</h1><p>I&#x2F;O操作也叫输入输出操作。其中I是指Input，O是指Output，用于读或者写数据的，有些语言中也叫流操作，是指数据通信的通道。</p>
<p>Golang 标准库对 IO 的抽象非常精巧，各个组件可以随意组合，可以作为接口设计的典范。</p>
<h2 id="io包"><a href="#io包" class="headerlink" title="io包"></a>io包</h2><p>io包中提供I&#x2F;O原始操作的一系列接口。它主要包装了一些已有的实现，如 os 包中的那些，并将这些抽象成为实用性的功能和一些其他相关的接口。</p>
<p>由于这些接口和原始的操作以不同的实现包装了低级操作，客户不应假定它们对于并行执行是安全的。</p>
<p>在io包中最重要的是两个接口：Reader和Writer接口，首先来介绍这两个接口。</p>
<p>Reader接口的定义，Read()方法用于读取数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;&#x3D; n &lt;&#x3D; len(p)）以及任何遇到的错误。即使 Read 返回的 n &lt; len(p)，它也会在调用过程中使用 p的全部作为暂存空间。若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的东西，而不是等待更多。</p>
<p>当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或 EOF 情况，它就会返回读取的字节数。它会从相同的调用中返回（非nil的）错误或从随后的调用中返回错误（和 n &#x3D;&#x3D; 0）。这种一般情况的一个例子就是 Reader 在输入流结束时会返回一个非零的字节数，可能的返回不是 err &#x3D;&#x3D; EOF 就是 err &#x3D;&#x3D; nil。无论如何，下一个 Read 都应当返回 0, EOF。</p>
<p>调用者应当总在考虑到错误 err 前处理 n &gt; 0 的字节。这样做可以在读取一些字节，以及允许的 EOF 行为后正确地处理I&#x2F;O错误。</p>
<p>Read 的实现会阻止返回零字节的计数和一个 nil 错误，调用者应将这种情况视作空操作。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		读取数据：</span></span><br><span class="line"><span class="comment">			Reader接口：</span></span><br><span class="line"><span class="comment">				Read(p []byte)(n int, error)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//读取本地1.txt文件中的数据</span></span><br><span class="line">	<span class="comment">//step1：打开文件</span></span><br><span class="line">	fileName := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//step3：关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(file *os.File)</span></span> &#123;</span><br><span class="line">		err := file.Close()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//step2：读取数据</span></span><br><span class="line">	bs := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//第一次读取</span></span><br><span class="line"><span class="comment">		n, err := file.Read(bs)</span></span><br><span class="line"><span class="comment">		fmt.Println(err)        //&lt;nil&gt;</span></span><br><span class="line"><span class="comment">		fmt.Println(n)          //4</span></span><br><span class="line"><span class="comment">		fmt.Println(bs)         //[97 98 99 100]</span></span><br><span class="line"><span class="comment">		fmt.Println(string(bs)) //abcd</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//第二次读取</span></span><br><span class="line"><span class="comment">		n, err = file.Read(bs)</span></span><br><span class="line"><span class="comment">		fmt.Println(err)        //&lt;nil&gt;</span></span><br><span class="line"><span class="comment">		fmt.Println(n)          //4</span></span><br><span class="line"><span class="comment">		fmt.Println(bs)         //[101 102 103 104]</span></span><br><span class="line"><span class="comment">		fmt.Println(string(bs)) //efgh</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//第三次读取</span></span><br><span class="line"><span class="comment">		n, err = file.Read(bs)</span></span><br><span class="line"><span class="comment">		fmt.Println(err)        //&lt;nil&gt;</span></span><br><span class="line"><span class="comment">		fmt.Println(n)          //2</span></span><br><span class="line"><span class="comment">		fmt.Println(bs)         //[105 106 103 104]</span></span><br><span class="line"><span class="comment">		fmt.Println(string(bs)) //ijgh</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//第四次读取</span></span><br><span class="line"><span class="comment">		n, err = file.Read(bs)</span></span><br><span class="line"><span class="comment">		fmt.Println(err) //EOF，文件的末尾</span></span><br><span class="line"><span class="comment">		fmt.Println(n)   //0</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	n := <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err = file.Read(bs)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> || err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;读取到了文件的末尾，结束读取操作。。&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">		fmt.Println(<span class="type">string</span>(bs[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		abcd</span></span><br><span class="line"><span class="comment">		efgh</span></span><br><span class="line"><span class="comment">		ij</span></span><br><span class="line"><span class="comment">		读取到了文件的末尾，结束读取操作。。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Writer接口的定义，Write()方法用于写出数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">        Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数n（0 &lt;&#x3D; n &lt;&#x3D; len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的n &lt; len(p)，它就必须返回一个非nil的错误。Write 不能修改此切片的数据，即便它是临时的。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	fileName := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	<span class="comment">//step1：打开文件</span></span><br><span class="line">	<span class="comment">//step2：写出数据</span></span><br><span class="line">	<span class="comment">//step3：关闭文件</span></span><br><span class="line">	<span class="comment">//file, err := os.Open(fileName)</span></span><br><span class="line">	file, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写出数据</span></span><br><span class="line">	<span class="comment">//bs := []byte&#123;65, 66, 67, 68, 69, 70&#125; //A,B,C,D,E,F</span></span><br><span class="line">	<span class="comment">//bs := []byte&#123;97, 98, 99, 100&#125; //a,b,c,d</span></span><br><span class="line">	<span class="comment">//n,err := file.Write(bs)</span></span><br><span class="line">	<span class="comment">//n, err := file.Write(bs[:2])</span></span><br><span class="line">	<span class="comment">//fmt.Println(n)</span></span><br><span class="line">	<span class="comment">//HandleErr(err)</span></span><br><span class="line">	<span class="comment">//file.WriteString(&quot;\n&quot;)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//直接写出字符串</span></span><br><span class="line">	<span class="comment">//n, err := file.WriteString(&quot;HelloWorld&quot;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(n)</span></span><br><span class="line">	<span class="comment">//HandleErr(err)</span></span><br><span class="line">	<span class="comment">////</span></span><br><span class="line">	file.WriteString(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	n, err := file.Write([]<span class="type">byte</span>(<span class="string">&quot;today&quot;</span>))</span><br><span class="line">	fmt.Println(n)</span><br><span class="line">	HandleErr(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleErr</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Seeker接口的定义，封装了基本的 Seek 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">        Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Seeker 用来移动数据的读写指针<br>Seek 设置下一次读写操作的指针位置，每次的读写操作都是从指针位置开始的<br>whence 的含义：<br>    如果 whence 为 0：表示从数据的开头开始移动指针<br>    如果 whence 为 1：表示从数据的当前指针位置开始移动指针<br>    如果 whence 为 2：表示从数据的尾部开始移动指针<br>offset 是指针移动的偏移量<br>    返回移动后的指针位置和移动过程中遇到的任何错误</p>
</blockquote>
<p> ReaderFrom接口的定义，封装了基本的 ReadFrom 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderFrom <span class="keyword">interface</span> &#123;</span><br><span class="line">        ReadFrom(r Reader) (n <span class="type">int64</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReadFrom 从 r 中读取数据到对象的数据流中<br>    直到 r 返回 EOF 或 r 出现读取错误为止<br>    返回值 n 是读取的字节数<br>    返回值 err 就是 r 的返回值 err</p>
</blockquote>
<p>WriterTo接口的定义，封装了基本的 WriteTo 方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterTo <span class="keyword">interface</span> &#123;</span><br><span class="line">        WriteTo(w Writer) (n <span class="type">int64</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WriterTo 将对象的数据流写入到 w 中<br>    直到对象的数据流全部写入完毕或遇到写入错误为止<br>    返回值 n 是写入的字节数<br>    返回值 err 就是 w 的返回值 err</p>
<p>定义ReaderAt接口，ReaderAt 接口封装了基本的 ReadAt 方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderAt <span class="keyword">interface</span> &#123;</span><br><span class="line">        ReadAt(p []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReadAt 从对象数据流的 off 处读出数据到 p 中<br>    忽略数据的读写指针，从数据的起始位置偏移 off 处开始读取<br>    如果对象的数据流只有部分可用，不足以填满 p<br>    则 ReadAt 将等待所有数据可用之后，继续向 p 中写入<br>    直到将 p 填满后再返回<br>    在这点上 ReadAt 要比 Read 更严格<br>    返回读取的字节数 n 和读取时遇到的错误<br>    如果 n &lt; len(p)，则需要返回一个 err 值来说明<br>    为什么没有将 p 填满（比如 EOF）<br>    如果 n &#x3D; len(p)，而且对象的数据没有全部读完，则<br>    err 将返回 nil<br>    如果 n &#x3D; len(p)，而且对象的数据刚好全部读完，则<br>    err 将返回 EOF 或者 nil（不确定）</p>
</blockquote>
<p>定义WriterAt接口，WriterAt 接口封装了基本的 WriteAt 方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterAt <span class="keyword">interface</span> &#123;</span><br><span class="line">        WriteAt(p []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>WriteAt 将 p 中的数据写入到对象数据流的 off 处<br>    忽略数据的读写指针，从数据的起始位置偏移 off 处开始写入<br>    返回写入的字节数和写入时遇到的错误<br>    如果 n &lt; len(p)，则必须返回一个 err 值来说明<br>    为什么没有将 p 完全写入</p>
</blockquote>
<h1 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h1><p>在io包中主要是操作流的一些方法，今天主要学习一下copy。就是把一个文件复制到另一个目录下。</p>
<p>它的原理就是通过程序，从源文件读取文件中的数据，在写出到目标文件里。</p>
<h2 id="io包下的Read-和Write"><a href="#io包下的Read-和Write" class="headerlink" title="io包下的Read()和Write()"></a>io包下的Read()和Write()</h2><p>我们可以通过io包下的Read()和Write()方法，边读边写，就能够实现文件的复制。这个方法是按块读取文件，块的大小也会影响到程序的性能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srcFile := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	destFile := <span class="string">&quot;main/2.txt&quot;</span></span><br><span class="line">	total, err := copyFile1(srcFile, destFile)</span><br><span class="line">	fmt.Println(total, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数的功能：实现文件的拷贝，返回值是拷贝的总数量(字节),错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile1</span><span class="params">(srcFile, destFile <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	file1, err := os.Open(srcFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	file2, err := os.OpenFile(destFile, os.O_WRONLY|os.O_CREATE, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file1.Close()</span><br><span class="line">	<span class="keyword">defer</span> file2.Close()</span><br><span class="line">	<span class="comment">// 拷贝数据</span></span><br><span class="line">	bs := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>, <span class="number">1024</span>)</span><br><span class="line">	n := <span class="number">-1</span> <span class="comment">//读取的数据量</span></span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err = file1.Read(bs)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF || n == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;拷贝完毕。。&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;报错了。。。&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> total, err</span><br><span class="line">		&#125;</span><br><span class="line">		total += n</span><br><span class="line">		file2.Write(bs[:n])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="io包下的Copy"><a href="#io包下的Copy" class="headerlink" title="io包下的Copy()"></a>io包下的Copy()</h2><p>我们也可以直接使用io包下的Copy()方法。</p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srcFile := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	destFile := <span class="string">&quot;main/2.txt&quot;</span></span><br><span class="line">	total, err := copyFile2(srcFile, destFile)</span><br><span class="line">	fmt.Println(total, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile2</span><span class="params">(srcFile, destFile <span class="type">string</span>)</span></span> (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	file1, err := os.Open(srcFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	file2, err := os.OpenFile(destFile, os.O_WRONLY|os.O_CREATE, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file1.Close()</span><br><span class="line">	<span class="keyword">defer</span> file2.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> io.Copy(file2, file1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在io包中，不止提供了Copy()方法，还有另外2个公开的copy方法：CopyN()，CopyBuffer()。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Copy（dst,src） <span class="comment">//为复制src 全部到 dst 中。</span></span><br><span class="line"></span><br><span class="line">CopyN(dst,src,n) <span class="comment">//为复制src 中 n 个字节到 dst。</span></span><br><span class="line"></span><br><span class="line">CopyBuffer（dst,src,buf）<span class="comment">//为指定一个buf缓存区，以这个大小完全复制。</span></span><br></pre></td></tr></table></figure>

<p>无论是哪个copy方法最终都是由copyBuffer（）这个私有方法实现的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyBuffer</span><span class="params">(dst Writer, src Reader, buf []<span class="type">byte</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// If the reader has a WriteTo method, use it to do the copy.</span></span><br><span class="line">	<span class="comment">// Avoids an allocation and a copy.</span></span><br><span class="line">	<span class="keyword">if</span> wt, ok := src.(WriterTo); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> wt.WriteTo(dst)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Similarly, if the writer has a ReadFrom method, use it to do the copy.</span></span><br><span class="line">	<span class="keyword">if</span> rt, ok := dst.(ReaderFrom); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> rt.ReadFrom(src)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> buf == <span class="literal">nil</span> &#123;</span><br><span class="line">		size := <span class="number">32</span> * <span class="number">1024</span></span><br><span class="line">		<span class="keyword">if</span> l, ok := src.(*LimitedReader); ok &amp;&amp; <span class="type">int64</span>(size) &gt; l.N &#123;</span><br><span class="line">			<span class="keyword">if</span> l.N &lt; <span class="number">1</span> &#123;</span><br><span class="line">				size = <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				size = <span class="type">int</span>(l.N)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		buf = <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		nr, er := src.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> nr &gt; <span class="number">0</span> &#123;</span><br><span class="line">			nw, ew := dst.Write(buf[<span class="number">0</span>:nr])</span><br><span class="line">			<span class="keyword">if</span> nw &gt; <span class="number">0</span> &#123;</span><br><span class="line">				written += <span class="type">int64</span>(nw)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ew != <span class="literal">nil</span> &#123;</span><br><span class="line">				err = ew</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> nr != nw &#123;</span><br><span class="line">				err = ErrShortWrite</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> er != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> er != EOF &#123;</span><br><span class="line">				err = er</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> written, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这部分代码可以看出，复制主要分为3种。</p>
<p> 1.如果被复制的Reader（src）会尝试能否断言成writerTo，如果可以则直接调用下面的writerTo方法</p>
<p> 2.如果 Writer（dst） 会尝试能否断言成ReadFrom ，如果可以则直接调用下面的readfrom方法</p>
<p> 3.如果都木有实现，则调用底层read实现复制。</p>
<p>其中，有这么一段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> buf == <span class="literal">nil</span> &#123;</span><br><span class="line">		size := <span class="number">32</span> * <span class="number">1024</span></span><br><span class="line">		<span class="keyword">if</span> l, ok := src.(*LimitedReader); ok &amp;&amp; <span class="type">int64</span>(size) &gt; l.N &#123;</span><br><span class="line">			<span class="keyword">if</span> l.N &lt; <span class="number">1</span> &#123;</span><br><span class="line">				size = <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				size = <span class="type">int</span>(l.N)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		buf = <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>这部分主要是实现了对Copy和CopyN的处理。通过上面的调用关系图，我们看出CopyN在调用后，会把Reader转成LimiteReader。</p>
<p>区别是如果Copy，直接建立一个缓存区默认大小为 32* 1024 的buf，如果是CopyN 会先判断 要复制的字节数，如果小于默认大小，会创建一个等于要复制字节数的buf。</p>
<h2 id="ioutil包"><a href="#ioutil包" class="headerlink" title="ioutil包"></a>ioutil包</h2><p>第三种方法是使用ioutil包中的 <code>ioutil.WriteFile()</code>和<code>ioutil.ReadFile()</code>，但由于使用一次性读取文件，再一次性写入文件的方式，所以该方法不适用于大文件，容易内存溢出。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srcFile := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	destFile := <span class="string">&quot;main/2.txt&quot;</span></span><br><span class="line">	total, err := copyFile3(srcFile, destFile)</span><br><span class="line">	fmt.Println(total, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile3</span><span class="params">(srcFile, destFile <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	input, err := ioutil.ReadFile(srcFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = ioutil.WriteFile(destFile, input, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;操作失败：&quot;</span>, destFile)</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(input), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前ReadFile和WriteFile已弃用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我们来测试一下这3种拷贝需要花费时间，拷贝的文件都是一样的一个mp4文件(400M)。</p>
<p>第一种：io包下Read()和Write()直接读写：我们自己创建读取数据的切片的大小，直接影响性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拷贝完毕。。</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">401386819</span><br><span class="line"></span><br><span class="line">real    0m7.911s</span><br><span class="line">user    0m2.900s</span><br><span class="line">sys     0m7.661s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种：io包下Copy()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">401386819</span><br><span class="line"></span><br><span class="line">real    0m1.594s</span><br><span class="line">user    0m0.533s</span><br><span class="line">sys     0m1.136s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三种：ioutil包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">401386819</span><br><span class="line"></span><br><span class="line">real    0m1.515s</span><br><span class="line">user    0m0.339s</span><br><span class="line">sys     0m0.625s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这3种方式，在性能上，不管是还是io.Copy()还是ioutil包，性能都是还不错的。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>断点续传与bufio包</title>
    <url>/2023/06/12/Go/15/</url>
    <content><![CDATA[<h1 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h1><h2 id="Seeker接口"><a href="#Seeker接口" class="headerlink" title="Seeker接口"></a>Seeker接口</h2><p>Seeker是包装基本Seek方法的接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">        Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>seek(offset,whence),设置指针光标的位置，随机读写文件：</p>
<p>​	第一个参数：偏移量<br>​	第二个参数：如何设置			</p>
<p>​				0：seekStart表示相对于文件开始，<br>​				1：seekCurrent表示相对于当前偏移量，<br>​				2：seek end表示相对于结束。</p>
<p>1.txt内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABCDEFababHelloWorldHelloWorld</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	fileName := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(fileName, os.O_RDWR, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">//读写</span></span><br><span class="line">	bs := []<span class="type">byte</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">	file.Read(bs)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bs))</span><br><span class="line"></span><br><span class="line">	file.Seek(<span class="number">4</span>, io.SeekStart)</span><br><span class="line">	file.Read(bs)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bs))</span><br><span class="line"></span><br><span class="line">	file.Seek(<span class="number">2</span>, <span class="number">0</span>) <span class="comment">//SeekStart</span></span><br><span class="line">	file.Read(bs)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bs))</span><br><span class="line"></span><br><span class="line">	file.Seek(<span class="number">3</span>, io.SeekCurrent)</span><br><span class="line">	file.Read(bs)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bs))</span><br><span class="line"></span><br><span class="line">	file.Seek(<span class="number">0</span>, io.SeekEnd)</span><br><span class="line">	file.WriteString(<span class="string">&quot;ABC&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">E</span><br><span class="line">C</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<h2 id="断点续传-1"><a href="#断点续传-1" class="headerlink" title="断点续传"></a>断点续传</h2><p>首先思考几个问题<br>Q1：如果你要传的文件，比较大，那么是否有方法可以缩短耗时？<br>Q2：如果在文件传递过程中，程序因各种原因被迫中断了，那么下次再重启时，文件是否还需要重头开始？<br>Q3：传递文件的时候，支持暂停和恢复么？即使这两个操作分布在程序进程被杀前后。</p>
<p>通过断点续传可以实现，不同的语言有不同的实现方式。我们看看Go语言中，通过Seek()方法如何实现：</p>
<p>先说一下思路：想实现断点续传，主要就是记住上一次已经传递了多少数据，那我们可以创建一个临时文件，记录已经传递的数据量，当恢复传递的时候，先从临时文件中读取上次已经传递的数据量，然后通过Seek()方法，设置到该读和该写的位置，再继续传递数据。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	srcFile := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	destFile := srcFile[strings.LastIndex(srcFile, <span class="string">&quot;/&quot;</span>)+<span class="number">1</span>:]</span><br><span class="line">	tempFile := destFile + <span class="string">&quot;temp.txt&quot;</span></span><br><span class="line"></span><br><span class="line">	file1, err := os.Open(srcFile)</span><br><span class="line">	file2, err := os.OpenFile(destFile, os.O_CREATE|os.O_WRONLY, os.ModePerm)</span><br><span class="line">	file3, err := os.OpenFile(tempFile, os.O_CREATE|os.O_RDWR, os.ModePerm)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file1.Close()</span><br><span class="line">	<span class="keyword">defer</span> file2.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//step1：先读取临时文件中的数据，再seek</span></span><br><span class="line">	file3.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">	bs := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">	n1, err := file3.Read(bs)</span><br><span class="line">	countStr := <span class="type">string</span>(bs[:n1])</span><br><span class="line">	count, err := strconv.ParseInt(countStr, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//step2：设置读，写的位置：</span></span><br><span class="line">	file1.Seek(count, io.SeekStart)</span><br><span class="line">	file2.Seek(count, io.SeekStart)</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>, <span class="number">1024</span>)</span><br><span class="line">	n2 := <span class="number">-1</span>            <span class="comment">//读取的数据量</span></span><br><span class="line">	n3 := <span class="number">-1</span>            <span class="comment">//写出的数据量</span></span><br><span class="line">	total := <span class="type">int</span>(count) <span class="comment">//读取的总量</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//step3：复制文件</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n2, err = file1.Read(data)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF || n2 == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;文件复制完毕。。&quot;</span>)</span><br><span class="line">			file3.Close()</span><br><span class="line">			os.Remove(tempFile)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		n3, err = file2.Write(data[:n2])</span><br><span class="line">		total += n3</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将复制的总量，存储到临时文件中</span></span><br><span class="line">		file3.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">		file3.WriteString(strconv.Itoa(total))</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;total:%d\n&quot;</span>, total)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//假装断电</span></span><br><span class="line">		<span class="comment">//if total &gt; 8000&#123;</span></span><br><span class="line">		<span class="comment">//	panic(&quot;假装断电了。。。&quot;)</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleErr</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="bufio包"><a href="#bufio包" class="headerlink" title="bufio包"></a>bufio包</h1><h2 id="bufio包原理"><a href="#bufio包原理" class="headerlink" title="bufio包原理"></a>bufio包原理</h2><p>bufio 是通过缓冲来提高效率。</p>
<p>io操作本身的效率并不低，低的是频繁的访问本地磁盘的文件。所以bufio就提供了缓冲区(分配一块内存)，读和写都先在缓冲区中，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。</p>
<p>简单的说就是，把文件读取进缓冲（内存）之后再读取的时候就可以避免文件系统的io 从而提高速度。同理，在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。看完以上解释有人可能会表示困惑了，直接把 内容-&gt;文件 和 内容-&gt;缓冲-&gt;文件相比， 缓冲区好像没有起到作用嘛。其实缓冲区的设计是为了存储多次的写入，最后一口气把缓冲区内容写入文件。</p>
<p>bufio 封装了io.Reader或io.Writer接口对象，并创建另一个也实现了该接口的对象。</p>
<p>io.Reader或io.Writer 接口实现read() 和 write() 方法，对于实现这个接口的对象都是可以使用这两个方法的。</p>
<h3 id="Reader对象"><a href="#Reader对象" class="headerlink" title="Reader对象"></a>Reader对象</h3><p>bufio.Reader 是bufio中对io.Reader 的封装</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reader implements buffering for an io.Reader object.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf          []<span class="type">byte</span></span><br><span class="line">	rd           io.Reader <span class="comment">// reader provided by the client</span></span><br><span class="line">	r, w         <span class="type">int</span>       <span class="comment">// buf read and write positions</span></span><br><span class="line">	err          <span class="type">error</span></span><br><span class="line">	lastByte     <span class="type">int</span> <span class="comment">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class="line">	lastRuneSize <span class="type">int</span> <span class="comment">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bufio.Read(p []byte) 相当于读取大小len(p)的内容，思路如下：</p>
<ol>
<li>当缓存区有内容的时，将缓存区内容全部填入p并清空缓存区</li>
<li>当缓存区没有内容的时候且len(p)&gt;len(buf),即要读取的内容比缓存区还要大，直接去文件读取即可</li>
<li>当缓存区没有内容的时候且len(p)&lt;len(buf),即要读取的内容比缓存区小，缓存区从文件读取内容充满缓存区，并将p填满（此时缓存区有剩余内容）</li>
<li>以后再次读取时缓存区有内容，将缓存区内容全部填入p并清空缓存区（此时和情况1一样）</li>
</ol>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;main/1.txt&quot;</span></span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(file *os.File)</span></span> &#123;</span><br><span class="line">		err := file.Close()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建Reader对象</span></span><br><span class="line">	<span class="comment">//b1 := bufio.NewReader(file)</span></span><br><span class="line">	<span class="comment">//1.Read()，高效读取</span></span><br><span class="line">	<span class="comment">//p := make([]byte, 1024)</span></span><br><span class="line">	<span class="comment">//n1, err := b1.Read(p)</span></span><br><span class="line">	<span class="comment">//fmt.Println(n1)</span></span><br><span class="line">	<span class="comment">//fmt.Println(string(p[:n1]))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.ReadLine()</span></span><br><span class="line">	<span class="comment">//data, flag, err := b1.ReadLine()</span></span><br><span class="line">	<span class="comment">//fmt.Println(flag)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(data)</span></span><br><span class="line">	<span class="comment">//fmt.Println(string(data))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.ReadString()</span></span><br><span class="line">	<span class="comment">//s1, err := b1.ReadString(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(s1)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//s1, err = b1.ReadString(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(s1)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//s1, err = b1.ReadString(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(s1)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//for &#123;</span></span><br><span class="line">	<span class="comment">//	s1, err := b1.ReadString(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//	if err == io.EOF &#123;</span></span><br><span class="line">	<span class="comment">//		fmt.Println(&quot;读取完毕。。&quot;)</span></span><br><span class="line">	<span class="comment">//		break</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(s1)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.ReadBytes()</span></span><br><span class="line">	<span class="comment">//data, err := b1.ReadBytes(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(string(data))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Scanner,输入的内容如果有空格，只能接收到空格前面的数据</span></span><br><span class="line">	<span class="comment">//s2 := &quot;&quot;</span></span><br><span class="line">	<span class="comment">//fmt.Scanln(&amp;s2)</span></span><br><span class="line">	<span class="comment">//fmt.Println(s2)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//可以接收到空格后面的数据</span></span><br><span class="line">	b2 := bufio.NewReader(os.Stdin)</span><br><span class="line">	s2, _ := b2.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Writer对象"><a href="#Writer对象" class="headerlink" title="Writer对象"></a>Writer对象</h3><p>bufio.Writer 是bufio中对io.Writer 的封装</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Writer implements buffering for an io.Writer object.</span></span><br><span class="line"><span class="comment">// If an error occurs writing to a Writer, no more data will be</span></span><br><span class="line"><span class="comment">// accepted and all subsequent writes, and Flush, will return the error.</span></span><br><span class="line"><span class="comment">// After all data has been written, the client should call the</span></span><br><span class="line"><span class="comment">// Flush method to guarantee all data has been forwarded to</span></span><br><span class="line"><span class="comment">// the underlying io.Writer.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> &#123;</span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">	buf []<span class="type">byte</span></span><br><span class="line">	n   <span class="type">int</span></span><br><span class="line">	wr  io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bufio.Write(p []byte) 的思路如下</p>
<ol>
<li>判断buf中可用容量是否可以放下 p</li>
<li>如果能放下，直接把p拼接到buf后面，即把内容放到缓冲区</li>
<li>如果缓冲区的可用容量不足以放下，且此时缓冲区是空的，直接把p写入文件即可</li>
<li>如果缓冲区的可用容量不足以放下，且此时缓冲区有内容，则用p把缓冲区填满，把缓冲区所有内容写入文件，并清空缓冲区</li>
<li>判断p的剩余内容大小能否放到缓冲区，如果能放下（此时和步骤1情况一样）则把内容放到缓冲区</li>
<li>如果p的剩余内容依旧大于缓冲区，（注意此时缓冲区是空的，情况和步骤3一样）则把p的剩余内容直接写入文件</li>
</ol>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;main/2.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(file *os.File)</span></span> &#123;</span><br><span class="line">		err := file.Close()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(file)</span><br><span class="line"></span><br><span class="line">	w1 := bufio.NewWriter(file)</span><br><span class="line">	<span class="comment">//n, err := w1.WriteString(&quot;helloworld&quot;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(n)</span></span><br><span class="line">	<span class="comment">//err = w1.Flush()</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125; //刷新缓冲区</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		_, err2 := w1.WriteString(fmt.Sprintf(<span class="string">&quot;%d:hello&quot;</span>, i))</span><br><span class="line">		<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err = w1.Flush()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bufio包-1"><a href="#bufio包-1" class="headerlink" title="bufio包"></a>bufio包</h2><p>bufio包实现了有缓冲的I&#x2F;O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I&#x2F;O的帮助函数的对象。</p>
<h3 id="bufio-Reader"><a href="#bufio-Reader" class="headerlink" title="bufio.Reader"></a>bufio.Reader</h3><p>bufio.Reader 实现了如下接口：<br>    io.Reader<br>    io.WriterTo<br>    io.ByteScanner<br>    io.RuneScanner</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewReaderSize 将 rd 封装成一个带缓存的 bufio.Reader 对象，</span></span><br><span class="line"><span class="comment">// 缓存大小由 size 指定（如果小于 16 则会被设置为 16）。</span></span><br><span class="line"><span class="comment">// 如果 rd 的基类型就是有足够缓存的 bufio.Reader 类型，则直接将</span></span><br><span class="line"><span class="comment">// rd 转换为基类型返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="type">int</span>)</span></span> *Reader</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewReader 相当于 NewReaderSize(rd, 4096)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *Reader</span><br><span class="line"></span><br><span class="line"><span class="comment">// Peek 返回缓存的一个切片，该切片引用缓存中前 n 个字节的数据，</span></span><br><span class="line"><span class="comment">// 该操作不会将数据读出，只是引用，引用的数据在下一次读取操作之</span></span><br><span class="line"><span class="comment">// 前是有效的。如果切片长度小于 n，则返回一个错误信息说明原因。</span></span><br><span class="line"><span class="comment">// 如果 n 大于缓存的总大小，则返回 ErrBufferFull。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Peek(n <span class="type">int</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read 从 b 中读出数据到 p 中，返回读出的字节数和遇到的错误。</span></span><br><span class="line"><span class="comment">// 如果缓存不为空，则只能读出缓存中的数据，不会从底层 io.Reader</span></span><br><span class="line"><span class="comment">// 中提取数据，如果缓存为空，则：</span></span><br><span class="line"><span class="comment">// 1、len(p) &gt;= 缓存大小，则跳过缓存，直接从底层 io.Reader 中读</span></span><br><span class="line"><span class="comment">// 出到 p 中。</span></span><br><span class="line"><span class="comment">// 2、len(p) &lt; 缓存大小，则先将数据从底层 io.Reader 中读取到缓存</span></span><br><span class="line"><span class="comment">// 中，再从缓存读取到 p 中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Buffered 返回缓存中未读取的数据的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Buffered() <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadBytes 功能同 ReadSlice，只不过返回的是缓存的拷贝。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadBytes(delim <span class="type">byte</span>) (line []<span class="type">byte</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadString 功能同 ReadBytes，只不过返回的是字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadString(delim <span class="type">byte</span>) (line <span class="type">string</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<h3 id="bufio-Writer"><a href="#bufio-Writer" class="headerlink" title="bufio.Writer"></a>bufio.Writer</h3><p>bufio.Writer 实现了如下接口：<br>    io.Writer<br>    io.ReaderFrom<br>    io.ByteWriter</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewWriterSize 将 wr 封装成一个带缓存的 bufio.Writer 对象，</span></span><br><span class="line"><span class="comment">// 缓存大小由 size 指定（如果小于 4096 则会被设置为 4096）。</span></span><br><span class="line"><span class="comment">// 如果 wr 的基类型就是有足够缓存的 bufio.Writer 类型，则直接将</span></span><br><span class="line"><span class="comment">// wr 转换为基类型返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(wr io.Writer, size <span class="type">int</span>)</span></span> *Writer</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewWriter 相当于 NewWriterSize(wr, 4096)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(wr io.Writer)</span></span> *Writer</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteString 功能同 Write，只不过写入的是字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> WriteString(s <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteRune 向 b 写入 r 的 UTF-8 编码，返回 r 的编码长度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> WriteRune(r <span class="type">rune</span>) (size <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush 将缓存中的数据提交到底层的 io.Writer 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Flush() <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Available 返回缓存中未使用的空间的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Available() <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Buffered 返回缓存中未提交的数据的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Buffered() <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 将 b 的底层 Writer 重新指定为 w，同时丢弃缓存中的所有数据，复位</span></span><br><span class="line"><span class="comment">// 所有标记和错误信息。相当于创建了一个新的 bufio.Writer。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Reset(w io.Writer)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>包的使用和time包</title>
    <url>/2023/06/10/Go/13/</url>
    <content><![CDATA[<h1 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h1><p>Go语言使用包（package）这种语法元素来组织源码，所有语法可见性均定义在package这个级别，与Java 、python等语言相比，这算不上什么创新，但与C传统的include相比，则是显得“先进”了许多。</p>
<p>Go 语言的源码复用建立在包（package）基础之上。包通过 package, import, GOPATH 操作完成。</p>
<h2 id="main包"><a href="#main包" class="headerlink" title="main包"></a>main包</h2><p>Go 语言的入口 main() 函数所在的包（package）叫 main，main 包想要引用别的代码，需要import导入！</p>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>src 目录是以代码包的形式组织并保存 Go 源码文件的。每个代码包都和 src 目录下的文件夹一一对应。每个子目录都是一个代码包。</p>
<blockquote>
<p>代码包包名和文件目录名，不要求一致。比如文件目录叫 hello，但是代码包包名可以声明为 “main”，但是同一个目录下的源码文件第一行声明的所属包，必须一致！</p>
</blockquote>
<p>同一个目录下的所有.go文件的第一行添加 包定义，以标记该文件归属的包，演示语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure>

<p>包需要满足：</p>
<ul>
<li>一个目录下的同级文件归属一个包。也就是说，在同一个包下面的所有文件的package名，都是一样的。</li>
<li>在同一个包下面的文件<code>package</code>名都建议设为是该目录名，但也可以不是。也就是说，包名可以与其目录不同名。</li>
<li>包名为 main 的包为应用程序的入口包，其他包不能使用。</li>
</ul>
<blockquote>
<p>在同一个包下面的文件属于同一个工程文件，不用<code>import</code>包，可以直接使用</p>
</blockquote>
<p>包可以嵌套定义，对应的就是嵌套目录，但包名应该与所在的目录一致。</p>
<p>包中，通过标识符首字母是否大写，来确定是否可以被导出。首字母大写才可以被导出，视为 public 公共的资源。</p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>要引用其他包，可以使用 import 关键字，可以单个导入或者批量导入，语法演示：</p>
<p>A：通常导入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package&quot;</span></span><br><span class="line"><span class="comment">// 批量导入</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;package1&quot;</span></span><br><span class="line">  <span class="string">&quot;package2&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>B：点操作<br>我们有时候会看到如下的方式导入包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	. <span class="string">&quot;fmt&quot;</span></span><br><span class="line">) </span><br></pre></td></tr></table></figure>

<p>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	. <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span></span> p(n <span class="type">int</span>) S &#123;</span><br><span class="line">	Print(n)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">defer</span> s.p(<span class="number">1</span>).p(<span class="number">2</span>)</span><br><span class="line">	Print(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C：起别名</p>
<p>别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字。导入时，可以为包定义别名，语法演示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  p1 <span class="string">&quot;package1&quot;</span></span><br><span class="line">  p2 <span class="string">&quot;package2&quot;</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment">// 使用时：别名操作，调用包函数时前缀变成了我们的前缀</span></span><br><span class="line">p1.Method()</span><br></pre></td></tr></table></figure>

<p>D：_操作<br>如果仅仅需要导入包时执行初始化操作，并不需要使用包内的其他函数，常量等资源。则可以在导入包时，匿名导入。</p>
<p>这个操作经常是让很多人费解的一个操作符，请看下面这个import：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:@tcp(127.0.0.1:3306)/flask_meeting?charset=utf8mb4&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;错误信息&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;连接成功&quot;</span>, db)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。也就是说，使用下划线作为包的别名，会仅仅执行init()。</p>
<blockquote>
<p>导入的包的路径名，可以是相对路径也可以是绝对路径，推荐使用绝对路径（起始于工程根目录）。</p>
</blockquote>
<h2 id="GOPATH环境变量"><a href="#GOPATH环境变量" class="headerlink" title="GOPATH环境变量"></a>GOPATH环境变量</h2><p>import导入时，会从GO的安装目录（也就是GOROOT环境变量设置的目录）和GOPATH环境变量设置的目录中，检索 src&#x2F;package 来导入包。如果不存在，则导入失败。<br>GOROOT，就是GO内置的包所在的位置。<br>GOPATH，就是我们自己定义的包的位置。</p>
<p>通常我们在开发Go项目时，调试或者编译构建时，需要设置GOPATH指向我们的项目目录，目录中的src目录中的包就可以被导入了。</p>
<h2 id="init-包初始化"><a href="#init-包初始化" class="headerlink" title="init() 包初始化"></a>init() 包初始化</h2><p>下面我们详细的来介绍一下这两个函数：init()、main() 是 go 语言中的保留函数。我们可以在源码中，定义 init() 函数。此函数会在包被导入时执行，例如如果是在 main 中导入包，包中存在 init()，那么 init() 中的代码会在 main() 函数执行前执行，用于初始化包所需要的特定资料。例如：<br>包源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/userPackage/tool.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> userPackage</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;tool init&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;userPackage&quot;</span></span><br><span class="line">  )</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;main run&quot;</span>)</span><br><span class="line">  <span class="comment">// 使用userPackage</span></span><br><span class="line">  userPackage.SomeFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行时，会先输出 “tool init”，再输出 “main run”。</p>
<p>下面我们详细的来介绍一下init()、main() 这两个函数。在 go 语言中的区别如下：<br>相同点：</p>
<p>两个函数在定义时不能有任何的参数和返回值。<br>该函数只能由 go 程序自动调用，不可以被引用。</p>
<p>不同点：</p>
<p>init 可以应用于任意包中，且可以重复定义多个。<br>main 函数只能用于 main 包中，且只能定义一个。</p>
<p>两个函数的执行顺序：</p>
<p>在 main 包中的 go 文件默认总是会被执行。</p>
<ul>
<li><p>对同一个 go 文件的 init( ) 调用顺序是从上到下的。</p>
</li>
<li><p>对同一个 package 中的不同文件，将文件名按字符串进行“从小到大”排序，之后顺序调用各文件中的init()函数。</p>
</li>
<li><p>对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数。</p>
</li>
<li><p>如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main，一次执行对应的 init 方法。main 包总是被最后一个初始化，因为它总是依赖别的包</p>
</li>
</ul>
<p>避免出现循环 import，例如：A –&gt; B –&gt; C –&gt; A。</p>
<p>一个包被其它多个包 import，但只能被初始化一次</p>
<h2 id="管理外部包"><a href="#管理外部包" class="headerlink" title="管理外部包"></a>管理外部包</h2><p>go允许import不同代码库的代码。对于import要导入的外部的包，可以使用 go get 命令取下来放到GOPATH对应的目录中去。</p>
<p>举个例子，比如说我们想通过go语言连接mysql数据库，那么需要先下载mysql的数据包，打开终端并输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go get github.com/go-sql-driver/mysql</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>也就是说，对于go语言来讲，其实并不关心你的代码是内部还是外部的，总之都在GOPATH里，任何import包的路径都是从GOPATH开始的；唯一的区别，就是内部依赖的包是开发者自己写的，外部依赖的包是go get下来的。</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们可以通过go install 来编译包文件。</p>
<p>我们知道一个非main包在编译后会生成一个.a文件（在临时目录下生成，除非使用go install安装到$GOROOT或$GOPATH下，否则你看不到.a），用于后续可执行程序链接使用。</p>
<p>比如Go标准库中的包对应的源码部分路径在：$GOROOT&#x2F;src，而标准库中包编译后的.a文件路径在$GOROOT&#x2F;pkg&#x2F;darwin_amd64下。</p>
<ul>
<li>pkg 目录是用来存放通过 go install 命令安装后的代码包的归档文件(.a 文件)。归档文件的名字就是代码包的名字。所有归档文件都会被存放到该目录下的平台相关目录中，即在 <code>$GOPATH/pkg/$GOOS_$GOARCH</code> 中，同样以代码包为组织形式。</li>
</ul>
<h1 id="time包"><a href="#time包" class="headerlink" title="time包"></a>time包</h1><p>time包：<br>       1年&#x3D;365天，day<br>       1天&#x3D;24小时，hour<br>       1小时&#x3D;60分钟，minute<br>       1分钟&#x3D;60秒，second<br>       1秒钟&#x3D;1000毫秒，millisecond<br>       1毫秒&#x3D;1000微秒，microsecond–&gt;μs<br>       1微秒&#x3D;1000纳秒，nanosecond–&gt;ns<br>       1纳秒&#x3D;1000皮秒，picosecond–&gt;ps</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.获取当前的时间</span></span><br><span class="line">	t1 := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, t1) <span class="comment">//time.Time</span></span><br><span class="line">	fmt.Println(t1)        <span class="comment">//2023-06-10 11:16:15.340273 +0800 CST m=+0.003384001</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.获取指定的时间</span></span><br><span class="line">	t2 := time.Date(<span class="number">2008</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">28</span>, <span class="number">0</span>, time.Local)</span><br><span class="line">	fmt.Println(t2) <span class="comment">//2008-07-15 16:30:28 +0800 CST</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.time--&gt;string之间的转换</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 t1.Format(&quot;格式模板&quot;)--&gt;string</span></span><br><span class="line"><span class="comment">		模板的日期必须是固定：06-1-2-3-4-5</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s1 := t1.Format(<span class="string">&quot;2006-1-2 15:04:05&quot;</span>)</span><br><span class="line">	fmt.Println(s1) <span class="comment">//2023-6-10 11:16:15</span></span><br><span class="line"></span><br><span class="line">	s2 := t1.Format(<span class="string">&quot;2006/01/02&quot;</span>)</span><br><span class="line">	fmt.Println(s2) <span class="comment">//2023/06/10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//string--&gt;time</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 time.Parse(&quot;模板&quot;,str)--&gt;time,err</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s3 := <span class="string">&quot;1999年10月10日&quot;</span> <span class="comment">//string</span></span><br><span class="line">	t3, err := time.Parse(<span class="string">&quot;2006年01月02日&quot;</span>, s3)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(t3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, t3)</span><br><span class="line"></span><br><span class="line">	fmt.Println(t1.String())</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.根据当前时间，获取指定的内容</span></span><br><span class="line">	year, month, day := t1.Date() <span class="comment">//年，月，日</span></span><br><span class="line">	fmt.Println(year, month, day) <span class="comment">//2023 June 10</span></span><br><span class="line"></span><br><span class="line">	hour, min, sec := t1.Clock()</span><br><span class="line">	fmt.Println(hour, min, sec) <span class="comment">//时，分，秒</span></span><br><span class="line"></span><br><span class="line">	year2 := t1.Year()</span><br><span class="line">	fmt.Println(<span class="string">&quot;年：&quot;</span>, year2)</span><br><span class="line">	fmt.Println(t1.YearDay())</span><br><span class="line"></span><br><span class="line">	month2 := t1.Month()</span><br><span class="line">	fmt.Println(<span class="string">&quot;月：&quot;</span>, month2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;日：&quot;</span>, t1.Day())</span><br><span class="line">	fmt.Println(<span class="string">&quot;时：&quot;</span>, t1.Hour())</span><br><span class="line">	fmt.Println(<span class="string">&quot;分钟：&quot;</span>, t1.Minute())</span><br><span class="line">	fmt.Println(<span class="string">&quot;秒：&quot;</span>, t1.Second())</span><br><span class="line">	fmt.Println(<span class="string">&quot;纳秒：&quot;</span>, t1.Nanosecond())</span><br><span class="line"></span><br><span class="line">	fmt.Println(t1.Weekday()) <span class="comment">//Wednesday</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.时间戳：指定的日期，距离1970年1月1日0点0时0分0秒的时间差值：秒，纳秒</span></span><br><span class="line"></span><br><span class="line">	t4 := time.Date(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">	timeStamp1 := t4.Unix() <span class="comment">//秒的差值</span></span><br><span class="line">	fmt.Println(timeStamp1)</span><br><span class="line">	timeStamp2 := t1.Unix()</span><br><span class="line">	fmt.Println(timeStamp2)</span><br><span class="line"></span><br><span class="line">	timeStamp3 := t4.UnixNano()</span><br><span class="line">	fmt.Println(timeStamp3) <span class="comment">//3600 000 000 000</span></span><br><span class="line">	timeStamp4 := t1.UnixNano()</span><br><span class="line">	fmt.Println(timeStamp4)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6.时间间隔</span></span><br><span class="line">	t5 := t1.Add(time.Minute)</span><br><span class="line">	fmt.Println(t1)</span><br><span class="line">	fmt.Println(t5)</span><br><span class="line">	fmt.Println(t1.Add(<span class="number">24</span> * time.Hour))</span><br><span class="line"></span><br><span class="line">	t6 := t1.AddDate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	fmt.Println(t6)</span><br><span class="line"></span><br><span class="line">	d1 := t5.Sub(t1)</span><br><span class="line">	fmt.Println(d1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//7.睡眠</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second) <span class="comment">//让当前的程序进入睡眠状态</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main。。。over。。。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//睡眠[1-10]的随机秒数</span></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	randNum := rand.Intn(<span class="number">10</span>) + <span class="number">1</span> <span class="comment">//int</span></span><br><span class="line">	fmt.Println(randNum)</span><br><span class="line">	time.Sleep(time.Duration(randNum) * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;睡醒了。。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time.Time</span><br><span class="line">2023-06-10 11:24:17.1424817 +0800 CST m=+0.003008901</span><br><span class="line">2008-07-15 16:30:28 +0800 CST</span><br><span class="line">2023-6-10 11:24:17</span><br><span class="line">2023/06/10</span><br><span class="line">1999-10-10 00:00:00 +0000 UTC</span><br><span class="line">time.Time</span><br><span class="line">2023-06-10 11:24:17.1424817 +0800 CST m=+0.003008901</span><br><span class="line">2023 June 10</span><br><span class="line">11 24 17</span><br><span class="line">年： 2023</span><br><span class="line">161</span><br><span class="line">月： June</span><br><span class="line">日： 10</span><br><span class="line">时： 11</span><br><span class="line">分钟： 24</span><br><span class="line">秒： 17</span><br><span class="line">纳秒： 142481700</span><br><span class="line">Saturday</span><br><span class="line">3600</span><br><span class="line">1686367457</span><br><span class="line">3600000000000</span><br><span class="line">1686367457142481700</span><br><span class="line">2023-06-10 11:24:17.1424817 +0800 CST m=+0.003008901</span><br><span class="line">2023-06-10 11:25:17.1424817 +0800 CST m=+60.003008901</span><br><span class="line">2023-06-11 11:24:17.1424817 +0800 CST m=+86400.003008901</span><br><span class="line">2024-06-10 11:24:17.1424817 +0800 CST</span><br><span class="line">1m0s</span><br><span class="line">main。。。over。。。。。</span><br><span class="line">7</span><br><span class="line">睡醒了。。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>Goroutine并发模型</title>
    <url>/2023/06/14/Go/17/</url>
    <content><![CDATA[<h1 id="Go语言的协程——Goroutine"><a href="#Go语言的协程——Goroutine" class="headerlink" title="Go语言的协程——Goroutine"></a>Go语言的协程——Goroutine</h1><p><strong>进程(Process)，线程(Thread)，协程(Coroutine，也叫轻量级线程)</strong></p>
<ul>
<li><p>进程<br>进程是一个程序在一个数据集中的一次动态执行过程，可以简单理解为“正在执行的程序”，它是CPU资源分配和调度的独立单位。<br>进程一般由程序、数据集、进程控制块三部分组成。我们编写的程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 <strong>进程的局限是创建、撤销和切换的开销比较大。</strong></p>
</li>
<li><p>线程<br>线程是在进程之后发展出来的概念。 线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成。一个进程可以包含多个线程。<br>线程的优点是减小了程序并发执行时的开销，提高了操作系统的并发性能，缺点是线程没有自己的系统资源，只拥有在运行时必不可少的资源，但同一进程的各线程可以共享进程所拥有的系统资源，如果把进程比作一个车间，那么线程就好比是车间里面的工人。不过对于某些独占性资源存在锁机制，处理不当可能会产生“死锁”。</p>
</li>
<li><p>协程<br>协程是一种用户态的轻量级线程，又称微线程，英文名Coroutine，协程的调度完全由用户控制。人们通常将协程和子程序（函数）比较着理解。 子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。</p>
</li>
</ul>
<p><strong>与传统的系统级线程和进程相比，协程的最大优势在于其”轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过1万的。这也是协程也叫轻量级线程的原因。</strong></p>
<blockquote>
<p>协程的特点在于是一个线程执行，与多线程相比，其优势体现在：协程的执行效率极高。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
</blockquote>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><h3 id="什么是Goroutine"><a href="#什么是Goroutine" class="headerlink" title="什么是Goroutine"></a>什么是Goroutine</h3><p>go中使用Goroutine来实现并发concurrently。</p>
<p>Goroutine是Go语言特有的名词。区别于进程Process，线程Thread，协程Coroutine，因为Go语言的创造者们觉得和他们是有所区别的，所以专门创造了Goroutine。</p>
<p>Goroutine是与其他函数或方法同时运行的函数或方法。Goroutines可以被认为是轻量级的线程。与线程相比，创建Goroutine的成本很小，它就是一段代码，一个函数入口。以及在堆上为其分配的一个堆栈（初始大小为4K，会随着程序的执行自动增长删除）。因此它非常廉价，Go应用程序可以并发运行数千个Goroutines。</p>
<blockquote>
<p>Goroutines在线程上的优势。</p>
<ol>
<li>与线程相比，Goroutines非常便宜。它们只是堆栈大小的几个kb，堆栈可以根据应用程序的需要增长和收缩，而在线程的情况下，堆栈大小必须指定并且是固定的</li>
<li>Goroutines被多路复用到较少的OS线程。在一个程序中可能只有一个线程与数千个Goroutines。如果线程中的任何Goroutine都表示等待用户输入，则会创建另一个OS线程，剩下的Goroutines被转移到新的OS线程。所有这些都由运行时进行处理，我们作为程序员从这些复杂的细节中抽象出来，并得到了一个与并发工作相关的干净的API。</li>
<li>当使用Goroutines访问共享内存时，通过设计的通道可以防止竞态条件发生。通道可以被认为是Goroutines通信的管道。</li>
</ol>
</blockquote>
<h3 id="主goroutine"><a href="#主goroutine" class="headerlink" title="主goroutine"></a>主goroutine</h3><p>封装main函数的goroutine称为主goroutine。</p>
<p>主goroutine所做的事情并不是执行main函数那么简单。它首先要做的是：设定每一个goroutine所能申请的栈空间的最大尺寸。在32位的计算机系统中此最大尺寸为250MB，而在64位的计算机系统中此尺寸为1GB。如果有某个goroutine的栈空间尺寸大于这个限制，那么运行时系统就会引发一个栈溢出(stack overflow)的运行时恐慌。随后，这个go程序的运行也会终止。</p>
<p>此后，主goroutine会进行一系列的初始化工作，涉及的工作内容大致如下：</p>
<ol>
<li><p>创建一个特殊的defer语句，用于在主goroutine退出时做必要的善后处理。因为主goroutine也可能非正常的结束</p>
</li>
<li><p>启动专用于在后台清扫内存垃圾的goroutine，并设置GC可用的标识</p>
</li>
<li><p>执行mian包中的init函数</p>
</li>
<li><p>执行main函数</p>
<p>执行完main函数后，它还会检查主goroutine是否引发了运行时恐慌，并进行必要的处理。最后主goroutine会结束自己以及当前进程的运行。</p>
</li>
</ol>
<h3 id="如何使用Goroutines"><a href="#如何使用Goroutines" class="headerlink" title="如何使用Goroutines"></a>如何使用Goroutines</h3><p>在函数或方法调用前面加上关键字go，您将会同时运行一个新的Goroutine。</p>
<p>实例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    fmt.Println(<span class="string">&quot;main function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：可能会值输出<code>main function</code>。</p>
<p>由于主线程和新的goroutine是并发执行的，它们在时间上是相互独立的，因此主线程在打印”main function”之后，很可能立即结束，而新的goroutine可能没有足够的时间来执行<code>fmt.Println(&quot;Hello world goroutine&quot;)</code>语句，从而导致该语句没有被执行和打印。</p>
<p>我们开始的Goroutine怎么样了?我们需要了解Goroutine的规则</p>
<ol>
<li>当新的Goroutine开始时，Goroutine调用立即返回。与函数不同，go不等待Goroutine执行结束。当Goroutine调用，并且Goroutine的任何返回值被忽略之后，go立即执行到下一行代码。</li>
<li>main的Goroutine应该为其他的Goroutines执行。如果main的Goroutine终止了，程序将被终止，而其他Goroutine将不会运行。</li>
</ol>
<p>修改以上代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们已经调用了时间包的Sleep方法，它会在执行过程中睡觉。在这种情况下，main的goroutine被用来睡觉1秒。现在调用go hello()有足够的时间在main Goroutine终止之前执行。这个程序首先打印Hello world goroutine，等待1秒，然后打印<code>main function</code>。</p>
<h3 id="启动多个Goroutines"><a href="#启动多个Goroutines" class="headerlink" title="启动多个Goroutines"></a>启动多个Goroutines</h3><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numbers</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">250</span> * time.Millisecond)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alphabets</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;e&#x27;</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">400</span> * time.Millisecond)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> numbers()</span><br><span class="line">    <span class="keyword">go</span> alphabets()</span><br><span class="line">    time.Sleep(<span class="number">3000</span> * time.Millisecond)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main terminated&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 a 2 3 b 4 c 5 d e main terminated  </span><br></pre></td></tr></table></figure>

<p>时间轴分析：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/dxc.png"></p>
<h1 id="Go语言的并发模型"><a href="#Go语言的并发模型" class="headerlink" title="Go语言的并发模型"></a>Go语言的并发模型</h1><p>Go 语言相比Java等一个很大的优势就是可以方便地编写并发程序。Go 语言内置了 goroutine 机制，使用goroutine可以快速地开发并发程序， 更好的利用多核处理器资源。接下来我们来了解一下Go语言的并发原理。</p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>在现代操作系统中，线程是处理器调度和分配的基本单位，进程则作为资源拥有的基本单位。每个进程是由私有的虚拟地址空间、代码、数据和其它各种系统资源组成。线程是进程内部的一个执行单元。 每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。 用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。</p>
<p>我们先从线程讲起，无论语言层面何种并发模型，到了操作系统层面，一定是以线程的形态存在的。而操作系统根据资源访问权限的不同，体系架构可分为用户空间和内核空间；内核空间主要操作访问CPU资源、I&#x2F;O资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源，用户空间呢就是上层应用程序的固定活动空间，用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“Shell脚本”来调用内核空间提供的资源。</p>
<p>我们现在的计算机语言，可以狭义的认为是一种“软件”，它们中所谓的“线程”，往往是用户态的线程，和操作系统本身内核态的线程（简称KSE），还是有区别的。</p>
<p>Go并发编程模型在底层是由操作系统所提供的线程库支撑的，因此还是得从线程实现模型说起。</p>
<p>线程可以视为进程中的控制流。一个进程至少会包含一个线程，因为其中至少会有一个控制流持续运行。因而，一个进程的第一个线程会随着这个进程的启动而创建，这个线程称为该进程的主线程。当然，一个进程也可以包含多个线程。这些线程都是由当前进程中已存在的线程创建出来的，创建的方法就是调用系统调用，更确切地说是调用<br>pthread create函数。拥有多个线程的进程可以并发执行多个任务，并且即使某个或某些任务被阻塞，也不会影响其他任务正常执行，这可以大大改善程序的响应时间和吞吐量。另一方面，线程不可能独立于进程存在。它的生命周期不可能逾越其所属进程的生命周期。</p>
<p>线程的实现模型主要有3个，分别是:用户级线程模型、内核级线程模型和两级线程模型。它们之间最大的差异就在于线程与内核调度实体( Kernel Scheduling Entity,简称KSE)之间的对应关系上。顾名思义，内核调度实体就是可以被内核的调度器调度的对象。在很多文献和书中，它也称为内核级线程，是操作系统内核的最小调度单元。</p>
<h3 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h3><p>用户线程与KSE是1对1关系(1:1)。大部分编程语言的线程库(如linux的pthread，Java的java.lang.Thread，C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个不同的KSE静态关联，因此其调度完全由OS调度器来做。这种方式实现简单，直接借助OS提供的线程能力，并且不同用户线程之间一般也不会相互影响。但其创建，销毁以及多个线程之间的上下文切换等操作都是直接由OS层面亲自来做，在需要使用大量线程的场景下对OS的性能影响会很大。每个线程由内核调度器独立的调度，所以如果一个线程阻塞则不影响其他的线程。</p>
<p>优点：在多核处理器的硬件的支持下，内核空间线程模型支持了真正的并行，当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。</p>
<p>缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</p>
<h3 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h3><p>用户线程与KSE是多对1关系(M:1)，这种线程的创建，销毁以及多个线程之间的协调等操作都是由用户自己实现的线程库来负责，对OS内核透明，一个进程中所有创建的线程都与同一个KSE在运行时动态关联。现在有许多语言实现的 <strong>协程</strong> 基本上都属于这种方式。这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的数量与上下文切换所花费的代价也会小得多。但该模型有个致命的缺点，如果我们在某个用户线程上调用阻塞式系统调用(如用阻塞方式read网络IO)，那么一旦KSE因阻塞被内核调度出CPU的话，剩下的所有对应的用户线程全都会变为阻塞状态（整个进程挂起）。<br>所以这些语言的<strong>协程库</strong>会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。</p>
<p>优点： 这种模型的好处是线程上下文切换都发生在用户空间，避免的模态切换（mode switch），从而对于性能有积极的影响。</p>
<p>缺点：所有的线程基于一个内核调度实体即内核线程，这意味着只有一个处理器可以被利用，在多处理器环境下这是不能够被接受的，本质上，用户线程只解决了并发问题，但是没有解决并行问题。如果线程因为 I&#x2F;O 操作陷入了内核态，内核态线程阻塞等待 I&#x2F;O 数据，则所有的线程都将会被阻塞，用户空间也可以使用非阻塞而 I&#x2F;O，但是不能避免性能及复杂度问题。</p>
<h3 id="两级线程模型"><a href="#两级线程模型" class="headerlink" title="两级线程模型"></a>两级线程模型</h3><p>用户线程与KSE是多对多关系(M:N)，这种实现综合了前两种模型的优点，为一个进程中创建多个KSE，并且线程可以与不同的KSE在运行时进行动态关联，当某个KSE由于其上工作的线程的阻塞操作被内核调度出CPU时，当前与其关联的其余用户线程可以重新与其他KSE建立关联关系。当然这种动态关联机制的实现很复杂，也需要用户自己去实现，这算是它的一个缺点吧。Go语言中的并发就是使用的这种实现方式，Go为了实现该模型自己实现了一个运行时调度器来负责Go中的”线程”与KSE的动态关联。此模型有时也被称为 <strong>混合型线程模型</strong>，<strong>即用户调度器实现用户线程到KSE的“调度”，内核调度器实现KSE到CPU上的调度</strong>。</p>
<h2 id="Go并发调度-G-P-M模型"><a href="#Go并发调度-G-P-M模型" class="headerlink" title="Go并发调度: G-P-M模型"></a>Go并发调度: G-P-M模型</h2><p>在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。goroutine机制实现了M : N的线程模型，goroutine机制是协程（coroutine）的一种实现，golang内置的调度器，可以让多核CPU中每个CPU执行一个协程。</p>
<h3 id="调度器是如何工作的"><a href="#调度器是如何工作的" class="headerlink" title="调度器是如何工作的"></a>调度器是如何工作的</h3><p>有了上面的认识，我们可以开始真正的介绍Go的并发机制了，先用一段代码展示一下在Go语言中新建一个“线程”(Go语言中称为Goroutine)的样子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用go关键字加上一个函数（这里用了匿名函数）</span></span><br><span class="line"><span class="comment">// 调用就做到了在一个新的“线程”并发执行任务</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="comment">// do something in one new goroutine</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>理解goroutine机制的原理，关键是理解Go语言scheduler的实现。</p>
<p>Go语言中支撑整个scheduler实现的主要有4个重要结构，分别是M、G、P、Sched， 前三个定义在runtime.h中，Sched定义在proc.c中。</p>
<ul>
<li>Sched结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。</li>
<li>M结构是Machine，系统线程，它由操作系统管理的，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。</li>
<li>P结构是Processor，处理器，它的主要用途就是用来执行goroutine的，它维护了一个goroutine队列，即runqueue。Processor是让我们从N:1调度到M:N调度的重要部分。</li>
<li>G是goroutine实现的核心结构，它包含了栈，指令指针，以及其他对调度goroutine很重要的信息，例如其阻塞的channel。</li>
</ul>
<blockquote>
<p>Processor的数量是在启动时被设置为环境变量GOMAXPROCS的值，或者通过运行时调用函数GOMAXPROCS()进行设置。Processor数量固定意味着任意时刻只有GOMAXPROCS个线程在运行go代码。</p>
</blockquote>
<p>我们分别用三角形，矩形和圆形表示Machine Processor和Goroutine。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/moxing4.jpg" alt="moxing4"></p>
<p>在单核处理器的场景下，所有goroutine运行在同一个M系统线程中，每一个M系统线程维护一个Processor，任何时刻，一个Processor中只有一个goroutine，其他goroutine在runqueue中等待。一个goroutine运行完自己的时间片后，让出上下文，回到runqueue中。 多核处理器的场景下，为了运行goroutines，每个M系统线程会持有一个Processor。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/moxing5.jpg" alt="moxing5"></p>
<p>在正常情况下，scheduler会按照上面的流程进行调度，但是线程会发生阻塞等情况，看一下goroutine对线程阻塞等的处理。</p>
<h3 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h3><p>当正在运行的goroutine阻塞的时候，例如进行系统调用，会再创建一个系统线程（M1），当前的M线程放弃了它的Processor，P转到新的线程中去运行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/moxing6.jpg" alt="moxing6"></p>
<h3 id="runqueue执行完成"><a href="#runqueue执行完成" class="headerlink" title="runqueue执行完成"></a>runqueue执行完成</h3><p>当其中一个Processor的runqueue为空，没有goroutine可以调度。它会从另外一个上下文偷取一半的goroutine。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/moxing7.jpg" alt="moxing7"></p>
<blockquote>
<p>其图中的G，P和M都是Go语言运行时系统（其中包括内存分配器，并发调度器，垃圾收集器等组件，可以想象为Java中的JVM）抽象出来概念和数据结构对象：<br>G：Goroutine的简称，上面用go关键字加函数调用的代码就是创建了一个G对象，是对一个要并发执行的任务的封装，也可以称作用户态线程。属于用户级资源，对OS透明，具备轻量级，可以大量创建，上下文切换成本低等特点。<br>M：Machine的简称，在linux平台上是用clone系统调用创建的，其与用linux pthread库创建出来的线程本质上是一样的，都是利用系统调用创建出来的OS线程实体。M的作用就是执行G中包装的并发任务。<strong>Go运行时系统中的调度器的主要职责就是将G公平合理的安排到多个M上去执行</strong>。其属于OS资源，可创建的数量上也受限了OS，通常情况下G的数量都多于活跃的M的。<br>P：Processor的简称，逻辑处理器，主要作用是管理G对象（每个P都有一个G队列），并为G在M上的运行提供本地化资源。</p>
</blockquote>
<p>从两级线程模型来看，似乎并不需要P的参与，有G和M就可以了，那为什么要加入P这个东东呢？<br>其实Go语言运行时系统早期(Go1.0)的实现中并没有P的概念，Go中的调度器直接将G分配到合适的M上运行。但这样带来了很多问题，例如，不同的G在不同的M上并发运行时可能都需向系统申请资源（如堆内存），由于资源是全局的，将会由于资源竞争造成很多系统性能损耗，为了解决类似的问题，后面的Go（Go1.1）运行时系统加入了P，让P去管理G对象，M要想运行G必须先与一个P绑定，然后才能运行该P管理的G。这样带来的好处是，我们可以在P对象中预先申请一些系统资源（本地资源），G需要的时候先向自己的本地P申请（无需锁保护），如果不够用或没有再向全局申请，而且从全局拿的时候会多拿一部分，以供后面高效的使用。就像现在我们去政府办事情一样，先去本地政府看能搞定不，如果搞不定再去中央，从而提供办事效率。<br>而且由于P解耦了G和M对象，这样即使M由于被其上正在运行的G阻塞住，其余与该M关联的G也可以随着P一起迁移到别的活跃的M上继续运行，从而让G总能及时找到M并运行自己，从而提高系统的并发能力。<br>Go运行时系统通过构造G-P-M对象模型实现了一套用户态的并发调度系统，可以自己管理和调度自己的并发任务，所以可以说Go语言<strong>原生支持并发</strong>。<strong>自己实现的调度器负责将并发任务分配到不同的内核线程上运行，然后内核调度器接管内核线程在CPU上的执行与调度。</strong></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Go运行时完整的调度系统是很复杂，很难用一篇文章描述的清楚，这里只能从宏观上介绍一下，让大家有个整体的认识。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Goroutine1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> task2()</span><br><span class="line">    <span class="keyword">go</span> task3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如我们有一个G(Goroutine1)已经通过P被安排到了一个M上正在执行，在Goroutine1执行的过程中我们又创建两个G，这两个G会被马上放入与Goroutine1相同的P的本地G任务队列中，排队等待与该P绑定的M的执行，这是最基本的结构，很好理解。 关键问题是:</p>
<p><strong>a.如何在一个多核心系统上尽量合理分配G到多个M上运行，充分利用多核，提高并发能力呢？</strong><br>如果我们在一个Goroutine中通过<strong>go</strong>关键字创建了大量G，这些G虽然暂时会被放在同一个队列, 但如果这时还有空闲P（系统内P的数量默认等于系统cpu核心数），Go运行时系统始终能保证至少有一个（通常也只有一个）活跃的M与空闲P绑定去各种G队列去寻找可运行的G任务，该种M称为<strong>自旋的M</strong>。一般寻找顺序为：自己绑定的P的队列，全局队列，然后其他P队列。如果自己P队列找到就拿出来开始运行，否则去全局队列看看，由于全局队列需要锁保护，如果里面有很多任务，会转移一批到本地P队列中，避免每次都去竞争锁。如果全局队列还是没有，就要开始玩狠的了，直接从其他P队列偷任务了（偷一半任务回来）。这样就保证了在还有可运行的G任务的情况下，总有与CPU核心数相等的M+P组合 在执行G任务或在执行G的路上(寻找G任务)。</p>
<p><strong>b. 如果某个M在执行G的过程中被G中的系统调用阻塞了，怎么办？</strong><br>在这种情况下，这个M将会被内核调度器调度出CPU并处于阻塞状态，与该M关联的其他G就没有办法继续执行了，但Go运行时系统的一个监控线程(sysmon线程)能探测到这样的M，并把与该M绑定的P剥离，寻找其他空闲或新建M接管该P，然后继续运行其中的G，大致过程如下图所示。然后等到该M从阻塞状态恢复，需要重新找一个空闲P来继续执行原来的G，如果这时系统正好没有空闲的P，就把原来的G放到全局队列当中，等待其他M+P组合发掘并执行。</p>
<p><strong>c. 如果某一个G在M运行时间过长，有没有办法做抢占式调度，让该M上的其他G获得一定的运行时间，以保证调度系统的公平性?</strong><br>我们知道linux的内核调度器主要是基于时间片和优先级做调度的。对于相同优先级的线程，内核调度器会尽量保证每个线程都能获得一定的执行时间。为了防止有些线程”饿死”的情况，内核调度器会发起抢占式调度将长期运行的线程中断并让出CPU资源，让其他线程获得执行机会。当然在Go的运行时调度器中也有类似的抢占机制，但并不能保证抢占能成功，因为Go运行时系统并没有内核调度器的中断能力，它只能通过向运行时间过长的G中设置抢占flag的方法温柔的让运行的G自己主动让出M的执行权。<br>说到这里就不得不提一下Goroutine在运行过程中可以动态扩展自己线程栈的能力，可以从初始的2KB大小扩展到最大1G（64bit系统上），因此在每次调用函数之前需要先计算该函数调用需要的栈空间大小，然后按需扩展（超过最大值将导致运行时异常）。Go抢占式调度的机制就是利用在判断要不要扩栈的时候顺便查看以下自己的抢占flag，决定是否继续执行，还是让出自己。<br>运行时系统的监控线程会计时并设置抢占flag到运行时间过长的G，然后G在有函数调用的时候会检查该抢占flag，如果已设置就将自己放入全局队列，这样该M上关联的其他G就有机会执行了。但如果正在执行的G是个很耗时的操作且没有任何函数调用(如只是for循环中的计算操作)，即使抢占flag已经被设置，该G还是将一直霸占着当前M直到执行完自己的任务。</p>
<p>注：本文参考他人博客进行整理</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>ioutil包与并发编程初识</title>
    <url>/2023/06/13/Go/16/</url>
    <content><![CDATA[<h1 id="ioutil包"><a href="#ioutil包" class="headerlink" title="ioutil包"></a>ioutil包</h1><p>除了io包可以读写数据，Go语言中还提供了一个辅助的工具包就是ioutil，里面的方法虽然不多，但是都还蛮好用的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;io/ioutil&quot;</span></span><br></pre></td></tr></table></figure>

<p>该包的介绍只有一句话：Package ioutil implements some I&#x2F;O utility functions。</p>
<h2 id="ioutil包的方法"><a href="#ioutil包的方法" class="headerlink" title="ioutil包的方法"></a>ioutil包的方法</h2><p>下面我们来看一下里面的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discard 是一个 io.Writer 接口，调用它的 Write 方法将不做任何事情</span></span><br><span class="line"><span class="comment">// 并且始终成功返回。</span></span><br><span class="line"><span class="keyword">var</span> Discard io.Writer = devNull(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadAll 读取 r 中的所有数据，返回读取的数据和遇到的错误。</span></span><br><span class="line"><span class="comment">// 如果读取成功，则 err 返回 nil，而不是 EOF，因为 ReadAll 定义为读取</span></span><br><span class="line"><span class="comment">// 所有数据，所以不会把 EOF 当做错误处理。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadFile 读取文件中的所有数据，返回读取的数据和遇到的错误。</span></span><br><span class="line"><span class="comment">// 如果读取成功，则 err 返回 nil，而不是 EOF</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteFile 向文件中写入数据，写入前会清空文件。</span></span><br><span class="line"><span class="comment">// 如果文件不存在，则会以指定的权限创建该文件。</span></span><br><span class="line"><span class="comment">// 返回遇到的错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="type">string</span>, data []<span class="type">byte</span>, perm os.FileMode)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadDir 读取指定目录中的所有目录和文件（不包括子目录）。</span></span><br><span class="line"><span class="comment">// 返回读取到的文件信息列表和遇到的错误，列表是经过排序的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="type">string</span>)</span></span> ([]os.FileInfo, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NopCloser 将 r 包装为一个 ReadCloser 类型，但 Close 方法不做任何事情。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NopCloser</span><span class="params">(r io.Reader)</span></span> io.ReadCloser</span><br><span class="line"></span><br><span class="line"><span class="comment">// TempFile 在 dir 目录中创建一个以 prefix 为前缀的临时文件，并将其以读</span></span><br><span class="line"><span class="comment">// 写模式打开。返回创建的文件对象和遇到的错误。</span></span><br><span class="line"><span class="comment">// 如果 dir 为空，则在默认的临时目录中创建文件（参见 os.TempDir），多次</span></span><br><span class="line"><span class="comment">// 调用会创建不同的临时文件，调用者可以通过 f.Name() 获取文件的完整路径。</span></span><br><span class="line"><span class="comment">// 调用本函数所创建的临时文件，应该由调用者自己删除。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, prefix <span class="type">string</span>)</span></span> (f *os.File, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TempDir 功能同 TempFile，只不过创建的是目录，返回目录的完整路径。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, prefix <span class="type">string</span>)</span></span> (name <span class="type">string</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		ioutil包：</span></span><br><span class="line"><span class="comment">			ReadFile()</span></span><br><span class="line"><span class="comment">			WriteFile()</span></span><br><span class="line"><span class="comment">			ReadDir()</span></span><br><span class="line"><span class="comment">			..</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.读取文件中的所有的数据</span></span><br><span class="line">	<span class="comment">//fileName := &quot;main/1.txt&quot;</span></span><br><span class="line">	<span class="comment">//data, err := ioutil.ReadFile(fileName)</span></span><br><span class="line">	<span class="comment">////fmt.Println(err)</span></span><br><span class="line">	<span class="comment">////fmt.Println(data)</span></span><br><span class="line">	<span class="comment">//fmt.Println(string(data))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.写出数据(覆盖写)</span></span><br><span class="line">	<span class="comment">//fileName := &quot;main/1.txt&quot;</span></span><br><span class="line">	<span class="comment">//s1 := &quot;床前明月光，地上鞋三双&quot;</span></span><br><span class="line">	<span class="comment">//err := ioutil.WriteFile(fileName, []byte(s1), os.ModePerm)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.ReadAll()</span></span><br><span class="line">	<span class="comment">//s2 := &quot;王二狗和李小花是两个好朋友，Ruby就是我，也是他们的朋友&quot;</span></span><br><span class="line">	<span class="comment">//r1 := strings.NewReader(s2)</span></span><br><span class="line">	<span class="comment">//data, err := ioutil.ReadAll(r1)</span></span><br><span class="line">	<span class="comment">//fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//fmt.Println(data)</span></span><br><span class="line">	<span class="comment">//fmt.Println(string(data))</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.ReadDir()，读取一个目录下的子内容：子文件和子目录，但是只能读取一层</span></span><br><span class="line">	<span class="comment">//dirName := &quot;main&quot;</span></span><br><span class="line">	<span class="comment">//fileInfos, err := ioutil.ReadDir(dirName)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//fmt.Println(len(fileInfos))</span></span><br><span class="line">	<span class="comment">//for i := 0; i &lt; len(fileInfos); i++ &#123;</span></span><br><span class="line">	<span class="comment">//	//fmt.Printf(&quot;%T\n&quot;, fileInfos[i])</span></span><br><span class="line">	<span class="comment">//	fmt.Printf(&quot;第 %d 个：名称：%s，是否是目录：%t\n&quot;, i, fileInfos[i].Name(), fileInfos[i].IsDir())</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.临时目录和临时文件</span></span><br><span class="line">	dir, err := ioutil.TempDir(<span class="string">&quot;./&quot;</span>, <span class="string">&quot;Test&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> os.Remove(dir)</span><br><span class="line">	fmt.Println(dir)</span><br><span class="line"></span><br><span class="line">	file, err := ioutil.TempFile(dir, <span class="string">&quot;Test&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> os.Remove(file.Name())</span><br><span class="line">	fmt.Println(file.Name())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h2><p>因为文件夹下还有子文件夹，而ioutil包的ReadDir()只能获取一层目录，所以我们需要自己去设计算法来实现，最容易实现的思路就是使用递归。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dirName := <span class="string">&quot;C:\\Users\\19393\\Desktop\\操作系统&quot;</span></span><br><span class="line">	readDir(dirName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readDir</span><span class="params">(dirName <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fileInfos, err := ioutil.ReadDir(dirName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(fileInfos); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> fileInfos[i].IsDir() &#123;</span><br><span class="line">			dirName = dirName + <span class="string">&quot;\\&quot;</span> + fileInfos[i].Name()</span><br><span class="line">			readDir(dirName)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;文件名:%s\n&quot;</span>, fileInfos[i].Name())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>该包目前已弃用</strong></em></p>
<h1 id="并发性Concurrency"><a href="#并发性Concurrency" class="headerlink" title="并发性Concurrency"></a>并发性Concurrency</h1><h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p>
<p>CPU的速度太快啦。。。</p>
<h2 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h2><p>Go是并发语言，而不是并行语言。在讨论如何在Go中进行并发处理之前，我们首先必须了解什么是并发，以及它与并行性有什么不同。(Go is a concurrent language and not a parallel one. )</p>
<p><strong>并发性Concurrency是同时处理许多事情的能力。</strong></p>
<p>举个例子，假设一个人在晨跑。在晨跑时，他的鞋带松了。现在这个人停止跑步，系鞋带，然后又开始跑步。这是一个典型的并发性示例。这个人能够同时处理跑步和系鞋带，这是一个人能够同时处理很多事情。</p>
<p>什么是并行性parallelism，它与并发concurrency有什么不同?<br>并行就是同时做很多事情。这听起来可能与并发类似，但实际上是不同的。</p>
<p>让我们用同样的慢跑例子更好地理解它。在这种情况下，我们假设这个人正在慢跑，并且使用它的手机听音乐。在这种情况下，一个人一边慢跑一边听音乐，那就是他同时在做很多事情。这就是所谓的并行性(parallelism)。</p>
<p>并发性和并行性——<em>一种技术上的观点</em>。<br>假设我们正在编写一个web浏览器。web浏览器有各种组件。其中两个是web页面呈现区域和下载文件从internet下载的下载器。假设我们以这样的方式构建了浏览器的代码，这样每个组件都可以独立地执行。当这个浏览器运行在单个核处理器中时，处理器将在浏览器的两个组件之间进行上下文切换。它可能会下载一个文件一段时间，然后它可能会切换到呈现用户请求的网页的html。这就是所谓的并发性。并发进程从不同的时间点开始，它们的执行周期重叠。在这种情况下，下载和呈现从不同的时间点开始，它们的执行重叠。</p>
<p>假设同一浏览器运行在多核处理器上。在这种情况下，文件下载组件和HTML呈现组件可能同时在不同的内核中运行。这就是所谓的<strong>并行性</strong>。</p>
<p>并行性Parallelism不会总是导致更快的执行时间。这是因为并行运行的组件可能需要相互通信。例如，在我们的浏览器中，当文件下载完成时，应该将其传递给用户，比如使用弹出窗口。这种通信发生在负责下载的组件和负责呈现用户界面的组件之间。这种通信开销在并发concurrent 系统中很低。当组件在多个内核中并行concurrent 运行时，这种通信开销很高。因此，并行程序并不总是导致更快的执行时间!</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/t.png"></p>
<h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是一个程序在一个数据集中的一次动态执行过程，可以简单理解为“正在执行的程序”，它是CPU资源分配和调度的独立单位。<br>进程一般由程序、数据集、进程控制块三部分组成。我们编写的程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。 <strong>进程的局限是创建、撤销和切换的开销比较大。</strong></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是在进程之后发展出来的概念。 线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成。一个进程可以包含多个线程。<br>线程的优点是减小了程序并发执行时的开销，提高了操作系统的并发性能，缺点是线程没有自己的系统资源，只拥有在运行时必不可少的资源，但同一进程的各线程可以共享进程所拥有的系统资源，如果把进程比作一个车间，那么线程就好比是车间里面的工人。不过对于某些独占性资源存在锁机制，处理不当可能会产生“死锁”。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程是一种用户态的轻量级线程，又称微线程，英文名Coroutine，协程的调度完全由用户控制。人们通常将协程和子程序（函数）比较着理解。<br>子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。 </p>
<p><strong>与传统的系统级线程和进程相比，协程的最大优势在于其”轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过1万的。这也是协程也叫轻量级线程的原因。</strong></p>
<blockquote>
<p>协程与多线程相比，其优势体现在：协程的执行效率极高。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
</blockquote>
<p><strong>Go语言对于并发的实现是靠协程，Goroutine</strong></p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>go的基本介绍</title>
    <url>/2023/06/01/Go/2/</url>
    <content><![CDATA[<h2 id="Go的特点"><a href="#Go的特点" class="headerlink" title="Go的特点"></a>Go的特点</h2><ul>
<li>高性能，该并发</li>
<li>部署简单，学习简单</li>
<li>丰富的标准库</li>
<li>完善的工具链</li>
<li>静态链接</li>
<li>快速编译</li>
<li>跨平台</li>
<li>垃圾回收</li>
</ul>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（静态编译）。Go语言提供的工具都通过一个单独的命令<code>go</code>调用，<code>go</code>命令有一系列子命令。最简单的一个子命令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件。要想运行上述程序，命令行进入其目录，执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run helloworld.go</span></span><br></pre></td></tr></table></figure>

<p>Go语言原生支持Unicode，它可以处理全世界任何语言的文本。</p>
<p>如果不只是一次性实验，并且希望能够编译这个程序，保存编译结果以备将来之用。可以用build子命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build helloworld.go</span></span><br></pre></td></tr></table></figure>

<p>这个命令生成一个名为<code>helloworld</code>的<em><strong>可执行的二进制文件（Windows系统下生成的可执行文件是helloworld.exe），之后可以随时运行它</strong></em>（在Windows系统下在命令行直接输入helloworld.exe命令运行），不需任何处理（因为静态编译，所以不用担心在系统库更新的时候冲突，<em><strong>python也有相关的库<code>pyinstaller</code>将程序转为可执行文件</strong></em>）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./helloworld</span></span><br><span class="line">hello world </span><br></pre></td></tr></table></figure>

<h2 id="Go的简介-挺有意思的，建议看看"><a href="#Go的简介-挺有意思的，建议看看" class="headerlink" title="Go的简介(挺有意思的，建议看看)"></a>Go的简介(挺有意思的，建议看看)</h2><p>​		Go语言的代码通过<em><strong>包</strong></em>（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。每个源文件都以一条<code>package</code>声明语句开始，上述例子里就是<code>package main</code>，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。</p>
<p>​		Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如<code>fmt</code>包，就含有格式化输出、接收输入的函数。<code>Println</code>是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。</p>
<p>​		<strong><code>	main</code>包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在<code>main</code>里的<code>main</code> <em>函数</em> 也很特殊，它是整个程序执行时的入口（C系语言类似）</strong>。<code>main</code>函数所做的事情就是程序做的。当然了，<code>main</code>函数一般调用其它包里的函数完成很多工作（例如：<code>fmt.Println</code>）。</p>
<ul>
<li><p>必须告诉编译器源文件需要哪些包，这就是跟随在<code>package</code>声明后面的<code>import</code>声明扮演的角色。hello world例子只用到了一个包，大多数程序需要导入多个包。</p>
</li>
<li><p>必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。<em><strong>这项严格要求避免了程序开发过程中引入未使用的包</strong></em>（<em><strong>Go语言编译过程没有警告信息</strong></em>）。</p>
<p>  <code>import</code>声明必须跟在文件的<code>package</code>声明之后。随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字<code>func</code>、<code>var</code>、<code>const</code>、<code>type</code>定义）。这些内容的声明顺序并不重要（最好按照规范要求自己）。上述例子的程序已经尽可能短了，只声明了一个函数，其中只调用了一个其他函数。为了节省篇幅，有些时候示例程序会省略<code>package</code>和<code>import</code>声明，但是，这些声明在源代码里有，并且必须得有才能编译。</p>
<p>  一个函数的声明由<code>func</code>关键字、函数名、参数列表、返回值列表（上述例子里的<code>main</code>函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。</p>
<p>  Go语言<em><strong>不需要在语句或者声明的末尾添加分号</strong></em>，除非一行上有多条语句。实际上，编译器<em><strong>会主动把特定符号后的换行符转换为分号</strong></em>，因此<em><strong>换行符添加的位置会影响Go代码的正确解析</strong></em>（比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字<code>break</code>、<code>continue</code>、<code>fallthrough</code>或<code>return</code>中的一个、运算符和分隔符<code>++</code>、<code>--</code>、<code>)</code>、<code>]</code>或<code>&#125;</code>中的一个）。举个例子，函数的左括号<code>&#123;</code>必须和<code>func</code>函数声明在同一行上，且位于末尾，不能独占一行，而在表达式<code>x + y</code>中，可在<code>+</code>后换行，不能在<code>+</code>前换行（以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编译错误）</p>
</li>
</ul>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a><strong>go clean</strong></h3><p>go clean 命令是用来移除当前源码包里面编译生成的文件，这些文件包括</p>
<ul>
<li>_obj&#x2F; 旧的object目录，由Makefiles遗留</li>
<li>_test&#x2F; 旧的test目录，由Makefiles遗留</li>
<li>_testmain.go 旧的gotest文件，由Makefiles遗留</li>
<li>test.out 旧的test记录，由Makefiles遗留</li>
<li>build.out 旧的test记录，由Makefiles遗留</li>
<li>*.[568ao] object文件，由Makefiles遗留</li>
<li>DIR(.exe) 由 go build 产生</li>
<li>DIR.test(.exe) 由 go test -c 产生</li>
<li>MAINFILE(.exe) 由 go build MAINFILE.go产生</li>
</ul>
<h3 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a><strong>go test</strong></h3><p>go test 命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag</p>
<h3 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a><strong>go doc</strong></h3><p>go doc 命令其实就是一个很强大的文档工具。</p>
<p>如何查看相应package的文档呢？ 例如builtin包，那么执行go doc builtin；如果是http包，那么执行go doc net&#x2F;http；查看某一个包里面的函数，那么执行go doc fmt Printf；也可以查看相应的代码，执行go doc -src fmt Printf；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看net/http包</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go doc net/http</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看time包</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go doc time</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个包里的指定函数</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go doc <span class="built_in">fmt</span> Printf</span></span><br></pre></td></tr></table></figure>

<p>通过命令在命令行执行 go doc -http&#x3D;:端口号，比如godoc -http&#x3D;:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被限制访问的用户来说是一个不错的选择。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">godoc -http=:9527</span></span><br></pre></td></tr></table></figure>

<hr>
<p>go fix 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1</p>
<p>go version 查看go当前的版本</p>
<p>go env 查看当前go的环境变量</p>
<p>go list 列出当前全部安装的package</p>
<h2 id="gofmt和goimports的配置"><a href="#gofmt和goimports的配置" class="headerlink" title="gofmt和goimports的配置"></a><code>gofmt</code>和<code>goimports</code>的配置</h2><p>​		<em><strong>Go语言在代码格式上采取了很强硬的态度</strong></em>。<code>gofmt</code>工具把代码格式化为标准格式（这个格式化工具没有任何可以调整代码格式的参数，Go语言就是这么任性），并且<code>go</code>工具中的<code>fmt</code>子命令会对指定包，否则默认为当前目录中所有.go源文件应用<code>gofmt</code>命令。我们应该养成格式化自己的代码的习惯。以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执导致了Go语言的<a href="https://baike.baidu.com/item/Tiobe/2830870?fr=aladdin"><code>TIOBE</code></a>排名较低，争议的话题较少。更重要的是，这样可以做多种自动源码转换，如果放任Go语言代码格式，这些转换就不大可能了。</p>
<p>很多文本编辑器都可以配置为保存文件时自动执行<code>gofmt</code>，这样源代码总会被恰当地格式化，<code>gofmt</code>包含在标准的分发包中。还有个相关的工具，<code>goimports</code>，可以根据代码需要，自动地添加或删除<code>import</code>声明。这个工具并没有包含在标准的分发包中，可以用下面的命令在在<code>goland</code>中在任意一个项目的终端执行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get -v golang.org/x/tools/cmd/goimports</span><br></pre></td></tr></table></figure>


<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df0d744ab4bc4f0f9204e4f4d0eb0a90~tplv-k3u1fbpfcp-watermark.image" alt="image-20230513220732135.png"></p>
<p>进入<code>GOPATH</code>(Go语言安装目录)，执行以下命令安装<code>goimports</code>,没有加版本号会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> install golang.org/x/tools/cmd/goimports@latest</span><br></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc5eae7c83743338f84058f08c881ca~tplv-k3u1fbpfcp-watermark.image" alt="image-20230513221248033.png"></p>
<p>至此，我们可以在 <code>GOPATH/bin </code>目录下看到 <code>goimports.exe</code></p>
<p>然后在<code>goland</code>的设置中点击工具&gt;File Watcher</p>
<p>添加<code>gofmt</code>和<code>goimports</code></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2632d630f887491b9370e03f4b43b1ba~tplv-k3u1fbpfcp-watermark.image" alt="image-20230513221553805.png"></p>
<p><code>goimports.exe</code>在<code>GOPATH/bin </code>目录下,其实<code>goland</code>能够自动找到它</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc409d417dc34f17a299b7e35691e9d6~tplv-k3u1fbpfcp-watermark.image" alt="image-20230513221658244.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c31c5998d814a3f9e30de7b2b7c91af~tplv-k3u1fbpfcp-watermark.image" alt="image-20230513221724453.png"></p>
<p>点击确定，<code>gofmt</code>和<code>goimports</code>配置成功</p>
<p>原文链接：<a href="https://juejin.cn/post/7232689996821495865">Go的基本介绍（附gofmt和goimports配置）|青训营笔记 - 掘金 (juejin.cn)</a></p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>变量与常量</title>
    <url>/2023/06/01/Go/4/</url>
    <content><![CDATA[<h1 id="基本语法——变量var"><a href="#基本语法——变量var" class="headerlink" title="基本语法——变量var"></a>基本语法——变量var</h1><h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p>变量是为存储特定类型的值而提供给内存位置的名称。在go中声明变量有多种语法。</p>
<p>所以变量的本质就是一小块内存，用于存储数据，在程序运行过程中数值可以改变</p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>var名称类型是声明单个变量的语法。</p>
<blockquote>
<p>以字母或下划线开头，由一个或多个字母、数字、下划线组成</p>
</blockquote>
<p>声明一个变量</p>
<p>第一种，指定变量类型，声明后若不赋值，使用<em><strong>默认值</strong></em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span></span><br><span class="line">name = value</span><br></pre></td></tr></table></figure>

<p>第二种，根据值自行判定变量类型(类型推断Type inference)</p>
<p>如果一个变量有一个初始值，Go将自动能够使用初始值来推断该变量的类型。因此，如果变量具有初始值，则可以省略变量声明中的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = value</span><br></pre></td></tr></table></figure>

<p>第三种，省略var, 注意 :&#x3D;左侧的变量不应该是已经声明过的(多个变量同时声明时，至少保证一个是新变量)，否则会导致编译错误(简短声明)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := value</span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">c : = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式它只能被用在函数体内，而不可以用于全局变量的声明与赋值</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">string</span> = <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World false</span><br></pre></td></tr></table></figure>

<h4 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h4><p>第一种，以逗号分隔，声明与赋值分开，若不赋值，存在默认值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1, name2, name3 <span class="keyword">type</span></span><br><span class="line">name1, name2, name3 = v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>第二种，直接赋值，下面的变量类型可以是不同的类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1, name2, name3 = v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>第三种，集合类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    name1 type1</span><br><span class="line">    name2 type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a :&#x3D; 20 就是不被允许的，编译器会提示错误 no new variables on left side of :&#x3D;，但是 a &#x3D; 20 是可以的，因为这是给相同的变量赋予一个新的值。</p>
<p>如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试编译这段代码将得到错误 a declared and not used</p>
<p>此外，单纯地给 a 赋值也是不够的，这个值必须被使用</p>
<p>在同一个作用域中，已存在同名的变量，则之后的声明初始化，则退化为赋值操作。但这个前提是，最少要有一个新的变量被定义，且在同一作用域，例如，下面的y就是新定义的变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">140</span></span><br><span class="line">	fmt.Println(&amp;x)</span><br><span class="line">	x, y := <span class="number">200</span>, <span class="string">&quot;abc&quot;</span></span><br><span class="line">	fmt.Println(&amp;x, x)</span><br><span class="line">	fmt.Print(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xc04200a2b0</span><br><span class="line">0xc04200a2b0 200</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<h1 id="基本语法——常量constant"><a href="#基本语法——常量constant" class="headerlink" title="基本语法——常量constant"></a>基本语法——常量constant</h1><h2 id="常量的使用"><a href="#常量的使用" class="headerlink" title="常量的使用"></a>常量的使用</h2><h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式类型定义： </span></span><br><span class="line"><span class="keyword">const</span> b <span class="type">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment">//隐式类型定义：</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">const</span> LENGTH <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">const</span> WIDTH <span class="type">int</span> = <span class="number">5</span>   </span><br><span class="line">   <span class="keyword">var</span> area <span class="type">int</span></span><br><span class="line">   <span class="keyword">const</span> a, b, c = <span class="number">1</span>, <span class="literal">false</span>, <span class="string">&quot;str&quot;</span> <span class="comment">//多重赋值</span></span><br><span class="line"></span><br><span class="line">   area = LENGTH * WIDTH</span><br><span class="line">   fmt.Printf(<span class="string">&quot;面积为 : %d&quot;</span>, area)</span><br><span class="line">   <span class="built_in">println</span>()</span><br><span class="line">   <span class="built_in">println</span>(a, b, c)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面积为 : 50</span><br><span class="line">1 false str</span><br></pre></td></tr></table></figure>

<p>常量可以作为枚举，常量组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>常量组中如不指定类型和初始化值，则与上一行非空常量右值相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		x <span class="type">uint16</span> = <span class="number">16</span></span><br><span class="line">		y</span><br><span class="line">		s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">		z</span><br><span class="line">	)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, y, y)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, z, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint16,16</span><br><span class="line">string,abc</span><br></pre></td></tr></table></figure>

<p>常量的注意事项：</p>
<ul>
<li><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型</p>
</li>
<li><p><em><strong>不曾使用的常量，在编译的时候，是不会报错的</strong></em></p>
</li>
<li><p>显示指定类型的时候，必须确保常量左右值类型一致，需要时可做显示类型转换。这与变量就不一样了，变量是可以是不同的类型值</p>
</li>
</ul>
<h3 id="iota关键字"><a href="#iota关键字" class="headerlink" title="iota关键字"></a>iota关键字</h3><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量</p>
<p>iota 可以被用作枚举值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a&#x3D;0, b&#x3D;1, c&#x3D;2 可以简写为如下形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>iota 用法</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 ha ha 100 100 7 8</span><br></pre></td></tr></table></figure>

<p>如果中断iota自增，则必须显式恢复。且后续自增值按行序递增</p>
<p>自增默认是int类型，可以自行进行显示指定类型</p>
<p>数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址</p>
<h1 id="变量与常量的示例"><a href="#变量与常量的示例" class="headerlink" title="变量与常量的示例"></a>变量与常量的示例</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="string">&quot;initial&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b, c <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> e <span class="type">float64</span></span><br><span class="line"></span><br><span class="line">	f := <span class="type">float32</span>(e)</span><br><span class="line"></span><br><span class="line">	g := a + <span class="string">&quot;foo&quot;</span></span><br><span class="line">	fmt.Println(a, b, c, d, e, f) <span class="comment">// initial 1 2 true 0 0</span></span><br><span class="line">	fmt.Println(g)                <span class="comment">// initialapple</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> s <span class="type">string</span> = <span class="string">&quot;constant&quot;</span></span><br><span class="line">	<span class="keyword">const</span> h = <span class="number">500000000</span></span><br><span class="line">	<span class="keyword">const</span> i = <span class="number">3e20</span> / h</span><br><span class="line">	fmt.Println(s, h, i, math.Sin(h), math.Sin(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">initial 1 2 true 0 0</span><br><span class="line">initialfoo</span><br><span class="line">constant 500000000 6e+11 -0.28470407323754404 0.7591864109375384</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型与输入输出</title>
    <url>/2023/06/02/Go/5/</url>
    <content><![CDATA[<h1 id="基本语法——数据类型"><a href="#基本语法——数据类型" class="headerlink" title="基本语法——数据类型"></a>基本语法——数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>以下是go中可用的基本数据类型</p>
<p><a href="https://smms.app/image/mkKRra8JejXWM4V" target="_blank"><img src="https://s2.loli.net/2023/06/02/mkKRra8JejXWM4V.jpg" ></a></p>
<h3 id="布尔型bool"><a href="#布尔型bool" class="headerlink" title="布尔型bool"></a>布尔型bool</h3><p>布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool &#x3D; true</p>
<h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><p><strong>1、</strong>整数型</p>
<ul>
<li><p>int8<br>有符号 8 位整型 (-128 到 127)<br>长度：8bit</p>
</li>
<li><p>int16<br>有符号 16 位整型 (-32768 到 32767)</p>
</li>
<li><p>int32<br>有符号 32 位整型 (-2147483648 到 2147483647)</p>
</li>
<li><p>int64<br>有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</p>
</li>
<li><p>uint8<br>无符号 8 位整型 (0 到 255)<br>8位都用于表示数值：</p>
</li>
<li><p>uint16<br>无符号 16 位整型 (0 到 65535)</p>
</li>
<li><p>uint32<br>无符号 32 位整型 (0 到 4294967295)</p>
</li>
<li><p>uint64<br>无符号 64 位整型 (0 到 18446744073709551615)</p>
</li>
</ul>
<blockquote>
<p>int和uint:根据底层平台，表示32或64位整数。除非需要使用特定大小的整数，否则通常应该使用int来表示整数。<br>大小:32位系统32位，64位系统64位。<br>范围:-2147483648到2147483647的32位系统和-9223372036854775808到9223372036854775807的64位系统。</p>
</blockquote>
<p><strong>2、浮点型</strong></p>
<ul>
<li><p>float32</p>
<p>IEEE-754 32位浮点型数</p>
</li>
<li><p>float64</p>
<p>IEEE-754 64位浮点型数</p>
</li>
<li><p>complex64</p>
<p>32 位实数和虚数</p>
</li>
<li><p>complex128</p>
<p>64 位实数和虚数</p>
</li>
</ul>
<p><strong>3、其他</strong></p>
<ul>
<li><p>byte</p>
<p>类似 uint8</p>
</li>
<li><p>rune</p>
<p>类似 int32</p>
</li>
<li><p>uint</p>
<p>32 或 64 位</p>
</li>
<li><p>int</p>
<p>与 uint 一样大小</p>
</li>
<li><p>uintptr</p>
<p>无符号整型，用于存放一个指针</p>
</li>
</ul>
<h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><p>字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line">str = <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="数据类型转换：Type-Convert"><a href="#数据类型转换：Type-Convert" class="headerlink" title="数据类型转换：Type Convert"></a>数据类型转换：Type Convert</h3><p>语法格式：Type(Value)</p>
<p>常数：在有需要的时候，会自动转型</p>
<p>变量：需要手动转型	T(V)</p>
<p>注意点：兼容类型可以转换</p>
<h2 id="复合类型-派生类型"><a href="#复合类型-派生类型" class="headerlink" title="复合类型(派生类型)"></a>复合类型(派生类型)</h2><p>1、指针类型（Pointer）<br>2、数组类型<br>3、结构化类型(struct)<br>4、Channel 类型<br>5、函数类型<br>6、切片类型<br>7、接口类型（interface）<br>8、Map 类型</p>
<h1 id="键盘输入和打印输出"><a href="#键盘输入和打印输出" class="headerlink" title="键盘输入和打印输出"></a>键盘输入和打印输出</h1><h2 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h2><h3 id="fmt包"><a href="#fmt包" class="headerlink" title="fmt包"></a>fmt包</h3><p>fmt包实现了类似C语言printf和scanf的格式化I&#x2F;O。格式化verb（’verb’）源自C语言但更简单。</p>
<p>详见官网fmt的API：<a href="https://golang.google.cn/pkg/fmt/">https://golang.google.cn/pkg/fmt/</a></p>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="常用打印函数"><a href="#常用打印函数" class="headerlink" title="常用打印函数"></a>常用打印函数</h3><p><strong>打印：</strong></p>
<p><a href="https://golang.google.cn/pkg/fmt/#Print">func Print(a …interface{}) (n int, err error)</a></p>
<p><strong>格式化打印：</strong></p>
<p><a href="https://golang.google.cn/pkg/fmt/#Printf">func Printf(format string, a …interface{}) (n int, err error)</a></p>
<p><strong>打印后换行</strong></p>
<p><a href="https://golang.google.cn/pkg/fmt/#Println">func Println(a …interface{}) (n int, err error)</a></p>
<p>格式化打印中的常用占位符：</p>
<blockquote>
<p>格式化打印占位符：<br>            %v,原样输出<br>            %T，打印类型<br>            %t,bool类型<br>            %s，字符串<br>            %f，浮点<br>            %d，10进制的整数<br>            %b，2进制的整数<br>            %o，8进制<br>            %x，%X，16进制<br>                %x：0-9，a-f<br>                %X：0-9，A-F<br>            %c，打印字符<br>            %p，打印地址</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">100</span>           <span class="comment">//int</span></span><br><span class="line">	b := <span class="number">3.14</span>          <span class="comment">//float64</span></span><br><span class="line">	c := <span class="literal">true</span>          <span class="comment">// bool</span></span><br><span class="line">	d := <span class="string">&quot;Hello World&quot;</span> <span class="comment">//string</span></span><br><span class="line">	e := <span class="string">`Ruby`</span>        <span class="comment">//string</span></span><br><span class="line">	f := <span class="string">&#x27;A&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%b\n&quot;</span>, a, a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%f\n&quot;</span>, b, b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%t\n&quot;</span>, c, c)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%s\n&quot;</span>, d, d)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%s\n&quot;</span>, e, e)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%d,%c\n&quot;</span>, f, f, f)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-----------------------&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, c)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, d)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, e)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, f)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int,1100100</span><br><span class="line">float64,3.140000</span><br><span class="line">bool,true</span><br><span class="line">string,Hello World</span><br><span class="line">string,Ruby</span><br><span class="line">int32,65,A</span><br><span class="line">-----------------------</span><br><span class="line">100</span><br><span class="line">3.14</span><br><span class="line">true</span><br><span class="line">Hello World</span><br><span class="line">Ruby</span><br><span class="line">65</span><br></pre></td></tr></table></figure>



<h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><h3 id="fmt包读取键盘输入"><a href="#fmt包读取键盘输入" class="headerlink" title="fmt包读取键盘输入"></a>fmt包读取键盘输入</h3><p>常用方法：</p>
<ul>
<li><a href="https://golang.google.cn/pkg/fmt/#Scan">func Scan(a …interface{}) (n int, err error)</a></li>
</ul>
<p>​		Scan 从标准输入扫描文本，读取由 <strong>空白符</strong> 分隔的值分别保存到本函数的参数中。（换行符也被视为空白符）</p>
<ul>
<li><p><a href="https://golang.google.cn/pkg/fmt/#Scanf">func Scanf(format string, a …interface{}) (n int, err error)</a></p>
<p>Scanf从标准输入扫描文本，按照 format 参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。</p>
</li>
<li><p><a href="https://golang.google.cn/pkg/fmt/#Scanln">func Scanln(a …interface{}) (n int, err error)</a></p>
<p>Scanln类似Scan，它在遇到换行时停止扫描。最后一个数据后面必须有换行或者到达结束位置。</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> y <span class="type">float64</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入一个整数，一个浮点类型：&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;x,&amp;y)<span class="comment">//读取键盘的输入，通过操作地址，赋值给x和y   阻塞式</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;x的数值：%d，y的数值：%f\n&quot;</span>,x,y)</span><br><span class="line"></span><br><span class="line">	fmt.Scanf(<span class="string">&quot;%d,%f&quot;</span>,&amp;x,&amp;y)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;x:%d,y:%f\n&quot;</span>,x,y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入一个整数，一个浮点类型：</span><br><span class="line">100 3.14</span><br><span class="line">x的数值：100，y的数值：3.140000</span><br><span class="line">100,5.20</span><br><span class="line">x:100,y:5.200000</span><br></pre></td></tr></table></figure>

<h3 id="bufio包读取"><a href="#bufio包读取" class="headerlink" title="bufio包读取"></a>bufio包读取</h3><p><a href="https://golang.google.cn/pkg/bufio/">https://golang.google.cn/pkg/bufio/</a></p>
<p>bufio包中都是IO操作的方法：</p>
<p>先创建Reader对象,然后就可以各种读取了。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入一个字符串：&quot;</span>)</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	s1, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;读到的数据：&quot;</span>, s1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入一个字符串：</span><br><span class="line">hello wxy</span><br><span class="line">读到的数据： hello wxy</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>reader := bufio.NewReader(os.Stdin)</code>：这行代码创建了一个用于读取用户输入的读取器。<code>bufio.NewReader</code> 函数接受一个参数 <code>os.Stdin</code>，它表示标准输入（通常是键盘输入）。<code>reader</code> 是一个读取器对象，我们可以使用它来读取用户输入的字符串。</li>
<li><code>s1, _ := reader.ReadString(&#39;\n&#39;)</code>：这行代码使用读取器 <code>reader</code> 从标准输入读取字符串，直到遇到换行符 (<code>&#39;\n&#39;</code>) 为止。它将读取的字符串赋值给变量 <code>s1</code>。注意，这里使用了 <code>_</code>（下划线）来忽略函数的第二个返回值（表示可能的错误），因为我们不关心错误处理。</li>
</ul>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>go的编码规范</title>
    <url>/2023/06/01/Go/3/</url>
    <content><![CDATA[<h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><p>本规范旨在为日常Go项目开发提供一个代码的规范指导，方便团队形成一个统一的代码风格，提高代码的可读性，规范性和统一性。本规范将从命名规范，注释规范，代码风格和 Go 语言提供的常用的工具这几个方面做一个说明。该规范参考了 go 语言官方代码的风格制定。</p>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>命名是代码规范中很重要的一部分，统一的命名规则有利于提高的代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。</p>
<p>Go在命名时以字母a到Z或a到Z或下划线开头，后面跟着零或更多的字母、下划线和数字(0到9)。Go不允许在命名时中使用@、$和%等标点符号。Go是一种区分大小写的编程语言。因此，Manpower和manpower是两个不同的命名。</p>
<blockquote>
<ol>
<li>当命名（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就<strong>可以被外部包的代码所使用</strong>（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；</li>
<li><strong>命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的</strong>（像面向对象语言中的 private ）</li>
</ol>
</blockquote>
<h3 id="包命名：package"><a href="#包命名：package" class="headerlink" title="包命名：package"></a>包命名：package</h3><p>保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为<strong>小写</strong>单词，不要使用下划线或者混合大小写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo</span><br><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure>

<h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>尽量采取有意义的文件名，简短，有意义，应该为<strong>小写</strong>单词，使用<strong>下划线</strong>分隔各个单词。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">my_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<h3 id="结构体命名"><a href="#结构体命名" class="headerlink" title="结构体命名"></a>结构体命名</h3><ul>
<li><p>采用驼峰命名法，首字母根据访问控制大写或者小写</p>
</li>
<li><p>struct 申明和初始化格式采用多行，例如下面：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多行申明</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="type">string</span></span><br><span class="line">    Email     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多行初始化</span></span><br><span class="line">u := User&#123;</span><br><span class="line">    Username: <span class="string">&quot;astaxie&quot;</span>,</span><br><span class="line">    Email:    <span class="string">&quot;astaxie@gmail.com&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名"></a>接口命名</h3><ul>
<li>命名规则基本和上面的结构体类型保持一致。</li>
<li>单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><ul>
<li>和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则： <ul>
<li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient</li>
<li>其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID</li>
<li>错误示例：UrlArray，应该写成 urlArray 或者 URLArray</li>
</ul>
</li>
<li>若变量类型为 bool 类型，则名称应以 has, is, can 或 allow 开头</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isExist <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> hasConflict <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> canManage <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> allowGitHook <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><p>常量均需使用全部大写字母组成，并使用下划线分词</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> APP_VER = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure>


<p>如果是枚举类型的常量，需要先创建相应类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="type">string</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    HTTP  Scheme = <span class="string">&quot;http&quot;</span></span><br><span class="line">    HTTPS Scheme = <span class="string">&quot;https&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>下面的列表显示了Go中的保留字。这些保留字不能用作常量或变量或任何其他标识符名称。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24fd930b2dd64516845b351960d1df8b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="guanjianzi"></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Go提供C风格的<code>/* */</code>块注释和C ++风格的<code>//</code>行注释。行注释是常态；块注释主要显示为包注释，但在表达式中很有用或禁用大量代码。</p>
<ul>
<li>单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释</li>
<li>多行注释也叫块注释，均已以 &#x2F;* 开头，并以 *&#x2F; 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段</li>
</ul>
<p>go 语言自带的 godoc 工具可以根据注释生成文档，生成可以自动生成对应的网站（ golang.org 就是使用 godoc 工具直接生成的），注释的质量决定了生成的文档的质量。每个包都应该有一个包注释，在package子句之前有一个块注释。对于多文件包，包注释只需要存在于一个文件中，任何一个都可以。包评论应该介绍包，并提供与整个包相关的信息。它将首先出现在<code>godoc</code>页面上，并应设置下面的详细文档。</p>
<p>详细的如何写注释可以<br>参考：<a href="http://golang.org/doc/effective_go.html#commentary">http://golang.org/doc/effective_go.html#commentary</a></p>
<h3 id="包注释"><a href="#包注释" class="headerlink" title="包注释"></a>包注释</h3><p>每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中（一般是和包同名的文件）即可。 包注释应该包含下面基本信息(请严格按照这个顺序，简介，创建人，创建时间）：</p>
<ul>
<li>包的基本简介（包名，简介）</li>
<li>创建者，格式： 创建人： rtx 名</li>
<li>创建时间，格式：创建时间： yyyyMMdd</li>
</ul>
<p>例如 util 包的注释示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。</span></span><br><span class="line"><span class="comment">// 创建人： wxy</span></span><br><span class="line"><span class="comment">// 创建时间： 20230601</span></span><br></pre></td></tr></table></figure>

<h3 id="结构（接口）注释"><a href="#结构（接口）注释" class="headerlink" title="结构（接口）注释"></a>结构（接口）注释</h3><p>每个自定义的结构体或者接口都应该有注释说明，该注释对结构进行简要介绍，放在结构体定义的前一行，格式为： 结构体名， 结构体说明。同时结构体内的每个成员变量都要有说明，该说明放在成员变量的后面（注意对齐），实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User ， 用户对象，定义了用户的基础信息</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="type">string</span> <span class="comment">// 用户名</span></span><br><span class="line">    Email     <span class="type">string</span> <span class="comment">// 邮箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数（方法）注释"><a href="#函数（方法）注释" class="headerlink" title="函数（方法）注释"></a>函数（方法）注释</h3><p>每个函数，或者方法（结构体或者接口下的函数称为方法）都应该有注释说明，函数的注释应该包括三个方面（严格按照此顺序撰写）：</p>
<ul>
<li>简要说明，格式说明：以函数名开头，“，”分隔说明部分</li>
<li>参数列表：每行一个参数，参数名开头，“，”分隔说明部分</li>
<li>返回值： 每行一个返回值</li>
</ul>
<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewtAttrModel ， 属性数据层操作类的工厂方法</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      ctx ： 上下文信息</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      属性操作类指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAttrModel</span><span class="params">(ctx *common.Context)</span></span> *AttrModel &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码逻辑注释"><a href="#代码逻辑注释" class="headerlink" title="代码逻辑注释"></a>代码逻辑注释</h3><p>对于一些关键位置的代码逻辑，或者局部较为复杂的逻辑，需要有相应的逻辑说明，方便其他开发者阅读该段代码，实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br><span class="line">xxxxx</span><br><span class="line">xxxxxxx</span><br><span class="line">xxxxxxx</span><br></pre></td></tr></table></figure>

<h3 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h3><p>统一使用中文注释，对于中英文字符之间严格使用空格分隔， 这个不仅仅是中文和英文之间，英文和中文标点之间也都要使用空格分隔，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取</span></span><br></pre></td></tr></table></figure>


<p>上面 Redis 、 id 、 DB 和其他中文字符之间都是用了空格分隔。 </p>
<ul>
<li>建议全部使用单行注释</li>
<li>和代码的规范一样，单行注释不要过长，禁止超过 120 字符。</li>
</ul>
<h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><h3 id="缩进和折行"><a href="#缩进和折行" class="headerlink" title="缩进和折行"></a>缩进和折行</h3><ul>
<li>缩进直接使用 gofmt 工具格式化即可（gofmt 是使用 tab 缩进的）；</li>
<li>折行方面，一行最长不超过120个字符，超过的请使用换行展示，尽量保持格式优雅。</li>
</ul>
<p>我们使用Goland开发工具，可以直接使用快捷键：ctrl+alt+L，即可。</p>
<h3 id="语句的结尾"><a href="#语句的结尾" class="headerlink" title="语句的结尾"></a>语句的结尾</h3><p>Go语言中是不需要类似于Java需要冒号结尾，默认一行就是一条数据</p>
<p>如果你打算将多个语句写在同一行，它们则必须使用 <strong>;</strong> </p>
<h3 id="括号和空格"><a href="#括号和空格" class="headerlink" title="括号和空格"></a>括号和空格</h3><p>括号和空格方面，也可以直接使用 gofmt 工具格式化（go 会强制左大括号不换行，换行会报语法错误），所有的运算符和操作数之间要留空格。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的方式</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 错误的方式</span></span><br><span class="line"><span class="keyword">if</span> a&gt;<span class="number">0</span>  <span class="comment">// a ，0 和 &gt; 之间应该空格</span></span><br><span class="line">&#123;       <span class="comment">// 左大括号不可以换行，会报语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="import-规范"><a href="#import-规范" class="headerlink" title="import 规范"></a>import 规范</h3><p>import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;myproject/models&quot;</span></span><br><span class="line">    <span class="string">&quot;myproject/controller&quot;</span></span><br><span class="line">    <span class="string">&quot;myproject/utils&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/astaxie/beego&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)   </span><br></pre></td></tr></table></figure>

<p>有顺序的引入包，不同的类型采用空格分离，第一种是标准库，第二是项目包，第三是第三方包。</p>
<p>在项目中不要使用相对路径引入包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是不好的导入</span></span><br><span class="line"><span class="keyword">import</span> “../net”</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是正确的做法</span></span><br><span class="line"><span class="keyword">import</span> “github.com/repo/proj/src/net”</span><br></pre></td></tr></table></figure>

<p>但是如果是引入本项目中的其他包，最好使用相对路径。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul>
<li>错误处理的原则就是不能丢弃任何有返回err的调用，不要使用 _ 丢弃，必须全部处理。接收到错误，要么返回err，或者使用log记录下来</li>
<li>尽早return：一旦有错误发生，马上返回</li>
<li>尽量不要使用panic，除非你知道你在做什么</li>
<li>错误描述如果是英文必须为小写，不需要标点结尾</li>
<li>采用独立的错误流进行处理</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// normal code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>单元测试文件名命名规范为 example_test.go<br>测试用例的函数名称必须以 Test 开头，例如：TestExample<br>每个重要的函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试</p>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><p>上面提到了很过规范， go 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范，</p>
<p><strong>gofmt</strong><br>大部分的格式问题可以通过gofmt解决， gofmt 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 gofmt 的结果为准。</p>
<p><strong>goimport</strong><br>我们强烈建议使用 goimport ，该工具在 gofmt 的基础上增加了自动删除和引入包.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go get golang.org/x/tools/cmd/goimports</span></span><br></pre></td></tr></table></figure>

<p><em><strong>以上两种工具上一篇文章已经介绍过怎么配置</strong></em></p>
<p><strong>go vet</strong><br>vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go get golang.org/x/tools/cmd/vet</span></span><br></pre></td></tr></table></figure>


<p>使用如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go vet .</span></span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>数组&amp;切片&amp;集合&amp;字符串</title>
    <url>/2023/06/03/Go/7/</url>
    <content><![CDATA[<h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h1><h2 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h2><p>Go 语言提供了数组类型的数据结构。<br>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。</p>
<p>数组元素可以通过索引（位置）来读取（或者修改），索引从0开始，第一个元素索引为 0，第二个索引为 1，以此类推。数组的下标取值范围是从0开始，到长度减1。</p>
<p>数组一旦定义后，大小不能更改。</p>
<h2 id="数组的语法"><a href="#数组的语法" class="headerlink" title="数组的语法"></a>数组的语法</h2><p><strong>声明和初始化数组</strong></p>
<p>需要指明数组的大小和存储的数据类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>] <span class="type">float32</span></span><br><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>初始化数组中 {} 中的元素个数不能大于 [] 中的数字。<br>如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance = []<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span></span><br></pre></td></tr></table></figure>

<p>数组的其他创建方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">4</span>] <span class="type">float32</span> <span class="comment">// 等价于：var arr2 = [4]float32&#123;&#125;</span></span><br><span class="line">fmt.Println(a) <span class="comment">// [0 0 0 0]</span></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">5</span>] <span class="type">string</span>&#123;<span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;王二狗&quot;</span>, <span class="string">&quot;rose&quot;</span>&#125;</span><br><span class="line">fmt.Println(b) <span class="comment">// [ruby 王二狗 rose  ]</span></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">5</span>] <span class="type">int</span>&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125; <span class="comment">// byte</span></span><br><span class="line">fmt.Println(c) <span class="comment">// [65 66 67 68 69]</span></span><br><span class="line">d := [...] <span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">// 根据元素的个数，设置数组的大小</span></span><br><span class="line">fmt.Println(d)<span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">e := [<span class="number">5</span>] <span class="type">int</span>&#123;<span class="number">4</span>: <span class="number">100</span>&#125; <span class="comment">// [0 0 0 0 100]</span></span><br><span class="line">fmt.Println(e)</span><br><span class="line">f := [...] <span class="type">int</span>&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">1</span>, <span class="number">9</span>: <span class="number">1</span>&#125; <span class="comment">// [1 0 0 0 1 0 0 0 0 1]</span></span><br><span class="line">fmt.Println(f)</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p><code>0: 1</code> 表示将索引为 0 的位置的元素初始化为 1，<code>4: 1</code> 表示将索引为 4 的位置的元素初始化为 1，<code>9: 1</code> 表示将索引为 9 的位置的元素初始化为 1。其余位置的元素将使用默认值进行初始化，对于整数数组，默认值为 0。</p>
<p><strong>访问数组元素</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">float32</span> salary = balance[<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> n [<span class="number">10</span>]<span class="type">int</span> <span class="comment">/* n 是一个长度为 10 的数组 */</span></span><br><span class="line">   <span class="keyword">var</span> i,j <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 为数组 n 初始化元素 */</span>         </span><br><span class="line">   <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      n[i] = i + <span class="number">100</span> <span class="comment">/* 设置元素为 i + 100 */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 输出每个数组元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Element[%d] = %d\n&quot;</span>, j, n[j] )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Element[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">Element[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">Element[<span class="number">2</span>] = <span class="number">102</span></span><br><span class="line">Element[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line">Element[<span class="number">4</span>] = <span class="number">104</span></span><br><span class="line">Element[<span class="number">5</span>] = <span class="number">105</span></span><br><span class="line">Element[<span class="number">6</span>] = <span class="number">106</span></span><br><span class="line">Element[<span class="number">7</span>] = <span class="number">107</span></span><br><span class="line">Element[<span class="number">8</span>] = <span class="number">108</span></span><br><span class="line">Element[<span class="number">9</span>] = <span class="number">109</span></span><br></pre></td></tr></table></figure>

<p><strong>数组的长度</strong></p>
<p>通过将数组作为参数传递给len函数，可以获得数组的长度。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="type">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;length of a is&quot;</span>,<span class="built_in">len</span>(a))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">length of a is 4</span><br></pre></td></tr></table></figure>

<p>您甚至可以忽略声明中数组的长度并将其替换为…让编译器为你找到长度。这是在下面的程序中完成的。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="type">int</span>&#123;<span class="number">12</span>, <span class="number">78</span>, <span class="number">50</span>&#125; <span class="comment">// ... makes the compiler determine the length</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[12 78 50]</span><br></pre></td></tr></table></figure>

<p>遍历数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="type">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123; <span class="comment">//looping from 0 to the length of the array</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d th element of a is %.2f\n&quot;</span>, i, a[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 th element of a is 67.70</span><br><span class="line">1 th element of a is 89.80</span><br><span class="line">2 th element of a is 21.00</span><br><span class="line">3 th element of a is 78.00</span><br></pre></td></tr></table></figure>

<p>使用range遍历数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="type">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    sum := <span class="type">float64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;<span class="comment">//range returns both the index and value</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d the element of a is %.2f\n&quot;</span>, i, v)</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;\nsum of all elements of a&quot;</span>,sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 the element of a is 67.70</span><br><span class="line">1 the element of a is 89.80</span><br><span class="line">2 the element of a is 21.00</span><br><span class="line">3 the element of a is 78.00</span><br><span class="line"></span><br><span class="line">sum of all elements of a 256.5</span><br></pre></td></tr></table></figure>

<p>如果您只需要值并希望忽略索引，那么可以通过使用_ blank标识符替换索引来实现这一点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123; <span class="comment">//ignores index  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go 语言支持多维数组，以下为常用的多维数组声明语法方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threedim [<span class="number">5</span>][<span class="number">10</span>][<span class="number">4</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>三维数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span>&#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;   <span class="comment">/*  第三行索引为 2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">			twoD[i][j] = i + j</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;2d: &quot;</span>, twoD)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2d:  [[0 1 2] [1 2 3]]</span><br></pre></td></tr></table></figure>

<h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h2><p>Go中的数组是值类型，而不是引用类型。这意味着当它们被分配给一个新变量时，将把原始数组的副本分配给新变量。如果对新变量进行了更改，则不会在原始数组中反映。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="type">string</span>&#123;<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;China&quot;</span>, <span class="string">&quot;India&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;France&quot;</span>&#125;</span><br><span class="line">    b := a <span class="comment">// a copy of a is assigned to b</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&quot;Singapore&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a is &quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;b is &quot;</span>, b) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a is [USA China India Germany France]  </span><br><span class="line">b is [Singapore China India Germany France] </span><br></pre></td></tr></table></figure>

<p>数组的大小是类型的一部分。因此[5]int和[25]int是不同的类型。因此，数组不能被调整大小。不要担心这个限制，因为切片的存在是为了解决这个问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">78</span>, <span class="number">8</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    b = a <span class="comment">//not possible since [3]int and [5]int are distinct types</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片(Slice)"></a>切片(Slice)</h1><h2 id="什么是切片"><a href="#什么是切片" class="headerlink" title="什么是切片"></a>什么是切片</h2><p><em><strong>Go 语言切片是对数组的抽象</strong></em>。<br>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大<br>切片是一种方便、灵活且强大的包装器。切片本身没有任何数据。它们只是对现有数组的引用。<br>切片与数组相比，不需要设定长度，在[]中不用设定值，相对来说比较自由<br>从概念上面来说slice像一个结构体，这个结构体包含了三个元素： </p>
<blockquote>
<ol>
<li>指针，指向数组中slice指定的开始位置</li>
<li>长度，即slice的长度</li>
<li>最大长度，也就是slice开始位置到数组的最后位置的长度</li>
</ol>
</blockquote>
<h2 id="切片的语法"><a href="#切片的语法" class="headerlink" title="切片的语法"></a>切片的语法</h2><p><strong>定义切片</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>切片不需要说明长度。<br>或使用make()函数来创建切片:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">//也可以简写为</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s :=[] <span class="type">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:endIndex] </span><br></pre></td></tr></table></figure>

<p>将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片（<strong>前闭后开</strong>），长度为endIndex-startIndex</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:] </span><br></pre></td></tr></table></figure>

<p>缺省endIndex时将表示一直到arr的最后一个元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[:endIndex] </span><br></pre></td></tr></table></figure>

<p>缺省startIndex时将表示从arr的第一个元素开始</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="type">int</span> = a[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//creates a slice from a[1] to a[3]</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改切片"><a href="#修改切片" class="headerlink" title="修改切片"></a>修改切片</h2><p>slice没有自己的任何数据。它只是底层数组的一个表示。对slice所做的任何修改都将反映在底层数组中。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    darr := [...]<span class="type">int</span>&#123;<span class="number">57</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">82</span>, <span class="number">100</span>, <span class="number">78</span>, <span class="number">67</span>, <span class="number">69</span>, <span class="number">59</span>&#125;</span><br><span class="line">    dslice := darr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;array before&quot;</span>,darr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dslice &#123;</span><br><span class="line">        dslice[i]++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;array after&quot;</span>,darr) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，<code>range</code> 遍历 <code>dslice</code> 时返回的是索引，而不是值。切片是对数组的引用，因此<em><strong>修改切片的值也会影响到原始数组</strong></em>。</p>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array before [57 89 90 82 100 78 67 69 59]  </span><br><span class="line">array after [57 89 91 83 101 78 67 69 59]  </span><br></pre></td></tr></table></figure>

<p>当多个片共享相同的底层数组时，每个元素所做的更改将在数组中反映出来。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    numa := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">78</span>, <span class="number">79</span> ,<span class="number">80</span>&#125;</span><br><span class="line">    nums1 := numa[:] <span class="comment">//creates a slice which contains all elements of the array</span></span><br><span class="line">    nums2 := numa[:]</span><br><span class="line">    fmt.Println(<span class="string">&quot;array before change 1&quot;</span>,numa)</span><br><span class="line">    nums1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;array after modification to slice nums1&quot;</span>, numa)</span><br><span class="line">    nums2[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;array after modification to slice nums2&quot;</span>, numa)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array before change 1 [78 79 80]  </span><br><span class="line">array after modification to slice nums1 [100 79 80]  </span><br><span class="line">array after modification to slice nums2 [100 101 80]  </span><br></pre></td></tr></table></figure>

<h2 id="len-和-cap"><a href="#len-和-cap" class="headerlink" title="len() 和 cap()"></a>len() 和 cap()</h2><p>切片的长度是切片中元素的数量。切片的容量是从创建切片的索引开始的底层数组中元素的数量。</p>
<p>切片是可索引的，并且可以由 len() 方法获取长度<br>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>make([]int, 3, 5)</code> 创建了一个切片 <code>numbers</code>，长度为 3，容量为 5。<code>make</code> 函数用于创建切片、映射和通道，并指定它们的长度和容量。</p>
<p>运行结果:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">3</span> <span class="built_in">cap</span>=<span class="number">5</span> slice=[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>空切片</strong></p>
<p>一个切片在未初始化之前默认为 nil，长度为 0</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">len=0 cap=0 slice=[]</span><br><span class="line">切片是空的</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;   </span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers ==&quot;</span>, numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[1:4] ==&quot;</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[:3] ==&quot;</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[4:] ==&quot;</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">9</span> <span class="built_in">cap</span>=<span class="number">9</span> slice=[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line">numbers == [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line">numbers[<span class="number">1</span>:<span class="number">4</span>] == [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">numbers[:<span class="number">3</span>] == [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">numbers[<span class="number">4</span>:] == [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">5</span> slice=[]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">9</span> slice=[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="built_in">len</span>=<span class="number">3</span> <span class="built_in">cap</span>=<span class="number">7</span> slice=[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>切片的容量（<code>cap</code>）是指切片的底层数组中从切片的起始位置到数组末尾的元素数量。在这个例子中，切片 <code>numbers</code> 的容量与底层数组的容量相同，都是 9。这是因为我们没有指定切片的容量，Go语言会默认将切片的容量设置为底层数组中剩余的元素数量。<code>number2</code> 的容量是从切片的起始位置到底层数组的末尾，即剩余的元素数量。<code>number2</code> 的容量是 9，与底层数组的容量相同。<code>number3</code> 的容量是 7，因为从索引 2 开始，底层数组中还有 7 个元素。</p>
<h2 id="append-和-copy"><a href="#append-和-copy" class="headerlink" title="append() 和 copy()"></a>append() 和 copy()</h2><p>append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice<br>copy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数</p>
<p>append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩余空间（即(cap-len) &#x3D;&#x3D; 0）时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响</p>
<p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">len=0 cap=0 slice=[]</span><br><span class="line">len=1 cap=1 slice=[0]</span><br><span class="line">len=2 cap=2 slice=[0 1]</span><br><span class="line">len=5 cap=6 slice=[0 1 2 3 4]</span><br><span class="line">len=5 cap=12 slice=[0 1 2 3 4]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>numbers容量为6是因为在分配底层数组时，系统会根据策略进行内存分配，通常是分配比所需容量稍微多一点的容量。所以，在这个例子中，底层数组的容量被分配为了6。</p>
<p>numbers1与numbers两者不存在联系，numbers发生变化时，numbers1是不会随着变化的。也就是说copy方法是不会建立两个切片的联系的</p>
</blockquote>
<h1 id="集合-Map"><a href="#集合-Map" class="headerlink" title="集合(Map)"></a>集合(Map)</h1><h2 id="什么是Map"><a href="#什么是Map" class="headerlink" title="什么是Map"></a>什么是Map</h2><p>map是Go中的内置类型，它将一个值与一个键关联起来。可以使用相应的键检索值。</p>
<p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值<br>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的，也是引用类型</p>
<p>使用map过程中需要注意的几点： </p>
<ul>
<li>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取</li>
<li>map的长度是不固定的，也就是和slice一样，也是一种引用类型</li>
<li>内置的len函数同样适用于map，返回map拥有的key的数量 </li>
<li>map的key可以是所有可比较的类型，如布尔型、整数型、浮点型、复杂型、字符串型……也可以键。</li>
</ul>
<h2 id="Map的使用"><a href="#Map的使用" class="headerlink" title="Map的使用"></a>Map的使用</h2><h3 id="使用make-创建map"><a href="#使用make-创建map" class="headerlink" title="使用make()创建map"></a>使用make()创建map</h3><p>可以使用内建函数 make 也可以使用 map 关键字来定义 Map:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable = <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rating := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span> &#123;<span class="string">&quot;C&quot;</span>:<span class="number">5</span>, <span class="string">&quot;Go&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;Python&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;C++&quot;</span>:<span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">   <span class="comment">/* 创建集合 */</span></span><br><span class="line">   countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* map 插入 key-value 对，各个国家对应的首都 */</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;France&quot;</span>] = <span class="string">&quot;Paris&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Italy&quot;</span>] = <span class="string">&quot;Rome&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Japan&quot;</span>] = <span class="string">&quot;Tokyo&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;India&quot;</span>] = <span class="string">&quot;New Delhi&quot;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 使用 key 输出 map 值 */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 查看元素在集合中是否存在 */</span></span><br><span class="line">   captial, ok := countryCapitalMap[<span class="string">&quot;United States&quot;</span>]</span><br><span class="line">   <span class="comment">/* 如果 ok 是 true, 则存在，否则不存在 */</span></span><br><span class="line">   <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is&quot;</span>, captial)  </span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is not present&quot;</span>) </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k, v) <span class="comment">// b 8; a A</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;key&quot;</span>, k) <span class="comment">// key a; key b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Capital of France is Paris</span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br><span class="line">Capital of United States is not present</span><br><span class="line">a A</span><br><span class="line">b B</span><br><span class="line">key a</span><br><span class="line">key b</span><br></pre></td></tr></table></figure>

<h3 id="delete-函数"><a href="#delete-函数" class="headerlink" title="delete() 函数"></a>delete() 函数</h3><p>delete(map, key) 函数用于删除集合的元素, 参数为 map 和其对应的 key。删除函数不返回任何值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">   <span class="comment">/* 创建 map */</span></span><br><span class="line">   countryCapitalMap := <span class="keyword">map</span>[<span class="type">string</span>] <span class="type">string</span> &#123;<span class="string">&quot;France&quot;</span>:<span class="string">&quot;Paris&quot;</span>,<span class="string">&quot;Italy&quot;</span>:<span class="string">&quot;Rome&quot;</span>,<span class="string">&quot;Japan&quot;</span>:<span class="string">&quot;Tokyo&quot;</span>,<span class="string">&quot;India&quot;</span>:<span class="string">&quot;New Delhi&quot;</span>&#125;</span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">&quot;原始 map&quot;</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 删除元素 */</span></span><br><span class="line">   <span class="built_in">delete</span>(countryCapitalMap,<span class="string">&quot;France&quot;</span>);</span><br><span class="line">   fmt.Println(<span class="string">&quot;Entry for France is deleted&quot;</span>)  </span><br><span class="line">   </span><br><span class="line">   fmt.Println(<span class="string">&quot;删除元素后 map&quot;</span>)   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 打印 map */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始 map</span><br><span class="line">Capital of France is Paris</span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br><span class="line">Entry for France is deleted</span><br><span class="line">删除元素后 map</span><br><span class="line">Capital of Italy is Rome</span><br><span class="line">Capital of Japan is Tokyo</span><br><span class="line">Capital of India is New Delhi</span><br></pre></td></tr></table></figure>

<h3 id="ok-idiom"><a href="#ok-idiom" class="headerlink" title="ok-idiom"></a>ok-idiom</h3><p>我们可以通过key获取map中对应的value值。语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[key] </span><br></pre></td></tr></table></figure>

<p>但是当key如果不存在的时候，我们会得到该value值类型的默认值，比如string类型得到空字符串，int类型得到0。但是程序不会报错。</p>
<p>所以我们可以使用ok-idiom获取值，可知道key&#x2F;value是否存在</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key] </span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">	x, ok := m[<span class="string">&quot;b&quot;</span>]</span><br><span class="line">	fmt.Println(x, ok)</span><br><span class="line">	x, ok = m[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">	fmt.Println(x, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br><span class="line"><span class="number">1</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="map的长度"><a href="#map的长度" class="headerlink" title="map的长度"></a>map的长度</h3><p>使用len函数可以确定map的长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(<span class="keyword">map</span>)  <span class="comment">// 可以得到map的长度</span></span><br></pre></td></tr></table></figure>

<h3 id="map是引用类型"><a href="#map是引用类型" class="headerlink" title="map是引用类型"></a>map是引用类型</h3><p>与切片相似，映射是引用类型。当将映射分配给一个新变量时，它们都指向相同的内部数据结构。因此，一个的变化会反映另一个。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    personSalary := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="string">&quot;steve&quot;</span>: <span class="number">12000</span>,</span><br><span class="line">        <span class="string">&quot;jamie&quot;</span>: <span class="number">15000</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    personSalary[<span class="string">&quot;mike&quot;</span>] = <span class="number">9000</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Original person salary&quot;</span>, personSalary)</span><br><span class="line">    newPersonSalary := personSalary</span><br><span class="line">    newPersonSalary[<span class="string">&quot;mike&quot;</span>] = <span class="number">18000</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Person salary changed&quot;</span>, personSalary)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Original person salary map[steve:12000 jamie:15000 mike:9000]  </span><br><span class="line">Person salary changed map[steve:12000 jamie:15000 mike:18000] </span><br></pre></td></tr></table></figure>

<blockquote>
<p>map不能使用&#x3D;&#x3D;操作符进行比较。&#x3D;&#x3D;只能用来检查map是否为空。否则会报错：invalid operation: map1 &#x3D;&#x3D; map2 (map can only be comparedto nil)</p>
</blockquote>
<h1 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h1><h2 id="什么是string"><a href="#什么是string" class="headerlink" title="什么是string"></a>什么是string</h2><p>Go中的字符串是一个字节的切片。可以通过将其内容封装在“”中来创建字符串。Go中的字符串是Unicode兼容的，并且是UTF-8编码的。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    name := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string的使用"><a href="#string的使用" class="headerlink" title="string的使用"></a>string的使用</h2><p>访问字符串中的单个字节</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, s[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%c &quot;</span>, s[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>%c：相应Unicode码点所表示的字符</p>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">72 101 108 108 111 32 87 111 114 108 100 </span><br><span class="line">H e l l o   W o r l d </span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>条件语句与循环语句</title>
    <url>/2023/06/02/Go/6/</url>
    <content><![CDATA[<h1 id="程序的流程结构"><a href="#程序的流程结构" class="headerlink" title="程序的流程结构"></a>程序的流程结构</h1><p>程序的流程控制结构一共有三种：顺序结构，选择结构，循环结构。</p>
<p>顺序结构：从上向下，逐行执行。</p>
<p>选择结构：条件满足，某些代码才会执行。0-1次</p>
<p>​	分支语句：if，switch，select</p>
<p>循环结构：条件满足，某些代码会被反复的执行多次。0-N次</p>
<p>​	循环语句：for</p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="If语句"><a href="#If语句" class="headerlink" title="If语句"></a>If语句</h2><p>语法格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式<span class="number">1</span> &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式1为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 布尔表达式<span class="number">2</span>&#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式1为 false ,布尔表达式2为true时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">/* 在上面两个布尔表达式都为false时，执行*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用 if 语句判断布尔表达式 */</span></span><br><span class="line">   <span class="keyword">if</span> a &lt; <span class="number">20</span> &#123;</span><br><span class="line">       <span class="comment">/* 如果条件为 true 则执行以下语句 */</span></span><br><span class="line">       fmt.Printf(<span class="string">&quot;a 小于 20\n&quot;</span> )</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;a 的值为 : %d\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果其中包含一个可选的语句组件(在评估条件之前执行)，则还有一个变体。它的语法是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> statement; condition &#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="number">7</span>%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;7 is even&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;7 is odd&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="number">8</span>%<span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;8 is divisible by 4&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> num := <span class="number">9</span>; num &lt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(num, <span class="string">&quot;is negative&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">		fmt.Println(num, <span class="string">&quot;has 1 digit&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(num, <span class="string">&quot;has multiple digits&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，num的定义在if里，那么只能够在该if..else语句块中使用，否则编译器会报错的。</p>
</blockquote>
<h2 id="switch语句：“开关”"><a href="#switch语句：“开关”" class="headerlink" title="switch语句：“开关”"></a>switch语句：“开关”</h2><p>switch是一个条件语句，它计算表达式并将其与可能匹配的列表进行比较，并根据匹配执行代码块。它可以被认为是一种惯用的方式来写多个if else子句。</p>
<p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。<br>switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也<em><strong>不需要再加break</strong></em>。</p>
<p><em><strong>而如果switch没有表达式，它会匹配true</strong></em></p>
<p><em>Go里面switch默认相当于每个case最后带有break</em>，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。</p>
<p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。<br>可以<strong>同时测试多个可能符合条件的值，使用逗号分割它们</strong>，例如：case val1, val2, val3。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/* 定义局部变量 */</span></span><br><span class="line">	<span class="keyword">var</span> grade = <span class="string">&quot;B&quot;</span></span><br><span class="line">	<span class="keyword">var</span> marks = <span class="number">90</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> marks &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">90</span>:</span><br><span class="line">		grade = <span class="string">&quot;A&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">		grade = <span class="string">&quot;B&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>:</span><br><span class="line">		grade = <span class="string">&quot;C&quot;</span> <span class="comment">//case 后可以由多个数值</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		grade = <span class="string">&quot;D&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> grade == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;优秀!\n&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> grade == <span class="string">&quot;B&quot;</span>, grade == <span class="string">&quot;C&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;良好\n&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> grade == <span class="string">&quot;D&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;及格\n&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> grade == <span class="string">&quot;F&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;不及格\n&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;差\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;你的等级是 %s\n&quot;</span>, grade)</span><br><span class="line">    </span><br><span class="line">    t := time.Now()</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;It&#x27;s before noon&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;It&#x27;s after noon&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优秀!</span><br><span class="line">你的等级是 A</span><br><span class="line">It&#x27;s before noon</span><br></pre></td></tr></table></figure>



<h3 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h3><p>如需贯通后续的case，就添加fallthrough</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> x := <span class="number">5</span>; x &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(x)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		x += <span class="number">10</span></span><br><span class="line">		fmt.Println(x)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		x += <span class="number">20</span></span><br><span class="line">		fmt.Println(x)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br><span class="line">35</span><br></pre></td></tr></table></figure>

<hr>
<p>解释：</p>
<p>根据switch语句的逻辑，首先会执行default分支，但是由于我们没有在default分支中写入任何代码，所以会直接跳过。在case 5分支的最后，我们使用了fallthrough关键字。fallthrough关键字的作用是强制执行下一个case分支的代码，而不进行条件判断。</p>
<p>在<code>switch</code>语句中，<code>default</code>用于处理没有匹配到任何<code>case</code>的情况。当<code>switch</code>表达式的值与所有的<code>case</code>都不匹配时，程序会执行<code>default</code>分支中的代码。</p>
<p><code>default</code>分支是可选的，也就是说可以选择是否在<code>switch</code>语句中包含它。如果没有<code>default</code>分支，而且没有任何一个<code>case</code>匹配到<code>switch</code>表达式的值，那么<code>switch</code>语句将不会执行任何代码。</p>
<p><code>default</code>分支通常被用作最后一个分支，用于处理不常见或者意外的情况。它可以用来提供一个默认的处理逻辑，或者给用户一个错误提示。</p>
<p>以下是一个示例，展示了<code>default</code>的使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> num &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;小数&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;中数&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;大数&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;未知数&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，如果<code>num</code>的值不属于1到9之间的任何一个数，那么就会执行<code>default</code>分支，并输出”未知数”。<code>default</code>分支可以用来处理一些边缘情况或者未预料到的情况，确保程序的健壮性。</p>
<hr>
<p><em>case中的表达式是可选的，可以省略。如果该表达式被省略，则被认为是switch true，并且每个case表达式都被计算为true，并执行相应的代码块</em>。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    num := <span class="number">75</span></span><br><span class="line">    <span class="keyword">switch</span> &#123; <span class="comment">// expression is omitted</span></span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">50</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;num is greater than 0 and less than 50&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">51</span> &amp;&amp; num &lt;= <span class="number">100</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;num is greater than 51 and less than 100&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">101</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;num is greater than 100&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num is greater than 51 and less than 100</span><br></pre></td></tr></table></figure>

<blockquote>
<p>switch的注意事项</p>
<ol>
<li>case后的常量值不能重复</li>
<li>case后可以有多个常量值</li>
<li>fallthrough应该是某个case的最后一行。如果它出现在中间的某个地方，编译器就会抛出错误。</li>
</ol>
</blockquote>
<h3 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h3><p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">   <span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">nil</span>:	  </span><br><span class="line">         fmt.Printf(<span class="string">&quot; x 的类型 :%T&quot;</span>,i)                </span><br><span class="line">      <span class="keyword">case</span> <span class="type">int</span>:	  </span><br><span class="line">         fmt.Printf(<span class="string">&quot;x 是 int 型&quot;</span>)                       </span><br><span class="line">      <span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;x 是 float64 型&quot;</span>)           </span><br><span class="line">      <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">float64</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;x 是 func(int) 型&quot;</span>)                      </span><br><span class="line">      <span class="keyword">case</span> <span class="type">bool</span>, <span class="type">string</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;x 是 bool 或 string 型&quot;</span> )       </span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;未知型&quot;</span>)     </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x 的类型 :&lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>在这段代码中，变量<code>x</code>的类型被声明为<code>interface&#123;&#125;</code>，它是一个空接口。空接口可以表示任意类型的值，包括<code>nil</code>。当我们使用类型断言<code>x.(type)</code>来获取<code>x</code>的具体类型时，如果<code>x</code>的值是<code>nil</code>，那么<code>case nil</code>分支会匹配成功。这里需要注意的是，<code>nil</code>是一个特殊的值，表示一个指针类型或接口类型的零值，表示该指针或接口不指向任何具体的对象。在这种情况下，我们可以将其视为一种特殊的类型。因此，<code>case nil</code>分支被用来处理<code>x</code>为<code>nil</code>的情况。</p>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>循环语句表示条件满足，可以反复的执行某段代码。</p>
<p>for是唯一的循环语句。(Go没有while循环)</p>
<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>语法结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for init; condition; post &#123; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>初始化语句只执行一次。在初始化循环之后，将检查该条件。如果条件计算为true，那么{}中的循环体将被执行，然后是post语句。post语句将在循环的每次成功迭代之后执行。在执行post语句之后，该条件将被重新检查。如果它是正确的，循环将继续执行，否则循环终止。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot; %d&quot;</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在for循环中声明的变量仅在循环范围内可用。因此，i不能在外部访问循环。</p>
</blockquote>
<p><strong>所有的三个组成部分，即初始化、条件和post都是可选的。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>效果与while相似</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>效果与for(;;) 一样</p>
<p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for key, value := range oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">9</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   numbers := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* for 循环 */</span></span><br><span class="line">   <span class="keyword">for</span> a := <span class="number">0</span>; a &lt; <span class="number">5</span>; a++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> a &lt; b &#123;</span><br><span class="line">      a++</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i,x:= <span class="keyword">range</span> numbers &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i,x)</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a 的值为: 0</span><br><span class="line">a 的值为: 1</span><br><span class="line">a 的值为: 2</span><br><span class="line">a 的值为: 3</span><br><span class="line">a 的值为: 4</span><br><span class="line">a 的值为: 1</span><br><span class="line">a 的值为: 2</span><br><span class="line">a 的值为: 3</span><br><span class="line">a 的值为: 4</span><br><span class="line">a 的值为: 5</span><br><span class="line">a 的值为: 6</span><br><span class="line">a 的值为: 7</span><br><span class="line">a 的值为: 8</span><br><span class="line">a 的值为: 9</span><br><span class="line">第 0 位 x 的值 = 1</span><br><span class="line">第 1 位 x 的值 = 2</span><br><span class="line">第 2 位 x 的值 = 3</span><br><span class="line">第 3 位 x 的值 = 5</span><br><span class="line">第 4 位 x 的值 = 0</span><br><span class="line">第 5 位 x 的值 = 0</span><br></pre></td></tr></table></figure>



<h3 id="多层for循环"><a href="#多层for循环" class="headerlink" title="多层for循环"></a>多层for循环</h3><p>for循环中又有循环嵌套，就表示多层循环了。</p>
<h2 id="跳出循环的语句"><a href="#跳出循环的语句" class="headerlink" title="跳出循环的语句"></a>跳出循环的语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>break：跳出循环体。break语句用于在结束其正常执行之前突然终止for循环</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">//loop is terminated if i &gt; 5</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\nline after for loop&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 </span><br><span class="line">line after for loop</span><br></pre></td></tr></table></figure>

<h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>continue：跳出一次循环。continue语句用于跳过for循环的当前迭代。在continue语句后面的for循环中的所有代码将不会在当前迭代中执行。循环将继续到下一个迭代。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3 5 7 9 </span><br></pre></td></tr></table></figure>

<h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>goto：可以无条件地转移到过程中指定的行。</p>
<p>语法结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">label: statement;</span><br></pre></td></tr></table></figure>

<p>​												<a href="https://smms.app/image/ZUna3jv2o9h5xgN" target="_blank"><img src="https://s2.loli.net/2023/06/02/ZUna3jv2o9h5xgN.jpg" ></a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/* 定义局部变量 */</span></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 循环 */</span></span><br><span class="line">LOOP:</span><br><span class="line">	<span class="keyword">for</span> a &lt; <span class="number">20</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> a == <span class="number">15</span> &#123;</span><br><span class="line">			<span class="comment">/* 跳过迭代 */</span></span><br><span class="line">			a = a + <span class="number">1</span></span><br><span class="line">			<span class="keyword">goto</span> LOOP</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;a的值为 : %d\n&quot;</span>, a)</span><br><span class="line">		a++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a的值为 : 10</span><br><span class="line">a的值为 : 11</span><br><span class="line">a的值为 : 12</span><br><span class="line">a的值为 : 13</span><br><span class="line">a的值为 : 14</span><br><span class="line">a的值为 : 16</span><br><span class="line">a的值为 : 17</span><br><span class="line">a的值为 : 18</span><br><span class="line">a的值为 : 19</span><br></pre></td></tr></table></figure>

<p>统一错误处理<br>多处错误处理存在代码重复时是非常棘手的，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	err := firstCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    err = secondCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br></pre></td></tr></table></figure>

<h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num1 := rand.Int()</span><br><span class="line">	fmt.Println(num1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		num := rand.Intn(<span class="number">10</span>)</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;</span><br><span class="line">	rand.Seed(<span class="number">1000</span>)</span><br><span class="line">	num2 := rand.Intn(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;---&gt;&quot;</span>, num2)</span><br><span class="line"></span><br><span class="line">	t1 := time.Now()</span><br><span class="line">	fmt.Println(t1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, t1)</span><br><span class="line"></span><br><span class="line">	timeStamp1 := t1.Unix()</span><br><span class="line">	fmt.Println(timeStamp1)</span><br><span class="line"></span><br><span class="line">	timestamp2 := t1.UnixNano()</span><br><span class="line">	fmt.Println(timestamp2)</span><br><span class="line"></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;---&gt;&quot;</span>, rand.Intn(<span class="number">100</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	num3 := rand.Intn(<span class="number">46</span>) + <span class="number">3</span></span><br><span class="line">	fmt.Println(num3)</span><br><span class="line">	num4 := rand.Intn(<span class="number">62</span>) + <span class="number">15</span></span><br><span class="line">	fmt.Println(num4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2359980755445512729</span><br><span class="line">6</span><br><span class="line">0</span><br><span class="line">9</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">---&gt; 5</span><br><span class="line">2023-06-02 12:00:50.6796224 +0800 CST m=+0.001542201</span><br><span class="line">time.Time</span><br><span class="line">1685678450</span><br><span class="line">1685678450679622400</span><br><span class="line">---&gt; 74</span><br><span class="line">---&gt; 79</span><br><span class="line">---&gt; 18</span><br><span class="line">---&gt; 21</span><br><span class="line">---&gt; 68</span><br><span class="line">---&gt; 41</span><br><span class="line">---&gt; 33</span><br><span class="line">---&gt; 31</span><br><span class="line">---&gt; 26</span><br><span class="line">---&gt; 37</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>在随机数生成中，种子（seed）是用于初始化随机数生成器的值。种子决定了随机数序列的起始点。在某种程度上，相同种子会生成相同的随机数序列。</p>
<p>在上述代码中，<code>rand.Seed()</code>方法用于设置随机数生成器的种子。如果没有显式地设置种子，Go语言的<code>math/rand</code>包默认使用一个固定的种子，这意味着每次程序运行时都会生成相同的随机数序列。这在某些情况下可能不是我们所期望的。</p>
<p>通过调用<code>rand.Seed()</code>方法并传入一个不同的种子值，我们可以改变随机数生成器的起始点，从而产生不同的随机数序列。通常情况下，我们会使用当前时间的纳秒级时间戳作为种子，以确保每次运行程序时都能生成不同的随机数序列。</p>
<p>在代码中，<code>rand.Seed(1000)</code>将种子设置为固定值1000，因此后续生成的随机数序列将始终相同。而<code>rand.Seed(time.Now().UnixNano())</code>使用当前时间的纳秒级时间戳作为种子，可以产生不同的随机数序列。</p>
<p>但是<em><strong>自从Go 1.2 0以来,rand.Seed就已经被弃用了</strong></em>！</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>函数与defer</title>
    <url>/2023/06/04/Go/8/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h2><p>函数是执行特定任务的代码块。</p>
<h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><p>go 语言至少有一个 main 函数</p>
<p>语法格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(parametername type1, parametername type2)</span></span> (output1 type1, output2 type2) &#123;</span><br><span class="line"><span class="comment">//这里是处理逻辑代码</span></span><br><span class="line"><span class="comment">//返回多个值</span></span><br><span class="line"><span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>func：函数由 func 开始声明</li>
<li>funcName：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parametername type：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>output1 type1, output2 type2：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>上面返回值声明了两个变量 output1 和 output2，如果你不想声明也可以，直接就两个类型。</li>
<li>如果只有一个返回值且不声明返回值变量，那么你可以省略包括返回值的括号（即一个返回值可以不声明返回类型）</li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<h2 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, k <span class="type">string</span>)</span></span> (v <span class="type">string</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	v, ok = m[k]</span><br><span class="line">	<span class="keyword">return</span> v, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res := add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(res) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">	v, ok := exists(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>&#125;, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">	fmt.Println(v, ok) <span class="comment">// A True</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">A true</span><br></pre></td></tr></table></figure>

<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="参数的使用"><a href="#参数的使用" class="headerlink" title="参数的使用"></a>参数的使用</h3><p>形式参数：定义函数时，用于接收外部传入的数据，叫做形式参数，简称形参。</p>
<p>实际参数：调用函数时，传给形参的实际的数据，叫做实际参数，简称实参。</p>
<p>函数调用：</p>
<p> A：函数名称必须匹配</p>
<p> B：实参与形参必须一一对应：顺序，个数，类型</p>
<h3 id="可变参"><a href="#可变参" class="headerlink" title="可变参"></a>可变参</h3><p>Go 函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(arg ...<span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>arg ...int</code> 告诉 Go 这个函数接受不定数量的参数。注意，这些参数的类型全部是 int。在函数体中，变量 arg 是一个 int 的 slice：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arg &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;And the number is: %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>go 语言函数的参数也是存在<strong>值传递</strong>和<strong>引用传递</strong></p>
<p>函数运用场景</p>
<p><strong>值传递</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明函数变量 */</span></span><br><span class="line">   getSquareRoot := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用函数 */</span></span><br><span class="line">   fmt.Println(getSquareRoot(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用传递</strong></p>
<p>这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。</p>
<p>只有 add1 函数知道 x 变量所在的地址，才能修改 x 变量的值。所以我们需要将 x 所在地址 &amp; x 传入函数，并将函数的参数的类型由 int 改为 * int，即改为指针类型，才能在函数中修改 x 变量的值。此时参数仍然是按 copy 传递的，只是 copy 的是一个指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// 请注意，</span></span><br><span class="line">	*a = *a + <span class="number">1</span> <span class="comment">// 修改了a的值</span></span><br><span class="line">	<span class="keyword">return</span> *a   <span class="comment">// 返回新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">3</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">	x1 := add1(&amp;x)            <span class="comment">// 调用 add1(&amp;x) 传x的地址</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出 &quot;x+1 = 4&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x =  3</span><br><span class="line">x+1 =  4</span><br><span class="line">x =  4</span><br></pre></td></tr></table></figure>

<ul>
<li>传指针使得多个函数能操作同一个对象。</li>
<li>传指针比较轻量级 (8bytes), 只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话，在每次 copy 上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。</li>
<li><strong>Go 语言中 slice，map 这三种类型的实现机制类似指针</strong>，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变 slice 的长度，则仍需要取地址传递指针）</li>
</ul>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><h3 id="什么是函数的返回值"><a href="#什么是函数的返回值" class="headerlink" title="什么是函数的返回值"></a>什么是函数的返回值</h3><p>一个函数被调用后，返回给调用处的执行结果，叫做函数的返回值。</p>
<p>调用处需要使用变量接收该结果</p>
<h3 id="一个函数可以返回多个值"><a href="#一个函数可以返回多个值" class="headerlink" title="一个函数可以返回多个值"></a>一个函数可以返回多个值</h3><p>一个函数可以没有返回值，也可以有一个返回值，也可以有返回多个值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Mahesh&quot;</span>, <span class="string">&quot;Kumar&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (add <span class="type">int</span>, Multiplied <span class="type">int</span>) &#123;</span><br><span class="line">add = A+B</span><br><span class="line">Multiplied = A*B</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h3><p>_是 Go 中的空白标识符。它可以代替任何类型的任何值。让我们看看这个空白标识符的用法。</p>
<p>比如 rectProps 函数返回的结果是面积和周长，如果我们只要面积，不要周长，就可以使用空白标识符。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectProps</span><span class="params">(length, width <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">float64</span>) &#123;  </span><br><span class="line">    <span class="keyword">var</span> area = length * width</span><br><span class="line">    <span class="keyword">var</span> perimeter = (length + width) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> area, perimeter</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    area, _ := rectProps(<span class="number">10.8</span>, <span class="number">5.6</span>) <span class="comment">// perimeter is discarded</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area %f &quot;</span>, area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>作用域：变量可以使用的范围。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>一个函数内部定义的变量，就叫做局部变量</p>
<p>变量在哪里定义，就只能在哪个范围使用，超出这个范围，我们认为变量就被销毁了。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>一个函数外部定义的变量，就叫做全局变量</p>
<p>所有的函数都可以使用，而且共享这一份数据</p>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>一个函数自己调用自己，就叫做递归调用，一个递归函数一定要有出口，否则会陷入死循环</p>
<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><h2 id="延迟是什么？"><a href="#延迟是什么？" class="headerlink" title="延迟是什么？"></a>延迟是什么？</h2><p>即延迟（defer）语句，延迟语句被用于执行一个函数调用，在这个函数之前，延迟语句返回。</p>
<h2 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h2><p>你可以在函数中添加多个 defer 语句。当函数执行到最后时，这些 defer 语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。</p>
<ul>
<li>如果有很多调用 defer，那么 defer 是采用<code>后进先出</code>模式</li>
<li>在离开所在的方法时，执行（报错的时候也会执行）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后才执行 <code>file.Close()</code></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	b := <span class="number">2</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(b)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finished</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Finished finding largest&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largest</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> finished()    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Started finding largest&quot;</span>)</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">            max = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Largest number in&quot;</span>, nums, <span class="string">&quot;is&quot;</span>, max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">78</span>, <span class="number">109</span>, <span class="number">2</span>, <span class="number">563</span>, <span class="number">300</span>&#125;</span><br><span class="line">    largest(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Started finding largest  </span><br><span class="line">Largest number in [78 109 2 563 300] is 563  </span><br><span class="line">Finished finding largest </span><br></pre></td></tr></table></figure>

<h2 id="延迟方法"><a href="#延迟方法" class="headerlink" title="延迟方法"></a>延迟方法</h2><p>延迟并不仅仅局限于函数。延迟一个方法调用也是完全合法的。让我们编写一个小程序来测试这个。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	firstName <span class="type">string</span></span><br><span class="line">	lastName  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> fullName() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s %s&quot;</span>, p.firstName, p.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := person&#123;</span><br><span class="line">		firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">		lastName:  <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> p.fullName()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Welcome &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Welcome John Smith </span><br></pre></td></tr></table></figure>

<h2 id="延迟参数"><a href="#延迟参数" class="headerlink" title="延迟参数"></a>延迟参数</h2><p>延迟函数的参数在执行延迟语句时被执行，而不是在执行实际的函数调用时执行。</p>
<p>让我们通过一个例子来理解这个问题。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printA</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a in deferred function&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">5</span></span><br><span class="line">    <span class="keyword">defer</span> printA(a)</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a before deferred function call&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value of a before deferred function call 10 </span><br><span class="line">value of a in deferred function 5 </span><br></pre></td></tr></table></figure>

<h2 id="堆栈的推迟"><a href="#堆栈的推迟" class="headerlink" title="堆栈的推迟"></a>堆栈的推迟</h2><p>当一个函数有多个延迟调用时，它们被添加到一个堆栈中，并在 Last In First Out（LIFO）后进先出的顺序中执行。</p>
<p>编写一个小程序，它使用一堆 defers 打印一个字符串。示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    name := <span class="string">&quot;Naveen&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Orignal String: %s\n&quot;</span>, <span class="type">string</span>(name))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Reversed String: &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">rune</span>(name) &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%c&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>在 Go 语言中，<code>rune</code> 是一个整数类型别名，用于表示 Unicode 字符。它实际上是一个 32 位的整数，可以存储任何 Unicode 码点的值。在 Go 中，字符串是由一系列的 Unicode 字符组成的。每个 Unicode 字符可以由一个或多个字节表示。使用 <code>rune </code>类型，我们可以按字符而不是字节来处理字符串。<code>rune </code>类型的主要作用是允许我们在字符串中按字符进行迭代、索引和操作。当我们需要遍历字符串中的每个字符时，特别是在涉及多字节字符（如中文、日文或特殊符号）的情况下，使用<code>rune</code> 类型可以确保正确处理每个字符。在上面的代码示例中，我们使用 <code>[]rune(name)</code> 将字符串 <code>name</code> 转换为一个 <code>rune</code> 切片，以便我们可以按字符迭代处理它。这样可以确保逆序打印字符串中的每个字符，而不仅仅是按字节逆序打印。</p>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Orignal String: Naveen </span><br><span class="line">Reversed String: neevaN </span><br></pre></td></tr></table></figure>

<h2 id="defer-注意点"><a href="#defer-注意点" class="headerlink" title="defer 注意点"></a>defer 注意点</h2><p>defer 函数：<br>当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。<br>当执行外围函数中的 return 语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。<br>当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数。</p>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>指针与结构体</title>
    <url>/2023/06/05/Go/9/</url>
    <content><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针的概念"><a href="#指针的概念" class="headerlink" title="指针的概念"></a>指针的概念</h2><p>指针是存储另一个变量的内存地址的变量。</p>
<p>我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。</p>
<p>一个指针变量可以指向任何一个值的内存地址。</p>
<h2 id="获取变量的地址"><a href="#获取变量的地址" class="headerlink" title="获取变量的地址"></a>获取变量的地址</h2><p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span>   </span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;变量的地址: %x\n&quot;</span>, &amp;a  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量的地址: 20818a220</span><br></pre></td></tr></table></figure>

<h2 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h2><p>声明指针，*T是指针变量的类型，它指向T类型的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 指向整型*/</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="type">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;a 变量的地址是: %x\n&quot;</span>, &amp;a  )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;ip 变量的存储地址: %x\n&quot;</span>, ip )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a 变量的地址是: <span class="number">20818</span>a220</span><br><span class="line">ip 变量的存储地址: <span class="number">20818</span>a220</span><br><span class="line">*ip 变量的值: <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> name <span class="type">int8</span></span><br><span class="line"><span class="keyword">type</span> first <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">	b <span class="type">bool</span></span><br><span class="line">	name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = first&#123;<span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> b *first = &amp;a</span><br><span class="line">	fmt.Println(a.b, a.a, a.name, &amp;a, b.a, &amp;b, (*b).a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false 1 2 &amp;&#123;1 false 2&#125; 1 0xc042068018 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取指针地址在指针变量前加&amp;的方式</p>
</blockquote>
<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p><strong>Go 空指针</strong><br>当一个指针被定义后没有分配到任何变量时，它的值为 nil。<br>nil 指针也称为空指针。<br>nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。<br>一个指针变量通常缩写为 ptr。</p>
<p>空指针判断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr != <span class="literal">nil</span>)     <span class="comment">/* ptr 不是空指针 */</span></span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">nil</span>)    <span class="comment">/* ptr 是空指针 */</span></span><br></pre></td></tr></table></figure>

<h2 id="获取指针的值"><a href="#获取指针的值" class="headerlink" title="获取指针的值"></a>获取指针的值</h2><p>获取一个指针意味着访问指针指向的变量的值。语法是：*a</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    a := &amp;b</span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of b is&quot;</span>, *a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作指针改变变量的数值"><a href="#操作指针改变变量的数值" class="headerlink" title="操作指针改变变量的数值"></a>操作指针改变变量的数值</h2><p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    a := &amp;b</span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of b is&quot;</span>, *a)</span><br><span class="line">    *a++</span><br><span class="line">    fmt.Println(<span class="string">&quot;new value of b is&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address of b is 0x1040a124  </span><br><span class="line">value of b is 255  </span><br><span class="line">new value of b is 256  </span><br></pre></td></tr></table></figure>

<h2 id="使用指针传递函数的参数"><a href="#使用指针传递函数的参数" class="headerlink" title="使用指针传递函数的参数"></a>使用指针传递函数的参数</h2><p>示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(val *<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    *val = <span class="number">55</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">58</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a before function call is&quot;</span>,a)</span><br><span class="line">    b := &amp;a</span><br><span class="line">    change(b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a after function call is&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value of a before function call is 58  </span><br><span class="line">value of a after function call is 55  </span><br></pre></td></tr></table></figure>

<p><strong>不要将一个指向数组的指针传递给函数。使用切片。</strong></p>
<p>假设我们想对函数内的数组进行一些修改，并且对调用者可以看到函数内的数组所做的更改。一种方法是将一个指向数组的指针传递给函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    (*arr)[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[90 90 91]</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[90 90 91]</span><br></pre></td></tr></table></figure>

<p><strong>虽然将指针传递给一个数组作为函数的参数并对其进行修改，但这并不是实现这一目标的惯用方法。我们有切片。</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(sls []<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sls[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(a[:])</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[90 90 91]</span><br></pre></td></tr></table></figure>



<p>Go不支持指针算法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">b := [...]<span class="type">int</span>&#123;<span class="number">109</span>, <span class="number">110</span>, <span class="number">111</span>&#125;</span><br><span class="line">p := &amp;b</span><br><span class="line">p++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nvalid operation: p++ (non-numeric type *[3]int)</p>
</blockquote>
<p><strong>指针数组</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX <span class="type">int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   a := []<span class="type">int</span>&#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">200</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; MAX; i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, a[i] )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>有一种情况，我们可能需要保存数组，这样我们就需要使用到指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX <span class="type">int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> ptr [MAX]*<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; MAX; i++ &#123;</span><br><span class="line">		ptr[i] = &amp;a[i] <span class="comment">/* 整数地址赋值给指针数组 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; MAX; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, *ptr[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<h2 id="指针的指针"><a href="#指针的指针" class="headerlink" title="指针的指针"></a>指针的指针</h2><p><strong>指针的指针</strong></p>
<p>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr **<span class="type">int</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> ptr *<span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> pptr **<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   a = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指针 ptr 地址 */</span></span><br><span class="line">   ptr = &amp;a</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指向指针 ptr 地址 */</span></span><br><span class="line">   pptr = &amp;ptr</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 获取 pptr 的值 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;变量 a = %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;指针变量 *ptr = %d\n&quot;</span>, *ptr )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;指向指针的指针变量 **pptr = %d\n&quot;</span>, **pptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量 a = 3000</span><br><span class="line">指针变量 *ptr = 3000</span><br><span class="line">指向指针的指针变量 **pptr = 3000</span><br></pre></td></tr></table></figure>

<p><strong>指针作为函数参数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span>= <span class="number">200</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 b 的值 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用函数用于交换值</span></span><br><span class="line"><span class="comment">   * &amp;a 指向 a 变量的地址</span></span><br><span class="line"><span class="comment">   * &amp;b 指向 b 变量的地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   swap(&amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保存 x 地址的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 赋值给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 赋值给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">交换前 a 的值 : 100</span><br><span class="line">交换前 b 的值 : 200</span><br><span class="line">交换后 a 的值 : 200</span><br><span class="line">交换后 b 的值 : 100</span><br></pre></td></tr></table></figure>

<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="什么是结构体"><a href="#什么是结构体" class="headerlink" title="什么是结构体"></a>什么是结构体</h2><p>Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。<br>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</p>
<h2 id="结构体的定义和初始化"><a href="#结构体的定义和初始化" class="headerlink" title="结构体的定义和初始化"></a>结构体的定义和初始化</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦定义了结构体类型，它就能用于变量的声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初始化结构体</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.按照顺序提供初始化值</span></span><br><span class="line">P := person&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line"><span class="comment">// 2.通过field:value的方式初始化，这样可以任意顺序</span></span><br><span class="line">P := person&#123;age:<span class="number">24</span>, name:<span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 3.new方式,未设置初始值的，会赋予类型的默认初始值</span></span><br><span class="line">p := <span class="built_in">new</span>(person)</span><br><span class="line">p.age=<span class="number">24</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体的访问"><a href="#结构体的访问" class="headerlink" title="结构体的访问"></a>结构体的访问</h2><p>访问结构体成员(访问结构的各个字段)</p>
<p>通过点.操作符用于访问结构的各个字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="type">string</span></span><br><span class="line">   author <span class="type">string</span></span><br><span class="line">   subject <span class="type">string</span></span><br><span class="line">   book_id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* 声明 Book2 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 title : %s\n&quot;</span>, Book1.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 author : %s\n&quot;</span>, Book1.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 subject : %s\n&quot;</span>, Book1.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 1 book_id : %d\n&quot;</span>, Book1.book_id)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 title : %s\n&quot;</span>, Book2.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 author : %s\n&quot;</span>, Book2.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 subject : %s\n&quot;</span>, Book2.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book 2 book_id : %d\n&quot;</span>, Book2.book_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Book 1 title : Go 语言</span><br><span class="line">Book 1 author : www.runoob.com</span><br><span class="line">Book 1 subject : Go 语言教程</span><br><span class="line">Book 1 book_id : 6495407</span><br><span class="line">Book 2 title : Python 教程</span><br><span class="line">Book 2 author : www.runoob.com</span><br><span class="line">Book 2 subject : Python 语言教程</span><br><span class="line">Book 2 book_id : 6495700</span><br></pre></td></tr></table></figure>

<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>指针指向一个结构体，也可以创建指向结构的指针。</p>
<p><strong>结构体指针</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br></pre></td></tr></table></figure>

<p>以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>

<p>使用结构体指针访问结构体成员，使用 “.” 操作符</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer.title;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="type">string</span></span><br><span class="line">   author <span class="type">string</span></span><br><span class="line">   subject <span class="type">string</span></span><br><span class="line">   book_id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* Declare Book1 of type Book */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* Declare Book2 of type Book */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   printBook(&amp;Book1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   printBook(&amp;Book2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book *Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Book title : Go 语言</span><br><span class="line">Book author : www.runoob.com</span><br><span class="line">Book subject : Go 语言教程</span><br><span class="line">Book book_id : 6495407</span><br><span class="line">Book title : Python 教程</span><br><span class="line">Book author : www.runoob.com</span><br><span class="line">Book subject : Python 语言教程</span><br><span class="line">Book book_id : 6495700</span><br></pre></td></tr></table></figure>

<p>结构体实例化也可以是这样的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Books)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;data&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, Books&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>在<code>Books</code>类型上定义了一个<code>String</code>方法。这个方法具有一个接收者<code>(s Books)</code>，表示它是<code>Books</code>类型的一个实例方法。这个方法返回一个字符串<code>&quot;data&quot;</code>。<code>Books&#123;&#125;</code>创建了一个<code>Books</code>类型的实例，然后通过<code>%v</code>打印输出。由于<code>Books</code>类型实现了<code>String</code>方法，该方法将被调用，返回字符串<code>&quot;data&quot;</code>。</p>
<h2 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h2><p><strong>结构体的匿名字段</strong></p>
<p>可以用字段来创建结构，这些字段只包含一个没有字段名的类型。这些字段被称为匿名字段。</p>
<p>在类型中，使用不写字段名的方式，使用另一个类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们初始化一个学生</span></span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="number">120</span>&#125;, <span class="string">&quot;Computer Science&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 我们访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His name is &quot;</span>, mark.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is &quot;</span>, mark.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is &quot;</span>, mark.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改对应的备注信息</span></span><br><span class="line">    mark.speciality = <span class="string">&quot;AI&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark changed his speciality&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改他的年龄信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark become old&quot;</span>)</span><br><span class="line">    mark.age = <span class="number">46</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is&quot;</span>, mark.age)</span><br><span class="line">    <span class="comment">// 修改他的体重信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark is not an athlet anymore&quot;</span>)</span><br><span class="line">    mark.weight += <span class="number">60</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is&quot;</span>, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">His name is  Mark</span><br><span class="line">His age is  25</span><br><span class="line">His weight is  120</span><br><span class="line">His speciality is  Computer Science</span><br><span class="line">Mark changed his speciality</span><br><span class="line">His speciality is  AI</span><br><span class="line">Mark become old</span><br><span class="line">His age is 46</span><br><span class="line">Mark is not an athlet anymore</span><br><span class="line">His weight is 180</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以使用”.”的方式进行调用匿名字段中的属性值</p>
<p>实际就是字段的继承</p>
<p>其中可以将匿名字段理解为字段名和字段类型都是同一个</p>
<p>基于上面的理解，所以可以<code>mark.Human = Human&#123;&quot;Marcus&quot;, 55, 220&#125; </code>和<code>mark.Human.age = 46</code></p>
<p>若存在匿名字段中的字段与非匿名字段名字相同，则最外层的优先访问，就近原则</p>
</blockquote>
<p>通过匿名访问和修改字段相当的有用，但是不仅仅是struct字段哦，所有的内置类型和自定义类型都是可以作为匿名字段的。</p>
<h2 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h2><p>嵌套的结构体<br>一个结构体可能包含一个字段，而这个字段反过来就是一个结构体。这些结构被称为嵌套结构。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;  </span><br><span class="line">    city, state <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    p.name = <span class="string">&quot;Naveen&quot;</span></span><br><span class="line">    p.age = <span class="number">50</span></span><br><span class="line">    p.address = Address &#123;</span><br><span class="line">        city: <span class="string">&quot;Chicago&quot;</span>,</span><br><span class="line">        state: <span class="string">&quot;Illinois&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Name:&quot;</span>, p.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Age:&quot;</span>,p.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>,p.address.city)</span><br><span class="line">    fmt.Println(<span class="string">&quot;State:&quot;</span>,p.address.state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提升字段"><a href="#提升字段" class="headerlink" title="提升字段"></a>提升字段</h2><p>在结构体中属于匿名结构体的字段称为提升字段，因为它们可以被访问，就好像它们属于拥有匿名结构字段的结构一样。理解这个定义是相当复杂的。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;  </span><br><span class="line">    city, state <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">    address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    p.name = <span class="string">&quot;Naveen&quot;</span></span><br><span class="line">    p.age = <span class="number">50</span></span><br><span class="line">    p.Address = Address&#123;</span><br><span class="line">        city:  <span class="string">&quot;Chicago&quot;</span>,</span><br><span class="line">        state: <span class="string">&quot;Illinois&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Name:&quot;</span>, p.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Age:&quot;</span>, p.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>, p.city) <span class="comment">//city is promoted field</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;State:&quot;</span>, p.state) <span class="comment">//state is promoted field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name: Naveen  </span><br><span class="line">Age: 50  </span><br><span class="line">City: Chicago  </span><br><span class="line">State: Illinois</span><br></pre></td></tr></table></figure>

<h2 id="导出结构体和字段"><a href="#导出结构体和字段" class="headerlink" title="导出结构体和字段"></a>导出结构体和字段</h2><p>如果结构体类型以大写字母开头，那么它是一个导出类型，可以从其他包访问它。类似地，如果结构体的字段以大写开头，则可以从其他包访问它们。</p>
<p>示例代码：</p>
<p>1.在computer目录下，创建文件spec.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> computer</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Spec <span class="keyword">struct</span> &#123; <span class="comment">//exported struct  </span></span><br><span class="line">    Maker <span class="type">string</span> <span class="comment">//exported field</span></span><br><span class="line">    model <span class="type">string</span> <span class="comment">//unexported field</span></span><br><span class="line">    Price <span class="type">int</span> <span class="comment">//exported field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建main.go 文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;structs/computer&quot;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> spec computer.Spec</span><br><span class="line">    spec.Maker = <span class="string">&quot;apple&quot;</span></span><br><span class="line">    spec.Price = <span class="number">50000</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Spec:&quot;</span>, spec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spec: &#123;apple  50000&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h2><p>结构体是值类型，如果每个字段具有可比性，则是可比较的。如果它们对应的字段相等，则认为两个结构体变量是相等的。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> name <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    name1 := name&#123;<span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;Jobs&quot;</span>&#125;</span><br><span class="line">    name2 := name&#123;<span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;Jobs&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> name1 == name2 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name1 and name2 are equal&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name1 and name2 are not equal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    name3 := name&#123;firstName:<span class="string">&quot;Steve&quot;</span>, lastName:<span class="string">&quot;Jobs&quot;</span>&#125;</span><br><span class="line">    name4 := name&#123;&#125;</span><br><span class="line">    name4.firstName = <span class="string">&quot;Steve&quot;</span></span><br><span class="line">    <span class="keyword">if</span> name3 == name4 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name3 and name4 are equal&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name3 and name4 are not equal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name1 and name2 are equal  </span><br><span class="line">name3 and name4 are not equal  </span><br></pre></td></tr></table></figure>

<p><strong>如果结构变量包含的字段是不可比较的，那么结构变量是不可比较的</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> image <span class="keyword">struct</span> &#123;  </span><br><span class="line">    data <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    image1 := image&#123;data: <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">155</span>,</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    image2 := image&#123;data: <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">155</span>,</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    <span class="keyword">if</span> image1 == image2 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;image1 and image2 are equal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invalid operation: image1 == image2 (struct containing map[int]int cannot be compared)</code></p>
<h2 id="结构体作为函数的参数"><a href="#结构体作为函数的参数" class="headerlink" title="结构体作为函数的参数"></a>结构体作为函数的参数</h2><p>结构体作为函数参数使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="type">string</span></span><br><span class="line">   author <span class="type">string</span></span><br><span class="line">   subject <span class="type">string</span></span><br><span class="line">   book_id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line">   <span class="keyword">var</span> Book2 Books        <span class="comment">/* 声明 Book2 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 1 描述 */</span></span><br><span class="line">   Book1.title = <span class="string">&quot;Go 语言&quot;</span></span><br><span class="line">   Book1.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book1.subject = <span class="string">&quot;Go 语言教程&quot;</span></span><br><span class="line">   Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* book 2 描述 */</span></span><br><span class="line">   Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">   Book2.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">   Book2.subject = <span class="string">&quot;Python 语言教程&quot;</span></span><br><span class="line">   Book2.book_id = <span class="number">6495700</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">   printBook(Book1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">   printBook(Book2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name     <span class="type">string</span></span><br><span class="line">	password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> checkPassword(password <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> u.password == password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> resetPassword(password <span class="type">string</span>) &#123;</span><br><span class="line">	u.password = password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := user&#123;name: <span class="string">&quot;wang&quot;</span>, password: <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">	a.resetPassword(<span class="string">&quot;2048&quot;</span>)</span><br><span class="line">	fmt.Println(a.checkPassword(<span class="string">&quot;2048&quot;</span>)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>make、new操作</strong></p>
<p>make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。<br>内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：new返回指针</p>
<p>内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值。make返回初始化后的（非零）值。</p>
<ul>
<li><code>new</code>用于任何类型的内存分配，返回的是类型的指针，指向新分配的零值内存空间。</li>
<li><code>make</code>仅用于切片、映射和通道的内存分配，返回的是经过初始化后的非零值。</li>
</ul>
<h1 id="指针与结构体举例"><a href="#指针与结构体举例" class="headerlink" title="指针与结构体举例"></a>指针与结构体举例</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name     <span class="type">string</span></span><br><span class="line">	password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := user&#123;name: <span class="string">&quot;wang&quot;</span>, password: <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">	b := user&#123;<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">	c := user&#123;name: <span class="string">&quot;wang&quot;</span>&#125;</span><br><span class="line">	c.password = <span class="string">&quot;1024&quot;</span></span><br><span class="line">	<span class="keyword">var</span> d user</span><br><span class="line">	d.name = <span class="string">&quot;wang&quot;</span></span><br><span class="line">	d.password = <span class="string">&quot;1024&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(a, b, c, d)                 <span class="comment">// &#123;wang 1024&#125; &#123;wang 1024&#125; &#123;wang 1024&#125; &#123;wang 1024&#125;</span></span><br><span class="line">	fmt.Println(checkPassword(a, <span class="string">&quot;haha&quot;</span>))   <span class="comment">// false</span></span><br><span class="line">	fmt.Println(checkPassword2(&amp;a, <span class="string">&quot;haha&quot;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPassword</span><span class="params">(u user, password <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> u.password == password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPassword2</span><span class="params">(u *user, password <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> u.password == password</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;wang 1024&#125; &#123;wang 1024&#125; &#123;wang 1024&#125; &#123;wang 1024&#125;</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>大二自学</tag>
      </tags>
  </entry>
  <entry>
    <title>电大软件测试～第一次作业</title>
    <url>/2023/05/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/test1/</url>
    <content><![CDATA[<h2 id="第一次作业及参考答案"><a href="#第一次作业及参考答案" class="headerlink" title="第一次作业及参考答案"></a>第一次作业及参考答案</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>针对电子科技大学信息门户的“密码找回”界面的邮箱输入域进行验证， 采用等价划分法设计相应的测试用例，包括尽量多的无效等价类。</p>
<p>答:</p>
<p>有效等价类如下：</p>
<blockquote>
<p>(1)邮箱输入学符串格式<u>***@uestc.edu.cn</u>或<u>***@UESTC.EDU.CN</u>(*为字母或数字)</p>
</blockquote>
<p>无效等价类:</p>
<blockquote>
<p>(2)*中带有非字母或数字的其它字符</p>
<p>(3)邮箱输入的字符串中缺少‘@’字符</p>
<p>(4)邮箱输入的字符串中有两个或多个‘@’字符</p>
<p>(5)邮箱输入字符串中‘@’字符后不是标准的域名字段</p>
</blockquote>
<p>测试用例：</p>
<table>
<thead>
<tr>
<th align="left">测试用例编号</th>
<th>测试用例</th>
<th>覆盖等价类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td><a href="mailto:&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x40;&#117;&#x65;&#x73;&#x74;&#x63;&#46;&#101;&#x64;&#x75;&#46;&#x63;&#x6e;">&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x40;&#117;&#x65;&#x73;&#x74;&#x63;&#46;&#101;&#x64;&#x75;&#46;&#x63;&#x6e;</a></td>
<td>(1)</td>
</tr>
<tr>
<td align="left">2</td>
<td>#<a href="mailto:&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#x40;&#117;&#101;&#115;&#x74;&#99;&#46;&#101;&#100;&#117;&#x2e;&#x63;&#x6e;">&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#x40;&#117;&#101;&#115;&#x74;&#99;&#46;&#101;&#100;&#117;&#x2e;&#x63;&#x6e;</a></td>
<td>(2)</td>
</tr>
<tr>
<td align="left">3</td>
<td>exampleuestc.edu.cn</td>
<td>(3)</td>
</tr>
<tr>
<td align="left">4</td>
<td>example@@uestc.edu.cn</td>
<td>(4)</td>
</tr>
<tr>
<td align="left">5</td>
<td>example@domaincom</td>
<td>(5)</td>
</tr>
</tbody></table>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>综合运用边界值方法和等价类方法，针对三角形问题设计相应的测试用例。假定输入三个整数（a、b、c）作为边，分别满足一般三角形、等腰三角形和等边三角形。</p>
<p>1）判断一般三角形的有效等价类是什么? 判断一般三角形的无效等价类是什么?</p>
<p>2）判断等腰三角形的有效等价类是什么? 判断等腰三角形的无效等价类是什么?</p>
<p>3）判断等边三角形的有效等价类是什么? 判断等边三角形的无效等价类是什么?</p>
<p>答：</p>
<p>三角形判断条件如下：</p>
<blockquote>
<p>1)三角形的边长均大于0</p>
<p>2)构成一般三角形的条件：任意两边之和大于第三边</p>
<p>3)构成等腰三角形的条件：任意两边相等</p>
<p>4)构成等腰三角形的条件：三条边都相等</p>
</blockquote>
<p>(1)判断一般三角形的有效等价类与边界值规则设计：</p>
<blockquote>
<p>(a≥0)∧(b≥0)∧(c≥0)∧((a+b)&gt;c)∧((a+c)&gt;b)∧((b+c)&gt;a)</p>
</blockquote>
<p>判断一般三角形的无效等价类与边界值规则设计：</p>
<blockquote>
<p>①(a≥0)∧(b≥0)∧(c≥0)∧(((a+b)≤c)∨((a+c)≤b)∨((b+c)≤a))</p>
<p>②(a≤0)∨(b≤0)∨(c≤0)</p>
</blockquote>
<p>(2)判断等腰三角形的有效等价类与边界值规则设计：</p>
<blockquote>
<p>(a≥0)∧(b≥0)∧(c≥0)∧((a+b)&gt;c)∧((a+c)&gt;b)∧((b+c)&gt;a)∧((a&#x3D;b)∨(b&#x3D;c)∨(a&#x3D;c))</p>
</blockquote>
<p>判断等腰三角形的无效等价类与边界值规则设计：</p>
<blockquote>
<p>①(a!&#x3D;b)∧(b!&#x3D;c)∧(c!&#x3D;a) </p>
<p>②(a≤0)∨(b≤0)∨(c≤0)</p>
</blockquote>
<p>(3)判断等边三角形的有效等价类与边界值规则设计：</p>
<blockquote>
<p>(a≥0)∧(b≥0)∧(c≥0)∧((a+b)&gt;c)∧((a+c)&gt;b)∧((b+c)&gt;a)∧(a&#x3D;b&#x3D;c)</p>
</blockquote>
<p>判断等边三角形的无效等价类与边界值规则设计：</p>
<blockquote>
<p>①(a!&#x3D;b)</p>
<p>②(a≤0)∨(b≤0)∨(c≤0)</p>
</blockquote>
<p>测试用例</p>
<table>
<thead>
<tr>
<th>测试用例编号</th>
<th>测试用例输入(a,b,c)</th>
<th>预期结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(5,6,8)</td>
<td>一般三角形</td>
</tr>
<tr>
<td>2</td>
<td>(5,6,5)</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>3</td>
<td>(5,5,5)</td>
<td>等边三角形</td>
</tr>
<tr>
<td>4</td>
<td>(5,0,5)</td>
<td>非三角形</td>
</tr>
<tr>
<td>5</td>
<td>(2,2,5)</td>
<td>非三角形</td>
</tr>
</tbody></table>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>系统的年、月、日数据由Y、M、D单元来存储相应值，若要测试NextData（Y,M,D）函数，采用判定表方法设计相应的测试用例。</p>
<p>答：</p>
<p>被测函数功能：该程序输出为输入日期的下一个日期。</p>
<p>例如：输入为2023年4月2日，函数输出为2023年4月3日。</p>
<p>函数输入变量Y，M，D，均为正整数，并满足如下条件：</p>
<p>1）1900≤Y≤2100</p>
<p>2）1≤M≤12</p>
<p>3）1≤D≤31</p>
<p>4）能被 400 整除，或者能被4整除但不能 100 整除的部是闰年(366 天)，其余的年份均为平年(365 天)</p>
<table>
<thead>
<tr>
<th>输入参数</th>
<th>有效等价类</th>
<th>无效等价类</th>
</tr>
</thead>
<tbody><tr>
<td>Y</td>
<td>1900≤Y≤2100，Y1闰年，Y2平年</td>
<td>＜1900，＞2100，非正整数，其他符号</td>
</tr>
<tr>
<td>M</td>
<td>1≤M≤12，M1{1,3,5,7,8,10}，M2{4,6,9,11}，M3{2}，M4{12}</td>
<td>&lt;1，&gt;12，非正整数，其他符号</td>
</tr>
<tr>
<td>D</td>
<td>1≤D≤31，D1{1,27}，D2{28}，D3{29}，D4{30}，D5{31}</td>
<td>&lt;1，&gt;31，D6，非正整数，其他符号</td>
</tr>
</tbody></table>
<p><em><strong>判定表设计：</strong></em></p>
<p>结果：</p>
<p>1、year,month不变,day+1</p>
<p>2、year不变,month+1,day&#x3D;1</p>
<p>3、year+1,month&#x3D;1,day&#x3D;1</p>
<p>4、错误的输入</p>
<table>
<thead>
<tr>
<th>用例</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>Y</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
<td>Y1</td>
</tr>
<tr>
<td>M</td>
<td>M3</td>
<td>M3</td>
<td>M3</td>
<td>M1</td>
<td>M1</td>
<td>M1</td>
<td>M2</td>
<td>M2</td>
<td>M2</td>
<td>M4</td>
<td>M4</td>
<td>M4</td>
</tr>
<tr>
<td>D</td>
<td>D3</td>
<td>D2,D1</td>
<td>D4,D5</td>
<td>D5</td>
<td>D1,D2,D3,D4</td>
<td>D6</td>
<td>D4</td>
<td>D5,D6</td>
<td>D1,D2,D3</td>
<td>D5</td>
<td>D1,D2,D3,D4</td>
<td>D6</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>用例</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
<th>21</th>
<th>22</th>
<th>23</th>
<th>24</th>
</tr>
</thead>
<tbody><tr>
<td>Y</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
<td>Y2</td>
</tr>
<tr>
<td>M</td>
<td>M3</td>
<td>M3</td>
<td>M3</td>
<td>M1</td>
<td>M1</td>
<td>M1</td>
<td>M2</td>
<td>M2</td>
<td>M2</td>
<td>M4</td>
<td>M4</td>
<td>M4</td>
</tr>
<tr>
<td>D</td>
<td>D2</td>
<td>D1</td>
<td>D3,D4,D5</td>
<td>D5</td>
<td>D1,D2,D3,D4</td>
<td>D6</td>
<td>D4</td>
<td>D5,D6</td>
<td>D1,D2,D3</td>
<td>D5</td>
<td>D5</td>
<td>D6</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
</tbody></table>
<p>测试用例如下：</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>Y</th>
<th>M</th>
<th>D</th>
<th>预期输出</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2023</td>
<td>4</td>
<td>1</td>
<td>2023,4,2</td>
</tr>
<tr>
<td>2</td>
<td>2023</td>
<td>3</td>
<td>28</td>
<td>2023,3,29</td>
</tr>
<tr>
<td>3</td>
<td>2023</td>
<td>3</td>
<td>29</td>
<td>2023,3,30</td>
</tr>
<tr>
<td>4</td>
<td>2023</td>
<td>3</td>
<td>30</td>
<td>2023,3,31</td>
</tr>
<tr>
<td>5</td>
<td>2023</td>
<td>3</td>
<td>31</td>
<td>2023,4,1</td>
</tr>
<tr>
<td>6</td>
<td>2023</td>
<td>11</td>
<td>28</td>
<td>2023,11,29</td>
</tr>
<tr>
<td>7</td>
<td>2023</td>
<td>11</td>
<td>29</td>
<td>2023,11,30</td>
</tr>
<tr>
<td>8</td>
<td>2023</td>
<td>11</td>
<td>30</td>
<td>2023,12,1</td>
</tr>
<tr>
<td>9</td>
<td>2023</td>
<td>11</td>
<td>31</td>
<td>错误</td>
</tr>
<tr>
<td>10</td>
<td>2023</td>
<td>2</td>
<td>28</td>
<td>2023,3,1</td>
</tr>
<tr>
<td>11</td>
<td>2023</td>
<td>2</td>
<td>29</td>
<td>错误</td>
</tr>
<tr>
<td>12</td>
<td>2023</td>
<td>2</td>
<td>30</td>
<td>错误</td>
</tr>
<tr>
<td>13</td>
<td>2023</td>
<td>2</td>
<td>31</td>
<td>错误</td>
</tr>
<tr>
<td>14</td>
<td>2020</td>
<td>2</td>
<td>28</td>
<td>2020,2,29</td>
</tr>
<tr>
<td>15</td>
<td>2020</td>
<td>2</td>
<td>29</td>
<td>2020,3,1</td>
</tr>
<tr>
<td>16</td>
<td>2020</td>
<td>2</td>
<td>30</td>
<td>错误</td>
</tr>
<tr>
<td>17</td>
<td>2020</td>
<td>2</td>
<td>31</td>
<td>错误</td>
</tr>
<tr>
<td>18</td>
<td>2020</td>
<td>12</td>
<td>28</td>
<td>2020,12,29</td>
</tr>
<tr>
<td>19</td>
<td>2020</td>
<td>12</td>
<td>29</td>
<td>2020,12,30</td>
</tr>
<tr>
<td>20</td>
<td>2020</td>
<td>12</td>
<td>30</td>
<td>2020,12,31</td>
</tr>
<tr>
<td>21</td>
<td>2020</td>
<td>12</td>
<td>31</td>
<td>2021,1,1</td>
</tr>
</tbody></table>
<hr>
<p>个人觉得以上判定表的设计比较复杂🥺，一般很难想到这么详细，我认为下面的判定表比较容易想到🤡</p>
<table>
<thead>
<tr>
<th></th>
<th>序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>条件</td>
<td>正确输入年Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>条件</td>
<td>正确输入月M</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>条件</td>
<td>正确输入日D</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>动作</td>
<td>函数运行成功</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>动作</td>
<td>函数运行失败</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>测试用例表的话可以模仿参考答案书写✍</p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>针对某机构人员管理的业务规则需求：</p>
<p>1）年薪制员工：严重过失，扣年终风险金的4%；过失，扣年终风险金的2%。</p>
<p>2）非年薪制员工：严重过失，扣当月薪资的8%；过失，扣当月薪资的4%。</p>
<p>请绘制出因果图和判定表，并给出相应的测试用例。</p>
<p>答：</p>
<ul>
<li><p>因果分析</p>
<p>原因：</p>
<blockquote>
<p>C1：年薪制员工</p>
<p>C3：严重过失</p>
<p>C3：过失</p>
</blockquote>
<p>结果：</p>
<blockquote>
<p>e1：扣年终风险金的4%</p>
<p>e2：扣年终风险金的2%</p>
<p>e3：扣月薪资的8%</p>
<p>e4：扣月薪资的4%</p>
</blockquote>
</li>
<li><p>因果图设计</p>
<p><img src="https://s2.loli.net/2023/05/31/7xV4hjUMqRTa3ky.png" alt="3HA4ZSM3_6U1BEFKKP_2H5U.png"></p>
</li>
<li><p>判定表设计</p>
<table>
<thead>
<tr>
<th></th>
<th>序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>条件</td>
<td>C1：年薪制员工</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>条件</td>
<td>C3：严重过失</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>条件</td>
<td>C3：过失</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>结果</td>
<td>e1：扣年终风险金的4%</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>结果</td>
<td>e2：扣年终风险金的2%</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>结果</td>
<td>e3：扣月薪资的8%</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>结果</td>
<td>e4：扣月薪资的4%</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>结果</td>
<td>不操作</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>结果</td>
<td>不可能</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>有效等价类测试用例</p>
<table>
<thead>
<tr>
<th>用例</th>
<th>输入数据</th>
<th>预期输出</th>
</tr>
</thead>
<tbody><tr>
<td>TC1</td>
<td>年薪制员工，严重过失</td>
<td>扣年终风险金的4%</td>
</tr>
<tr>
<td>TC2</td>
<td>年薪制员工，过失</td>
<td>扣年终风险金的2%</td>
</tr>
<tr>
<td>TC3</td>
<td>非年薪制员工，严重过失</td>
<td>扣月薪资的8%</td>
</tr>
<tr>
<td>TC4</td>
<td>非年薪制员工，过失</td>
<td>扣月薪资的4%</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>测试一个登录页面在不同浏览器和语言下的功能正确性，其输入条件如下:</p>
<p>1）输入项（账号、密码）</p>
<p>2）浏览器（IE、chrome、FireFox、360）</p>
<p>3）语言（中文、英文）</p>
<p>请问进行完整组合的兼容性测试需要多少个测试用例？采用成对组合的兼容性测试需要多少个测试用例？给出成对组合测试用例表。</p>
<p>答：</p>
<p>完整组合测试有2x2X4x2&#x3D;32 个，成对组合测试需要8个测试用例</p>
<p>成对组合测试用例表</p>
<table>
<thead>
<tr>
<th>用例</th>
<th>账号</th>
<th>密码</th>
<th>浏览器</th>
<th>语言</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>空值</td>
<td>空值</td>
<td>IE</td>
<td>中文</td>
</tr>
<tr>
<td>2</td>
<td>空值</td>
<td>有值</td>
<td>chrome</td>
<td>英文</td>
</tr>
<tr>
<td>3</td>
<td>有值</td>
<td>空值</td>
<td>FireFox</td>
<td>中文</td>
</tr>
<tr>
<td>4</td>
<td>有值</td>
<td>有值</td>
<td>360</td>
<td>英文</td>
</tr>
<tr>
<td>5</td>
<td>空值</td>
<td>空值</td>
<td>360</td>
<td>中文</td>
</tr>
<tr>
<td>6</td>
<td>空值</td>
<td>有值</td>
<td>FireFox</td>
<td>英文</td>
</tr>
<tr>
<td>7</td>
<td>有值</td>
<td>空值</td>
<td>chrome</td>
<td>中文</td>
</tr>
<tr>
<td>8</td>
<td>有值</td>
<td>有值</td>
<td>IE</td>
<td>英文</td>
</tr>
</tbody></table>
<p><em><strong>以上内容来自老师提供的原版答案，如有错误，欢迎批评指正</strong></em>😆</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>电大软件测试～第二次作业</title>
    <url>/2023/05/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/test2/</url>
    <content><![CDATA[<h2 id="第二次作业及参考答案"><a href="#第二次作业及参考答案" class="headerlink" title="第二次作业及参考答案"></a>第二次作业及参考答案</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p> 在一个客户信息查询界面中，输入条件有“姓名”、“身份证号”、“手机”，采用正交表方式设计该界面查询功能的测试用例。</p>
<p>答：</p>
<p>针对本测试有3个输入条件，每个输入有2种取值情况，可以选择L₄(2³)正交表，其正交表值如下表所示：</p>
<table>
<thead>
<tr>
<th>实验数\列号</th>
<th>姓名</th>
<th>身份证号</th>
<th>手机</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>测试用例：</p>
<table>
<thead>
<tr>
<th>测试用例&#x2F;查询条件</th>
<th>姓名</th>
<th>身份证号</th>
<th>手机</th>
</tr>
</thead>
<tbody><tr>
<td>测试用例1</td>
<td>填写</td>
<td>填写</td>
<td>填写</td>
</tr>
<tr>
<td>测试用例2</td>
<td>填写</td>
<td>空</td>
<td>空</td>
</tr>
<tr>
<td>测试用例3</td>
<td>空</td>
<td>填写</td>
<td>空</td>
</tr>
<tr>
<td>测试用例4</td>
<td>空</td>
<td>空</td>
<td>填写</td>
</tr>
</tbody></table>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>根据如下图所示的程序流程图，分别使用语句覆盖测试、判定覆盖测试、条件覆盖测试和路径覆盖测试进行测试用例设计。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/YaGS6fzEgLuwdKp.png"></p>
<p>答：</p>
<p><em><strong>1）语句覆盖</strong></em></p>
<p>设计测试用例，使得被测试程序中的每条可执行语句至少被执行一次。其测试用例表如下所示。</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖语句</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>X&gt;0 AND Y&gt;10;Y&#x3D;Y&#x2F;X;X&lt;-10 OR Y&lt;0</td>
</tr>
<tr>
<td>2</td>
<td>(X,Y)&#x3D;(0,-1)</td>
<td>(X,Y)&#x3D;(0,1)</td>
<td>X&gt;0 AND Y&gt;10;X&lt;-10 OR Y&lt;0;Y&#x3D;-(Y+X)</td>
</tr>
</tbody></table>
<p><em><strong>2）判定覆盖</strong></em></p>
<p>设计测试用例,使得被测试程序中的每个判断的”真”、”假”分支至少被执行一次。设X&gt;0 AND Y&gt;10为判定条件M，X&lt;-10 OR Y&lt;0为判定条件N。<br>设计的判定覆盖测试用例如下表所示。</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖判定条件</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>M为真，N为假</td>
</tr>
<tr>
<td>2</td>
<td>(X,Y)&#x3D;(0,-1)</td>
<td>(X,Y)&#x3D;(0,1)</td>
<td>M为假，N为真</td>
</tr>
</tbody></table>
<p><em><strong>3）条件覆盖</strong></em></p>
<p>设计测试用例,使得被测试程序中分支判断语句中每个条件的可能值至少被满足一次。<br>设</p>
<blockquote>
<p>条件X&gt;0:<br>取真时为T1，取假时为F1<br>条件Y&gt;10:<br>取真时为T2，取假时为F2<br>条件x&lt;-10:<br>取真时为T3，取假时为F3<br>条件Y&lt;0:<br>取真时为T4,取假时为 F4</p>
</blockquote>
<p>设计的条件覆盖测试用例如下表所示。</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖条件</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(X,Y)&#x3D;(1,-1)</td>
<td>(X,Y)&#x3D;(1,0)</td>
<td>T1，F2，F3，T4</td>
</tr>
<tr>
<td>2</td>
<td>(X,Y)&#x3D;(-11,11)</td>
<td>(X,Y)&#x3D;(-11,0)</td>
<td>F1，T2，T3，F4</td>
</tr>
</tbody></table>
<p><em><strong>4）基本路径覆盖</strong></em></p>
<p>设计测试用例,使得被测试程序中的基本路径至少被覆盖一次。依据该程序控制流图计算环路复杂度&#x3D;3（判断节点数目+1）,因此,该程序的基本路径有3条。</p>
<p>设计的基本路径覆盖测试用例如下表所示</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖路径</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(X,Y)&#x3D;(0,0)</td>
<td>(X,Y)&#x3D;(0,0)</td>
<td>ace</td>
</tr>
<tr>
<td>2</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>(X,Y)&#x3D;(1,11)</td>
<td>abce</td>
</tr>
<tr>
<td>3</td>
<td>(X,Y)&#x3D;(-11,1)</td>
<td>(X,Y)&#x3D;(-11,10)</td>
<td>acde</td>
</tr>
<tr>
<td>4</td>
<td>不存在</td>
<td>不存在</td>
<td>abcde</td>
</tr>
</tbody></table>
<p>但是看这篇文章<a href="https://blog.csdn.net/dickdick111/article/details/90478058?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%8E%AF%E5%BD%A2%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-90478058.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187"> 软件测试——程序控制流图，McCabe环形复杂度_根据程序画出控制流图_Dic0k的博客-CSDN博客</a>，按照它的逻辑，环形复杂度应该有5条。（很奇怪）</p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>针对如下样本程序，分析该程序逻辑覆盖测试方法中的语句覆盖、判定覆盖、条件覆盖和基本路径覆盖，并说明哪种方法覆盖率高？为什么？</p>
<p>被测样本程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;start main function:path a...&quot;</span>);</span><br><span class="line">  <span class="type">int</span> A=<span class="number">0</span>,B=<span class="number">0</span>,X=<span class="number">0</span>;</span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">  System.out.println(<span class="string">&quot;输入A：&quot;</span>);  A = s.nextInt();</span><br><span class="line">  System.out.println(<span class="string">&quot;输入B=&quot;</span>);  B = s.nextInt();</span><br><span class="line">  System.out.println(<span class="string">&quot;输入X=&quot;</span>);  X = s.nextInt();</span><br><span class="line">  s.close();  </span><br><span class="line">  <span class="keyword">if</span> (A&gt;<span class="number">1</span> &amp;&amp; B==<span class="number">0</span>) &#123;</span><br><span class="line">	X=X/A;</span><br><span class="line">	System.out.println(<span class="string">&quot;path c&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;path b&quot;</span>);  &#125;</span><br><span class="line">  <span class="keyword">if</span> (A==<span class="number">2</span> || X&gt;<span class="number">1</span>) &#123;</span><br><span class="line">	X=X+<span class="number">1</span>;</span><br><span class="line">	System.out.println(<span class="string">&quot;path e&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;path d&quot;</span>);  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;end main function.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	答：</p>
<p>​	<u><em><strong>注：以下答案只参考了标准答案的一部分</strong></em></u></p>
<p><img src="https://s2.loli.net/2023/05/31/P7NxLnZ9QhsHmyW.png" alt="VF1D1EJ2__LKYS_1_GPGJ5W.png"></p>
<ol>
<li><p>语句覆盖测试</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖路径</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(A,B,X)&#x3D;(2,0,2)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path c，path e，end main function.</td>
<td>ace</td>
</tr>
<tr>
<td>2</td>
<td>(A,B,X)&#x3D;(0,1,1)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path b，path d，end main function.</td>
<td>abd</td>
</tr>
</tbody></table>
</li>
<li><p>判定覆盖测试</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖路径</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(A,B,X)&#x3D;(2,0,2)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path c，path e，end main function.</td>
<td>ace</td>
</tr>
<tr>
<td>2</td>
<td>(A,B,X)&#x3D;(0,1,1)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path b，path d，end main function.</td>
<td>abd</td>
</tr>
</tbody></table>
</li>
<li><p>条件覆盖测试</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖路径</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(A,B,X)&#x3D;(2,0,2)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path c，path e，end main function.</td>
<td>ace</td>
</tr>
<tr>
<td>2</td>
<td>(A,B,X)&#x3D;(0,1,1)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path b，path d，end main function.</td>
<td>abd</td>
</tr>
</tbody></table>
</li>
<li><p>基本路径覆盖测试</p>
<table>
<thead>
<tr>
<th>用例序号</th>
<th>输入数据</th>
<th>预期输出</th>
<th>覆盖路径</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(A,B,X)&#x3D;(2,0,2)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path c，path e，end main function.</td>
<td>ace</td>
</tr>
<tr>
<td>2</td>
<td>(A,B,X)&#x3D;(0,1,1)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path b，path d，end main function.</td>
<td>abd</td>
</tr>
<tr>
<td>3</td>
<td>(A,B,X)&#x3D;(0,1,2)</td>
<td>start main function:path a…，输入A：，输入B&#x3D;，输入X&#x3D;，path b，path e，end main function.</td>
<td>abe</td>
</tr>
</tbody></table>
</li>
</ol>
<p>综上所述，基本路径覆盖测试用的测试用例最多，覆盖的路径也最多，故基本路径覆盖的覆盖率最高。</p>
<p><em><strong>注：<a href="https://blog.csdn.net/The_Azur/article/details/117936347">环形复杂度必定是基本路径个数的上限。</a></strong></em></p>
<p><img src="https://s2.loli.net/2023/05/31/HtDjYwSso3WKVFn.png" alt="Snipaste_2023-05-31_21-48-19.png"></p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>使用PMD代码分析工具针对如下被测程序，找出该程序存在的潜在缺陷，给出结果界面截图，并说明各个缺陷出现的原因。</p>
<p>被测样本程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;start main function:path a...&quot;</span>);</span><br><span class="line">  <span class="type">int</span> A=<span class="number">0</span>,B=<span class="number">0</span>,X=<span class="number">0</span>;</span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">  System.out.println(<span class="string">&quot;输入A：&quot;</span>);  A = s.nextInt();</span><br><span class="line">  System.out.println(<span class="string">&quot;输入B=&quot;</span>);  B = s.nextInt();</span><br><span class="line">  System.out.println(<span class="string">&quot;输入X=&quot;</span>);  X = s.nextInt();</span><br><span class="line">  s.close();  </span><br><span class="line">  <span class="keyword">if</span> (A&gt;<span class="number">1</span> &amp;&amp; B==<span class="number">0</span>) &#123;</span><br><span class="line">	X=X/A;</span><br><span class="line">	System.out.println(<span class="string">&quot;path c&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;path b&quot;</span>);  &#125;</span><br><span class="line">  <span class="keyword">if</span> (A==<span class="number">2</span> || X&gt;<span class="number">1</span>) &#123;</span><br><span class="line">	X=X+<span class="number">1</span>;</span><br><span class="line">	System.out.println(<span class="string">&quot;path e&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;path d&quot;</span>);  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;end main function.&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<p><u><em><strong>注：以下答案只参考了标准答案的一部分</strong></em></u></p>
<p><a href="https://smms.app/image/5I4amZs2cXEldHv" target="_blank"><img src="https://s2.loli.net/2023/05/31/5I4amZs2cXEldHv.jpg" alt="Z__LBIY38___C`L5GCFZSVF.jpg"></a></p>
<p>以下是可能的缺陷（感觉每个人做出来都不一样哈哈哈哈😆）：</p>
<blockquote>
<p>（1）VariableNamingConventions：</p>
<p>​		①变量应以小写字符开头，’A’’B’’X’均以大写字符开头</p>
<p>（2）UseUtilityClass：</p>
<p>​		①所有方法都是静态的，可以考虑使用实用工具类，或添加一个私		有构造函数，或使类抽象来屏蔽这个警告</p>
<p>（3）LocalVariableCouldBeFinal：</p>
<p>​		①局部变量’s’可以声明为final</p>
<p>（4）LocalVaraiableNamingConventions：</p>
<p>​		①局部变量名’A’’B’’X’不匹配’[a-z][a-zA-Z0-9]*’</p>
<p>（5）MethodArgumentCouldBeFinal：</p>
<p>​		①参数’args’未赋值，可以声明为final</p>
<p>（6）CommentRequired：</p>
<p>​		①类注释是必需的</p>
<p>​		②公共方法和构造函数的注释是必需的</p>
<p>（7）OneDeclarationPerLine：</p>
<p>​		①int A&#x3D;0,B&#x3D;0,X&#x3D;0; 每个声明为一行，可以增强代码的可读性</p>
<p>（8）UnusedAssignment：</p>
<p>​		①变量’B’的初始化式从未使用（后被重写）</p>
<p>​		②变量’A’的初始化式从未使用（后被覆盖）</p>
<p>​		③变量’X’的初始化式从未使用（后被覆盖）</p>
<p>​		④ X&#x3D;X+1; 赋给变量’X’的值从未使用过</p>
<p>（9）SystemPrintln：</p>
<p>​		①使用System.out.println</p>
<p>（10）ShortVariable：</p>
<p>​		① Scanner s &#x3D; new Scanner(System.in); 避免使用像s这样名字较		短的变量</p>
<p>​		②避免使用短名称的变量：如A,B,X</p>
<p>（11）DataflowAnomalyAnalysis：</p>
<p>​		①发现变量’A’的’DD’异常</p>
<p>​			int A&#x3D;0,B&#x3D;0,X&#x3D;0;</p>
<p>​			Scanner s &#x3D; new Scanner(System.in);</p>
<p>​		    System.out.println(“输入A：”);A &#x3D; s.nextInt();</p>
<p>​		②发现变量’X’的’DU’异常</p>
<p>​		X&#x3D;X+1;</p>
<p>​		System.out.println(“path e”);</p>
<p>​	} else {</p>
<p>​		System.out.println(“path d”);  }</p>
<p>​		System.out.println(“end main function.”);</p>
<p>​	}</p>
<p>​		③发现变量’X’的’DD’异常</p>
<p>​		int A&#x3D;0,B&#x3D;0,X&#x3D;0;</p>
<p> ​		Scanner s &#x3D; new Scanner(System.in);</p>
<p>​		System.out.println(“输入A：”);  A &#x3D; s.nextInt();</p>
<p>​		 System.out.println(“输入B&#x3D;”);  B &#x3D; s.nextInt();</p>
<p>​        System.out.println(“输入X&#x3D;”);  X &#x3D; s.nextInt();</p>
<p>​		④发现变量’B’的’DD’异常</p>
<p>​		int A&#x3D;0,B&#x3D;0,X&#x3D;0;</p>
<p>​	Scanner s &#x3D; new Scanner(System.in);</p>
<p>​	System.out.println(“输入A：”);  A &#x3D; s.nextInt();</p>
<p>​	System.out.println(“输入B&#x3D;”);  B &#x3D; s.nextInt();</p>
<p>（12）CloseResource：</p>
<p>​		①Scanner s &#x3D; new Scanner(System.in); 确保像InputStream对象		这样的资源在使用后被关闭</p>
</blockquote>
<p>我感觉第四题应该不会考🙂</p>
<p><em><strong>声明：除特殊标注外（综合考虑其他同学的答案），答案均为老师原版答案</strong></em></p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库期末复习</title>
    <url>/2023/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93/db1/</url>
    <content><![CDATA[<h2 id="第一章数据库系统概论"><a href="#第一章数据库系统概论" class="headerlink" title="第一章	数据库系统概论"></a>第一章	数据库系统概论</h2><ul>
<li><p>在数据库管理系统的层次结构中，下面哪个层次负责对数据文件进行操作访问?<br>A.操作界面层	B.语言翻译处理层	C.数据存取层	<strong>D.数据存储层</strong></p>
<p>  根据处理对象的不同，数据库管理系统的层次结构由外至内依次为应用层、语言翻译处理层、数据存取层、数据存储层。</p>
<p>  (1)应用层：是数据库管理系统与终端用户和应用程序的界面，负责处理各种数据库应用，如使用结构化查询语言<a href="https://baike.baidu.com/item/SQL?fromModule=lemma_inlink">SQL</a>发出的事务请求或嵌入通用的<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink">程序设计语言</a>的应用程序对<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93?fromModule=lemma_inlink">数据库</a>的请求。</p>
<p>  (2)语言处理层：由DDL编译器、DML编译器、DCL编译器、查询器等组成，负责完成对<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80?fromModule=lemma_inlink">数据库语言</a>的各类语句进行词法分析、<a href="https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90?fromModule=lemma_inlink">语法分析</a>和<a href="https://baike.baidu.com/item/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90?fromModule=lemma_inlink">语义分析</a>，生成可执行的代码。此外，还负责进行授权检验、视图转换、完整性检查、查询优化等。</p>
<p>  (3)数据存取层：将上层的集合操作转换为对<strong>记录</strong>的操作，包括扫描、排序、查找、插入、删除、修改等，完成数据的存取、路径的维护以及并发控制等任务。</p>
<p>  (4)数据存储层：由文件管理器和缓冲区管理器组成，负责完成数据的页面存储和系统的缓冲区管理等任务，包括打开和关闭文件、读写页面、读写缓冲区、页面淘汰、内外存交换以及外层管理等。</p>
</li>
<li><p>在数据库领域技术中，下面哪种技术可以实现数据集成?<br>A.数据库技术	<strong>B.数据仓库技术</strong>	C.数据挖掘技术	D.商业智能技术</p>
<p>数据仓库 (Data Warehouse) 简称DW，存储大量数据的集成中心。数据仓库的目的是构建面向分析的集成化数据环境，为企业提供决策支持（Decision-Support）。它为企业提供一定的BI（商业智能）能力，指导业务流程改进、监视时间、成本、质量以及控制。数据库挖掘可建立在数据仓库基础上进行数据分析处理。</p>
</li>
<li><p>下面哪种数据库系统应用结构适合银行业务系统?<br>A.集中式结构    B.客户&#x2F;服务器结构	<strong>C.分布式结构</strong>	D.以上结构都可以<br>  分布式数据库的应用场景主要特征是海量并发，所以理论说，业务规模越大，使用分布式数据库的需求也就越迫切。</p>
</li>
<li><p>MySql——应用广泛的开源<strong>关系</strong>数据库管理系统，<em>不是企业级DBMS</em>，PostgreSQL——技术领先的开源<strong>对象-关系</strong>数据库管理系统</p>
</li>
<li><p>下面哪个程序实现PostgreSQL服务器起停控制？pg_ctl</p>
<blockquote>
<p>初始化数据库<br>pg_ctl init<br>启动数据库<br>pg_ctl start<br>关闭数据库<br>pg_ctl stop<br>重启数据库<br>pg_ctl restart </p>
</blockquote>
</li>
<li><p>下面哪类数据库是功能最强大的数据库?<br>A.MySQL	B.PostgreSQL	<strong>C.Oracle Database</strong>	D.SQL Server<br>Oracle Database——甲骨文公司推出的企业级数据库管理系统</p>
</li>
<li><p>SQLite数据库可以在手机中运行</p>
</li>
<li><p>用户程序可以直接访问数据库文件吗？<br>用户程序通常不能直接访问数据库文件。一般来说，用户程序需要通过应用程序向数据库管理系统（DBMS）发送请求，然后由DBMS解析请求并从数据库中检索所需的数据，最后将数据返回给应用程序，以便用户可以使用它们。这样做可以保证数据的安全性和完整性。</p>
</li>
<li><p>NOSQL数据库适用于存储非结构化或半结构化数据的场景。</p>
</li>
<li><p><strong>元数据</strong>（<strong>Metadata</strong>），又称<strong>中介数据</strong>、<strong>中继数据</strong>，为描述<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370?fromModule=lemma_inlink">数据</a>的数据（data about data），主要是描述数据<a href="https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7/1405051?fromModule=lemma_inlink">属性</a>（property）的<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF/111163?fromModule=lemma_inlink">信息</a>，用来支持如指示存储位置、<a href="https://baike.baidu.com/item/%E5%8E%86%E5%8F%B2/360?fromModule=lemma_inlink">历史</a>数据、<a href="https://baike.baidu.com/item/%E8%B5%84%E6%BA%90/9089683?fromModule=lemma_inlink">资源</a>查找、文件记录等功能。业务规则数据在数据库中也是一种元数据。正确</p>
</li>
<li><p>下面哪类数据库应用系统需要使用数据分析处理技术？决策支持</p>
</li>
<li><p>记录（Record）<br>表中的每一行称为一个<strong>记录</strong>，它由若干个字段组成．<br>字段（Field）<br>也称域．表中的每一列称为一个<strong>字段</strong>．每个字段都有相应的描述信息，如数据类型、数据宽度等</p>
</li>
</ul>
<h2 id="第二章数据库关系模型"><a href="#第二章数据库关系模型" class="headerlink" title="第二章	数据库关系模型"></a>第二章	数据库关系模型</h2><p>实体完整性是指关系表的属性组成必须是完整的。错误！！</p>
<p>自然连接是一种等值连接。正确！！</p>
<p>代理键是为了唯一标识关系的不同元组，需要在表单或报表中显示出来。错误！！</p>
<p>关系表：</p>
<blockquote>
<p>表中每行存储实体的一个实例数据表中每列包含实体的一项属性数据表中单元格只能存储单个值<br>不允许有重复的行<br>不允许有重复的列列<br>顺序可任意<br>行顺序可任意</p>
</blockquote>
<p>笛卡尔积：</p>
<p><a href="https://smms.app/image/IGhF634XaVM19PY" target="_blank"><img src="https://s2.loli.net/2023/06/03/IGhF634XaVM19PY.png" ></a></p>
<p>在关系中，可以用来唯一标识元组的属性列，称为<strong>键</strong>(Key)，其它属性列都为非键列。</p>
<p><strong>复合键</strong>(Compound Key)——是指关系中用来唯一标识元组的多列作为键。(学号,课程编号)就是一组复合键。</p>
<p><strong>候选键</strong>(Candidate Key)——关系中可能有多个列均适合作为键，将其中每个都称为候选键。</p>
<p><strong>主键</strong>(Primary key)是关系表中最有代表性的一个候选键。每个关系表中只能定义一个主键。</p>
<p>主键的作用：</p>
<blockquote>
<p>唯一标识关系表的每行（元组)<br>与关联表的外键建立联系，实现关系表之间连接<br>数据库文件使用主键值来组织关系表的数据存储<br>数据库使用主键索引快速检索数据</p>
</blockquote>
<p><strong>代理键</strong>——采用DBMS自动生成的数字序列作为关系表的主键。<br>代理键有什么用途?<br>由DBMS自动生成的数字序列作为主键，可替代复合主键，以便获得更高性能的数据访	问操作处理。</p>
<p>关系模式语句中主键表示方法:关系名（<u>主键属性</u>，属性2，，属性x)</p>
<p><a href="https://smms.app/image/Aipa9Wvl3EJYZHb" target="_blank"><img src="https://s2.loli.net/2023/06/03/Aipa9Wvl3EJYZHb.png" ></a></p>
<p><strong>关系模型</strong>(Relation Model)——是一种基于二维表结构存储数据实体及实体间联系的数据模型。</p>
<p>集合运算操作包括<strong>选择</strong>(select)、<strong>投影</strong>（project)、<strong>连接</strong>（join) 、<strong>交</strong>(intersection）、<strong>并</strong>(union)、<strong>差</strong>(difference）等。<br>专门关系操作包括数据行<strong>插入</strong>(Insert) 、<strong>修改</strong>(Update）、<strong>删除</strong>(Delete）操作。</p>
<p><a href="https://smms.app/image/iPBg21lY8NzprSx" target="_blank"><img src="https://s2.loli.net/2023/06/03/iPBg21lY8NzprSx.png" ></a></p>
<p>以下是老师给的答案，有些许小错误，提供个思路就可以啦~</p>
<p><a href="https://smms.app/image/oT586hL2t3Zcj7f" target="_blank"><img src="https://s2.loli.net/2023/06/03/oT586hL2t3Zcj7f.png" ></a></p>
<p>关系模型完整性是指在关系数据模型中对关系实施的完整性约束。</p>
<p>完整性约束作用:</p>
<blockquote>
<p>消除关系表的元组重复存储</p>
<p>保持关联表的数据一致性</p>
<p>实现业务数据规则</p>
</blockquote>
<p>关系模型完整性约束分类:</p>
<ul>
<li>实体完整性约束</li>
</ul>
<p><strong>实体完整性</strong>是指在关系表中实施的<strong>主键取值约束</strong>，以保证关系表中的每个元组可以被唯	一标识。</p>
<p>实体完整性约束规则:</p>
<p>①每个关系表中的主键属性列都<strong>不允许为空值</strong>(NULL)，否则就不可能标识实体。</p>
<p>②现实世界中的实体是靠主键来标识，<strong>主键取值应该唯一</strong>，并区分关系表中的每个元组。</p>
<ul>
<li>参照完整性约束</li>
</ul>
<p>参照完整性是指关系表之间需要遵守的数据约束，以保证关系之间关联列的数据一致性。</p>
<p><strong>参照完整性</strong>约束规则:若关系R中的外键F与关系S中的主键K相关联，则R中外键F值必须与S中主键K值一致。</p>
<p>外键(Foreign key)——在关联的两个关系中，它们具有一个或多个相同属性。若关联列在第一个关系中作为主键，则在第二个关系中作为外键。</p>
<ul>
<li>用户自定义完整性约束</li>
</ul>
<p><strong>用户自定义完整性</strong>是指用户根据具体业务对数据处理规则要求所定义的数据约束。</p>
<p>用户可以定义如下类型的完整性约束:</p>
<blockquote>
<p>定义列的数据类型与取值范围</p>
<p>定义列的缺省值</p>
<p>定义列是否允许取空值</p>
<p>定义列取值唯一性</p>
<p>定义列之间的数据依赖性</p>
</blockquote>
<p>从关系的数学定义来看，关系是各个域的笛卡尔集合。(×)</p>
<p>应该是子集</p>
<ol>
<li><p>关系模型由三个部分组成：数据结构，操作集合和完整性约束。</p>
<p>(1)关系数据结构:在关系模型中,现实世界的实体以及实体间的各种联系均用单一的结构类型即关系来表示。</p>
<p>(2)关系操作集合:关系模型中常用的关系操作包括查询操作和插入、删除、修改操作。</p>
<p>(3)关系完整性约束:关系模型中有实体完整性约束、参照完整性约束和用户定义的完整性约束三类约束。</p>
</li>
<li><p>在关系模型中，对关系有几种基本的数据操作方式，包括选择，投影，连接，除法等。这些操作可以用来查询、更新和控制关系数据。</p>
</li>
<li><p>关系数据查询中的选择运算是从关系中选择满足特定条件的元组。投影运算是从关系中选择特定属性列。连接运算是根据两个关系中共同属性的值相等来组合两个关系中的元组。</p>
</li>
<li><p>θ连接(内连接)是指在两个关系上执行一个比较运算符θ的连接操作。θ为“&#x3D;”的连接运算称为等值连接，自然连接是一种特殊的等值连接（两个关系中进行比较的分量必须是相同的属性组），它在连接后自动删除重复的列。</p>
</li>
<li><p>左外连接返回左表中所有记录和右表中匹配记录；如果右表中没有匹配记录，则结果为NULL。右外连接返回右表中所有记录和左表中匹配记录；如果左表中没有匹配记录，则结果为NULL。全外连接返回左表和右表中所有记录；如果其中一个表没有匹配记录，则结果为NULL。</p>
</li>
</ol>
<h2 id="第三章数据库操作SQL语言"><a href="#第三章数据库操作SQL语言" class="headerlink" title="第三章	数据库操作SQL语言"></a>第三章	数据库操作SQL语言</h2><ul>
<li><p>SQL语言是一种标准的数据库操作语言，可以支持所有数据库访问操作（错）</p>
<p>  主流的关系型数据库管理系统均支持SQL标准语言实现数据库操作</p>
</li>
<li><p>下面哪种数据类型不是PostgreSQL支持的数据类型?<br>A.json	B.line	C. macaddr	<strong>D. String</strong><br>  PostgreSQL支持<code>json</code>，<code>line</code>和<code>macaddr</code>数据类型。但是，它不支持名为<code>String</code>的数据类型。在PostgreSQL中，可以使用<code>text</code>或<code>varchar</code>数据类型来存储字串。</p>
</li>
</ul>
<h3 id="数据定义语句（DDL）"><a href="#数据定义语句（DDL）" class="headerlink" title="数据定义语句（DDL）"></a>数据定义语句（DDL）</h3><p>创建数据库：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> databse CourseDB;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> CourseDB <span class="keyword">rename</span> <span class="keyword">to</span> courseDB;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> courseDB;</span><br></pre></td></tr></table></figure>

<p>定义基本表 CREATE  TABLE</p>
<p>CREATE  TABLE 表名();</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(n)</td>
<td>长度为 n 的字符型</td>
</tr>
<tr>
<td>VARCHAR(n)</td>
<td>最大长度为 n 的变长字符型</td>
</tr>
<tr>
<td>NUMBER(n)</td>
<td>长度为 n 的数字型</td>
</tr>
<tr>
<td>lNT</td>
<td>长整型(4B)</td>
</tr>
<tr>
<td>SMALLlNT</td>
<td>短整型(2B)</td>
</tr>
<tr>
<td>BlGlNT</td>
<td>大整型(8B)</td>
</tr>
<tr>
<td>FLOAT(n)</td>
<td>精度至少为 n 位数字的浮点数</td>
</tr>
<tr>
<td>DATE</td>
<td>日期， 格式为 YYYY-MM-DD</td>
</tr>
<tr>
<td>TlME</td>
<td>时间， 格式为 HH:MM:SS</td>
</tr>
</tbody></table>
<p><strong>列级完整性约束条件</strong></p>
<blockquote>
<p>PRlMARY KEY	&#x2F;&#x2F;主码:当只有一个主码时，可直接在对应的属性列标注<br>NOT NULL	&#x2F;&#x2F;非空:表示该属性列不能取空值<br>UNlQUE	&#x2F;&#x2F;唯一值: 表示该属性列只能取唯一值<br>CHECK(条件) 	   &#x2F;&#x2F;检查:  检查该列是否满足某个条件，如 CHECK(某属性&gt;20)</p>
</blockquote>
<p>列完整约束</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span>  Course</span><br><span class="line">( CourseID  	<span class="type">char</span>(<span class="number">4</span>)      <span class="keyword">PRIMARY  Key</span>,</span><br><span class="line">  CourseName  	<span class="type">varchar</span>(<span class="number">20</span>)  <span class="keyword">NOT</span>  <span class="keyword">NULL</span>  <span class="keyword">UNIQUE</span>,</span><br><span class="line">  CourseType  	<span class="type">varchar</span>(<span class="number">10</span>)  <span class="keyword">NULL</span> <span class="keyword">CHECK</span>(CourseType <span class="keyword">IN</span>(<span class="string">&#x27;基础课&#x27;</span>,<span class="string">&#x27;专业课&#x27;</span>,<span class="string">&#x27;选修课&#x27;</span>)),</span><br><span class="line">  TestMethod  	<span class="type">char</span>(<span class="number">4</span>)      <span class="keyword">NOT</span>  <span class="keyword">NULL</span>  <span class="keyword">DEFAULT</span>  <span class="string">&#x27;闭卷考试&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>复合主键</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span>  Plan</span><br><span class="line">( CourseID  	<span class="type">char</span>(<span class="number">4</span>)  	<span class="keyword">NOT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">  TeacherID  	<span class="type">char</span>(<span class="number">4</span>)  	<span class="keyword">NOT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span>	CoursePlan_PK	<span class="keyword">PRIMARY Key</span>(CourseID,TeacherID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>使用表约束定义主键的优点:便于定义复合主键，可命名主键约束，便于定义代理键。</p>
<p>代理键</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span>  Plan</span><br><span class="line">( CoursePlanID	<span class="type">serial</span>		<span class="keyword">NOT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span>	CoursePlan_PK	<span class="keyword">PRIMARY Key</span>(CoursePlanID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>外键,级联删除</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span>  Register</span><br><span class="line">( CourseRegID  	<span class="type">serial</span>	<span class="keyword">NOT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">  CoursePlanID  	<span class="type">Int</span>  		<span class="keyword">NOT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">  StudentID  	<span class="type">char</span>(<span class="number">13</span>),</span><br><span class="line">  Note  		<span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span>	CourseRegID_PK	<span class="keyword">PRIMARY Key</span>(CourseRegID),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span>	CoursePlanID_FK	<span class="keyword">FOREIGN Key</span>(CoursePlanID)</span><br><span class="line">	<span class="keyword">REFERENCES</span>  Plan(CoursePlanID)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>表修改</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="type">name</span>&gt; <span class="keyword">add</span> &lt;columnName&gt; &lt;<span class="keyword">type</span>&gt; &lt;<span class="keyword">constraint</span>&gt;;</span><br></pre></td></tr></table></figure>

<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>&lt;表名&gt; <span class="keyword">DROP</span>  <span class="keyword">COLUMN</span> &lt;列名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>&lt;表名&gt; <span class="keyword">DROP</span>  <span class="keyword">CONSTRAINT</span> &lt;列名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新表名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">RENAME</span> &lt;原列名&gt; <span class="keyword">TO</span> &lt;新列名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">ALTER</span>  <span class="keyword">COLUMN</span> &lt;列名&gt; <span class="keyword">TYPE</span>&lt;新的数据类型&gt;;</span><br></pre></td></tr></table></figure>

<p>索引作用:支持对数据库表中数据快速查找，其原理类似图书目录，可以快速定位章节内容。</p>
<p>索引优点:</p>
<blockquote>
<p>可快速连接关联表<br>减少分组和排序时间<br>提高关系表数据检索速度</p>
</blockquote>
<p>索引局限:</p>
<blockquote>
<p>索引会占用额外存储空间<br>创建和维护索引都需要较大时间开销											<br>数据操纵因维护索引带来系统性能开销</p>
</blockquote>
<p>创建索引<br>例:在学生信息表Student中，为出生日期Birthday列创建索引，以便支持按出生日期快	速查询学生信息。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> Birthday_Idx <span class="keyword">ON</span> STUDENT (Birthday) ;</span><br></pre></td></tr></table></figure>

<p>修改索引<br>例在学生信息表Student中，将原索引Birthday_ldx更名为Bday_ldx，其索引修改SQL	语句如下</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> Birthday_Idx <span class="keyword">RENAME</span> T0 Bday_ldx ;</span><br></pre></td></tr></table></figure>

<p>删除索引</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">INDEX</span> bday_idx;</span><br></pre></td></tr></table></figure>

<h3 id="数据操纵语句（DML）"><a href="#数据操纵语句（DML）" class="headerlink" title="数据操纵语句（DML）"></a>数据操纵语句（DML）</h3><p>插入</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Student <span class="keyword">VALUES</span>(<span class="string">&#x27;2017220101105&#x27;</span>,<span class="string">&#x27;赵东&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1999-04-23&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>, <span class="string">&#x27;liuyin@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>更新</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  Student</span><br><span class="line"><span class="keyword">SET</span>  Email=<span class="string">&#x27;zhaodong@163.com&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span>   StudentName=<span class="string">&#x27;赵东&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span>  STUDENT</span><br><span class="line"><span class="keyword">WHERE</span>   StudentName=<span class="string">&#x27;赵东&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>清空</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> STUDENT;</span><br></pre></td></tr></table></figure>

<h3 id="数据查询语句（DQL）"><a href="#数据查询语句（DQL）" class="headerlink" title="数据查询语句（DQL）"></a>数据查询语句（DQL）</h3><p>先分组再排序！！！</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>]  &lt;目标列&gt;[，&lt;目标列&gt;…]</span><br><span class="line">[ <span class="keyword">INTO</span> &lt;新表&gt; ]</span><br><span class="line"><span class="keyword">FROM</span>  &lt;表名|视图名&gt;[，&lt;表名|视图名&gt;…]</span><br><span class="line">[ <span class="keyword">WHERE</span>  &lt;条件表达式&gt; ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;列名&gt; [<span class="keyword">HAVING</span> &lt;条件表达式&gt; ]]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span>  &lt;列名&gt; [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ] ];</span><br></pre></td></tr></table></figure>

<p>1）使用BETWEEN..AND关键词来限定列值范围，还可以使用关键词LIKE与通配符来限定查询条件。<br>2)使用通配符来限定字符串数据范围。下划线（_）通配符用于代表一个未指定的字符。百分号(%）通配符用于代表一个或多个未指定的字符。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT</span><br><span class="line"><span class="keyword">WHERE</span> BirthDay <span class="keyword">BETWEEN</span> <span class="string">&#x27;2000-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2000-12-30&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> Email <span class="keyword">LIKE</span> <span class="string">&#x27;%@163.com &#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p><a href="https://smms.app/image/oiIjqcgDLa6Vud7" target="_blank"><img src="https://s2.loli.net/2023/06/03/oiIjqcgDLa6Vud7.png" ></a></p>
<p><a href="https://smms.app/image/GOKjh5RsYXb16uA" target="_blank"><img src="https://s2.loli.net/2023/06/03/GOKjh5RsYXb16uA.png" ></a></p>
<p>例1:若要统计Student表中的学生人数，在SELECT语句中可以使用COUNT )函数来计算，其查询SQL语句如下:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> COUNT(*) <span class="keyword">AS</span> 学生人数 <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>

<p>例2:找出STUDENT表中年龄最大和年龄最小的学生出生日期，其查询SQL语句如下:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Min (Birthday) <span class="keyword">AS</span> 最大年龄,Max (Birthday) <span class="keyword">AS</span> 最小年龄 <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>

<p>分组：</p>
<p>having 是对于 group by 的列的条件约束,除了group外,列名称不能和聚合函数一起用</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Major  <span class="keyword">AS</span> 专业,  COUNT（StudentID） <span class="keyword">AS</span> 学生人数</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span>  StudentGender=’男’</span><br><span class="line"><span class="keyword">GROUP</span>  <span class="keyword">BY</span>  Major</span><br><span class="line"><span class="keyword">HAVING</span>  COUNT(*)&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>子查询：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  TeacherID,  TeacherName,  TeacherTitle</span><br><span class="line"><span class="keyword">FROM</span>  Teacher</span><br><span class="line"><span class="keyword">WHERE</span>  CollegeID  <span class="keyword">IN</span></span><br><span class="line">        (<span class="keyword">SELECT</span>  CollegeID  </span><br><span class="line">     <span class="keyword">FROM</span>  College</span><br><span class="line">     <span class="keyword">WHERE</span>  CollegeName=’计算机学院’);</span><br></pre></td></tr></table></figure>

<p>多表关联查询：</p>
<p>在选课管理系统数据库中，希望获得各个学院的教师信息列表，包括学院名称、教师编号、教师姓名、教师性别、职称等信息。要求按学院名称、教师编号分别排序输出，其查询SQL语句如下：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  B.CollegeName <span class="keyword">AS</span> 学院名称,  A.TeacherID  <span class="keyword">AS</span> 编号, A.TeacherName  <span class="keyword">AS</span> 姓名,  A.TeacherGender  <span class="keyword">AS</span> 性别,  A. TeacherTitle  <span class="keyword">AS</span> 职称</span><br><span class="line"><span class="keyword">FROM</span>  Teacher  <span class="keyword">AS</span>  A，College  <span class="keyword">AS</span>  B</span><br><span class="line"><span class="keyword">WHERE</span>  A.CollegeID=B.CollegeID </span><br><span class="line"><span class="keyword">ORDER</span>  <span class="keyword">BY</span>  B.CollegeName, A.TeacherID;</span><br></pre></td></tr></table></figure>

<p>在选课管理数据库中，希望查询所有开设课程的学生选课情况，包括课程名称、任课教师、选课学生人数。这需要关联课程信息表COURSE、教师信息表TEACHER、开课计划表PLAN、选课注册信息表REGISTER。其连接查询的SQL语句如下：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> C.CourseName <span class="keyword">AS</span> 课程名称, T.TeacherName <span class="keyword">AS</span> 教师, </span><br><span class="line">  COUNT (R.CoursePlanID)  <span class="keyword">AS</span> 选课人数</span><br><span class="line"><span class="keyword">FROM</span>  COURSE  <span class="keyword">AS</span>  C  <span class="keyword">JOIN</span>  PLAN  <span class="keyword">AS</span>  P  <span class="keyword">ON</span>  C.CourseID=P.CourseID </span><br><span class="line">  <span class="keyword">JOIN</span>  TEACHER  <span class="keyword">AS</span>  T  <span class="keyword">ON</span>  P.TeacherID=T.TeacherID</span><br><span class="line">  <span class="keyword">JOIN</span>  REGISTER  <span class="keyword">AS</span>  R  <span class="keyword">ON</span>  P.CoursePlanID=R.CoursePlanID</span><br><span class="line"><span class="keyword">GROUP</span>  <span class="keyword">BY</span> C.CourseName, T.TeacherName;</span><br></pre></td></tr></table></figure>

<p>在上面的内连接查询中，只能找出有学生注册的课程名称和选课人数，但不能找出没有学生注册的课程名称。<br>在SQL应用中，有时候也希望输出那些不满足连接条件的元组数据。这时，可使用JOIN–ON外连接方式实现。其实现方式有三种形式，具体如下:</p>
<blockquote>
<p><strong>LEFT JOIN</strong>:左外连接，即使没有与右表关联列值匹配，也从左表返回所<br>有的行。<br><strong>RIGHT JOIN</strong>:右外连接，即使没有与左表关联列值匹配，也从右表返回<br>所有的行。<br><strong>FULL JOIN</strong>:全外连接，同时进行左连接和右连接，就返回所有行。</a></p>
</blockquote>
<p>对A表和B表进行关联查询，哪种连接可以使B表中不匹配的元组数据可以出现在结果集中?<br>A. left join	<strong>B. right join</strong>	C. full join	D. inner join</p>
<p>在选课管理系统数据库中，希望能查询所有开设课程的学生选课情况，包括课程名称、任课教师、选课学生人数。这需要关联课程信息表COURSE、开课计划表CPLAN、教师信息表TEACHER、选课注册信息表REGISTER。若使用左外连接查询，该JOIN–ON连接查询的SQL语句如下:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> C.CourseName <span class="keyword">AS</span> 课程名称, T.TeacherName <span class="keyword">AS</span> 教师, </span><br><span class="line">COUNT  (R.CoursePlanID)  <span class="keyword">AS</span> 选课人数</span><br><span class="line"><span class="keyword">FROM</span>  COURSE  <span class="keyword">AS</span>  C  <span class="keyword">JOIN</span>  PLAN  <span class="keyword">AS</span>  P  </span><br><span class="line"><span class="keyword">ON</span>  C.CourseID=P.CourseID </span><br><span class="line"><span class="keyword">JOIN</span>  TEACHER  <span class="keyword">AS</span>  T  <span class="keyword">ON</span>  P.TeacherID=T.TeacherID</span><br><span class="line"><span class="keyword">LEFT  JOIN</span>  REGISTER  <span class="keyword">AS</span>  R  <span class="keyword">ON</span>  P.CoursePlanID=R.CoursePlanID</span><br><span class="line"><span class="keyword">GROUP</span>  <span class="keyword">BY</span> C.CourseName, T.TeacherName;</span><br></pre></td></tr></table></figure>

<h3 id="数据控制语句（DCL）"><a href="#数据控制语句（DCL）" class="headerlink" title="数据控制语句（DCL）"></a>数据控制语句（DCL）</h3><p>授予，收回，拒绝权限</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>  <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span>  <span class="keyword">ON</span>  REGISTER  <span class="keyword">TO</span>  RoleS;</span><br><span class="line"><span class="keyword">REVOKE</span>  <span class="keyword">DELETE</span>  <span class="keyword">ON</span>  REGISTER  <span class="keyword">FROM</span>  RoleS;</span><br><span class="line">DENY  <span class="keyword">DELETE</span>  <span class="keyword">ON</span>  TEACHER  <span class="keyword">TO</span>  RoleT;</span><br></pre></td></tr></table></figure>

<p>视图是一个虚拟的表，它是从一个或几个基本表（或视图）导出的表。它包含行和列，就像一个真实的表一样。视图本身并不包含任何数据，它只包含映射到基表的一个查询语句。当基表数据发生变化时，视图数据也随之变化。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以提交数据，就像这些来自于某个单一的表一样。数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。</p>
<p>视图的优点：</p>
<blockquote>
<ol>
<li>使用视图简化复杂SQL查询操作</li>
<li>使用视图提高数据访问安全性</li>
<li>提供一定程度的数据逻辑独立性通过视图，可提供一定程度的数据逻辑独立性。当数据表结构发生改变，只要视图结构不变，应用程序可以不作修改。</li>
<li>集中展示用户所感兴趣的特定数据通过视图，可以将部分用户不关心的数据进行过滤，仅仅提供他们所感兴趣的数据。</li>
</ol>
</blockquote>
<p>创建视图</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span>  BasicCourseView  <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span>  CourseName,  CourseCredit,  CoursePeriod,  TestMethod</span><br><span class="line"><span class="keyword">FROM</span>    COURSE</span><br><span class="line"><span class="keyword">WHERE</span>  CourseType=‘基础课’;</span><br></pre></td></tr></table></figure>

<p>查询视图：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BasicTeacherInfoView <span class="keyword">ORDER</span> <span class="keyword">BY</span> 所属学院,教师姓名;</span><br></pre></td></tr></table></figure>

<p>删除视图：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span>&lt;视图名&gt;;</span><br></pre></td></tr></table></figure>

<p>下面哪项不是SQL语言的特性?<br>A.对数据库进行操作<br>B.实现控制逻辑编程<br>C.数据库游标操作<br>D.数据库事务操作</p>
<p><code>实现控制逻辑编程</code> 不是 SQL 语言的特性。SQL 语言是一种用于管理关系数据库的语言，它可以用来对数据库进行操作、数据库游标操作和数据库事务操作。但它不是一种通用的编程语言，不能用来实现控制逻辑编程。</p>
<p><strong>NUMERIC</strong>数据类型是一种精确数字数据类型，其精度在算术运算后保留到最小有效位，numeric是标准sql的数据类型，格式是numeric(m，n）。numeric(a，b)函数有两个参数，前面一个为总的位数，后面一个参数是小数点后的位数，例如numeric（5，2）是总位数为5，小数点后为2位的数，也就是说这个字段的整数位最大是3位。</p>
<p>在数据库中，使用更多索引可以加快数据库处理速度。（x）<br><em><strong>索引可以加快查询速度，但不能加快处理速度</strong></em></p>
<p><a href="https://smms.app/image/cGdF3HSLoqhszr2" target="_blank"><img src="https://s2.loli.net/2023/06/03/cGdF3HSLoqhszr2.png" alt="image.png"></a></p>
<p>针对视图 <code>Create view stuView as select * from student;</code> 可以进行 <code>D.以上均可</code> 操作访问。这个视图定义了一个查询语句，它从 <code>student</code> 表中选择所有列和所有行。因此，可以对这个视图执行 <code>SELECT</code>、<code>INSERT INTO</code> 和 <code>DELETE</code> 操作。<br>针对视图 <code>Create view stuView as select stuname, major from student;</code> 可以进行 <code>A. Select</code>,<code>C. delete</code> 操作访问。这个视图定义了一个查询语句，它从 <code>student</code> 表中选择 <code>stuname</code> 和 <code>major</code> 列。由于这个视图只包含部分列，因此不能对其执行 <code>INSERT INTO</code> 操作。</p>
<h2 id="第四章-数据库设计与实现"><a href="#第四章-数据库设计与实现" class="headerlink" title="第四章 数据库设计与实现"></a>第四章 数据库设计与实现</h2><p><strong>概念数据模型</strong>（Concept Data Model，CDM）是一种<strong>面向用户</strong>的系统数据模型，它用来描述现实世界的系统概念化数据结构。使数据库设计人员在系统设计的初始阶段，摆脱计算机系统及DBMS的具体技术问题，集中精力分析业务数据以及数据之间的联系等，描述系统的数据对象及其组成关系。 </p>
<p><strong>逻辑数据模型</strong> (Logic Data Model，LDM)是在概念数据模型基础上，从系统设计角度描述系统的数据对象组成及其关联结构，并考虑这些数据对象符合数据库对象的逻辑表示。 </p>
<p><strong>物理数据模型</strong>（Physical Data Model，PDM）是在逻辑数据模型基础上，针对具体DBMS所设计的数据模型。它用于描述系统数据模型在具体DBMS中的数据对象组织、<strong>存储方式</strong>、<strong>索引方式</strong>、访问路径等实现信息。（面向编程人员）</p>
<p>在E-R模型中，基本元素包括实体、属性、标识符和联系。</p>
<p><strong>实体</strong>(Entity)是指问题域中存在的人、事、物、地点等客观事物在逻辑层面的数据抽象。它用于描述事物的数据对象，如客户、交易、产品、订单等。</p>
<p><strong>属性</strong>是指描述实体特征的数据项。每个实体都具有1个或多个属性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_13-51-33.png"></p>
<p>实体联系的实例数量称为<strong>基数</strong>(Cardinality) 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_14-19-51.png"></p>
<p><strong>联系</strong>：实体间的联系，关联的实体数目称为联系度数</p>
<p>实体联系类型</p>
<ul>
<li>数量关系：1：1、1：N、M：N</li>
<li>必要性：可选，强制。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_14-20-21.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_14-21-28.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_14-22-01.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_14-22-12.png"></p>
<p>在E-R模型中，根据弱实体在语义上对强实体依赖程度的不同，弱实体又分为<strong>标识符依赖弱实体</strong>和<strong>非标识符依赖弱实体</strong>两类。如果弱实体的标识符中包含了所依赖实体的标识符，则该弱实体称为标识符依赖弱实体。</p>
<p>当使用关系数据库时，物理数据模型（PDM）即为关系模型。CDM&#x2F;LDM到PDM的转换其实就是E-R模型图到关系模型的转换。<br>E-R模型图到关系模型转换原理:</p>
<blockquote>
<p>将每一个实体转换成一个关系表，实体属性转换为关系表的列，实体标识符转换为关系表的主键或外键。将实体之间的联系转化为关系表之间的参照完整性约束。</p>
</blockquote>
<p>1:1实体联系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-30-41.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-31-07.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-31-22.png"></p>
<p>当带有实体继承联系的E-R模型图转换关系模型时，首先父实体和子实体都各自转换为表，其属性均转换为表的列。在处理实体继承联系转换时，将父表中的主键放置到子表中，既做主键又做外键。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-39-02.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-40-14.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_19-40-27.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/cdm.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/ldm.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/pdm.png">数据库规范化设计目的：</p>
<ul>
<li>减少数据库中的冗余数据，尽量使同一数据在数据库中仅保存一份，有效降低维护数据一致性的工作量。</li>
<li>设计合理的表间依赖关系和约束关系，便于实现数据完整性和一致性。</li>
<li>设计合理的数据库结构，便于系统对数据高效访问处理。</li>
</ul>
<p><strong>完全函数依赖与部分函数依赖</strong></p>
<p>例1：对于关系R（<u>X</u>,<u> Y</u>, N, O, P），其中（<u>X</u>,<u> Y</u>）为复合主键，若其它属性N,O,P都完整依赖于该复合主键，则称关系R为完全函数依赖。反之，其它属性N,O,P仅依赖于X，或仅依赖于Y，则称R为部分函数依赖。</p>
<p><strong>函数传递依赖</strong></p>
<p>例2：对于关系R（<u>X</u>, N, O, P），其中X为主键，若属性N依赖于X，而X不依赖于N，属性O依赖于N。则属性O函数传递依赖于X。</p>
<p><strong>多值函数依赖</strong></p>
<p>例3：对于教学关系R（课程, 教师, 课程参考书），一门课程可以有多个任课教师，也可以有多本参考书；每个任课教师可以任意选择他的参考书。该关系存在多值函数依赖。</p>
<p>如果X、Y是1:1的联系，则X↔Y。<br>如学号联系电话，即知道了学号，就可以在表中确定其联系电话;同样地，知道了联系电话，也可以在表中确定其学号。</p>
<p>如果X，Y是n :1的联系，则X→Y。<br>如学号-班号，即知道了学号，就可以在表中确定其班号;相反地，如果知道了班号，却无法确定学号。</p>
<p>如果X、Y是m : n的联系，则X和Y不存在函数依赖关系。<br>如学号和课程号没有函数依赖关系。即知道了学号，无法在表中确定课程号;同样地，如果知道了课程号，也无法确定学号。</p>
<p><strong>关系规范化范式</strong>：将一个有异常访问的关系分解成结构良好的关系的过程，使这些关系有最小冗余或没有冗余。</p>
<p>一般在我们设计关系型数据库的时候，<strong>最多考虑到BCNF就够</strong>。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。</p>
<p><em>关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。</em></p>
<ul>
<li><p>第一范式：关系表中属性不可再细分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/670f90e0d6a186d12a2a4545aea3ecd3.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/fcb526f0fae9df53625b573a822010e5.png"></p>
</li>
<li><p>第二范式：消除部分函数依赖，满足第一范式。</p>
<p>对于关系R（<u>X</u>,<u> Y</u>, N, O, P），其中（<u>X</u>,<u> Y</u>）为复合主键，N,O,P这三个非键属性都不存在只依赖A或只依赖B情况，则该关系满足第2范式,反之,不满足第2范式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/18eb762805d229aedb0c0046fceba05f.png"></p>
<p>对于<strong>（学号，课名） → 姓名</strong>，有 <strong>学号 → 姓名</strong>，存在部分函数依赖。<br>对于<strong>（学号，课名） → 系名</strong>，有 <strong>学号 → 系名</strong>，存在部分函数依赖。<br>对于<strong>（学号，课名） → 系主任</strong>，有 <strong>学号 → 系主任</strong>，存在部分函数依赖。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/0f18dc0ff9021cf8a32473f18065b11f.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/0dee50526984e0c559f2b29b4bff492f.png"></p>
</li>
<li><p>第三范式：切断属性传递依赖，满足第二范式。</p>
<p>接下来我们看看上表中的设计，是否符合3NF的要求。</p>
<p>对于<strong>选课</strong>表，主码为（学号，课名），主属性为<strong>学号</strong>和<strong>课名，</strong>非主属性只有一个，为分数，不可能存在传递函数依赖，所以<strong>选课</strong>表的设计，符合3NF的要求。</p>
<p>对于<strong>学生</strong>表，主码为<strong>学号</strong>，主属性为<strong>学号</strong>，非主属性为<strong>姓名</strong>、<strong>系名</strong>和<strong>系主任</strong>。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性<strong>系主任</strong>对于码<strong>学号</strong>的传递函数依赖，所以<strong>学生</strong>表的设计，不符合3NF的要求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/81582f29379da3cbd33f483e3978b701.jpg"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/ebb592146a8c9226463de96b70780c2b.png"></p>
</li>
<li><p>巴斯-科德范式(BCNF)：所有属性函数依赖的决定因子都是候选键。在3NF基础上，任何<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%B1%9E%E6%80%A7/120103?fromModule=lemma_inlink">主属性</a>不能对主键子集依赖（在3NF基础上消除主属性对主码子集的依赖）</p>
<p>举例：</p>
<ol>
<li>某公司有若干个仓库；</li>
<li>每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；</li>
<li>一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。</li>
</ol>
<p>那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？</p>
<p>答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量<br>主属性：仓库名、管理员、物品名<br>非主属性：数量<br>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p>
<p>但是存在主属性【仓库名】对于码（管理员，物品名）的部分函数依赖。</p>
<p>解决办法就是要在 3NF 的基础上消除<strong>主属性</strong>对于码的部分与传递函数依赖。</p>
<p>仓库（仓库名，管理员）<br>库存（仓库名，物品名，数量）</p>
</li>
<li><p>第四范式：消除多值函数依赖，满足巴斯-科德范式</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-04_21-43-16.png"></p>
</li>
</ul>
<p>关系的规范化程度依次提升:1NF→2NF →3NF→BCNF→ 4NF<br>关系的规范化程度越高，关系数据库存储的冗余数据就越少，可消除的数据访问异常就越多。不过关系的规范化程度越高，分解出来的关系表就越多，但在数据查询访问时，需关联更多关系表，其数据库处理效率会降低。</p>
<p>综合例题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-43-30.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-43-41.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-43-49.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-43-59.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-44-09.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-44-15.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-44-21.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-44-28.png"><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_11-44-37.png">所谓<strong>逆规范化</strong>，就是适当降低规范化范式约束，不再要求一个关系表必须达到很高的规范化程度，而是允许适当的数据冗余性，以获取数据访问性能。<br>逆规范化处理的基本方法:<br>(1)增加冗余列或派生列<br>(2)多个关系表合并为一个关系表</p>
<p>在E-R模型中，一个实体的其他关联实体数量称为什么？联系度数</p>
<p>在E-R模型图中，在定义一个实体时，必须指定它的标识符。 错误！！</p>
<h2 id="第五章-数据库管理"><a href="#第五章-数据库管理" class="headerlink" title="第五章 数据库管理"></a>第五章 数据库管理</h2><p>数据库管理概论</p>
<p>是指为保证数据库系统的正常运行和服务质量必须进行的系统管理工作。</p>
<p>为什么需要数据库管理?</p>
<ul>
<li>数据库系统随规模增大,系统会变得异常复杂</li>
<li>多用户数据库应用带来数据库访问复杂性</li>
<li>数据安全和数据隐私对机构和用户都非常重要</li>
<li>数据库系统随数据量增加和使用时间增长其性能会降低</li>
<li>系统遭遇意外事件，数据库损坏或数据丢失</li>
</ul>
<p>数据库管理目标</p>
<ul>
<li>保障数据库系统正常稳定运行</li>
<li>充分发挥数据库系统的软硬件处理能力</li>
<li>确保数据库系统安全和用户数据隐私性</li>
<li>有效管理数据库用户及其角色权限</li>
<li>解决数据库系统性能优化、系统故障与数据损坏等问题</li>
<li>最大程度地发挥数据库对其所属机构的作用</li>
</ul>
<p>在数据库中，<strong>事务</strong>(Transaction）是指针对<strong>单个业务处理功能</strong>的一组数据库访问操作，要求它们要么都成功执行，要么都不执行。在数据库系统中，<em><strong>事务是DBMS执行的最小任务单元。同时，事务也是DBMS最小的故障恢复任务单元和并发控制任务单元。</strong></em></p>
<p>事务<strong>ACID</strong>特性:</p>
<blockquote>
<p><strong>原子性</strong>（Atomicity):事务所有操作在数据库中要么全部执行，要么全部不执行。<br><strong>一致性</strong>(Consistency) :事务多次执行，其结果应一致。<br><strong>隔离性</strong>（lsolation):事务与事务之间隔离，并发执行透明。<br><strong>持续性</strong>(Durability ) :事务完成后，数据改变必须是永久的。</p>
</blockquote>
<p>事务SQL</p>
<ul>
<li>BEGIN 或 START TRANSACTION ；事务开始语句</li>
<li>ROLLBACK ；事务回滚语句</li>
<li>COMMIT ；事务提交语句</li>
<li>SAVEPOINT ；事务保存点语句</li>
</ul>
<p><a href="https://imgse.com/i/pCP9sAg"><img src="https://s1.ax1x.com/2023/06/05/pCP9sAg.png" alt="pCP9sAg.png" border="0" /></a><br>例：在选课管理数据库CurriculaDB中，使用事务程序实现对学院信息表College的数据插入，其事务SQL程序如下：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> college( collegeID, collegename)<span class="keyword">VALUES</span> (<span class="string">&#x27;004&#x27;</span>, <span class="string">&#x27;外语学院&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> college( collegeID, collegename)<span class="keyword">VALUES</span> (<span class="string">&#x27;005&#x27;</span>, <span class="string">&#x27;数学学院&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> college( collegeID, collegename)<span class="keyword">VALUES</span> (<span class="string">&#x27;006&#x27;</span>, <span class="string">&#x27;临床医学院&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>在事务过程中禁止使用的SQL语句：</p>
<blockquote>
<p>创建数据库 CREATE  DATABASE<br>修改数据库 ALTER  DATABASE<br>删除数据库 DROP  DATABASE<br>恢复数据库 RESTORE  DATABASE<br>加载数据库 LOAD  DATABASE<br>备份日志文件 BACKUP  LOG<br>恢复日志文件 RESTORE  LOG<br>授权操作 GRANT</p>
</blockquote>
<p>若用户没有显式地定义事务时，DBMS按默认事务方式处理，<strong>即每执行一个SQL语句将自动构成一个事务</strong>。若将多条SQL语句定义为一个事务时，才使用专门的事务SQL语句显式地定义事务。</p>
<p>为什么需要并发控制？</p>
<p>当多个事务程序在DBMS系统中同时运行时，可能会出现对一些共享数据同时进行访问操作，如一些事务修改数据，另一些事务读取数据。这些并发的共享数据操作，如果在DBMS中没有一定的约束控制情况下，可能会带来<strong>数据不一致性</strong>或<strong>事务程序死锁</strong>问题。因此，在多个事务并发运行时，必须进行并发控制处理。</p>
<p>并发控制–事务调度</p>
<p>目的</p>
<ul>
<li>支持并发事务处理，使更多用户并行操作，提高系统的并发访问能力。</li>
<li>保证一个事务工作不会对另一个事务工作产生不合理的影响。</li>
</ul>
<p>并发控制需解决的问题：</p>
<ul>
<li>丢失更新数据：对共享数据进行非锁定资源的读写操作。</li>
<li>脏数据读取：事务读取一个被取消持久化的共享数据。（事务读到的数据最后被回滚了，读到的是假数据）</li>
<li>不可重复读取：指一个事务对一个共享数据重复多次读取，但前后读取的数据不一致。（修改或删除）</li>
<li>幻像读取：后一次读比前一次读多了一些记录（插入）</li>
</ul>
<p><strong>并发事务调度</strong>就是控制多个事务的<strong>数据操作语句按照恰当的顺序访问共享数据</strong>，使这些事务执行之后，避免造成数据的不一致性，即解决“丢失更新数据”、“不可重复读”、“脏数据读”等问题。</p>
<p><strong>事务调度策略</strong></p>
<p>例：银行客户A的账户当前余款为1000元，客户B的账户当前余款为1500元。现在有两个事务T1和T2，其中T1事务将从客户A转账200元到客户B，T2事务也将从客户A转账400元到客户B。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-18-05.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-18-14.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-18-31.png"></p>
<p>在事务并发执行中，只有当事务中数据操作调度顺序的执行结果与事务串行执行结果一样时，该并发事务调度才能保证数据操作的正确性和一致性。符合这样效果的调度称为<strong>可串行化调度</strong>。<br>DBMS并发事务调度目标：使并发事务调度实现的处理结果与串行化调度处理结果<strong>一致</strong>。</p>
<p>锁</p>
<ul>
<li><strong>排它锁定</strong>(Lock-X)——锁定后，<strong>不允许</strong>其它事务对共享数据再加锁</li>
<li><strong>共享锁定</strong>(Lock-S)——锁定后，只允许其它事务对共享数据<strong>添加读取锁</strong></li>
</ul>
<p>资源锁定粒度</p>
<ul>
<li>数据库——粒度最大</li>
<li>表——粒度较大</li>
<li>页面——粒度中等</li>
<li>行——粒度小</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-28-05.png"></p>
<p>加锁协议</p>
<p><strong>一级加锁协议</strong>：任何事务在修改共享数据对象之前，必须对该数据执行排它锁定指令，直到该事务处理完成，才进行解锁指令执行。</p>
<p>特点：使用一级加锁协议，可<strong>避免出现更新丢失</strong>问题。但不能解决“不可重复读取”、“脏读”等数据不一致问题。</p>
<p>例：某航班剩余机票数据A的当前值为100张。现有分别来自不同售票点的两个并发事务T1和T2，其中T1事务将售出1张机票，T2事务将售出2张机票。以下分别给出它们在不加锁和按一级加锁协议的并发事务调度执行情况，见下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-37-29.png"></p>
<p><strong>二级加锁协议</strong>：在一级加锁协议基础上，针对并发事务的共享数据读操作，<strong>必须对该数据执行共享锁定指令</strong>，<strong>读完数据后即刻释放共享锁定</strong>。</p>
<p>特点：该加锁协议不但可以防止“丢失更新”的数据不一致性问题，还可防止出现<strong>脏读数据</strong>问题。但有可能会出现“不可重复读取”的数据不一致问题。</p>
<p>例：某航班剩余机票数据A的当前值为100张。现有分别来自不同售票点的两个并发事务T1和T2，其中T1事务将售出1张机票，T2事务进行机票空余数查询。以下分别给出它们在按一级加锁协议执行和按二级加锁协议的事务调度执行情况，见下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-39-03.png"></p>
<p><strong>三级加锁协议</strong>：在一级加锁协议基础上，当并发事务对共享数据进行读操作，必须对该数据执行共享锁定指令，直到该<strong>事务处理结束才释放共享锁定</strong>。</p>
<p>特点：该加锁协议不但可以防止“丢失更新”、“脏读”的数据不一致性问题，还可防止出现“不可重复读取”的数据一致性问题。</p>
<p>例：某航班剩余机票数据A的当前值为100张。现有分别来自不同售票点的两个并发事务T1和T2，其中T1事务将售出1张机票，T2事务进行机票空余数查询。以下分别给出它们在按二级加锁协议执行和按三级加锁协议的并发事务调度执行情况，见下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-39-19.png"></p>
<p>不同级别锁协议比较</p>
<table>
<thead>
<tr>
<th align="left"><strong>加锁协议级别</strong></th>
<th align="left"><strong>排它锁</strong></th>
<th align="left"><strong>共享锁</strong></th>
<th align="left"><strong>不丢失更新</strong></th>
<th align="left"><strong>不脏读</strong></th>
<th align="left"><strong>可重复读</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>一级</strong></td>
<td align="left">全程加锁</td>
<td align="left">不加</td>
<td align="left">是</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left"><strong>二级</strong></td>
<td align="left">全程加锁</td>
<td align="left">开始时加锁，读完数据释放锁定</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left"><strong>三级</strong></td>
<td align="left">全程加锁</td>
<td align="left">全程加锁</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>保证并发事务可串行化的一个协议是：<strong>二阶段锁定协议</strong></p>
<p>二阶段锁定协议规定每个事务必须分两个阶段提出加锁和解锁申请:</p>
<blockquote>
<p>增长阶段，事务只能获得锁，但不能释放锁。</p>
<p>缩减阶段，事务只能释放锁，但不能获得新锁。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_20-58-44.png"></p>
<p>在基于锁机制的并发事务执行中，如果这些事务同时锁定两个以及以上资源时，可能会出现彼此都不能继续执行的状态，即<strong>事务死锁</strong>状态。</p>
<p>例 两个事务T1和T2，它们都需要加锁访问数据库表Table1和Table2，其事务程序见图6-20a所示。当这两个事务程序调度执行时，只要不是按可串行化调度执行，则它们在执行时会出现死锁状态，见图6-20b所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_21-01-25.png"></p>
<p>死锁出现的必要条件</p>
<ul>
<li><p>互斥条件</p>
</li>
<li><p>请求和保持条件</p>
</li>
<li><p>不剥夺条件</p>
</li>
<li><p>环路等待条件</p>
</li>
</ul>
<p>防范死锁的策略</p>
<ul>
<li><p>允许事务一次发出当前所需全部资源的锁定，使用完成后，再释放给其它事务使用。</p>
</li>
<li><p>规定所有应用程序锁定资源的顺序必须完全相同。</p>
</li>
</ul>
<p>解决死锁的办法：当发生死锁时，回滚其中的一个事务，并取消它对数据库所做的改动。<br><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_21-03-36.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_21-10-46.png"></p>
<p>例：创建一个新用户，其账号名字为“userA”，密码为“123456”。该用户具有登录权限(Login）和角色继承权限（Inherit）系统权限，但它不是超级用户(SuperUser)，不具有创建数据库权限（CreateDB)、创建角色权限（CreateRole）、数据库复制权限（Replication) ,此外数据库连接数(Connection Limit）不受限。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> &quot;userA&quot; <span class="keyword">WITH</span></span><br><span class="line">	<span class="keyword">LOGIN</span> <span class="comment">--登录权限</span></span><br><span class="line">	<span class="keyword">NOSUPERUSER</span> <span class="comment">--不是超级用户</span></span><br><span class="line">	<span class="keyword">NOCREATEDB</span> <span class="comment">--不能创建数据库</span></span><br><span class="line">	<span class="keyword">NOCREATEROLE</span> <span class="comment">--没有创建角色权限</span></span><br><span class="line">	<span class="keyword">INHERIT</span> <span class="comment">--继承系统权限</span></span><br><span class="line">	<span class="keyword">NOREPLICATION</span> <span class="comment">--没有数据库复制权限</span></span><br><span class="line">	<span class="keyword">CONNECTION</span> <span class="keyword">LIMIT</span> <span class="number">-1</span> <span class="comment">--数据库连接数不受限</span></span><br><span class="line">	<span class="keyword">PASSWORD</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>修改删除用户：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span>  &lt;用户名&gt;  [ [ <span class="keyword">WITH</span> ] <span class="keyword">option</span> [ ... ] ];  	<span class="comment">--修改用户的属性</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span>  &lt;用户名&gt;  <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新用户名&gt;;  		<span class="comment">--修改用户的名称</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span>  &lt;用户名&gt;  <span class="keyword">SET</span> &lt;参数项&gt; &#123; <span class="keyword">TO</span> | = &#125; &#123; <span class="keyword">value</span> | <span class="keyword">DEFAULT</span> &#125;;												<span class="comment">--修改用户的参数值  </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span>  &lt;用户名&gt;  <span class="keyword">RESET</span> &lt;参数项&gt;;			<span class="comment">--重置用户参数值</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> userA;</span><br></pre></td></tr></table></figure>

<p>例：修改用户“userA”的账号密码为“gres123”。同时也限制该用户的数据库连接数为10。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> &quot;userA&quot; </span><br><span class="line">	<span class="keyword">CONNECTION</span> <span class="keyword">LIMIT</span> <span class="number">10</span></span><br><span class="line">	<span class="keyword">PASSWORD</span> <span class="string">&#x27;gres123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在DBMS中，为了方便对众多用户及其权限进行管理，通常将一组具有相同权限的用户定义为<strong>角色</strong>(Role)。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt; [ [ <span class="keyword">WITH</span> ] <span class="keyword">option</span> [ ... ] ]; 	 <span class="comment">--创建角色</span></span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt;  [ [ <span class="keyword">WITH</span> ] <span class="keyword">option</span> [ ... ] ]; 	 <span class="comment">--修改角色属性</span></span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt;  <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新角色名&gt;; 		 <span class="comment">--修改角色名称 </span></span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt;  <span class="keyword">SET</span> &lt;参数项&gt; &#123; <span class="keyword">TO</span> | = &#125; &#123; <span class="keyword">value</span> | <span class="keyword">DEFAULT</span> &#125;; </span><br><span class="line">									 <span class="comment">--修改角色参数值</span></span><br><span class="line"><span class="keyword">ALTER</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt;  <span class="keyword">RESET</span> &lt;参数项&gt;;			 <span class="comment">--复位角色参数值</span></span><br><span class="line"><span class="keyword">DROP</span>  <span class="keyword">ROLE</span>  &lt;角色名&gt;;						 <span class="comment">--删除指定角色</span></span><br></pre></td></tr></table></figure>

<p>例 ：在工程项目管理系统中，假定需要在ProjectDB数据库内创建经理角色Role_Manager。该角色具有登录权限（Login）和角色继承权限（Inherit）系统权限，但它不是超级用户（SuperUser），不具有创建数据库权限（CreateDB）、创建角色权限（CreateRole）、数据库复制权限（Replication），此外数据库连接数（Connection Limit）不受限。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">ROLE</span>  &quot;Role_Manager&quot;  <span class="keyword">WITH</span></span><br><span class="line"> <span class="keyword">LOGIN</span></span><br><span class="line"> <span class="keyword">NOSUPERUSER</span></span><br><span class="line"> <span class="keyword">NOCREATEDB</span></span><br><span class="line"> <span class="keyword">NOCREATEROLE</span></span><br><span class="line"> <span class="keyword">INHERIT</span></span><br><span class="line"> <span class="keyword">NOREPLICATION</span></span><br><span class="line"> <span class="keyword">CONNECTION</span> <span class="keyword">LIMIT</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>角色权限授予</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>  <span class="keyword">ON</span>  Department  <span class="keyword">TO</span> &quot;Role_Manager&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_21-26-06.png"></p>
<p><strong>数据库备份方法</strong>：</p>
<ul>
<li>完全数据库备份</li>
<li>差异数据库备份</li>
<li>事务日志备份</li>
<li>文件备份</li>
</ul>
<p>下面哪种备份文件是恢复数据库到故障点时刻状态必不可少的?</p>
<p>A．数据库完整备份文件	B．数据库差异备份文件</p>
<p><strong>C．事务日志备份文件</strong>	D．数据库文件备份</p>
<p>C. 事务日志备份文件是恢复数据库到故障点时刻状态必不可少的。事务日志是数据库管理系统用来记录数据库中的所有修改操作的文件。在进行数据库恢复时，事务日志记录的变更可以被用来重做或者撤销，从而将数据库恢复到某个指定的时间点或者事务点的状态。因此，事务日志备份文件非常重要，是进行数据库恢复的必要条件。A. 数据库完整备份文件包含整个数据库的所有数据，但是无法恢复到某个指定的时间点或者事务点的状。B. 数据库差异备份文件只包含自上次完整备份或差异备份以来发生的数据变更，也无法恢复到某个指定的时间点或者事务点的状态，因此也不一定是恢复到故障点时刻状态必不可少的。D. 数据库文件备份只是将数据库文件复制到另一个位置，也无法恢复到某个指定的时间点或者事务点的状态。</p>
<p>对于意外事件导致数据库系统损坏，最可靠的技术手段是<br>A.数据库备份与恢复<br>B.采用双机容错技术<br>C.进行访问权限控制<br>D.<strong>系统异地容灾</strong></p>
<p>在数据库系统安全模型中，哪种安全管理手段是DBMS系统提供的数据库安全访问机制?</p>
<p>A.用户身份认证<br>B.<strong>用户存取权限控制</strong><br>C.文件安全访问<br>D.数据加密存储</p>
<p>哪种数据库备份方式可以支持系统连续运行?</p>
<p>A.冷备份<br>B.<strong>热备份</strong><br>C.完整备份<br>D.差异备份</p>
<p>热备份可以支持系统连续运行。热备份是一种在系统运行时备份数据库的方法，备份期间数据库可以继续提供服务，不会中断用户对数据库的访问。在热备份期间，DBMS系统会将数据库的活动日志记录下来，并将备份与日志进行同步，以确保备份的数据与源数据库保持一致。热备份可以保证数据库系统的连续性和高可用性。相对而言，冷备份是在系统停止运行时备份数据库的方法，需要停止数据库服务，将数据库系统完全关闭，进行备份操作，备份期间数据库无法提供服务。冷备份会导致数据库系统的停机时间较长，并且备份数据与源数据库之间存在时间差，无法实时保持同步。完整备份和差异备份都是备份数据的方式，完整备份是将整个数据库备份，差异备份是只备份自上次备份后发生更改的数据，但它们并不能支持数据库系统的连续运行，需要在备份期间停止数据库服务。</p>
<p>在哪个粒度上对共享数据进行加锁访问，系统并发访问性能最好？行！</p>
<p>DBMS系统可自动恢复哪类数据？事务故障的数据错误</p>
<h2 id="第六章-数据库应用编程"><a href="#第六章-数据库应用编程" class="headerlink" title="第六章 数据库应用编程"></a>第六章 数据库应用编程</h2><p>开放式数据库互连（Open DataBase Connectivity）实现了应用程序对多种不同DBMS的数据库的访问，实现了数据库连接方式的变革。</p>
<p>ODBC定义了一套基于SQL的，公共的，与数据库无关的API，从而使得应用程序与数据库管理系统之间在逻辑上独立，使应用程序与数据库无关性</p>
<p>ODBC应用程序接口(ODBCAPI)是一种使用ODBC技术实现应用程序与数据库互连的标准接口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_22-26-31.png"></p>
<p>应用程序使用ODBC访问数据库的步骤：</p>
<blockquote>
<p>在ODBC驱动管理器中注册一个数据源;<br>根据数据源提供的数据库位置、数据库名称及驱动程序等信息，驱动管理器建立起ODBC与具体数据库的联系;<br>应用程序使用数据源建立与相应数据库的连接;<br>应用程序通过驱动程序管理器与数据库管理系统交换信息;<br>数据库管理系统执行完相应的SQL操作后，将结果通过驱动程序管理器返回给应用程序。</p>
</blockquote>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-05_22-26-52.png"></p>
<p>(1）加载驱动<br>加载JDBC驱动是通过调用方法:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span>.forName(&quot;驱动名字&quot;)</span><br></pre></td></tr></table></figure>

<p>例PostgreSQL数据库驱动程序加载语句:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span>.forName (&quot;org.postgresql.Driver&quot;)</span><br></pre></td></tr></table></figure>

<p>(2）建立连接<br>调用DriverManager. getConnection(String urI)方法建立数据库连接。</p>
<p>例：PostgreSQL数据库连接程序:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">String URL = &quot;jdbc: postgresql://localhost:5432/testdb&quot;;</span><br><span class="line">String userName = &quot;myuser &quot;;</span><br><span class="line">String <span class="keyword">passWord</span> = &quot;sa&quot;;</span><br><span class="line"><span class="keyword">connection</span> conn =</span><br><span class="line">DriverManager. getConnection(URL, userName, <span class="keyword">passWord</span>);</span><br></pre></td></tr></table></figure>

<p>(3)创建Statement对象<br>采用Connection对象的createStatement()方法创建Statement对象。其语句如下:<br>Statement stmt &#x3D; conn. createStatement () ;<br>(4）执行SQL语句<br>在创建Statement对象后，就可以调用Statement对象的executeQuery()、executeUpdate()方法执行SQL语句。</p>
<ul>
<li>executeQuery()用于执行select语句</li>
<li>executeUpdate()用于执行update、 insert、 delete语句</li>
</ul>
<p>例:Statement对象的SQL执行</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Statement</span> stmt = conn.createStatement() ;</span><br><span class="line">String <span class="keyword">sql</span> = &quot;INSERT INTO public.student (sid,sname,gender,birthday,major,phone)&quot; + &quot;VALUES (&#x27;2017001&#x27;，&#x27;张山&#x27;,&#x27;男&#x27;,&#x27;1998-10-10&#x27;,&#x27;软件工程&#x27;,&#x27;13602810001&#x27;)&quot;;</span><br><span class="line">stmt.executeUpdate(<span class="keyword">sql</span>) ;</span><br></pre></td></tr></table></figure>

<p>(5)ResultSet结果集<br>ResultSet对象作为结果集，它存放了执行SQL语句的返回结果数据。通过getXXX方法可以对结果集中的记录数据进行访问。<br>ResultSet中若包含了多行结果数据，可以使用记录指针访问它们。指针所指向的数据行叫做当前数据行。移动指针可以访问其他行，这需要使用ResultSet的next()方法。<br>示例代码如下:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">rs = stmt.executeQuery (<span class="keyword">sql</span>) ;</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;//依次取出数据</span><br><span class="line">	String <span class="type">name</span> = rs.getString(&quot;name&quot;) ; //取出<span class="type">name</span>列的内容</span><br><span class="line">	<span class="type">int</span> age = rs.getlnt(&quot;age&quot;) ; //取出age列的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(6）关闭连接<br>作为一种好的编程风格，在不需要ResultSet对象、Statement对象和Connection对象时，应该显式地关闭它们。关闭这些对象的方法为:close() ;<br>示例:</p>
<blockquote>
<p>rs.close();关闭结果集对象</p>
<p>stmt.close();关闭执行对象</p>
<p>conn.close();关闭连接对象</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_10-03-38.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_10-03-52.png"></p>
<p>Servlet是用Java语言编写的服务器端小程序，驻留在web服务器中运行，它扩展了web服务器的动态处理功能。</p>
<blockquote>
<p>1.客户机将HTTP请求发送给Web服务器</p>
<p>2.Web 服务器将该请求转发给Servlet</p>
<p>3.Servlet处理该请求</p>
<p>4.Servlet将响应发送给Web 服务器</p>
<p>5.Web服务器将响应转发给客户机</p>
</blockquote>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程(Stored Procedure）是数据库中的一种对象;由一组完成特定数据处理功能的SQL语句和过程语句组成的程序;它被编译后，存储在数据库中;外部程序可以调用数据库的存储过程执行。</p>
<p>PostgreSQL使用CREATE FUNCTION命令创建存储过程。(10版本后可以用CREATE PRECEDURE)</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR REPLACE</span> ] <span class="keyword">FUNCTION</span>/<span class="keyword">PROCEDURE</span>  <span class="type">name</span></span><br><span class="line">    ( [ [ argmode ] [ argname ] argtype [ &#123; <span class="keyword">DEFAULT</span> | = &#125; default_expr ] [, ...] ] )</span><br><span class="line">    [ <span class="keyword">RETURNS</span> retype | <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span> ( <span class="built_in">column_name</span>  column_type [, ...] ) ]</span><br><span class="line"><span class="keyword">AS</span> $$<span class="language-java">         <span class="comment">//$$</span></span>用于声明存储过程的实际代码的开始</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">        <span class="comment">-- 声明段</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">--函数体语句</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$<span class="language-ruby"> <span class="variable constant_">LANGUAGE</span> lang_name;  <span class="regexp">//</span><span class="variable">$$</span></span> 表明代码的结束, <span class="keyword">LANGUAGE</span>后面指明所用的编程语言</span><br></pre></td></tr></table></figure>

<p>（1）name：要创建的存储过程名；<br>（2）OR REPLACE ：覆盖同名的存储过程；<br>（3）argmode：存储过程参数的模式可以为IN、OUT或INOUT，缺省值是IN。<br>（4）argname：形式参数的名字。<br>（5）RETURNS：返回值；RETURNS TABLE：返回二维表</p>
<p>例：创建一个名为countRecords()的过程函数统计STUDENT表的记录数。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR REPLACE</span> <span class="keyword">FUNCTION</span> countRecords ()  </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">integer</span> <span class="keyword">AS</span> $$<span class="language-pgsql">  </span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">declare</span>  </span></span><br><span class="line"><span class="language-pgsql">    count <span class="type">integer</span>;  </span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">BEGIN</span>  </span></span><br><span class="line"><span class="language-pgsql">   <span class="keyword">SELECT</span> count(*) <span class="keyword">into</span> count <span class="keyword">FROM</span> STUDENT;  </span></span><br><span class="line"><span class="language-pgsql">   <span class="keyword">RETURN</span> count;  </span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">END</span>;  </span></span><br><span class="line"><span class="language-pgsql">$$</span> <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>练习:创建一个increment(i)的过程函数计算自增值。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR REPLACE</span> <span class="keyword">FUNCTION</span> <span class="keyword">increment</span>(i integer)</span><br><span class="line">RETURNS integer AS $$</span><br><span class="line">BEGIN</span><br><span class="line">	RETURN i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$<span class="language-pgsql"><span class="keyword">LANGUAGE</span> plpgsql;</span></span><br></pre></td></tr></table></figure>

<p>例：创建一个名为add_data (a, b，c）的存储过程实现a+b相加运算，并将结果放入c。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR REPLACE</span> <span class="keyword">PROCEDURE</span> add_data(a <span class="type">integer</span>,b <span class="type">integer</span>,<span class="keyword">inout</span> c <span class="type">integer</span>)<span class="keyword">AS</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">Begin</span></span></span><br><span class="line"><span class="language-pgsql">	c=a+b;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">End</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span><span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>练习:创建一个increment_pro(i)的存储过程计算自增值。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR REPLACE</span> <span class="keyword">PROCEDURE</span> increment_pro(<span class="keyword">inout</span> i <span class="type">integer</span>)<span class="keyword">AS</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">BEGIN</span></span></span><br><span class="line"><span class="language-pgsql">	i=i+<span class="number">1</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">Return</span>;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">END</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span><span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<p>如果程序员需要调用<strong>函数</strong>执行，其调用方式如下:<br>select  函数名(参数);<br>或者:select * from 函数名(参数);</p>
<p>如果需要调用<strong>存储过程</strong>执行，其调用方式如下:<br>CALL存储过程名（参数)</p>
<p>删除存储过程<br>DROP FUNCTION [ IF EXISTS ] name ( [ [ argmode ] [ argname ] argtype [, …] ] ) [ CASCADE | RESTRICT ]<br>主要参数：<br>（1）IF EXISTS：如果指定的存储过程不存在，那么发出提示信息。<br>（2）name ：现存的存储过程名称。<br>（3）argmode：参数的模式：IN(缺省), OUT, INOUT, VARIADIC。请注意，实际并不注明OUT参数，因为判断存储过程的身份只需要输入参数。<br>（4）argname：参数的名字。请注意，实际上并不注明参数的名字，因为判断函数的身份只需要输入参数的数据类型。<br>（5）argtype：如果有的话，是存储过程参数的类型。<br>（6）CASCADE：级联删除依赖于存储过程的对象(如触发器)。<br>（7）RESTRICT：如果有任何依赖对象存在，则拒绝删除该函数；这个是缺省值。</p>
<p>删除前面定义的函数testExec()</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> testExec();</span><br></pre></td></tr></table></figure>

<p>例删除前面定义的存储过程maintenance()</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> maintenance();</span><br></pre></td></tr></table></figure>

<h3 id="PL-x2F-pgSQL基本语法"><a href="#PL-x2F-pgSQL基本语法" class="headerlink" title="PL&#x2F;pgSQL基本语法"></a>PL&#x2F;pgSQL基本语法</h3><p>变量声明的语法如下：<br> declare<br>     变量名  变量类型；<br>如果声明变量为记录类型，变量声明格式为： variable_name RECORD;<br>注：RECORD不是真正的数据类型，只是一个占位符。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> </span><br><span class="line">	count intger;</span><br><span class="line">    rec <span class="type">RECORD</span>;</span><br></pre></td></tr></table></figure>

<p>条件语句<br>在PL&#x2F;pgSQL中有以下三种形式的条件语句<br>1)IF-THEN </p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> <span class="type">boolean</span>-expression <span class="keyword">THEN</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>; </span><br></pre></td></tr></table></figure>

<p>2)IF-THEN-ELSE</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> <span class="type">boolean</span>-expression <span class="keyword">THEN</span></span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">Statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br></pre></td></tr></table></figure>

<p> 3)IF-THEN-ELSIF-ELSE</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> <span class="type">boolean</span>-expression <span class="keyword">THEN</span></span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">ELSIF</span> <span class="type">boolean</span>-expression <span class="keyword">THEN</span></span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">ELSIF</span> <span class="type">boolean</span>-expression <span class="keyword">THEN</span></span><br><span class="line">     statements</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">	statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>; </span><br></pre></td></tr></table></figure>

<p>循环语句<br>1)LOOP 语句</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOOP</span></span><br><span class="line"> statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span> [ label ];</span><br></pre></td></tr></table></figure>

<p>2)EXIT</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOOP</span></span><br><span class="line">	count=count+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">EXIT</span> <span class="keyword">WHEN</span> count &gt;<span class="number">100</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure>

<p>3)CONTINUE</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOOP</span></span><br><span class="line"> 	count=count+<span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">EXIT</span> <span class="keyword">WHEN</span> count &gt; <span class="number">100</span>;</span><br><span class="line"> 	<span class="keyword">CONTINUE</span> <span class="keyword">WHEN</span> count &lt; <span class="number">50</span>;</span><br><span class="line"> 	count=count+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>; </span><br></pre></td></tr></table></figure>

<p> 4)WHILE</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHILE</span> amount_owed &gt; <span class="number">0</span> <span class="keyword">AND</span>  balance &gt; <span class="number">0</span> <span class="keyword">LOOP</span></span><br><span class="line">    <span class="comment">--do something</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure>

<p>5)FOR</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.<span class="number">.10</span> <span class="keyword">LOOP</span></span><br><span class="line">	<span class="keyword">RAISE</span> <span class="keyword">NOTICE</span> <span class="string">&#x27;i IS %&#x27;</span>,i;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"><span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="keyword">REVERSE</span> <span class="number">10.</span>.<span class="number">.1</span>  <span class="keyword">LOOP</span></span><br><span class="line">      <span class="comment">--do something</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure>

<p>遍历查询结果集</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> record_or_row <span class="keyword">IN</span> query <span class="keyword">LOOP</span></span><br><span class="line">     statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span> ;</span><br></pre></td></tr></table></figure>

<p>FOR循环可以遍历命令的结果并操作相应的数据，例如：</p>
<p>编写函数实现对学生表Student的查询结果集数据输出</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> Out_Record() <span class="keyword">returns</span> <span class="type">RECORD</span> <span class="keyword">as</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">declare</span> </span></span><br><span class="line"><span class="language-pgsql">	rec <span class="type">RECORD</span>;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">FOR</span> rec <span class="keyword">IN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">LOOP</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">raise</span> <span class="keyword">notice</span> <span class="string">&#x27;学生数据: %,%&#x27;</span>,rec.studentID,rec.studentName; </span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">return</span> rec;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">end</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span> <span class="keyword">language</span> plpgsql;</span><br></pre></td></tr></table></figure>

<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是特殊类型的存储过程，其过程程序由事件(如INSERT、UPDATE、DELETE操作等）触发而自动执行。</p>
<p>触发器用途:可以实现比约束更复杂的数据完整性，经常用于加强数据的完整性约束和	业务规则。</p>
<p>触发器特点</p>
<ul>
<li>与数据库对象相关:在表或视图上执行DML、DDL操作，其定义的事件触发<br>过程程序执行。</li>
<li>DML事件触发:由执行INSERT、DELETE、UPDATE操作时触发。</li>
<li>DDL事件触发:由执行CRETE、ALTER、DROP、SELECT INTO操作时触发。</li>
</ul>
<p>按DML操作语句分类: INSERT触发器、DELETE触发器、UPDATE触发器<br>按触发器执行次数分类:</p>
<blockquote>
<p>(1）语句级触发器:由关键字FOR EACH STATEMENT声明，在触发器作用的表上执行一条SQL语句时，该触发器程序只执行一次，即使是修改了零行数据的SQL，也会导致相应的触发器执行。FOR EACH STATEMENT为默认值。</p>
<p>(2）行级触发器:由关键字FOR EACH ROW标记的触发器，当触发器所在表中数据发生变化时，每变化一行就会执行一次触发器程序。</p>
</blockquote>
<p>例：学生成绩表上定义了行级DELETE触发器。如果该表删除了20条记录，则将导致DELETE触发器程序被执行20次。</p>
<p>按触发的时间分类:</p>
<blockquote>
<p>(1）BEFORE触发器:在触发事件之前执行触发器程序。<br>(2）AFTER触发器:在触发事件之后执行触发器程序。<br>(3）INSTEAD OF触发器:当触发事件发生后，执行触发器中指定的过程程序，而不是执行产生触发事件的SQL语句。</p>
</blockquote>
<p>触发器相关的特殊变量</p>
<p>1）NEW 数据类型是RECORD。对于行级触发器，它存有INSERT或UPDATE操作产生的新的数据行。对于语句级触发器，它的值是NULL。</p>
<p>2）OLD 数据类型是RECORD。对于行级触发器，它存有被UPDATE或DELETE操作修改或删除的旧的数据行。对于语句级触发器，它的值是NULL。</p>
<p>3）TG_OP 数据类型是text；是值为INSERT、UPDATE、DELETE 的一个字符串，它说明触发器是为哪个操作引发。</p>
<p>创建触发器的基本语法</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TRIGGER</span>  触发器名   </span><br><span class="line">    &#123; <span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span> | <span class="keyword">INSTEAD</span> <span class="keyword">OF</span> &#125;</span><br><span class="line">     <span class="keyword">ON</span> 表名</span><br><span class="line">     [ <span class="keyword">FOR</span> [ <span class="keyword">EACH</span> ] &#123; <span class="keyword">ROW</span> | <span class="keyword">STATEMENT</span> &#125; ]</span><br><span class="line">     <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> 存储过程名 ( 参数列表 )</span><br></pre></td></tr></table></figure>

<p>（1）指明所定义的触发器名<br>（2） BEFORE | AFTER | INSTEAD OF  指明触发器被触发的时间<br>（3） ON 表名 指明触发器所依附的表<br>（4） FOR  EACH  { ROW | STATEMENT }  指明触发器是行级还是列级<br>（5） EXECUTE PROCEDURE 存储过程名 ( 参数列表 )  指明触发时所执行的存储过程</p>
<p>创建触发器的基本步骤</p>
<p>（1）检查数据库中将要创建的触发器所依附的表或视图是否存在，如果不存在，必须首先创建该表或视图。</p>
<p>（2）创建触发器被触发时所要执行的触发器函数，该函数的类型必须是Trigger型，是触发器的执行函数。</p>
<p>（3）创建触发器，定义触发器依附的表，触发器被触发执行的时间，触发器是行级触发器还是语句级触发器，触发器执行需要满足的条件。</p>
<p>为了审计Grade表的课程成绩修改，创建audit_score表记录Grade表的成绩变化，其表结构如下:</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> audit_score( </span><br><span class="line">    changeID <span class="type">serial</span> <span class="keyword">not</span> <span class="keyword">null</span>,						<span class="comment">--修改序列号</span></span><br><span class="line">	username <span class="type">character</span>(<span class="number">20</span>),							<span class="comment">--操作用户</span></span><br><span class="line">	sid	<span class="type">character</span>(<span class="number">13</span>),								<span class="comment">--学号</span></span><br><span class="line">	cid	<span class="type">character</span>(<span class="number">4</span>),								<span class="comment">--课程编号</span></span><br><span class="line">	updatetime <span class="type">text</span>,								<span class="comment">--修改的时间</span></span><br><span class="line">	oldscore <span class="type">int</span>,									<span class="comment">--修改前的成绩</span></span><br><span class="line">	newscore <span class="type">int</span>,									<span class="comment">--修改后的成绩</span></span><br><span class="line">	<span class="keyword">constraint</span> changeID_PK <span class="keyword">primary key</span> (changeID)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建触发器函数</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or replace</span> <span class="keyword">function</span> score_audit() </span><br><span class="line"><span class="keyword">returns</span> <span class="type">trigger</span> <span class="keyword">as</span> $score_audit$</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">TG_OP</span> == <span class="string">&#x27;DELETE&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> audit_score(username,sid,cid,updatetime,oldscore)</span><br><span class="line">		<span class="keyword">select</span> <span class="keyword">user</span>,<span class="built_in">old</span>.studentid,<span class="built_in">old</span>.couseid,now(),<span class="built_in">old</span>.score;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">old</span>;</span><br><span class="line">	<span class="keyword">elsif</span> (<span class="built_in">TG_OP</span> == <span class="string">&#x27;UPDATE&#x27;</span>) <span class="keyword">then</span> </span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> audit_score(username,sid,cid,updatetime,oldscore,newscore)</span><br><span class="line">		<span class="keyword">select</span> <span class="keyword">user</span>,<span class="built_in">old</span>.studentid,<span class="built_in">old</span>.couseid,now(),<span class="built_in">old</span>.score,<span class="built_in">new</span>.score</span><br><span class="line">		<span class="keyword">where</span> <span class="built_in">old</span>.studentid = <span class="built_in">new</span>.sid <span class="keyword">and</span> <span class="built_in">old</span>.courseid = <span class="built_in">new</span>.cid;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span>;</span><br><span class="line">	<span class="keyword">elsif</span> (<span class="built_in">TG_OP</span> == <span class="string">&#x27;INSERT&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> audit_score(username,sid,cid,updatetime,oldscore,newscore)</span><br><span class="line">		<span class="keyword">select</span> <span class="keyword">user</span>,<span class="built_in">new</span>.studentid,<span class="built_in">new</span>.courseid,now(),<span class="keyword">null</span>,<span class="built_in">new</span>.score;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span>;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$score_audit$ <span class="keyword">language</span> plpgsql</span><br></pre></td></tr></table></figure>

<p>创建触发器</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> score_audit_triger</span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">OR</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> grade</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> score_audit();</span><br></pre></td></tr></table></figure>

<p>练习:在如下雇员表emp中被插入或更新一行数据时，触发函数程序将当前用户名和时间标记在该数据行中,并且检查雇员的姓名以及薪水是否为空，若为空，输出警示信息。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">	emplD <span class="type">char</span>(<span class="number">3</span>) <span class="keyword">primary key</span>,</span><br><span class="line">    empname <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	salary <span class="type">integer</span>,</span><br><span class="line">	last_date <span class="type">timestamp</span>,</span><br><span class="line">    last_user <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>1.触发器函数程序</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> emp_stamp ()<span class="keyword">RETURNS</span> <span class="type">trigger</span> <span class="keyword">AS</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">BEGIN</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="comment">--检查给出了empname以及salary</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">IF</span> <span class="built_in">NEW</span>.empname <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span></span><br><span class="line"><span class="language-pgsql">			<span class="keyword">RAISE</span> <span class="keyword">EXCEPTION</span> <span class="string">&#x27;雇员名不能为空&#x27;</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">END</span> <span class="keyword">IF</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">IF</span> <span class="built_in">NEW</span>.salary <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span></span><br><span class="line"><span class="language-pgsql">			<span class="keyword">RAISE</span> <span class="keyword">EXCEPTION</span> <span class="string">&#x27;%薪水不能为空&#x27;</span>,<span class="built_in">NEW</span>.empname;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">END</span> <span class="keyword">IF</span>;</span></span><br><span class="line"><span class="language-pgsql">			<span class="comment">--记住谁在什么时候改变了工资单</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="built_in">NEW</span>.last_date := <span class="built_in">current_timestamp</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="built_in">NEW</span>.last_user := <span class="built_in">current_user</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">RETURN</span> <span class="built_in">NEW</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">END</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span> <span class="keyword">LANGUAGE</span> plpgsql ;</span><br></pre></td></tr></table></figure>

<p>2.触发器定义程序</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> emp_stamp</span><br><span class="line"><span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> emp</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> emp_stamp();</span><br></pre></td></tr></table></figure>

<p>触发器修改</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TRIGGER</span> <span class="type">name</span> <span class="keyword">ON</span> <span class="built_in">table_name</span> <span class="keyword">RENAME</span> <span class="keyword">TO</span> new_name</span><br></pre></td></tr></table></figure>

<p>主要参数说明：<br>（1）name：现有触发器的名称。<br>（2）table_name：该触发器作用的表名字。<br>（3）new_name：触发器的新名字。</p>
<p>例如：将上述定义的触发器改名为score_audit_trig</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TRIGGER</span> score_audit_trigger <span class="keyword">ON</span> stu_score  <span class="keyword">RENAME</span> <span class="keyword">TO</span> score_audit_trig;</span><br></pre></td></tr></table></figure>

<p>触发器删除</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [ <span class="keyword">IF</span> <span class="keyword">EXISTS</span> ] <span class="type">name</span> <span class="keyword">ON</span> <span class="built_in">table_name</span> [ <span class="keyword">CASCADE</span> | <span class="keyword">RESTRICT</span> ]</span><br></pre></td></tr></table></figure>
<p>主要参数说明：</p>
<blockquote>
<p>（1）IF EXISTS：如果指定的触发器不存在，那么发出提示而不是抛出错误。<br>（2）name：要删除的触发器名。<br>（3）table_name：触发器定义所依附的表的名称。<br>（5）CASCADE：级联删除依赖此触发器的对象。<br>（6）RESTRICT：如果有依赖对象存在，那么拒绝删除。该参数缺省是拒绝删除。</p>
</blockquote>
<p> 例如：将上述触发器score_audit_trig删除，同时<em>级联删除</em>依赖触发器的对象。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> score_audit_trig <span class="keyword">ON</span> grade <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure>

<h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><ul>
<li>游标（Cursor）是一种临时的数据库对象；</li>
<li>用来存放从数据库表中查询返回的数据记录；</li>
<li>提供了从结果集中提取并分别处理每一条记录的机制；</li>
<li>游标总是与一条SQL查询语句相关联；</li>
<li>游标包括：SQL语言的查询结果，指向特定记录的指针。</li>
</ul>
<p>声明游标</p>
<blockquote>
<p>使用refcursor关键词定义的游标变量</p>
<p>使用游标声明语句定义游标<br>游标名	CURSOR [ ( arguments ) ] FOR query</p>
</blockquote>
<p>例：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Declare</span></span><br><span class="line">curs	<span class="type">refcursor</span>;</span><br><span class="line">curStudent <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student;</span><br><span class="line">curStudentOne <span class="keyword">CURSOR</span> (key <span class="type">integer</span>)  <span class="keyword">IS</span> </span><br><span class="line">            <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> SID = key;</span><br></pre></td></tr></table></figure>

<p>打开游标<br>（1）OPEN FOR:<br>打开未绑定的游标变量，其query查询语句是返回记录的SELECT语句。例如： </p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> curVars1 <span class="keyword">FOR</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> SID = mykey;</span><br></pre></td></tr></table></figure>

<p>（2）OPEN FOR EXECUTE</p>
<p>打开未绑定的游标变量。EXECUTE将动态执行查询字符串。例如：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> curVars1 <span class="keyword">FOR</span> <span class="keyword">EXECUTE</span> <span class="string">&#x27;SELECT * FROM &#x27;</span> || quote_ident(<span class="meta">$1</span>);</span><br></pre></td></tr></table></figure>

<p>​    注意：$1是指由存储过程传递的第1个参数。<br>（3）打开绑定游标<br>仅适用于绑定的游标变量，只有当该变量在声明时包含接收参数，才能以传递参数的形式打开该游标，参数将传入到游标声明的查询语句中，例如：</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> curStudent;</span><br><span class="line"><span class="keyword">OPEN</span> curStudentOne (<span class="string">&#x27;20160230302001&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>使用游标提取值<br>FETCH命令从游标中读取当前指针所指向记录的数据到目标中。可通过PL&#x2F;pgSQL内置的系统变量FOUND来判断读取是否成功。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> curVars1 <span class="keyword">INTO</span> rowvar;  <span class="comment">--rowvar为行变量</span></span><br><span class="line"><span class="keyword">FETCH</span> curStudent <span class="keyword">INTO</span> SID, Sname, sex;</span><br></pre></td></tr></table></figure>

<p>​    –请注意：游标的属性列必须与 目标列的数量一致，并且类型兼容。<br>关闭游标<br>当游标数据不再需要时，需要关闭游标，以释放其占有的系统资源，主要是释放游标数据所占用的内存资源</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> cursorName; </span><br></pre></td></tr></table></figure>

<p>需要注意：当游标被关闭后，如果需要再次读取游标的数据，需要重新使用open打开游标，这时游标重新查询返回新的结果。</p>
<p>例：在函数中使用游标查询student表的学号、学生姓名和性别。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or replace</span> <span class="keyword">function</span> cursorDemo()</span><br><span class="line"><span class="keyword">returns</span> <span class="type">boolean</span> <span class="keyword">as</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">declare</span></span></span><br><span class="line"><span class="language-pgsql">	unbound_refcursor <span class="type">refcursor</span>;</span></span><br><span class="line"><span class="language-pgsql">	vsid <span class="type">varchar</span>;</span></span><br><span class="line"><span class="language-pgsql">	vsname <span class="type">varchar</span>;</span></span><br><span class="line"><span class="language-pgsql">	vsgender <span class="type">varchar</span>;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">begin</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">open</span> unbound_refcursor <span class="keyword">for</span> <span class="keyword">execute</span> <span class="string">&#x27;select sid,sname,sex from 	student&#x27;</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">loop</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">fetch</span> unbound_refcursor <span class="keyword">into</span> vsid,vsname,vsgender;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">if</span> <span class="built_in">found</span> <span class="keyword">then</span></span></span><br><span class="line"><span class="language-pgsql">			<span class="keyword">raise</span> <span class="keyword">notice</span> <span class="string">&#x27;%,%,%&#x27;</span>,vsid,vsname,vsgender;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">else</span></span></span><br><span class="line"><span class="language-pgsql">			<span class="keyword">exit</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">end</span> <span class="keyword">if</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">end</span> <span class="keyword">loop</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">close</span> unbound_refcursor;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">raise</span> <span class="keyword">notice</span> <span class="string">&#x27;取数据循环结束...&#x27;</span>;</span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">return</span> <span class="keyword">true</span>;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">end</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span> <span class="keyword">language</span> plpgsql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cursorDemo();</span><br></pre></td></tr></table></figure>

<p>例：编写带参数的游标函数，从成绩表中查询分数大于某给定值的学号和课程号。</p>
<figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or replace</span> <span class="keyword">function</span> cusorGrade(myscore <span class="type">int</span>)<span class="keyword">returns</span> <span class="type">void</span> <span class="keyword">as</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">declare</span></span></span><br><span class="line"><span class="language-pgsql">		vstuscore Grade<span class="meta">%ROWTYPE</span>;		<span class="comment">--声明与表Grade结构相同的行变量</span></span></span><br><span class="line"><span class="language-pgsql">		vstucursor <span class="keyword">cursor</span>(invalue <span class="type">int</span>)</span></span><br><span class="line"><span class="language-pgsql">			<span class="keyword">for</span> <span class="keyword">select</span> courseid,studentid,grade <span class="keyword">from</span> Grade <span class="keyword">where</span> 	grade&gt;=invalue <span class="keyword">order</span> <span class="keyword">by</span></span></span><br><span class="line"><span class="language-pgsql">studentid;								<span class="comment">--声明带有输入参数的游标</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">begin</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">open</span> vstucursor (myscore);			<span class="comment">--打开带有参数的游标</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">loop</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">fetch</span> vstucursor <span class="keyword">into</span> vstuscore;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">exit</span> <span class="keyword">when</span> <span class="keyword">not</span> <span class="built_in">found</span> ;			<span class="comment">--假如没有检索到记录，结束循环处理</span></span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">raise</span> <span class="keyword">notice</span> <span class="string">&#x27;%,%,%&#x27;</span>, vstuscore.studentid,vstuscore.courseid,vstuscore.grade;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">end</span> <span class="keyword">loop</span>;</span></span><br><span class="line"><span class="language-pgsql">		<span class="keyword">close</span> vstucursor ;				<span class="comment">--关闭游标</span></span></span><br><span class="line"><span class="language-pgsql">	<span class="keyword">end</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span> <span class="keyword">language</span> plpgsql;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>存储过程和触发器的区别有:存储过程可以采用输入参数而触发器不可以</p>
</li>
<li><p>HTML语句和JSP语句都是下载到浏览器端来执行。X</p>
<p>  凡是使用到了java中的语言部分，一般都是在服务器端执行，解析后返回客户端形成标准的html</p>
</li>
</ul>
<p>Java嵌入SQL语句执行后，返回结果存储在什么对象中：ResultSet</p>
<p>Java嵌入SQL语句，能传递动态参数执行SQL语句查询的是什么接口：PreparedStatement</p>
<p>Java嵌入SQL语句，能调用执行存储过程的是什么接口：CallableStatement</p>
<p>从游标中读取数据，使用什么命令：fetch</p>
<h2 id="第七章-NoSQL数据库技术"><a href="#第七章-NoSQL数据库技术" class="headerlink" title="第七章 NoSQL数据库技术"></a>第七章 NoSQL数据库技术</h2><p>关系数据库局限</p>
<blockquote>
<p>不能直接管理非结构化数据</p>
<p>受单机服务器限制难以支持数据库高并发读写访问</p>
<p>受磁盘容量限制不能满足海量数据的高效存储和处理</p>
<p>难以实现分布式数据库的高扩展性、高可用性</p>
</blockquote>
<p><strong>大数据</strong>(big data)，指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合。</p>
<h3 id="5V特征"><a href="#5V特征" class="headerlink" title="5V特征"></a>5V特征</h3><ul>
<li>大量(Volume)</li>
<li>高速性(Velocity)</li>
<li>多样性（(Variety)</li>
<li>真实性(Veracity)</li>
<li>低价值(Value)</li>
</ul>
<p>(Not only SQL Database，<strong>NoSQL</strong>）是指一类非关系型、开源代码、具有水平扩展能力的分布式数据库。</p>
<p>NoSQL数据库的公共特性:</p>
<blockquote>
<p>支持非结构化数据存储，不用预先定义模式<br>分布式集群架构，无共享结构<br>弹性可扩展，可动态增减数据库结点数据分区存储，各分区结点并发访问<br>结点之间数据异步复制，实现最终数据一致性<br>数据处理遵循BASE特性原则</p>
</blockquote>
<h3 id="BASE特性"><a href="#BASE特性" class="headerlink" title="BASE特性"></a>BASE特性</h3><p>Basically Available（<strong>基本可用</strong>），允许数据库系统某些节点出现故障，其余节点能够继续运行，一直提供服务。<br>Soft state(<strong>软状态</strong>），允许数据库系统副本节点之间存在暂时的数据不一致，经过纠错处理，系统数据最终保持一致态。<br>Eventual Consistency(<strong>最终一致性</strong>），系统数据在某个时刻达到最终一致性。</p>
<p>分布式数据库一致性</p>
<blockquote>
<p>强一致性:无论更新操作在哪一个副本执行，数据复制必须同步完成。</p>
<p>弱一致性:数据更新后，其数据复制是异步完成，需要经过一定时间才能达到不同数据库结点数据一致。</p>
<p>最终一致性:弱一致性的一种特例，保证用户最终能够读取到更新数据。</p>
</blockquote>
<p>NoSQL数据库典型类型：<br><strong>键值数据库</strong>、<strong>图数据库</strong>、<strong>列式数据库</strong>、<strong>文档数据库</strong>。</p>
<p>NoSQL数据库与关系数据库比较</p>
<blockquote>
<p>NoSQL数据库采用非结构化数据存储模型，关系数据库采用结构化数据存储模型<br>NoSQL数据库采用分布式部署，关系数据库一般采用集中式部署<br>NoSQL数据库编程遵循BASE原则，关系数据库编程遵循ACID事务原则<br>NoSQL数据库没有统一的数据操作标准，关系数据库遵循SQL数据操作标准<br>NoSQL数据库支持海量数据存储，关系数据库数据存储受限于TB级</p>
</blockquote>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p><strong>一致性</strong>(Consistency） :不同结点数据库保持一致<br><strong>可用性</strong>(Availability) ：数据访问请求随时可满足<br><strong>分区容忍性</strong>(PartitionTolerance) ：当出现故障结点，系统仍能响应数据访问请求</p>
<p>CAP定理法则:</p>
<p>一个分布式系统不可能同时满足一致性(C:Consistency)、可用性(A: Availability)）和分区容错性(P:Partition tolerance)这三个基本需求，最多只能同时满足其中两项。</p>
<p>CA——放弃分区容错性，保证一致性和可用性，即传统的单机数据库处理方式。<br>AP——放弃强一致性，追求分区容错性和可用性，这是很多分布式系统设计时的选择。例如，一些电商系统采用此方案。<br>CP——放弃可用性，追求一致性和分区容错性。例如，很多NoSQL系统采用这种方案。</p>
<h3 id="四种NoSQL"><a href="#四种NoSQL" class="headerlink" title="四种NoSQL"></a>四种NoSQL</h3><p><strong>列存储数据库</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_14-03-31.png"></p>
<p>关系数据库:按行存储，每行数据存放在一个磁盘数据块</p>
<p>列存储数据库:按列存储，每列数据放到一个数据块中</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_14-03-42.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_14-04-53.png"></p>
<p><strong>键值数据库</strong>(Key-Value Database）是一种按照键值数据表结构组织存储数据的内存数据库。代表<strong>Redis</strong>。</p>
<p><strong>文档数据库</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_14-05-22.png"></p>
<p><strong>图形数据库</strong></p>
<p>代表：Neo4j图形数据库</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-06_14-05-37.png"></p>
<p><strong>NoSQL数据库的四大分类表格分析</strong></p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">Examples举例</th>
<th align="center">典型应用场景</th>
<th align="center">数据模型</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">键值（key-value）</td>
<td align="center">Redis</td>
<td align="center">内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td>
<td align="center">Key 指向 Value 的键值对，通常用hash table来实现</td>
<td align="center">查找速度快</td>
<td align="center">数据无结构化，通常只被当作字符串或者二进制数据</td>
</tr>
<tr>
<td align="center">列存储数据库</td>
<td align="center">Cassandra, HBase</td>
<td align="center">分布式的文件系统</td>
<td align="center">以列簇式存储，将同一列数据存在一起</td>
<td align="center">查找速度快，可扩展性强，更容易进行分布式扩展</td>
<td align="center">功能相对局限</td>
</tr>
<tr>
<td align="center">文档型数据库</td>
<td align="center">CouchDB, MongoDB</td>
<td align="center">Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td>
<td align="center">Key-Value对应的键值对，Value为结构化数据</td>
<td align="center">数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td>
<td align="center">查询性能不高，而且缺乏统一的查询语法。</td>
</tr>
<tr>
<td align="center">图形(Graph)数据库</td>
<td align="center">Neo4J</td>
<td align="center">社交网络，推荐系统等。专注于构建关系图谱</td>
<td align="center">图结构</td>
<td align="center">利用图结构相关算法。比如最短路径寻址，N度关系查找等</td>
<td align="center">很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。</td>
</tr>
</tbody></table>
<p>以下哪一项不是NoSQL的共同特征?(D)</p>
<p>A．分区 B．异步复制	C. BASE	D.CAP</p>
<p>在Neo4J集群中，数据的写入是通过主服务器来完成的，数据的读取可以通过集群中的任意一个Neo4J实例来完成。正确！！</p>
<p><strong>数据库系统面临的挑战</strong>：数据库高并发读写需求；海量数据的高效存储和处理；数据库高扩展性和高可用性需求；数据库在大数据处理方面的要求</p>
<p>以下哪一项不是大数据的特征？高密集价值数据。（是的有：高速产生、规模巨大，多样性）</p>
<p>HBASE中表和区域的关系可以是什么：1：N</p>
<p>以下哪一项不是MongoDB保留数据库：system，（是的有：local、admin、config）</p>
<p>CAP是在分布式环境下设计和部署系统时的3个核心需求。正确！！</p>
<p>Redis复制主要包括RDB复制和AOF复制。正确！！</p>
<p>HBASE中的区域和表的关系是随着数据的增加动态变化的。正确！！</p>
<p>MongoDB的分片是将一个集合的数据分别存储在不同的节点上减轻单机压力。错误</p>
<p>Neo4j的数据物理存储主要分为节点、关系、节点或关系上属性这三类数据存储。！错误</p>
<p>NoSQL数据库分类的依据是对数据的操作方式。错误</p>
<p>Redis数据库的底层实现是字典，对于数据库的增删改查操作都是通过对字典进行操作来实现的。正确！！</p>
<p>HBASE中表定义中要说明行健和表中包含的列族，列不用定义。正确！！</p>
<p>MongoDB复杂文档模型设计可以使用内嵌和引用的方法来解决。正确！！</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>电大软件测试～第三次作业</title>
    <url>/2023/06/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/test3/</url>
    <content><![CDATA[<h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>采用JUnit软件测试框架进行测试程序编程，实现对下面java程序进行单元测试，找出其中缺陷。然后修改缺陷，直到通过单元测试，给出测试程序脚本和运行结果界面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getMax</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get_max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= y) </span><br><span class="line">		max = x;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		max = y;</span><br><span class="line">	<span class="keyword">if</span> (z &gt;= x)</span><br><span class="line">		max = z;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<p>测试程序脚本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> junit.framework.TestCase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getMaxTest</span> <span class="keyword">extends</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       getMax Max=<span class="keyword">new</span> <span class="title class_">getMax</span>();</span><br><span class="line">       <span class="type">int</span> max= Max.get_max(<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>);</span><br><span class="line">       Assert.assertEquals(<span class="number">9</span>,max);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Before</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下是运行结果，发现代码有缺陷：z如果比x大，但比y小，程序会输出z，而实际情况是y最大。</p>
<p><a href="https://imgse.com/i/p9zYRRP"><img src="https://s1.ax1x.com/2023/06/01/p9zYRRP.png" alt="p9zYRRP.png" border="0" /></a></p>
<p>修改缺陷，以下是修改后的源程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getMax</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get_max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= y) </span><br><span class="line">		max = x;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		max = y;</span><br><span class="line">	<span class="keyword">if</span> (z &gt;= max)</span><br><span class="line">		max = z;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>其实就是将其中一个x改成max</strong></em></p>
<p>以下是单元测试通过的界面：</p>
<p><a href="https://imgse.com/i/p9zYoZQ"><img src="https://s1.ax1x.com/2023/06/01/p9zYoZQ.png" alt="p9zYoZQ.png" border="0" /></a></p>
<p>缺陷修改成功。</p>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>采用Postman接口测试软件对百度百科<a href="https://baike.baidu.com/">https://baike.baidu.com/</a>搜索引擎进行接口测试。如对词条“软件工程”返回页面内容进行测试验证，给出请求参数设置、Tests脚本、Body响应结果、Test Results结果说明及运行界面。</p>
<hr>
<p>以下是笔者的分析过程：</p>
<p>​	在百度百科页面搜索软件工程，得到的网址如下：</p>
<p><a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/25279?fromModule=lemma_search-box">https://baike.baidu.com/item/软件工程/25279?fromModule=lemma_search-box</a></p>
<p>如果是常规的get请求（大多数项目开发者会这样设置)，在url里面应该有<u>?word&#x3D;软件工程</u>的字符串（不一定是word这个单词，举这个例子表示形如这个url），但是该链接并不如此。</p>
<p>​	于是猜测是post请求，F12打开开发者工具对输入框进行分析，发现它在form表单里，初步断定是post请求，但是这个表单不是向当前网址提交的，表单的action属性是&#x2F;seach&#x2F;word，所以请求的url应该是其对应的绝对路径（还得拐个弯🥺），为<a href="https://baike.baidu.com/search/word">https://baike.baidu.com/search/word</a></p>
<p><a href="https://imgse.com/i/p9zUnPA"><img src="https://s1.ax1x.com/2023/06/01/p9zUnPA.png" alt="p9zUnPA.png" border="0" /></a></p>
<p><a href="https://imgse.com/i/p9zalWR"><img src="https://s1.ax1x.com/2023/06/01/p9zalWR.png" alt="p9zalWR.png" border="0"></a></p>
<p>​	还要注意到表单的method是GET方法，于是我大胆的猜测get方法也可以，经过postman测试，用get方法向<a href="https://baike.baidu.com/search">https://baike.baidu.com/search</a>也可以达到预期目标。</p>
<p><a href="https://imgse.com/i/p9za3S1"><img src="https://s1.ax1x.com/2023/06/01/p9za3S1.png" alt="p9za3S1.png" border="0"></a></p>
<hr>
<p>答：</p>
<p>请求参数设置</p>
<blockquote>
<p>URL：<a href="https://baike.baidu.com/search/word">https://baike.baidu.com/search/word</a></p>
<p>Method: post</p>
<p>Body：</p>
<p>​	键：word	值：软件工程</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>URL：<a href="https://baike.baidu.com/search">https://baike.baidu.com/search</a></p>
<p>Method：GET</p>
<p>参数：</p>
<p>​	键：word	值：软件工程</p>
</blockquote>
<p>Tests脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;Status code is 200&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">status</span>(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;Response body is not empty&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">body</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;The response contains the word &#x27;软件工程&#x27;&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">response</span>.<span class="title function_">text</span>()).<span class="property">to</span>.<span class="title function_">include</span>(<span class="string">&quot;软件工程&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Body响应结果</p>
<p>把你操作界面的body复制下来就可以啦~内容有很多（毕竟是百度的程序员😎）</p>
<p>Test Results结果</p>
<p><a href="https://imgse.com/i/p9za5pn"><img src="https://s1.ax1x.com/2023/06/01/p9za5pn.png" alt="p9za5pn.png" border="0"></a></p>
<blockquote>
<p>可以看到Status code is 200，Response body is not empty，The response contains the word ‘软件工程’，三次测试全部通过。</p>
</blockquote>
<p>运行界面</p>
<p><a href="https://imgse.com/i/p9zaIlq"><img src="https://s1.ax1x.com/2023/06/01/p9zaIlq.png" alt="p9zaIlq.png" border="0"></a></p>
<p>但是为了图方便感觉用get直接向<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">https://baike.baidu.com/item/软件工程</a>发请求也得行（这样子就少了很多分析啦~)</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试临考总结</title>
    <url>/2023/06/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/test4/</url>
    <content><![CDATA[<p>由于老师明确说不考概念记忆题😆，并且从我们这届开始改版全部是大题😤，所以就不要背那么多干巴巴的知识点啦~，但是一些必要的概念还是得大致知道啥意思吧，以下内容都基于老师发的PPT(●’◡’●)</p>
<h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><p><strong>软件测试(Software Testing）</strong>是一种检测软件的正确性、完整性、安全性和评估其质量的活动过程。换句话说，软件测试是一种以发现程序错误、衡量软件质量为目的，并对其是否满足用户需求进行评估的活动过程。</p>
<p><strong>软件质量保证（Software Quality Assurance，SQA）</strong>是指通过对软件产品进行有计划的评审与审计，来确保软件开发按照产品质量过程标准实施项目的管理活动。</p>
<p>软件质量保证与软件测试的关系：</p>
<blockquote>
<p>SQA指导软件测试的计划与执行，监督测试工作结果的客观性、准确性与有效性，并协助软件测试的工作流程改进。</p>
<p>软件测试是SQA工作落实的重要手段，它为SQA提供所需的质量数据，作为软件质量评价的客观依据。</p>
<p>SQA是一项<em><strong>软件质量管理性工作</strong></em>，侧重于对软件开发流程进行评审与监控。</p>
<p>软件测试是一项<em><strong>技术性工作</strong></em>，侧重于对软件质量特性进行检测与验证。</p>
</blockquote>
<p><strong>测试驱动开发(Test-Driven Development，简称TDD）</strong>是一种不同于传统软件开发流程的过程模型。它要求在编写某个功能的代码之前先编写测试代码，然后编写功能代码，通过测试来推动整个软件开发工作的进行。</p>
<p>下面哪项活动不是软件测试范畴</p>
<p>A．需求文档评审	B.设计评审	C.代码测试	D.过程评审</p>
<blockquote>
<p>过程评审是质量保证活动的一部分，用于评估软件开发过程是否符合既定标准和流程。</p>
</blockquote>
<p>编程完成后才进行测试存在哪些问题?</p>
<blockquote>
<p>测试的时间很有限，很难达到测试的覆盖率要求和测试的质量要求。同时，假如在项目开发的后期，发现一些软件需求阶段和概要设计阶段的错误和问题，修改这些缺陷导致的成本将是非常高的。</p>
</blockquote>
<h2 id="第二章-软件测试基本概念"><a href="#第二章-软件测试基本概念" class="headerlink" title="第二章 软件测试基本概念"></a>第二章 <strong>软件测试基本概念</strong></h2><p><strong>缺陷</strong>(Defect)是指欠缺或不够完备的地方。因为缺陷是相对质量要求而存在的，任何违背了质量要求、违背了客户的意愿，不能满足用户的要求，都可以认为是缺陷。</p>
<p>IEEE STD729关于<strong>软件质量</strong>定义:软件产品或服务满足用户需求的程度。</p>
<blockquote>
<p>①软件缺陷在开发早期出现的概率大，在早期进行缺陷修复的成本低。</p>
<p>②软件在开发后期出现缺陷的概率小，但修复成本高。</p>
<p>③软件测试工作应尽早开展。</p>
</blockquote>
<p><a href="https://smms.app/image/Oc54oYf2KPN81hg" target="_blank"><img src="https://s2.loli.net/2023/06/02/Oc54oYf2KPN81hg.png" ></a></p>
<p>在代码审查中，静态测试可发现如下编程缺陷:</p>
<blockquote>
<p>变量在初始化前使用、变量声明后未使用、变量在两次赋值之间从未使用</p>
<p>数组访问越界</p>
<p>存在不可到达代码</p>
<p>循环中无条件分支</p>
<p>接口参数类型或数目不匹配</p>
<p>空指针或指针类型错误</p>
<p>存在未被调用的函数和过程</p>
</blockquote>
<p>案例一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)attributeList.length();i++)&#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果把判断条件放在for语句内，每一次判断都要重新计算length， 浪费资源</p>
<p>正确代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tmp_iListLength=attributeList.length()</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=O;i&lt;tmp_iListLength; i++)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i ;</span><br><span class="line">...</span><br><span class="line">printf(<span class="string">&quot;i= %d \n&quot;</span>,i) ;</span><br></pre></td></tr></table></figure>

<p>正确代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span> ;</span><br><span class="line">printf (<span class="string">&quot;i= %d \n&quot;</span>,i) ;</span><br></pre></td></tr></table></figure>

<p>案例三</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> array[] = <span class="literal">null</span>; <span class="comment">//声明数组</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//为数组开辟空间，大小为3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= array.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;array[&quot;</span> + i + <span class="string">&quot;]=&quot;</span> + array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺陷应该是数组下标可能越界</p>
<p>个人修改的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> array[] = <span class="literal">null</span>; <span class="comment">//声明数组</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//为数组开辟空间，大小为3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;array[&quot;</span> + i + <span class="string">&quot;]=&quot;</span> + array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例四</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**********计算开始***********&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">// 定义整型变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">//定义整型变量</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> args[<span class="number">0</span>];  <span class="comment">// 接收第一个参数</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> args[<span class="number">1</span>];  <span class="comment">// 接收第二个参数</span></span><br><span class="line">            i = Integer.parseInt(str1);<span class="comment">//将第一个参数由字符串变为整型</span></span><br><span class="line">            j = Integer.parseInt(str2);<span class="comment">//将第二个参数由字符串变为整型</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i / j;           <span class="comment">//进行除法计算</span></span><br><span class="line">            System.out.println(<span class="string">&quot;两个数字相除的结果:&quot;</span> + temp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;<span class="comment">// 捕获算术异常System.out.println(&quot;出现异常了: &quot; + e);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;**********计算结束***********&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的缺陷：</p>
<blockquote>
<ul>
<li>在try块中，使用args数组来接收命令行参数。然而，没有对args数组的长度进行检查或验证。如果没有传递足够的参数，将会导致ArrayIndexOutOfBoundsException(数组索引越界异常)。</li>
<li>在try块中，将args数组的元素作为字符串参数传递给parseInt()方法进行整数转换。然而，如果传递的参数无法解析为整数，将会导致NumberFormatException(数字格式异常)。</li>
<li>在catch块中，捕获了ArithmeticException异常，但是该异常只能捕获除以0导致的算术异常。如果出现其他类型的异常，将无法被捕获和处理。</li>
</ul>
</blockquote>
<p>正确代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;********** 计算开始 ***********&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;缺少必要的参数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i / j;</span><br><span class="line">            System.out.println(<span class="string">&quot;两个数字相除的结果: &quot;</span> + temp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数格式错误: &quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为0: &quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数错误: &quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;********** 计算结束 ***********&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态测试是通过运行被测软件程序，观察该程序在运行过程中的系统行为、变量结果、内存、堆栈等运行数据，来判断软件系统是否存在缺陷的测试活动。<br>动态测试可发现的主要缺陷:</p>
<blockquote>
<p>程序逻辑错误</p>
<p>异常输入的功能失效</p>
<p>空指针使用</p>
<p>内存没有及时释放关闭的对象资源</p>
<p>Session失效</p>
<p>没有处理在空输入时点取Enter键情况</p>
</blockquote>
<p>案例一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name; <span class="comment">// 声明姓名属性</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">// 声明年龄属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tell</span><span class="params">()</span> &#123; <span class="comment">// 取得信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名: &quot;</span> + name + <span class="string">&quot;，年龄: &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明对象</span></span><br><span class="line">        per.name = <span class="string">&quot;张三&quot;</span>; <span class="comment">// 为姓名赋值</span></span><br><span class="line">        per.age = <span class="number">30</span>; <span class="comment">// 为年龄赋值</span></span><br><span class="line">        per.print(); <span class="comment">// 调用方法，打印信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在ClassDemo类的main方法中，创建了一个Person对象per，但没有实际实例化该对象，而是将其初始化为null。这意味着per对象没有被正确地创建和初始化，因此在尝试为per对象的name和age属性赋值时会导致NullPointerException(空指针异常)。<br>在Person类的tell()方法中，打印信息的语句使用了per.print()，但实际上应该调用的是per.tell()，因为tell()方法是定义在Person类的。</p>
</blockquote>
<p>案例二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream os=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    os=<span class="keyword">new</span> <span class="title class_">OutputStream</span>();</span><br><span class="line">      <span class="comment">//Do something with os here.</span></span><br><span class="line">    os.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(os!=<span class="literal">null</span>)</span><br><span class="line">         os.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream os=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    os=<span class="keyword">new</span> <span class="title class_">OutputStream</span>();</span><br><span class="line">      <span class="comment">//Do something with os here.</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(os!=<span class="literal">null</span>)</span><br><span class="line">     os.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的代码使用了 <code>finally</code> 块来确保在无论是否发生异常的情况下都能关闭输出流。</p>
<p><strong>软件验证（(verification）</strong>是指在开发软件过程中，检验软件是否已正确地实现了产品规格说明书所定义的系统功能和特性。<br><strong>软件确认(validation）</strong>是指在开发软件完成后，检查软件产品是否符合用户的真实需求。</p>
<blockquote>
<p>验证:我们正确地构造了产品吗?</p>
<p>确认:我们构造了正确的产品吗?</p>
</blockquote>
<p><em><strong>黑盒测试</strong></em>是指在测试中，把程序看作一个不能打开的黑盒子。在完全不考虑程序内部结构和内部特性的情况下，对程序功能进行测试，检查程序功能是否按照需求规格说明进行有效实现、是否能适当地接收输入数据而产生正确的输出信息。</p>
<p>黑盒测试是从用户观点出发开展的测试，其目的是尽可能发现软件的外部行为错误。黑盒测试常用于发现以下缺陷:</p>
<blockquote>
<p>检测软件是否有错误的功能或有功能遗漏<br>不能正确地接收输入数据、输出错误的结果<br>功能操作不够方便<br>界面出错、扭曲或不美观<br>安装过程中出现问题，安装步骤不清晰、不灵活<br>系统初始化存在问题</p>
</blockquote>
<p><em><strong>白盒测试</strong></em>是指在了解被测程序内部逻辑结构情况下，对该程序的内部变量、逻辑结构、运行路径进行测试，检验被测程序的内部动作或运行功能是否符合设计规格要求。</p>
<p>白盒测试常用于发现以下缺陷:</p>
<blockquote>
<p>程序逻辑错误<br>程序状态异常<br>程序路径无法跳转<br>变量遗漏初始化</p>
</blockquote>
<p><em><strong>单元测试</strong></em></p>
<blockquote>
<p>单元测试针对软件程序中的<strong>最小功能单元代码</strong>（类、函数、模块或组件)进行测试。<br>主要采用白盒测试方法，从程序的内部结构出发设计测试用例，检查单元程序已实现功能与设计规格是否一致、以及编码中是否存在逻辑错误。<br>单元测试一般由编程人员和测试人员共同完成，而以开发人员为主。通常需要编写<strong>驱动模块</strong>和<strong>桩模块</strong>。<br>单元测试还采用代码评审方法（走读、静态分析、评审）检查程序错误，代码评审可以发现程序**50%～70%**代码的缺陷。</p>
</blockquote>
<p><strong>集成测试</strong>（也称组装测试、联合测试）是一种在单元测试的基础上，将若干单元模块按照设计要求组装起来所进行的测试，其目标是发现模块接口相关问题。</p>
<p><strong>系统测试</strong>是在集成测试之后，在系统层面所进行的功能特性测试和非功能特性测试。</p>
<p><strong>验收测试</strong>是在软件提交用户前，在实际用户环境中，验证软件系统功能、性能及其它特性是否符合用户需求。</p>
<ul>
<li>α测试——软件公司在其产品推向市场前，采用实际运行环境和真实数据在软件公司内部进行的验收测试。</li>
<li>β测试——软件公司在其产品推向市场前，还需要在公司外部用户中进行试用测试。通过收集试用户的反馈意见，对该版本软件进行修正与完善，最终得到正式发布的版本。</li>
</ul>
<h2 id="第三章-软件测试方法"><a href="#第三章-软件测试方法" class="headerlink" title="第三章 软件测试方法"></a>第三章 软件测试方法</h2><h3 id="基于直觉和经验的方法"><a href="#基于直觉和经验的方法" class="headerlink" title="基于直觉和经验的方法"></a>基于直觉和经验的方法</h3><blockquote>
<p><strong>Ad-hoc测试方法</strong>强调测试人员更多根据自己的专业经验，不受测试用例约束，放开思路、灵活地进行各种测试。<br><strong>ALAC ( Act-like-a-customer，像客户那样做</strong>）测试方法是一种基于客户使用产品的经验知识进行系统测试，其出发点是应用帕累托(Pareto）二八法则进行重点测试。<br><strong>错误推测法</strong>是测试者根据自己的工作经验、专业知识和直觉来来推测出软件中可能存在的各种错误，从而对被测软件采用针对性的测试。</p>
</blockquote>
<h3 id="基于输入域方法（数据驱动测试）"><a href="#基于输入域方法（数据驱动测试）" class="headerlink" title="基于输入域方法（数据驱动测试）"></a>基于输入域方法（数据驱动测试）</h3><p><em><strong>等价类划分法：</strong></em></p>
<p>一个程序P有两个整型输入变量I1、I2，输出变量为Out,其计算函数为Out&#x3D;P(l1,I2)，假定在字长32位计算机上运行。所有输入数据组合有多少?	<em><strong>2³²x 2³²&#x3D;2⁶⁴</strong></em></p>
<p>例：采购收货单报表系统，要求用户输入处理报表的日期。假定日期限定在2000年1月1日到2023年12月30日。请设计“日期”输入数据验证的等价类。</p>
<blockquote>
<p>有效日期的等价类:2000年1月1日到2023年12月30日的日期值<br>无效日期的等价类:小于2000年1月1日的日期值<br>无效日期的等价类:大于2023年12月30日的日期值</p>
</blockquote>
<p>例：采购收货单报表系统，对于商品数量输入数据，应为大于0的整数，才能符合业务要求。请设计“数量”输入数据验证的等价类。</p>
<blockquote>
<p>有效“数量”字段输入等价类:大于0的整数。<br>无效“数量”字段输入等价类:小于等于0的整数。</p>
</blockquote>
<p>例：航班计划系统，对于某航班设定是否为往返航班，其输入数据应采用布尔数值，才能符合业务要求。请设计“来回程”输入数据验证的等价类。</p>
<blockquote>
<p>有效的“来回程”字段数据输入等价类:真&#x2F;假布尔值。<br>无效的“来回程”字段数据输入等价类:其它任何值。</p>
</blockquote>
<p>例：对于计算器软件的加法运算功能进行测试。请设计“+”功能测试的等价类。</p>
<blockquote>
<p>有效的数据输入等价类:整型数值<br>有效的数据输入等价类:实数数值<br>有效的数据输入等价类:负数数值<br>无效的数据输入等价类:非数字符号</p>
</blockquote>
<p>例:四川地税发票查询页面的发票金额字段输入检查功能测试。</p>
<blockquote>
<p>有效的“发票金额”字段数据输入等价类:大于0的数值数据。<br>无效的“发票金额”字段数据输入等价类:非数值数据。<br>无效的“发票金额”字段数据输入等价类:小于等于0的数值</p>
</blockquote>
<p><em><strong>边界值分析法</strong></em>就是在某个输入变量范围的边界上，输入一些特定数据，分析验证系统功能是否正常运行的测试方法。</p>
<p>例：酒店预订系统业务规定客户最多可提前20天预订酒店客房。请按边界值分析法设计酒店搜索功能的测试用例。</p>
<blockquote>
<p>假定客人在2023-3-12进行订房操作，预订后面10到20天内入住客房，其测试边界值可设置为:2023-3-21、2023-3-31、2023-4-1</p>
</blockquote>
<p>等价类划分法和边界值分析法仅适用于单因素（单变量）输入的数据测试。</p>
<h3 id="基于组合及其优化方法（多变量）"><a href="#基于组合及其优化方法（多变量）" class="headerlink" title="基于组合及其优化方法（多变量）"></a>基于组合及其优化方法（多变量）</h3><p><strong>判定表方法</strong>是一种借助表格方式完成多条件输入组合下测试用例设计，达至完全覆盖输出结果的测试方法。其表格组成样式如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>条件</td>
<td>正确输入年Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>条件</td>
<td>正确输入月M</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>条件</td>
<td>正确输入日D</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>动作</td>
<td>函数运行成功</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>动作</td>
<td>函数运行失败</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p><strong>因果图法</strong>是一种利用图解法分析输入的各种组合情况，从而设计测试用例的形式化方法。它适合于检查程序输入、输出错误，还能判定程序规范中的二义性、不完全性等错误。</p>
<p>因果图PPT上面举了好几页例子，肯定很重要哒~</p>
<p><img src="https://s2.loli.net/2023/06/02/WxI9MwjJepmurfE.png" alt="Snipaste_2023-06-02_15-46-16.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/jCuF49rsNHEm1a5.png" alt="Snipaste_2023-06-02_15-46-38.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/GqM7ES6sPwaBRKt.png" alt="Snipaste_2023-06-02_15-46-47.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/1QmJtbZgpjdr5x7.png" alt="Snipaste_2023-06-02_15-46-56.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/t8moTlbkVwfOLN3.png" alt="Snipaste_2023-06-02_15-47-10.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/L9t3abT6hHxMXNJ.png" alt="Snipaste_2023-06-02_15-48-36.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/2n1okyQVmwI9RrF.png" alt="Snipaste_2023-06-02_15-49-01.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/NWK8wLlgq2Q5AEB.png" alt="Snipaste_2023-06-02_15-50-08.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/CiUFqs6Q2tdLbj4.png" alt="Snipaste_2023-06-02_15-50-14.png"></p>
<p><img src="https://s2.loli.net/2023/06/02/YUzawnXV9oFRgex.png" alt="Snipaste_2023-06-02_15-50-20.png"></p>
<p>当有多个输入变量、每个变量又有多个取值。若要执行全覆盖组合测试，其工作量非常大。为了有效地减少测试组合数，可以采用<strong>成对组合测试方法</strong>，其基本思想是每两个输入变量所有取值组合形成不同测试用例。</p>
<p>例：</p>
<p>测试一个登录页面在不同浏览器和语言下的功能正确性，其输入条件如下:</p>
<p>1）输入项（账号、密码）</p>
<p>2）浏览器（IE、chrome、FireFox、360）</p>
<p>3）语言（中文、英文）</p>
<p>成对组合测试用例表</p>
<table>
<thead>
<tr>
<th>用例</th>
<th>账号</th>
<th>密码</th>
<th>浏览器</th>
<th>语言</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>空值</td>
<td>空值</td>
<td>IE</td>
<td>中文</td>
</tr>
<tr>
<td>2</td>
<td>空值</td>
<td>有值</td>
<td>chrome</td>
<td>英文</td>
</tr>
<tr>
<td>3</td>
<td>有值</td>
<td>空值</td>
<td>FireFox</td>
<td>中文</td>
</tr>
<tr>
<td>4</td>
<td>有值</td>
<td>有值</td>
<td>360</td>
<td>英文</td>
</tr>
<tr>
<td>5</td>
<td>空值</td>
<td>空值</td>
<td>360</td>
<td>中文</td>
</tr>
<tr>
<td>6</td>
<td>空值</td>
<td>有值</td>
<td>FireFox</td>
<td>英文</td>
</tr>
<tr>
<td>7</td>
<td>有值</td>
<td>空值</td>
<td>chrome</td>
<td>中文</td>
</tr>
<tr>
<td>8</td>
<td>有值</td>
<td>有值</td>
<td>IE</td>
<td>英文</td>
</tr>
</tbody></table>
<p><strong>正交实验测试法</strong>是一种依据伽罗华(Galois)理论，从大量实验数据中挑选适量的、具有代表性的数据进行实验，以达到降低实验成本的方法。</p>
<p>正交表构成</p>
<blockquote>
<p>行数:正交表中的行个数，即实验的次数，也是我们通过正交实验法设计的测试用例个数。行数(即&gt;测试用例次数)&#x3D;∑(每列水平数-1)+1</p>
<p>因素数:正交表中列的个数，即测试功能点的因子数。</p>
<p>水平数:任何单个因素能够取值的个数。正交表中包含值为从0到“水平数-1”或从1到“水平数”。即要测试功能点的输入取值数。</p>
<p>L代表正交表，它是运用数学理论在拉丁方和正交拉丁方基础上构造的规格化数据表格，常用的有L₈(2⁷)、L₉(3⁴)、L₁₆(4⁵)等。</p>
</blockquote>
<p>正交表特性</p>
<blockquote>
<p>1)每一列中各数字出现的次数都一样多;<br>2)任何两列所构成的各有序数对出现的次数都一样多。<br>例如在两水平正交表中，任何两列(同一横行内）有序对子共有4种:(1，1)、 (1，2)、(2，1)、 (2，2)。每种对数出现次数相等。在三水平情况下，任何两列(同一横行内）有序对共有9种，1.1、1.2、1.3、<br>2.1、2.2、2.3、<br>3.1、3.2、3.3，且每对出现数也均相等。</p>
</blockquote>
<p> 在一个客户信息查询界面中，输入条件有“姓名”、“身份证号”、“手机”，采用正交表方式设计该界面查询功能的测试用例。</p>
<p>针对本测试有3个输入条件，每个输入有2种取值情况，可以选择L₄(2³)正交表，其正交表值如下表所示：</p>
<table>
<thead>
<tr>
<th>实验数\列号</th>
<th>姓名</th>
<th>身份证号</th>
<th>手机</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>测试用例：</p>
<table>
<thead>
<tr>
<th>测试用例&#x2F;查询条件</th>
<th>姓名</th>
<th>身份证号</th>
<th>手机</th>
</tr>
</thead>
<tbody><tr>
<td>测试用例1</td>
<td>填写</td>
<td>填写</td>
<td>填写</td>
</tr>
<tr>
<td>测试用例2</td>
<td>填写</td>
<td>空</td>
<td>空</td>
</tr>
<tr>
<td>测试用例3</td>
<td>空</td>
<td>填写</td>
<td>空</td>
</tr>
<tr>
<td>测试用例4</td>
<td>空</td>
<td>空</td>
<td>填写</td>
</tr>
</tbody></table>
<h3 id="基于逻辑覆盖方法"><a href="#基于逻辑覆盖方法" class="headerlink" title="基于逻辑覆盖方法"></a>基于逻辑覆盖方法</h3><p><strong>语句覆盖法</strong>的基本思想是设计若干测试用例，使得被测程序中的每个可执行语句至少被执行一次。如果是顺序结构，就是让测试从头执行到尾。如果有分支、条件和循环，则需要执行足够的测试用例覆盖全部语句。</p>
<p><strong>语句覆盖测试能解决的问题</strong>:发现程序中一些永远不能被执行的语句缺陷，但不能发现程序中语句逻辑错误。</p>
<p>语句覆盖测试即使覆盖了程序中每个语句，但并不一定测试覆盖所有分支。试图覆盖程序中所有路径的测试方法称为<strong>路径覆盖</strong>。路径测试的最简单形式就是<strong>判定覆盖测试</strong>。<br><strong>判定覆盖测试基本思想</strong>:设计若干用例，运行被测程序，使得程序中每个判断语句的取真分支和取假分支至少执行一次，即判断真假值均可被满足。一个判定往往代表程序的一个分支，所以判定覆盖测试也称为<strong>分支覆盖测试</strong>。</p>
<p>判定覆盖测试能发现程序中一些永远不能被执行的分支缺陷，可以发现部分逻辑缺陷。</p>
<p><strong>条件覆盖</strong>的基本思想是设计若干测试用例，使其对被测程序进行测试，使每个判断中每个条件的可能取值至少满足一次。</p>
<p>符合条件覆盖的测试用例并不一定满足判定覆盖要求，反之，符合判定覆盖的测试用例也不一定满足条件覆盖要求。因此，需要找出符合两者的测试用例交集，该方法称为<strong>判定-条件覆盖</strong>。</p>
<p><strong>条件组合覆盖</strong>的基本思想是设计足够的测试用例，使得判断中每个条件的所有取值情况至少出现一次，并且每个判断本身的判定结果也至少出现一次。条件组合测试不一定能覆盖所有路径。</p>
<p><strong>基本路径覆盖</strong>就是设计测试用例，覆盖程序中所有可能的基本分支路径。<br>基本路径覆盖局限:不能保证覆盖所有条件组合</p>
<p>基本路径覆盖测试用例设计步骤:</p>
<blockquote>
<p>依据代码绘制流程图<br>确定流程图的环路复杂度<br>确定各个独立路径的基本集合<br>设计测试用例覆盖每条基本路径</p>
</blockquote>
<p>计算环路复杂度：</p>
<blockquote>
<p>（1）流图中的区域数等于环形复杂度。<br>（2）流图G的环形复杂度V(G)&#x3D;E-N+2，其中，E是流图中边的条数，N是结点数。<br>（3）流图G的环形复杂度V(G)&#x3D;P+1，其中，P是流图中判定结点的数目。</p>
</blockquote>
<h2 id="第四章-测试流程和规范"><a href="#第四章-测试流程和规范" class="headerlink" title="第四章  测试流程和规范"></a>第四章  测试流程和规范</h2><p>软件测试过程：</p>
<p>软件工程角度<br>需求评审→设计评审→单元测试→集成测试→系统测试→验收测试</p>
<p>项目管理角度<br>测试计划→测试设计→执行与监控→结果分析与评估→项目总结</p>
<p><strong>敏捷测试</strong>（自动化测试）是一种遵从敏捷软件开发原则，支持敏捷软件开发实现质量控制的测试实践。<br><strong>TMap</strong> (Test Management Approach，测试管理方法)是一种业务驱动的、基于风险策略的、结构化的测试管理方法，其目标是尽早地发现缺陷，以最小的成本、有效地、彻底地完成测试任务，以减少软件发布后的支持成本。</p>
<p><strong>基于脚本测试</strong>(Scripted Testing，ST），无论是手工测试，还是自动化测试，都需要先设计用例，生成测试脚本，然后执行脚本实施测试。<br><strong>探索式测试</strong>(Exploratory Testing，ET），不需要设计用例，一边思考，一边测试。<br><em><strong>在敏捷测试中，则主要采用探索式测试，基于脚本测试则作为补充</strong></em>;而在传统测试中，主要采用基于脚本测试，探索式测试作为补充。</p>
<h2 id="第五章-单元测试与集成测试"><a href="#第五章-单元测试与集成测试" class="headerlink" title="第五章 单元测试与集成测试"></a>第五章 单元测试与集成测试</h2><p><strong>单元静态测试</strong>是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。主要采用互查、走查、评审方法进行测试，也可通过代码缺陷扫描工具进行分析处理。</p>
<p>代码示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过用户UI界面输入的用户名，传递到Action层，进行用户角色识别操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request HttpServletRequest对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 用户角色，如管理员/普通用户/...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserRole</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userRole</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">&quot;schadmin&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 这是系统初始化时默认的管理员账号，如果是，则进行以下验证操作...      </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非系统初始化的账号，进行以下验证操作...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> userRole;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>userName可能会出现空指针情况</p>
<p>修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过用户UI界面输入的用户名，传递到Action层，进行用户角色识别操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request HttpServletRequest对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 用户角色，如管理员/普通用户/...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserRole</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userRole</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;schadmin&quot;</span>.equals(userName)) &#123;</span><br><span class="line">        <span class="comment">// 这是系统初始化时默认的管理员账号，如果是，则进行以下验证操作...      </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非系统初始化的账号，进行以下验证操作...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> userRole;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过用户输入的年龄，转换为数值型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request HttpServletRequest对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer 用户年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUserAge</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userAge</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userAge&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (userAge != <span class="literal">null</span>) &#123;</span><br><span class="line">        age = Integer.parseInt(userAge);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>userAge可能不是字符型数字。</p>
<p>建议写一个Util工具类，实现一些常见的数据转换方法，以供调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入的字符串转换为整型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intStr String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIntValue</span><span class="params">(String intStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parseInt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isNumeric(intStr)) &#123;</span><br><span class="line">        parseInt = Integer.parseInt(intStr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parseInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设电话号码字符串设计的标准格式为: 国家编码-区位号码-电话号码-分机号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> strPhoneNumber String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 电话号码 (如: 例子中的2313222)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPhoneNumber</span><span class="params">(String strPhoneNumber)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strPhoneNumber == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(strPhoneNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String[] arrPhone = strPhoneNumber.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arrPhone[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能出现数组越界错误。</p>
<p>修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPhoneNumber</span><span class="params">(String strPhoneNumber)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strPhoneNumber == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(strPhoneNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String[] arrPhone = strPhoneNumber.split(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arrPhone.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arrPhone[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeString</span><span class="params">(File file, String writeContent, String encoding)</span> <span class="keyword">throws</span> FileOperatorException &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        fos.write(writeContent.getBytes(encoding));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileOperatorException</span>(ex);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeString</span><span class="params">(File file, String writeContent, String encoding)</span> <span class="keyword">throws</span> FileOperatorException &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        fos.write(writeContent.getBytes(encoding));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileOperatorException</span>(ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">//如果没有finally下面的段语句，就无法释放文件资源</span></span><br><span class="line">         <span class="keyword">if</span> (fos != <span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileOperatorException</span>(e);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了确保代码在运行可靠、功能正确并且能够有良好的性能响应，仅仅进行静态测试是不够的，必须将该单元代码运行起来，验证代码业务逻辑合理性，并了解单元代码的实际表现，即对单元代码进行<strong>动态测试</strong>。</p>
<p>动态测试实现原理</p>
<blockquote>
<p>驱动程序(Driver)<br>被测单元(Unit)<br>桩程序(Stub)</p>
</blockquote>
<p>桩模块和驱动模块的概念搞不清楚，那么下面来介绍这两个概念： </p>
<blockquote>
<p>　　假设现在项目组把任务分给了7个人，每个人负责实现一个模块。你负责的是B模块，你很优秀，第一个完成了编码工作，现在需要开展单元测试工作，先分析结构图：<br>　　1、由于B模块不是最顶层模块，所以它一定不包含main函数(A模块包含main函数)，也就不能独立运行。<br>　　2、B模块调用了D模块和E模块，而目前D模块和E模块都还没有开发好，那么想让B模块通过编译器的编译也是不可能的。<br>　　那么怎样才能测试B模块呢?需要做：<br>　　1、写两个模块Sd和Se分别代替D模块和E模块(函数名、返回值、传递的参数相同)，这样B模块就可以通过编译了。Sd模块和Se模块就是桩模块。<br>　　2、写一个模块Da用来代替A模块，里面包含main函数，可以在main函数中调用B模块，让B模块运行起来。Da模块就是驱动模块。<br>　　桩模块的使命除了使得程序能够编译通过之外，还需要模拟返回被代替的模块的各种可能返回值(什么时候返回什么值需要根据测试用例的情况来决定)。<br>　　驱动模块的使命就是根据测试用例的设计去调用被测试模块，并且判断被测试模块的返回值是否与测试用例的预期结果相符</p>
</blockquote>
<p>集成测试模式:</p>
<blockquote>
<p><strong>非渐增式集成测试</strong><br>先分别测试每个模块，再把所有模块按设计要求组装在一起，然后再进行集成程序的测试。<br><strong>渐增式集成测试</strong><br>把下一个待测试的模块同已经测试好的模块结合起来进行测试，测试完以后再把下一个待测试模块结合进来测试。</p>
</blockquote>
<p><a href="https://smms.app/image/rnOYwCVIDNeBuol" target="_blank"><img src="https://s2.loli.net/2023/06/02/rnOYwCVIDNeBuol.png" alt="HU3PI_3`VKVH_46F9W_GL_4.png"></a></p>
<p><img src="https://s2.loli.net/2023/06/02/qkVeM75SoWYvXg4.png" alt="E_Y5_DZ_B7D_8_Y_B__R_Q8.png"></p>
<p>以上两种测试模式都属于渐增式集成测试。</p>
<p>针对叶节点模块进行单元测试，下面哪项不是必须的?<br>A.测试数据	B.被测单元	C.驱动程序	D.桩程序</p>
<blockquote>
<p>然而，对于叶节点模块的单元测试而言，通常不需要使用桩程序。叶节点模块是指在软件系统中没有其他依赖的最底层模块，也被称为叶子节点或叶子模块。由于它们不依赖其他模块或外部系统，所以不需要模拟或替代任何外部依赖项的行为。</p>
</blockquote>
<h2 id="第六章-系统测试"><a href="#第六章-系统测试" class="headerlink" title="第六章 系统测试"></a>第六章 系统测试</h2><p><strong>功能测试</strong>就是对软件系统的各功能进行验证，根据系统功能需求，逐项测试系统功能是否达到用户要求。</p>
<p><strong>回归测试</strong>是指修改了源代码后，重新进行系统功能测试以确认修改没有引入新的错误或导致其他代码产生错误（<strong>回归缺陷</strong>）。</p>
<p><strong>性能测试</strong>是一种为了发现系统性能问题或获取系统性能相关指标而进行的测试。一般在真实环境、特定负载条件下，通过测试工具模拟实际软件系统的运行及其操作，同时监控性能各项指标，最后对测试结果进行分析来确定系统的性能状况。</p>
<p>常见系统性能问题</p>
<blockquote>
<p>资源耗尽:CPU使用率达到100%<br>资源泄露:内存泄露导致资源耗尽<br>资源瓶颈:缺少可用线程、DB连接资源</p>
</blockquote>
<p><strong>负载测试</strong>（Load Test）：负载测试是一种性能测试，指数据在超负荷环境中运行，程序是否能够承担。 关注点：how much</p>
<p><strong>压力测试</strong>（Stress Test）： 压力测试（又叫强度测试）也是一种性能测试，它在系统资源特别低的情况下软件系统运行情况，目的是找到系统在哪里失效以及如何失效的地方。</p>
<p><strong>容量测试</strong>(Volume Test)：确定系统可处理同时在线的最大用户数 关注点：how much（而不是how fast） 容量测试，通常和数据库有关，容量和负载的区别在于：容量关注的是大容量，而不需要关注使用中的实际表现。</p>
<p>其中，容量测试、负载测试、压力测试的英文解释为：</p>
<blockquote>
<p>Volume Testing &#x3D; Large amounts of data<br>Load Testing &#x3D; Large amount of users<br>Stress Testing &#x3D; Too many users, too much data, too little time and too little room</p>
</blockquote>
<p>假设一个业务系统有1万个注册用户，每天有1半用户会在上班时间（8小时)访问该系统，平均在线时间为1个小时。那么访问该系统的上班时间平均每分钟在线用户数为多少?<br>5000×60&#x2F;(8×60)&#x3D;625</p>
<p><img src="https://s2.loli.net/2023/06/02/TSQZBrG6hRD1NCn.png" alt="Y_TBOAQ0UR1TJ27T2@S4SQY.png"></p>
<p><strong>容错性测试</strong>是检查系统容错能力，即系统在异常条件下自身是否具有防护性的措施或者某种灾难性恢复的手段。</p>
<p><strong>兼容性测试</strong>是指测试软件在特定的硬件平台上、不同的应用软件之间、不同的操纵系统平台上、不同的网络等环境中是否能够很友好的运行。</p>
<p><strong>软件可靠性</strong>是指软件系统在规定时间内及规定环境条件下，完成特定功能的能力。</p>
<p>软件可靠性评估：<br>MTTF (Mean Time To Failure)——系统平均无故障时间</p>
<p>MTTR (Mean Time To Recover)——故障平均修复时间</p>
<p>可用性度量&#x3D; MTTF &#x2F; (MTTF+MTTR）<br>例:如果系统每运行100个时间单位，会有1个时间单位无法提供服务，其系统的可用性是99%。</p>
<p>下面哪项不是系统性能降低的原因?<br>A．资源耗尽	<em><strong>B．响应时间慢</strong></em>	C．内存泄漏	D．网络拥挤</p>
<h2 id="第七章-验收测试"><a href="#第七章-验收测试" class="headerlink" title="第七章 验收测试"></a>第七章 验收测试</h2><p><strong>验收测试</strong>是在软件产品完成了系统测试之后、产品发布之前所进行的软件测试活动，它是软件测试的最后一个阶段，也称<strong>交付测试</strong>。</p>
<p>有些内容在第二章说到啦！</p>
<h2 id="第八章-软件本地化测试"><a href="#第八章-软件本地化测试" class="headerlink" title="第八章 软件本地化测试"></a>第八章 软件本地化测试</h2><p><strong>软件本地化</strong>是指将某软件产品的用户界面、文档资料、在线帮助等从其源语言向目标语言进行转化，使之适应目标语言及文化的处理过程。</p>
<p><strong>软件国际化</strong>是指为保证所开发软件产品能适应国际市场需要，通过特定的系统架构设计、代码编程技术支持软件能在不同语言、不同文化的国家及地区使用，使其在进行本地化时不需要修改软件的程序代码。</p>
<p><strong>软件本地化测试</strong>是根据软件本地化开发完成后，设计测试用例，并利用这些测试用例去运行被测试软件，以发现软件程序缺陷的过程。（含<strong>翻译验证</strong>）</p>
<h2 id="第九章-测试自动化及其框架"><a href="#第九章-测试自动化及其框架" class="headerlink" title="第九章 测试自动化及其框架"></a>第九章 测试自动化及其框架</h2><p><strong>自动化测试</strong>是指采用测试工具实现程序驱动替代人驱动所开展的软件测试活动。测试自动化除包括自动化测试之外，还包括测试辅助工作的自动化。</p>
<p>自动化测试不能完成下面哪项质量指标测试?</p>
<p>A.正确性	B.可靠性	C.性能效率 	D.易用性</p>
<p>自动化测试可以用于测试正确性、可靠性和性能效率等质量指标，但对于易用性的测试则相对有限。易用性通常涉及到用户界面的可操作性、用户体验和用户友好性等方面，这些特征难以完全通过自动化测试来覆盖和评估。易用性测试通常需要人工参与，通过用户实际操作和反馈来评估系统的易用性。</p>
<p><strong>JUnit</strong>是一种白盒测试工具，因为它主要用于单元测试，可以直接访问和测试代码的内部结构和逻辑。它通常用于Java开发环境中，用于测试Java应用程序的各个单元和模块。<strong>UFT</strong>（Unified Functional Testing）是一种黑盒测试工具，用于功能测试和自动化测试。它主要用于测试应用程序的外部行为和用户界面，而不需要了解应用程序的内部实现。<br><strong>Load Runner</strong>是一种性能测试工具，用于测试应用程序在负载和压力条件下的性能表现。它通常用于模拟多个用户同时访问应用程序，以评估其性能和可靠性。<br><strong>Selenium</strong>是一种自动化测试工具，主要用于Web应用程序的功能测试和回归测试。它可以模拟用户操作和交互，并对应用程序的用户界面进行测试。由于它主要关注应用程序的外部行为，因此它也被归类为黑盒测试工具。</p>
<h2 id="第十章-测试需求分析与测试计划"><a href="#第十章-测试需求分析与测试计划" class="headerlink" title="第十章 测试需求分析与测试计划"></a>第十章 测试需求分析与测试计划</h2><p>功能测试范围</p>
<blockquote>
<p>页面链接:页面是否存在、页面是否正确跳转<br>控件功能:按钮功能是否正确、列表内容是否正确、光标位置移动是否顺序正确<br>输入文本框:数据格式、数据类型、数据长度是否检查<br>Web图形测试:图片文字提示是否正确、图片链接是否正确、图片在不同分辨率下显示是否正确<br>表单测试:请求是否响应、脚本是否正确执行</p>
</blockquote>
<p>非功能测试范围。</p>
<blockquote>
<p>性能测试——响应时间、吞吐量等<br>安全测试——用户验证、授权访问、数据安全等<br>容错测试——部件损坏后系统仍正常运行能力<br>兼容性测试——硬件兼容性、操作系统兼容性、浏览器兼容性·可伸缩性测试——增加容量的能力<br>可用性测试——正常运行时间&#x2F;总运行时间</p>
</blockquote>
<h2 id="第十一章-软件质量保证"><a href="#第十一章-软件质量保证" class="headerlink" title="第十一章 软件质量保证"></a>第十一章 软件质量保证</h2><p><strong>软件度量</strong>是根据一定规则对软件项目、软件过程、软件产品进行数据定义、数据收集及量化处理，其目的是为了清晰地理解、预测、评估、控制和改善软件质量。</p>
<p><img src="https://s2.loli.net/2023/06/02/sZKupSB7FxJXjwI.png" alt="NK38BB~K_`__MF0`3SH_VC9.png"></p>
<p><a href="https://smms.app/image/VIRA859hNGcTP1H" target="_blank"><img src="https://s2.loli.net/2023/06/02/VIRA859hNGcTP1H.png" alt="_RF_ABD_90`8@LYLXYP4R@A.png"></a></p>
<p><a href="https://smms.app/image/1rZ85Mps9dmJN3z" target="_blank"><img src="https://s2.loli.net/2023/06/02/1rZ85Mps9dmJN3z.png" alt="_Q1DGL`_SUS_P_RW~_TX6_N.png"></a></p>
<p>再举个上机考试考的题吧，细思也不是不能出大题：</p>
<p>针对如下Java程序进行单元测试，找出该程序的缺陷。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对传入参数telCode（电话号码）进行处理，从中提取该电话号码的座机号码，并将其输出返回。 </span></span><br><span class="line"><span class="comment"> * 例如，输入电话号码为“86,28,83202112”， 返回值应为“83202112” */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getPhoneNo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getPhoneNumber</span><span class="params">(String telCode)</span> &#123; </span><br><span class="line">	  <span class="keyword">if</span> (telCode == <span class="literal">null</span> ) &#123; </span><br><span class="line">	    <span class="keyword">return</span> <span class="string">&quot;输入了空字符串&quot;</span>;&#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">		String localPhone[] = telCode.split(<span class="string">&quot;,&quot;</span>); </span><br><span class="line">		<span class="keyword">return</span> localPhone[<span class="number">2</span>]; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设计单元测试用例表，在该表中填写测试用例的输入数据和预期结果数据。</p>
<table>
<thead>
<tr>
<th>用例</th>
<th>telCode值</th>
<th>预期结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>86,28,83202112</td>
<td>83202112</td>
</tr>
<tr>
<td>2</td>
<td>Null</td>
<td>输入了空字符串</td>
</tr>
<tr>
<td>3</td>
<td>空格</td>
<td>输入电话号码格式错误</td>
</tr>
<tr>
<td>4</td>
<td>86,83202112</td>
<td>输入电话号码格式错误</td>
</tr>
<tr>
<td>5</td>
<td>86,28,83202112%</td>
<td>输入电话号码格式错误</td>
</tr>
</tbody></table>
<p>缺陷如下：</p>
<ol>
<li><p>电话号码为空时无法提示输入了空字符串。</p>
</li>
<li><p>电话号码输入为空格，或者其位数不符合要求，该程序报错而无法继续运行，应该提示输入电话号码格式错误。</p>
</li>
<li><p>当电话号码含有非法字符，该程序没有提示输入了非法字符，而是继续输出了非法字符，应该提示输入电话号码格式错误才对。</p>
</li>
</ol>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getPhoneNoTest_83202112</span> &#123;</span><br><span class="line">    getPhoneNo getPhoneNo=<span class="keyword">new</span> <span class="title class_">getPhoneNo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNo1</span><span class="params">()</span> &#123;</span><br><span class="line">        String expectedResult=<span class="string">&quot;83202112&quot;</span>;</span><br><span class="line">        assertEquals(expectedResult,getPhoneNo.getPhoneNumber(<span class="string">&quot;86,28,83202112&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNo2</span><span class="params">()</span> &#123;</span><br><span class="line">        String expectedResult=<span class="string">&quot;输入了空字符串&quot;</span>;</span><br><span class="line">        assertEquals(expectedResult,getPhoneNo.getPhoneNumber(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNo3</span><span class="params">()</span> &#123;</span><br><span class="line">        String expectedResult=<span class="string">&quot;输入电话号码格式错误&quot;</span>;</span><br><span class="line">        assertEquals(expectedResult,getPhoneNo.getPhoneNumber(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNo4</span><span class="params">()</span> &#123;</span><br><span class="line">        String expectedResult=<span class="string">&quot;输入电话号码格式错误&quot;</span>;</span><br><span class="line">        assertEquals(expectedResult,getPhoneNo.getPhoneNumber(<span class="string">&quot;86,83202112&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPhoneNo5</span><span class="params">()</span> &#123;</span><br><span class="line">        String expectedResult=<span class="string">&quot;输入电话号码格式错误&quot;</span>;</span><br><span class="line">        assertEquals(expectedResult,getPhoneNo.getPhoneNumber(<span class="string">&quot;86,28,83202112%&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的源程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getPhoneNo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhoneNumber</span><span class="params">(String telCode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (telCode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;输入了空字符串&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String localPhone[] = telCode.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (localPhone.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;输入电话号码格式错误&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> localPhone[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; phoneNumber.length(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> phoneNumber.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> ||c &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;输入电话号码格式错误&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> phoneNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之操作系统引论</title>
    <url>/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4/</url>
    <content><![CDATA[<ul>
<li>操作系统定义</li>
</ul>
<p>操作系统是一组<strong>控制和管理计算机软硬件资源</strong>、<strong>合理地对各类作业进行调度以及方便用户使用</strong>的程序集合。</p>
<p>操作系统是 位于硬件层(HAL)之上，所有其它系统软件层之下的一个<strong>系统软件</strong>，使得管理系统中的各种软件和硬件资源得以充分利用，方便用户使用计算机系统。</p>
<ul>
<li>OS的目标</li>
</ul>
<p><strong>方便性</strong>: 操作系统使计算机更易于使用。 </p>
<p><strong>有效性</strong>: 操作系统允许以更有效的方式使用计算机系统资源。 提高系统资源利用率 、提高系统的吞吐量。 </p>
<p><strong>可扩展性</strong>: 在操作系统中,允许有效地开发，测试和引进新的系统功能。 </p>
<p><strong>开放性</strong>: 实现应用程序的可移植性和互操作性,要求具有统一 的开放的环境。</p>
<p>其中有效性，可扩展性最重要。</p>
<ul>
<li>OS的作用</li>
</ul>
<p>1.作为用户与计算机硬件系统之间的接口</p>
<p>2.作为计算机系统资源的管理者(软硬件资源)</p>
<p>3.作为扩充机器</p>
<ul>
<li>OS的特征</li>
</ul>
<p>1、并发性（最重要的特征） 2、共享性 3、虚拟性 4、异步性</p>
<p><strong>并发是最重要的特征</strong>，其它特征都以并发为前提。其中最基本特征是<strong>并发和共享</strong>。</p>
<ul>
<li>OS的主要功能</li>
</ul>
<p>1、处理机管理（CPU）</p>
<p>2、存储器管理</p>
<p>3、设备管理</p>
<p>4、文件管理</p>
<p>5、方便用户使用的用户接口。</p>
<ul>
<li>OS的基本类型</li>
</ul>
<p><strong>批处理操作系统、分时操作系统和实时操作系统。</strong></p>
<ul>
<li>批处理、分时、实时系统（比较）</li>
</ul>
<p>批处理系统(batchprocessingsystem):操作员把用户提交的作业分类,把一批作业编成一个作业执行序列,由专门编制的监督程序(monitor)自动依次处理。其主要特征是:用户脱机使用计算机、成批处理、多道程序运行。</p>
<p>分时系统(timesharingoperationsystem):把处理机的运行时间分成很短的时间片,按时间片轮转的方式,把处理机分配给各进程使用。其主要特征是交互性、多用户同时性、独立性。</p>
<p>所谓“实时”，是表示“及时”，而实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的运行。其特征主要体现在实时控制和实时信息处理。</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之输入输出系统</title>
    <url>/2023/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2/</url>
    <content><![CDATA[<h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><p>​	输入输出系统是计算机系统中的主机与外部进行通信的系统。在计算机系统中，通常把处理机和主存储器之外的部分称为输入输出系统，输入输出系统的特点是异步性、实时性和设备无关性。</p>
<h2 id="I-x2F-O系统简介"><a href="#I-x2F-O系统简介" class="headerlink" title="I&#x2F;O系统简介"></a>I&#x2F;O系统简介</h2><p>​	<strong>设备管理的对象</strong>：主要是I&#x2F;O设备。<br>​	<strong>设备管理的基本任务</strong>：完成用户提出的I&#x2F;O请求，提高I&#x2F;O速率以及改善I&#x2F;O设备的利用率。<br>​	<strong>设备管理的主要功能有</strong>：缓冲区管理、设备分配、设备处理、虚拟设备及实现设备独立性等。</p>
<p>​	I&#x2F;O设备类型繁多，按设备的<strong>共享属性</strong>分类，可以分为三类，<strong>独占设备</strong>，在一段时间内只允许一个用户（进程）访问的设备，即临界资源。<strong>共享设备</strong>，在一段时间内允许多个进程同时访问的设备，当然，每一时刻仍然只允许一个进程访问，如磁盘（可寻址和可随机访问）。<strong>虚拟设备</strong>，通过虚拟技术将一台设备变换为若干台逻辑设备，供若干个用户（进程）同时使用。</p>
<p><strong>I&#x2F;O 系统的基本功能</strong></p>
<ol>
<li>设备分配</li>
<li>设备映射</li>
<li>设备驱动</li>
<li>I&#x2F;O缓冲区的管理</li>
</ol>
<p><strong>通用设备管理分层模型</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_20-16-19.png"></p>
<p>​	通常，设备并不是直接与CPU进行通信，而是与设备控制器通信，因此，在I&#x2F;O设备中应该含有与设备控制器之间的接口，在该接口有三种类型的信号，各对应一条信号线。</p>
<p>　① 数据信号线，用于在设备控制器之间传送数据信号，<em>对于输入设备而言</em>，由外界输入的信号经转换器转换后所形成的数据，通常先送入缓冲器中，当数量达到一定的比特（字符）数后，再从缓冲器通过一组信号线传送给设备控制器。<em>对输出设备而言</em>，则先将从设备控制器经过数据信号线传送来的一批数据先暂存于缓冲器中，经转换器做适当转换后，再逐个字符地输出。</p>
<p>　② 控制信号线，作为由设备控制器向I&#x2F;O设备发送控制信号时的通路，该信号规定了设备将要执行的操作，如读操作（指由设备向控制器传送数据）或写操作（由控制器接受数据），或执行磁头移动等操作。</p>
<p>　③ 状态信号线，用于传送设备当前状态的信号，设备的当前状态有正在读（或写）；设备已读（写）完成，并准备好新的数据传送。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628151650952-1466573946.png"></p>
<p><em><strong>设备控制器</strong></em>是计算机中的一个实体，其<strong>主要职责</strong>是<em><strong>控制一个或多个I&#x2F;O设备</strong></em>，以实现I&#x2F;O设备和计算机之间的数据交换，它是CPU与I&#x2F;O设备之间的接口，它接收从CPU发来的命令，并去控制I&#x2F;O设备工作，以使处理从繁杂的设备控制事务中解脱出来。它是一个可编址的设备，当它仅控制一个设备时，它只有一个唯一的设备地址，若控制器可连接多个设备时，则应该含有多个设备地址，并使每个设备地址对应一个设备。</p>
<p>在控制器中设置一状态寄存器，用其中的每一位来反映设备的某一种状态，当CPU将该寄存器的内存读入后，便可了解该设备的状态。<strong>I&#x2F;O逻辑</strong>，用于实现对设备的控制，通过一组控制线与处理机交互，处理机利用该逻辑向控制器发送I&#x2F;O命令，I&#x2F;O逻辑对收到的命令进行译码，每当CPU要启动一个设备时，<em>一方面将启动命令发送给控制器</em>，<em>另一方面又同时通过地址线把地址发送给控制器</em>，由控制器的I&#x2F;O逻辑对收到的地址进行译码，再根据所译出的命令对所选设备进行控制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_20-34-48.png"></p>
<p> <em><strong>I&#x2F;O通道</strong></em></p>
<p>　虽然在CPU与I&#x2F;O设备之间增加了设备控制器后，可以大大减少CPU对I&#x2F;O的干预，但是当主机所配置的外设很多时，CPU的负担仍然很重，因此，在CPU和设备控制器之间又增设了通道。其主要目的使一些原来由CPU处理的I&#x2F;O任务转由通道来承担，从而把CPU从繁杂的I&#x2F;O任务中解脱出来。在设置了通道后，<strong>CPU只需要向通道发送一条I&#x2F;O指令，通道在收到该指令后，便从内存中取出本次要执行的通道程序，然后执行该通道程序，仅当通道完成了规定的I&#x2F;O任务后，才向CPU发中断信号</strong>。I&#x2F;O通道是一种特殊的处理机，<em>具有执行I&#x2F;O指令的能力</em>，并通过执行通道（I&#x2F;O）程序来控制I&#x2F;O操作，但I&#x2F;O通道与一般的处理机不同，因为其指令类型单一同时没有自己的内存，<em>与CPU共享主内存</em>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_20-35-21.png"></p>
<p>虚拟设备是指被多个用户或进程交替使用的设备，宏观上好象多个用户同时在使用。(×）</p>
<p><font color=red>虚拟设备是指采用采用某种I&#x2F;O技术，将某个独占设备改进为多用户共享的设备，以提高资源的利用率。(通过虚拟技术将一台独占设备虚拟成多台逻辑设备，供多个进程同时使用)</font><br>我感觉说法差不多，但是网上给的答案是❌。</p>
<p>通道技术根本上是从软件上解决操作系统对输入输出操作的 控制问题。（× ）应该是硬件</p>
<p>逻辑设备是物理设备属性的表示，用来指定某一具体设备。（×）不特指某个具体设备，而是对应一类设备。</p>
<p>从设备的资源属性分类，可把设备分为独占设备、共享设备和虚拟设备。（ √）</p>
<p>用户在使用I&#x2F;O设备时，通常采用物理设备名，指明具体的设备。（×）用户在使用I&#x2F;O设备时，通常采用逻辑设备名，指明设备类型。</p>
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p><strong>中断处理程序</strong></p>
<p>对于为每一类设备设置一个I&#x2F;O进程的设备处理方式，其中断处理程序的处理过程分成以下几个步骤<br>▪测定是否有未响应的中断信号<br>▪程序完成当前指令后测试是否有未响应的中断信号。<br>▪如果没有，继续执行下一条指令。<br>▪如果有，则停止原有进程的执行，准备转去执行中断处理程序，为把处理机的控制权转交给中断处理程序做准备。</p>
<p><strong>保护被中断进程的CPU 环境</strong></p>
<p>通常由硬件自动将处理机状态字PSW 和程序计数器(PC)中的内容，保存在中断保留区(栈)中，然后把被中断进程的CPU现场信息(即包括所有的CPU寄存器，如通用寄存器、段寄存器等内容)都压入中断栈中。</p>
<p><strong>转入相应的设备处理程序</strong></p>
<p>由处理机对各个中断源进行测试，以确定引起本次中断的I&#x2F;O 设备，并发送一应答信号给发出中断请求的进程，使之消除该中断请求信号，然后将相应的设备中断处理程序的入口地址装入到程序计数器中，使处理机转向中断处理程序。</p>
<p><strong>中断处理</strong></p>
<p>该程序首先从设备控制器中读出设备状态，以判别本次中断是正常完成中断，还是异常结束中断。<br>▪ 若是前者，中断程序便进行结束处理；若还有命令，可再向控制器发送新的命令，进行新一轮的数据传送。<br>▪ 若是异常结束中断，则根据发生异常的原因做相应的处理。</p>
<p><strong>恢复被中断进程的现场</strong></p>
<p>当中断处理完成以后，便可将保存在中断栈中的被中断进程的现场信息取出，并装入到相应的寄存器中，其中包括该程序下一次要执行的指令的地址N+1、处理机状态字<br>PSW，以及各通用寄存器和段寄存器的内容。这样，当处理机再执行本程序时，便从N+1处开始，最终返回到被中断的程序。</p>
<h2 id="I-x2F-O设备的控制方式"><a href="#I-x2F-O设备的控制方式" class="headerlink" title="I&#x2F;O设备的控制方式"></a>I&#x2F;O设备的控制方式</h2><p><strong>轮询的可编程I&#x2F;O方式</strong></p>
<p>​	对I&#x2F;O设备的控制采取<strong>程序I&#x2F;O</strong>方式，或称为<font color=blue>忙-等待</font>方式，即在处理机向控制器发出一条I&#x2F;O指令启动输入设备输入数据时，要同时把状态寄存器中的忙&#x2F;闲标志busy设置为1，然后便不断地循环测试busy，只有当其为0时，表示输入完成，于是处理机将数据寄存器中的数据取出，送入内存指定单元中，这样便完成了一次的I&#x2F;O。在程序I&#x2F;O方式中，由于CPU的高速性和I&#x2F;O设备的低速性，致使CPU的绝大部分时间都处于等待I&#x2F;O设备完成数据I&#x2F;O的循环测试中，造成对CPU的极大浪费。</p>
<p><strong>中断的可编程I&#x2F;O方式</strong></p>
<p>　当某进程要启动某个I&#x2F;O设备工作时，便由CPU向相应的设备控制器发出一条I&#x2F;O命令，然后立即返回继续执行原来的任务，设备控制器于是按照该命令的要求去控制指定I&#x2F;O设备，此时，CPU与I&#x2F;O设备并行操作。一旦数据进入数据寄存器，控制器便通过控制线向CPU发送一个中断信号，由CPU检查输入过程中是否出错，若无错，便由控制器发送取走数据的信号，再通过控制器及数据线将数据写入内存指定单元中。在I&#x2F;O设备输入每个数据的过程中，由于无需CPU干预，因而可使CPU与I&#x2F;O设备并行工作，仅当完成一个数据输入时，才需CPU花费极短的时间去做一些中断处理。</p>
<p><strong>直接存储器访问方式</strong></p>
<p>　虽然中断驱动I&#x2F;O比程序I&#x2F;O方式更有效，但是，它仍是以字（节）为单位进行I&#x2F;O的，每当完成一个字（节）的I&#x2F;O时，控制器便要向CPU请求一次中断，换言之，采用中断驱动I&#x2F;O方式时的CPU是以字（节）为单位进行干预的，将这种方式用于块设备的I&#x2F;O是非常低效的，例如，为了从磁盘读取1KB的数据块，需要中断CPU1K次，为了进一步减少CPU对I&#x2F;O的干预而引入了直接存储器访问方式，该方式的特点如下：</p>
<p>　① 数据传输的基本单位是<strong>数据块</strong>，即在CPU与I&#x2F;O设备之间，每次传送至少一个数据块。</p>
<p>　② 所传送的数据是<strong>从设备直接送入内存</strong>的，或者相反。</p>
<p>　③ 仅在传送一个或多个数据块的开始和结束时，需要CPU干预，整块数据的传送是在控制器的控制下完成的。</p>
<p>　DMA控制器由三部分组成，主机与DMA控制器的接口；DMA控制器与块设备的接口；I&#x2F;O控制逻辑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628173514952-543939858.png"></p>
<p>　① 命令&#x2F;状态寄存器（CR），用于接收从CPU发送来的I&#x2F;O命令，或有关控制信息，或设备的状态。</p>
<p>　② 内存地址寄存器（MAR），在输入时，它存放把数据从设备传送到内存的起始目标地址，在输出时，它存放由内存到设备的内存源地址。</p>
<p>　③ 数据寄存器（DR），用于暂存从设备到内存，或从内存到设备的数据。</p>
<p>　④ 数据计数器（DC），存放本次CPU要读或写的字（节）数。</p>
<p> 　当CPU要从磁盘读入一个数据块时，便向磁盘控制器发送一条读命令，该命令被送到其中的命令寄存器（CR）中，同时，还需要发送本次要将数据读入的内存起始目标地址，该地址被送入内存地址寄存器（MAR）中，本次要读数据的字（节）数被送入数据寄存器（DC）中，还须将磁盘中的源地址直接送至DMA控制器的I&#x2F;O控制逻辑上，然后，启动DMA控制器进行数据传送，以后，CPU便可去处理其他任务，此后，整个数据传送过程便由DMA控制器进行控制，当DMA控制器已从磁盘中读入一个字（节）的数据并送入数据寄存器（DR）后，再挪用一个存储器周期，将该字（节）传送到MAR所指示的内存单元中，接着便对MAR内容加1，将DC内存减1，若减后DC内存不为0，表示传送未完成，便继续传送下一个字（节），否则，由DMA控制发出中断请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628174538171-789907791.png"></p>
<p>　下图展示了三种不同方式的流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628193955531-1354950266.png">　　</p>
<p><strong>I&#x2F;O通道控制方式</strong></p>
<p>　虽然DMA方式比起中断方式已经显著地减少CPU的干预，即已由以字（节）为单位的干预减少到了以数据块为单位进行干预，但CPU每发出一条I&#x2F;O指令，也只能去读（或写）一个连续的数据块，而当我们需要一次去读多个数据块且将他们分别传送到不同的内存区域，或者相反时，则须由CPU分别发出多条I&#x2F;O指令及进行多次中断才能完成。I&#x2F;O通道方式是DMA的发展，它可以进一步减少CPU的干预，即把一个数据块的读（或写）为单位的干预减少为<strong>对一组数据块的读（或写）及有关的控制和管理为单位的干预</strong>。同时，可以实现CPU、通道、I&#x2F;O设备的并行操作，提高资源利用率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_21-17-58.png"></p>
<p><strong>什么是中断？系统内部中断与外部中断有什么区别？</strong></p>
<p>中断是指计算机在执行程序的过程中，由于某些事件的发生而暂时中止当前程序的执行，转而去执行相应的事件处理程序，处理完毕后再返回原来程序继续执行的过程</p>
<p>中断可以分为两类：系统内部中断和外部中断。系统内部中断是指由CPU内部产生的中断，例如除零错误、溢出错误等。外部中断是指由CPU外部产生的中断，例如来自外设的中断请求。外部中断可以进一步分为可屏蔽中断和不可屏蔽中断。可屏蔽中断是指可以被屏蔽或忽略的中断，例如来自硬盘、打印机、网卡等外设的中断请求。不可屏蔽中断是指不能被屏蔽或忽略的中断，例如电源掉电、硬件线路故障等。</p>
<p><strong>缺页中断与一般中断的主要区别是什么？</strong></p>
<p>缺页中断作为中断,同样需要经历保护CPU现场、分析中断原因、转缺页中断处理程序进行处理、恢复CPU现场等步骤。但缺页中断又是一种特殊的中断,它与一般中断的主要区别是:</p>
<p>(1) 在指令执行期间产生和处理中断信号。通常,CPU都是在一条指令执行完后去检查是否有中断请求到达。若有便去响应中断;否则继续执行下一条指令。而缺页中断是在指令执行期间,发现所要访问的指令或数据不在内存时产生和处理的。</p>
<p>(2) 一条指令在执行期间,可能产生多次缺页中断。例如,对于一条读取数据的多字节指令,指令本身跨越两个页面,假定指令后一部分所在页面和数据所在页面均不在内存,则该指令的执行至少产生两次缺页中断。</p>
<p>总之，缺页中断与一般中断的主要区别在于它们产生和处理的时间不同。缺页中断是在指令执行期间产生和处理的，而一般中断是在指令执行完后检查是否有中断请求再进行处理的。</p>
<p><strong>什么是设备的独立性？</strong></p>
<p>也称设备无关性，指应用程序独立于具体使用的物理设备。应用程序中使用逻辑设备名请求使用某类设备，系统实际执行时使用物理设备名，系统完成逻辑设备名到物理设备名的转换。</p>
<p><strong>I&#x2F;O控制方式中的中断控制方式和DMA方式有什么不同？</strong></p>
<p>(1) 中断方式是在数据缓冲寄存区满后,发中断请求,CPU进行中断处理,但它以字（节)为单位进行I&#x2F;0，对块设备低效。;DMA方式则是在所要求传送的数据块全部传送结束时要求CPU进行中断处理,大大减少了CPU进行中断处理的次数。</p>
<p>(2) 中断方式的数据传送是由CPU控制完成的;而DMA方式则是在DMA控制器的控制下不经过CPU控制完成的。</p>
<h2 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h2><p>　在设备管理中，为了缓和CPU与I&#x2F;O设备速度不匹配的矛盾，提高CPU与I&#x2F;O设备的并行性，在I&#x2F;O设备与处理机交换数据时都用到了缓冲区。</p>
<p>　① 缓和CPU和I&#x2F;O设备间速度不匹配的矛盾。</p>
<p>　② 减少对CPU的中断频率，放宽对CPU中断响应时间的限制。</p>
<p>　③ 提高CPU和I&#x2F;O设备之间的并行性。</p>
<p><strong>单缓冲</strong></p>
<p>　每当用户进程发出一个I&#x2F;O请求时，操作系统便在主存中为之分配一个缓冲区，假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理（计算）的时间为C，由于T和C是可以并行的，当T&gt;C时，系统对每一块数据的处理时间为M+T，反之，为M+C，系统对每一块数据的处理时间为<strong>Max(C，T) + M</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628201003046-1717232929.png"></p>
<p>　在字符设备输入时，缓冲区用于暂存用户输入的一行数据，在输入期间，用户进程被挂起以等待数据输入完毕，在输出时，用户进程将一行数据输入到缓冲区后，继续进行处理，当用户进程已有第二行数据输出时，如果第一行数据尚未被提取完毕，则此时用户进程应该阻塞。</p>
<p><strong>双缓冲</strong></p>
<p>　为了加快输入和输出的速度，提高设备利用率，人们又引入了双缓冲区机制，称为缓冲对换，在设备输入时，先将数据送入第一个缓冲区，装满后便转向第二个缓冲区，此时操作系统可以从第一缓冲区中移出数据，并送入用户进程，接着由CPU对数据进行计算，在双缓冲时，系统处理一块数据的时间可以粗略地认为是Max(C，T)，如果C&lt;T，可使块设备连续输入，如果C&gt;T，则可使CPU不必等待设备输入。对于字符设备，若采用行输入方式，则采用双缓冲通常能消除用户的等待时间，即用户在输入完第一行后，在CPU执行第一行中的命令时，用户可继续向第二缓冲区输入下一行数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628202211796-1310715249.png"></p>
<p><strong>循环缓冲</strong></p>
<p>　当输入与输出或生产者与消费者的速度基本相匹配时，采用双缓冲能获得较好的效果，可使生产者和消费者基本上能并行操作，但若两者速度相差甚远，双缓冲的效果则不够理想，因此，引入了多缓冲机制，可将多个缓冲组织成循环缓冲形式。对于用作输入的循环缓冲，通常是提供给输入进程或计算进程使用，输入进程不断向空缓冲去输入数据，而计算进程则从中提取数据进行计算。</p>
<p>　循环缓冲区的组成如下</p>
<p>　① 多个缓冲区，在循环缓冲区中包括多个缓冲区，每个缓冲区的大小相同，作为输入的多缓冲区可分为三种类型，用于装输入数据的空缓冲区R、已装满数据的缓冲区G以及计算进程正在使用的先行工作缓冲区C</p>
<p>　② 多个指针，作为输入的缓冲区可设置三个指针，用于指示计算进程下一个可用缓冲区G的指针Nextg、指示输入进程下次可用的空缓冲区R的指针Nexti、以及用于指示计算进程正在使用的缓冲区C的指针Current。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160628203538952-358207840.png"></p>
<p>　计算进程和输入进程可以利用下述两个过程来使用循环缓冲区（循环缓冲的使用）。</p>
<p>　① Getbuf过程，当计算进程要使用缓冲区中的数据时，可调用Getbuf过程，该过程将由指针Nextg所指示的缓冲区提供给进程使用，相应的，须把它改为现行工作缓冲区，并将Current指针指向该缓冲区的第一个单元，同时将Nextg移向下一个G缓冲区，类似地，当输入进程要使用空缓冲区来装入数据时，调用Getbuf过程，由该过程将指针Nexti所指示的缓冲区提供给输入进程使用，同时将Nexti指针移向下一个R缓冲区。</p>
<p>　② Releasebuf过程，当计算进程把C缓冲区中的数据提取完毕时，便调用Releasebuf过程，将缓冲区C释放，此时，把该缓冲区由当前（现行）工作缓冲区C改为空缓冲区R，类似地，当输入进程把缓冲区装满时，也应该调用Releasebuf过程，将该缓冲区释放，并改为G缓冲区。</p>
<p>　使用输入循环缓冲，可使输入进程和计算进程并行执行（<strong>进程同步</strong>），相应地，指针Nexti和指针Nextg将不断地沿着顺时针方向移动，这样就会出现如下两种情况。</p>
<p>　① Nexti指针追赶上Nextg指针，这意味着输入进程的速度大于计算进程处理数据的速度，已把全部可用的空缓冲区装满，再无缓冲区可用，此时，输入进程应该阻塞，直到计算进程把某个缓冲区中的数据全部提取完，使之成为空缓冲区R，并调用Releasebuf过程将它释放时，才将输入进程唤醒，这种情况称为<strong>系统受计算限制</strong>。</p>
<p>　② Nextg指针追赶上Nexti指针，这意味着输入数据的速度低于计算进程处理数据的速度，使全部装有输入数据的缓冲区都被抽空，再无装有数据的缓冲区供计算进程提取数据，这时，计算进程应该阻塞，直至输入进程又装满某个缓冲区，并调用Releasebuf过程将它释放时，才去唤醒计算进程，这种情况称为<strong>系统受I&#x2F;O限制</strong>。</p>
<p><strong>缓冲池</strong></p>
<p>​	上述的缓冲区仅适用于某特定的I&#x2F;O进程和计算进程，因而它们属于专用缓冲，当系统较大时，将会有许多这样的循环缓冲，这样会消耗大量的内存空间，而且利用率不高，为了提高缓冲区的利用率，引入缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。</p>
<p>对于既可以用于输出的共用缓冲池，其中至少包含有一下三种类型的缓冲区：</p>
<p>　① 空（闲）缓冲区。</p>
<p>　② 装满输入数据的缓冲区。</p>
<p>　③ 装满输出数据的缓冲区。</p>
<p>　为了管理方便，将相同类型的缓冲区链成一个队列，形成了空缓冲队列emq、输入队列inq、输出队列outq。还具有四种工作缓冲区，用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区、用于提取输出数据的工作缓冲区。</p>
<p>　缓冲区可以工作在收容输入、提取输入、收容输出、提取输出四种工作方式下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_09-33-43.png"></p>
<p>　① <strong>收容输入</strong>，在输入进程需要输入数据时，便调用Getbuf(emp)过程，从空缓冲队列的队首取出一个空缓冲区，把它作为收容输入工作缓冲hin，然后，把数据输入其中，装满后再调用Putbuf(inq,hin)过程，将该缓冲区挂在输入队列上。</p>
<p>　② <strong>提取输入</strong>，当计算进程需要输入数据时，调用Getbuf(inq)过程，从输入队列队首取出一个缓冲区，作为提取输入工作缓冲区sin，计算进程从中提取数据，计算进程用完该数据后，再调用Putbuf(emq,sin)过程，将该缓冲区挂到空缓冲队列emq上。</p>
<p>　③ <strong>收容输出</strong>，当计算进程需要输出时，调用Getbuf(emq)过程从空缓冲区队列emq的队首取出一个空缓冲区，作为收容输出工作缓冲区hout，当其中装满输出数据后，又调用Putbuf(outq,hout)过程，将该缓冲区挂在outq末尾。</p>
<p>　④ <strong>提取输出</strong>，由输出进程调用Getbuf(outq)过程，从输出队列队首取出一个装满输出数据的缓冲区，作为提取输出工作缓冲区sout，在数据提取完后，再调用Putbuf(emq,sout)过程，将该缓冲区挂在空缓冲队列末尾。</p>
<h2 id="与设备无关的I-x2F-O软件"><a href="#与设备无关的I-x2F-O软件" class="headerlink" title="与设备无关的I&#x2F;O软件"></a>与设备无关的I&#x2F;O软件</h2><p><em><strong>设备独立性</strong></em></p>
<p>　应用程序独立于具体使用的物理设备，为了实现设备独立性而引入了<strong>逻辑设备</strong>和<strong>物理设备</strong>这两个概念，在应用程序中，使用逻辑设备名称来请求使用某类设备，而系统在实际执行时，还必须使用物理设备名称。因此，系统需具有将逻辑设备名称转换为某物理设备名称的功能，这类似于存储器管理所介绍的逻辑地址和物理地址的概念，在应用程序中使用的是逻辑地址，系统在分配和使用内存时，必须使用物理地址。</p>
<p>实现设备独立性后，可带来<em>两方面</em>的好处。</p>
<p>　① <strong>设备分配时的灵活性</strong>，进程能够以逻辑设备名称来请求某类设备时，系统可立即将该类设备中的任一台分配给进程，仅当所有此类设备全部分配完毕时，进程才会阻塞。</p>
<p>　② <strong>易于实现I&#x2F;O重定向</strong>，用于I&#x2F;O操作的设备可以更换，而不必改变应用程序。　　</p>
<p>驱动程序是一个与硬件(或设备)紧密相关的软件，为了实现设备独立性，必须再在驱动程序之上设置一层软件，称为<strong>设备独立性软件</strong>。</p>
<p>设备独立性软件的主要功能可分为以下两个方面：<br>(1) 执行所有设备的公有操作。<br>① 对独立设备的分配与回收；<br>② 将逻辑设备名映射为物理设备名，进一步可以找到相应物理设备的驱动程序；<br>③ 对设备进行保护，禁止用户直接访问设备；<br>④ 缓冲管理<br>⑤ 差错控制<br>⑥ 提供独立于设备的逻辑块</p>
<p>(2) 向用户层(或文件层)软件提供统一接口<br>无论何种设备，它们向用户所提供的接口应该是相同的。例如，对各种设备的读操作，在应用程序中都使用read；而对各种设备的写操作，也都使用write。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_21-41-20.png"></p>
<h2 id="磁盘系统及磁盘调度"><a href="#磁盘系统及磁盘调度" class="headerlink" title="磁盘系统及磁盘调度"></a>磁盘系统及磁盘调度</h2><p>现代计算机系统中，都配置了磁盘存储器，并以它为主来存放文件。对文件的操作，都将涉及到对磁盘的访问，磁盘I／O速度的高低和磁盘系统的可靠性，都将直接影响到系统性能。因此，设法改善磁盘系统的性能，已成为现代操作系统的重要任务之一 。</p>
<p>提高磁盘I&#x2F;O速度的主要途径：<br>（1）选择性能好的磁盘<br>（2）采用好的磁盘调度算法<br>（3）设置磁盘高速缓存（Disk Cache）<br>（4）其它方法<br>（5）采用高度可靠、快速的容量磁盘系统——磁盘冗余阵列</p>
<p>数据的组织和格式<br>▪ 存储面(surface)<br>▪ 磁道(track)<br>▪ 柱面<br>▪ 扇区(sectors)</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_21-51-03.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_21-51-19.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_21-52-33.png"></p>
<p><em><strong>磁盘调度</strong></em></p>
<p>　磁盘是多个进程共享的设备，当有多个进程都要求访问磁盘时，应采用一种最佳的调度算法，使<strong>各进程对磁盘的平均访问时间最小</strong>。由于在访问磁盘中，主要是寻道时间，因此，磁盘调度的目标是<strong>使磁盘的平均寻道时间最少</strong>。</p>
<p>请求序列：55,58,39,18,90,160,150,38,184</p>
<p>　① <strong>先来先服务（FCFS, First Come First Service）</strong>，这是一种最简单的磁盘调度算法，其根据进程请求访问磁盘的先后顺序进行调度，优点是<strong>公平、简单</strong>，每个进程的请求都能得到依次处理，不会出现某个进程的请求长期得不到满足的情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160629084945437-806152901.png"></p>
<p>　② <strong>最短寻道时间优先（SSTF，Shortest Seek Time First）</strong>，要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。但这种算法不能保证平均寻道时间最短。SSTF算法虽然能获得较好的寻道性能，但却可能导致某个进程发生<strong>“饥饿”</strong>现象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160629085421124-1044322453.png"></p>
<p>　③ <strong>扫描（SCAN）算法</strong>，该算法不仅考虑到欲访问的磁盘与当前磁道之间的距离，更<strong>优先考虑的是磁头当前的移动方向</strong>。例如，当磁头正在自里向外移动时，SCAN算法所考虑的下一个访问对象，应是其欲访问的磁道既在当前磁道之外，又是距离最近的。直至再无更外的磁道需要访问时，才将磁臂换向自外向里移动。其类似电梯的运行，也称为<strong>电梯调度算法</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160629090041437-489747422.png"></p>
<p>　　④ <strong>循环扫描（CSCAN）算法</strong>，SCAN算法既能够获得较好的寻道性能，又能防止饥饿现象，但是，当磁头刚从里向外移动而越过了某个磁道时，恰好又有一进程请求访问此磁道，这时，该进程必须等待，待磁头继续从里向外，然后再从外向里扫描完所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被大大地推迟。为了减少这种延迟，<strong>CSCAN算法规定磁头单向移动</strong>，例如，致使自里向外移动，当磁头移到最外的磁道访问后，磁头立即返回最里的欲访问的磁道，亦即<strong>将最小的磁道号紧接着最大的磁道号构成循环，进行循环扫描</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160629091148124-624346017.png"></p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之存储器管理</title>
    <url>/2023/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1/</url>
    <content><![CDATA[<h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><p>操作系统的职能之一，主要任务是为<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F?fromModule=lemma_inlink">多道程序</a>的运行提供良好的环境，方便用户使用存储器，提高存储器的利用率以及能从逻辑上<a href="https://baike.baidu.com/item/%E6%89%A9%E5%85%85%E5%86%85%E5%AD%98?fromModule=lemma_inlink">扩充内存</a>。主要目的和功能：</p>
<p>1、主存储器的分配和管理</p>
<p>2、提高主存储器的利用率</p>
<p>3、“扩充”主存容量</p>
<p>4、存储保护</p>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><strong>主存储器</strong></p>
<p>　用于保存进程运行时的程序和数据。CPU的 控制部件只能从主存中取得指令和数据到CPU寄 存器，同样，CPU寄存器中的数据可存入主存。 CPU与外设交换数据必须依托于主存。</p>
<p><strong>寄存器</strong></p>
<p>　寄存器访问速度最快，能与CPU协调工作，价格昂贵，容量不大，寄存器用于加速存储器的访问速度，如用寄存器存放操作数，或用作地址寄存器加快地址转换速度等。</p>
<p><strong>高速缓存</strong></p>
<p>​	CPU对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。 根据程序执行的局部性原理，将主存中一些经常访问的数据存放在高速缓存中，减少访问主存的次数，提高程序的执行速度。 有些计算机系统设置了两级高速缓存，即，一级高速缓存与二级高速缓存。cpu访问一级高速缓存最快。（i9 12900K，三级缓存：30MB）</p>
<p><strong>磁盘缓存</strong></p>
<p>　内存中一块存储区，对应于某固定磁盘，临时存储磁盘数据（如，数据预取）。磁盘的IO速度远低于对主存的访问速度，因此将频繁使用的一部分磁盘数据和信息暂时存放在磁盘缓存中，可减少访问磁盘的次数，磁盘缓存本身并不是一种实际存在的存储介质，它依托于固定磁盘，提供对主存储器空间的扩充，即<strong>利用主存中的存储空间，来暂存从磁盘中读出或写入的信息</strong>，主存可以看做是辅存的高速缓存，因为，辅存中的数据必须复制到主存方能使用，反之，数据也必须先存在主存中，才能输出到辅存。</p>
<blockquote>
<p>速度：寄存器&gt;高速缓存&gt;主存&gt;磁盘缓存<br>容量：寄存器&lt;高速缓存&lt;主存&lt;磁盘缓存<br>价格：寄存器&gt;高速缓存&gt;主存&gt;磁盘缓存</p>
</blockquote>
<h3 id="存储分配的三种方式"><a href="#存储分配的三种方式" class="headerlink" title="存储分配的三种方式"></a>存储分配的三种方式</h3><p>1.<strong>直接指定方式</strong>：程序员在编程序时，或编译程序(汇编程序)对源程序进行编译(汇编)时，使用实际存储地址。</p>
<p>2.<strong>静态分配方式</strong>(Static Allocation) ： 用户在编程时，或由编译程序产生的目的程序，均可从其地址空间的零地址开始；当装配程序对其进行连接装入时才确定它们在主存中的相应位置，从而生成可执行程序。也就是说，存储分配是在装入时实现的。</p>
<p>3.<strong>动态分配方式</strong>(Dynamic Allocation)： 动态分配是一种更加有效的使用主存储器的方法。 这种动态存储分配方式的特点是： </p>
<blockquote>
<p>(1)作业在存储空间中的位置，也是在其装入时确定的；<br>(2)在其执行过程中可根据需要申请附加的存储空间；<br>(3)一个作业已占用的部分存储区域不再需要时，可以要求归还给系统。</p>
</blockquote>
<p>关于名空间，地址空间(逻辑地址集合，虚)，存储空间(物理地址集合，实)的理解:</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_09-18-41.png"></p>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>​	为了使程序能够运行，必须先为之创建进程，而创建进程的第一件事，就是将程序和数据装入内存，如何将一个用户源程序变为一个可在内存中执行的程序，通常要经过如下几步，首先是编译（由编译程序将用户源代码编译成若干个目标模块），其次是链接（由链接程序将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块），最后是装入（由装入程序将装入模块装入内存）。</p>
<h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><p>① <strong>绝对装入方式</strong>，如果在编译时知道程序驻留在内存的什么位置，那么，编译程序将产生绝对地址的目标代码，绝对装入方式按照装入模块中的地址，将程序和数据装入内存，装入模块被装入内存后，由于程序中的<strong>逻辑地址与实际内存地址完全相同</strong>，故不需要对程序和数据的地址进行修改。</p>
<p>② <strong>可重定位装入方式</strong>，绝对装入方式只适用于单道程序环境，在多道程序环境下(编译程序不可能事先知道所编译的目标模块应放在内存的何处)，所得到的目标模块的起始地址通常都是以0开始的，程序中的其他地址也都是相对于起始地址计算的，此时应采用可重定位装入方式，根据内存的当前情况，将装入模块装入到内存的适当位置。该方式会使装入模块中的所有逻辑地址与实际装入内存的物理地址不同，需要对数据地址和指令地址进行修改，通常把再装入时对目标程序中指令和数据的修改过程称为重定位。</p>
<p><em><strong>静态重定位</strong></em>  </p>
<p>地址变换是在装入内存时一次完成的，且以后不能移动。 一般情况下,物理地址&#x3D;相对地址+内存中的起始地址，适用于多道程序环境，可以将装入模块装入到内存中任何允许的位置。</p>
<p><em><strong>动态重定位</strong></em></p>
<p>装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到<font color=red>程序执行时</font>进行。在硬件地址变换机构的支持下，随着对每条指令或数据的访问自动进行地址变换。利用一个重定位寄存器(RR)来实现。</p>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><p>① <strong>静态链接</strong>，在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个</p>
<p>完整的装入模块（又称执行模块），需要对相对地址进行修改（由于编译程序产生的所有目标模块中，使用的都是相对地址，其起始地址都为0，每个模块中的地址都是相对于起始地址计算的）。也需要变换外部调用符号（将每个模块中所用的外部调用符号都变换为相对地址），这种先进行链接所<strong>形成的一个完整的装入模块</strong>，又称为可执行文件，通常都不再拆开它，要运行时可直接将它装入内存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_09-44-17.png"></p>
<p>② <strong>装入时动态链接</strong>，用户源程序经编译后所得是目标模块，是在<strong>装入内存时边装入边链接</strong>的，即在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存，装入时动态链接有如下优点，便于修改和更新（各目标模块是分开的存放的，所以要修改或更新各目标模块非常容易），便于实现对目标模块的共享（很容易将一个目标模块链接到几个应用模块上，实现多个应用程序对该模块的共享）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_09-46-03.png"></p>
<p>采用装入时动态链接方式，虽然可将一个装入模块装入 到内存的任何地方，但装入模块的结构是静态的，表现在： 1. 进程（程序）在整个执行期间，装入模块是不改变的； 2. 每次运行时的装入模块是相同的。并且事先无法知道本次 要运行哪些模块，只能将所有可能要运行的模块在装入时 全部链接在一起，而实际上往往有些目标模块根本不会运 行。</p>
<p>③ <strong>运行时动态链接</strong>，将某些模块的链接推迟到<strong>程序执行时才进行链接</strong>，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存，把它链接到调用者模块上，凡在执行过程中未被调用到的模块，都不会被调入内存和被链接到装入模块上，这样不仅加快程序的装入过程，同时也节省了大量的内存空间。</p>
<p><font color=red>运行时动态链接是目前最常使用的链接方式</font>。</p>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><h3 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h3><p><strong>单一连续分配</strong></p>
<p>　这是一种最简单的存储管理方式，但只能在单用户、单任务的操作系统中，将内存分为系统区和用户区，系统区供OS使用，通常放在内存的低地址，用户区是指除系统区以外的全部内存空间，提供给用户使用。</p>
<p><strong>固定分区分配</strong></p>
<p>　固定分区分配是一种最简单的可运行多道程序的存储管理方式，将内存用户空间划分为若干个固定大小的区域，在每个分区只装入一道作业，这样，便允许多道作业并发执行，当有空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区，当该作业结束时，又可再从后备作业队列中找出另一作业调入该分区。</p>
<p>　对于内存的用户空间的划分，有如下两种方法。</p>
<p>　① 分区大小相等，即所有的内存分区大小相等。缺点是缺乏灵活性，即当程序太小时，会造成内存资源的浪费，程序太大时，一个分区由不足以装入该程序，只是该程序无法运行。</p>
<p>　② 分区大小不等，把内存区划分成含有多个较小的分区、适量中等分配和少量大分区，这样，便可根据程序的大小为之分配适当的分区。</p>
<p>　为了便于内存分配，将分区按大小进行排队，并为之建立一张<strong>分区说明</strong>表，其中各表项包括可用于分配的分区数、每个分区的起始地址、大小、状态（是否已分配），当有一个程序需要装入时，由内存分配程序检索该表，从中找出一个能满足要求的，尚未分配的分区，将之分配给该程序，然后将该表项中的状态设置为已分配，若未找到大小足够的分区，则拒绝为该用户分配内存。</p>
<table>
<thead>
<tr>
<th>分区号</th>
<th>大小</th>
<th>始址</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>12K</td>
<td>20K</td>
<td>已分配</td>
</tr>
<tr>
<td>2</td>
<td>32K</td>
<td>32K</td>
<td>已分配</td>
</tr>
<tr>
<td>3</td>
<td>64K</td>
<td>64K</td>
<td>已分配</td>
</tr>
<tr>
<td>4</td>
<td>128K</td>
<td>128K</td>
<td>未分配</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-02-41.png"></p>
<p>内存中已分配给用户但未被利用的区域称 为 <font color=red>“内零头” （内碎片）</font>。 固定分区分配有内零头产生。</p>
<p><font color=red>外零头</font>(External Fragment )： 没有分配但无法分配的空间 ，太小而无法分配，“分不出去的空间”</p>
<p><strong>动态分区分配</strong></p>
<p>动态分区分配是指根据进程的实际需要，动态地为之分配连续的内存空间。即分区的边界可以移动，分区的大小是可变的。动态分区又有两种不同选择，一种是分区的数目固定大小是可变的，而另一种则允许分区的数目和大小都是可变的。 为了说明它们之间的重要差异，我 们考虑一个具有256K字节存储器的系统。</p>
<p><em>分区数目固定</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-13-50.png"></p>
<p><em>分区数目可变</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-14-02.png"></p>
<p>为实现可变分区分配，常用的数据结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-16-26.png"></p>
<p><strong>可重定位分区分配</strong></p>
<p>​	在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间，若果在系统中只有若干个小的分区，即使他们容量总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。若想装入，则将内存中的所有作业进行移动，使他们全部相邻接，这样，即可把原来分散的多个小分区拼接成一个大分区，这时，就可以把作业装入该区。经过紧凑后的某些用户程序在内存中的位置发生了变化，此时若不对程序和数据的地址加以修改（变换），则程序必将无法执行，为此，<strong>在每次紧凑之后，都必须对移动了的数据和程序进行重定向</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160625173645781-121254084.png"></p>
<p>　在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转化为物理地址的工作，退推迟到程序指令要真正执行时进行。为了使地址变换不影响指令的执行速度，在系统中增设了一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址。在程序执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。该动作是随着对每条指令或数据的访问自动进行的，故称为<strong>动态重定位</strong>，当系统对内存进行了紧凑而使若干程序在内存中移动时，不需要对程序做任何修改，只要用该程序在内存的新起始地址去置换原来的起始地址即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-59-06.png"></p>
<p>　动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，<strong>增加了紧凑功能</strong>，通常，在找不到足够大的空闲分区来满足用户需求时进行紧凑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-59-26.png"></p>
<h3 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h3><ul>
<li><p><strong>最佳适应算法</strong>(Best fit: BF) ：就是为一作业选择分区时总是寻找<em><strong>其大小最接近作业所要求的存储区域</strong></em>。即：把作业放 入这样的分区后剩下的零头最小。 </p>
<p>  优点：如果存储空间中具有正好是所要求大小的存储空白区，则必然被选中；如果不存在这样的空白区，也只对比要求稍大的空白区进行划分，而绝不会去划分一个更大的空白区。因此，其后遇到大作业到来时，作业要求的存储区域就比较容易得到满足。 为了加快查找速度，应将存储空间中所有的空白区按其<strong>大小递增</strong>的顺序链接起来，组成一空白区链(Free List)。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-22-52.png"></p>
<p>  缺点：采用最佳适应算法，在每次分配时，总是产生最小的空白区。因此，经过一段时期后，存储空间中 可能留许多这样的空白区，由于其太小而无法使用。为了改善这种情况，在该算法中设置一参数G，用它来确 定最小分区的大小。当选择一个分区时，如果选中的空白区与要求的大小之差小于G，则不再对它划分，而把整个这个空白区分配给申请的作业。 最佳适应算法的另一缺点是：在回收一个分区时， 为了把它插入到空白区链中合适的位置上也颇为费时。 所以，这种算法乍看起来是最佳的，其实则不然。　</p>
</li>
<li><p><strong>最坏适应算法</strong>(Worst fit: WF)：与最佳适应算法相反，它在为作业选择存储区域时，总是寻找最大的空白区。在划分后剩下的空白区也是最大的，因而对以后的分配很可能仍然是有用的，这是该算法的一个优点。但是，由于最大的空白块总是首先被分配而进行 划分，当有大的作业时，其存储空间的申请往往得不到满足，这是该算法的一个缺点。为了支持这个算法的实现，空白块应以<strong>大小递减</strong>的顺序链接起来。</p>
</li>
<li><p><strong>首次适应算法</strong>(First Fit: FF) ：每个空白区按其在存储空间中<strong>地址递增</strong>的顺序链在一 起，即每个后继空白区的起始地址总是比前者的大。在 为作业分配存储区域时，从这个空白区链的始端开始查找，选择第一个足以满足请求的空白块，而不管它究竟 有多大。 显然，这个算法倾向于优先利用存储空 间中低址部分的空白区。</p>
<p>主要优点：算法简单，查找速度快；留在高址部分的大的空白区被划分的机会较少，因而在大作业到来时也比较容易得到满足。 主要缺点：这种算法常常利用一个大的空白区适应小作业的请求，从而留下一些较小的无法用的空白区，存储空间利用率不高；而且，由于所有的请求都是从空白区链的始端开始查找，因而这些小而无用的空白区集中在这个链的前端，相应地，一些较大空白区在链的尾端才能发现，这种情况将使找到合适空白区的速度降低。<strong>在低地址部分会积累大量外零头</strong>。</p>
</li>
<li><p><strong>下次适应算法</strong>(Next fit: NF) ：该算法实际上是首次适应算法的一种变形，故也被称为带旋转指针的首次适应算法(Next Fit with Roving Pointer)。 为此，我们把存储空间中空白区构成一个循环链。每次为存储请求查找合适的分区时，总是从<em><strong>上次查找结束的地方开始</strong></em>，只要找到一个足够大的空白区，就将它划分后分配出去。显然，采用这一策略后，存储空间的利用更加均衡，而不至于使小的空白区集中于存储器的一端。 但是，在存储器的另一端也不可能保留大的空白块，因此，当需要获得相当大的空白区时，能满足的可能性减少了。</p>
</li>
<li><p><strong>快速适应算法</strong>（Quik fit: QF)：将空闲分区根据其容量大小进行分类，对于每一类具<br>有相同容量的所有空闲分区，单独设立一个空闲分区链表。这样，系统中存在多个空闲分区链表；同时，在内存中设立一张管理分区类型，并记录了该类型空闲分区链表表头的索引表，该表的每一个表项记录了对应类型空闲分区链表表头的指针。<br>➢分配过程：根据进程的长度，寻找到能容纳它的最小空闲分区链表，并取下第一块进行分配即可。</p>
<p>优点：1.查找效率高。2.该算法在进行空闲分区分配时，不会对任何分区产生分<br>割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。<br>➢缺点：1.在分区归还主存时算法复杂，系统开销较大。2.该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或<br>多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重。</p>
</li>
</ul>
<h3 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h3><p><em>分配内存</em></p>
<p>系统利用某种分配算法，从空闲分区链（表）中找到所需大小的分区，其流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-42-15.png"></p>
<p><em>回收内存</em></p>
<p>当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链（表）中找到相应的插入点，此时会出现如下四种情况之一：<strong>回收分区与插入点的前一个空闲区F1相邻接</strong>，此时将回收区与插入点的前一分区合并，不必为回收区分配新表项，只需要修改前一分区F1的大小。<strong>回收分区与插入点的后以空闲分区F2相邻接</strong>，此时将两分区合并，形成新的空闲分区，用回收区的首址作为新空闲区的首址，大小为两者之和。<strong>回收区同时与插入点的前、后两个分区邻接</strong>，此时将三个分区合并，使用F1的表项和F1的首址，取消F2的表项，大小为三者之和。<strong>回收区既不与F1邻接，也不与F2邻接</strong>，这时为回收区单独建立一个新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160625171237203-1234395843.png"></p>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>​	伙伴系统规定，无论已分配分区还是空闲分区，其大小均为2的k次幂，k为整数，1&lt;&#x3D; k &lt;&#x3D; m，其中，2^1表示分配的最小分区的大小，2^m表示分配的最大分区的大小，通常2^m是整个可分配内存的大小。假设系统开始时的初始容量为2^m个字，由于不断切分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了k个空闲分区链表。</p>
<p>　当需要为进程分配一个长度为n的存储空间时，首先计算一个i值，使2^i-1 &lt; n &lt;&#x3D; 2^i，然后，在空闲分区大小为2^i的空闲分区链表中查找，若找到，即把该空闲分区分配给进程，否则，表明2^i的空闲分区已经耗尽，在大小为2^i+1的空闲分区链表中查找，若存在，则将该空闲分区分为两个大小为2^i的分区，一个用于分配，一个加入到大小为2^i的空闲分区链表中，若还是不存在，则继续在大小为2^i+2的空闲分区链表中查找，若存在，则将空闲分区进行两次分割，一次分割为两个大小为2^i+1的空闲分区，一个加入到大小为2^i+1的空闲分区链表中，另外一个继续进行分割，分成两个大小2^i的空闲块，一个用于分配，另外一个加入到大小为2^i的空闲分区链表中，以此类推。在最坏的情况下，可能需要对2^k的空闲分区进行k此分割才能得到所需分区。</p>
<p>　当回收空闲分区时，也需要经过多次合并，如回收大小为2^i的空闲分区时，若事先已经存在2^i的空闲分区，则应将其与伙伴分区合并为一个大小为2^i+1的空闲分区，若事先已存在2^i+1的空闲分区，则再次进行合并，合并为2^i+2的分区，以此类推。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_10-52-24.png"></p>
<h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><h3 id="页面与页表"><a href="#页面与页表" class="headerlink" title="页面与页表"></a>页面与页表</h3><p>　分页存储管理是将一个<strong>进程的逻辑地址空间分成若干个大小相等的片</strong>，称为页面或页，并为各页进行编号，从0开始。相应地，<strong>把内存空间分成与页面相同大小的若干个存储块</strong>，称为（物理）块或者页框，也同样为它们编号，如0#块，1#块等。在未进程分配内存时，以块为单位将进程的若干个页分别装入到多个可以不相邻接的物理块中，由于进程的最后一页经常装不满一块而形成不可利用的碎片，称之为页内碎片(程序大小一般不是页大小的整数倍)。</p>
<p>　页面大小由机器的地址结构决定。某一机器只能采用一种大小的页面。</p>
<ul>
<li><p>小页面</p>
</li>
<li><p>大页面</p>
</li>
</ul>
<p>​	页面的大小通常在1KB~8KB之间。</p>
<p>　分页地址中的地址结构如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_11-15-18.png"></p>
<p>　在分页存储管理方式中，任何一个逻辑地址都可转变为：页号+页内位移量。前一部分为页号P，后一部分为位移量W（或称为页内地址），总共32位，其中0<del>11位为页内地址，每页大小4KB，12</del>31位为页号，地址空间最多允许1M个页面。</p>
<p>设有一逻辑地址A，页面大小为L，则在分页存储管理方式中，它的地址被转换：<br>页号 P&#x3D;INT[A&#x2F;L]<br>页内位移量 W&#x3D;A MOD L<br>如有逻辑地址为：2170，页面大小为1KB，则<br>P&#x3D;INT[2170&#x2F;1024]&#x3D;2；W&#x3D;2170 MOD 1024&#x3D;122</p>
<p>　为了能够保证在内存中找到每个页面所对应的物理块，系统为每个进程建立了一张页面映射表，简称为页表。页表项纪录了相应页在内存中对应的物理块号，在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号，<strong>页表实现了从页号到物理块号的地址映像</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_11-13-45.png"></p>
<p>　即使在简单的分页系统中，也常在页表的表项中设置一存取控制字段，用于对该存储块中的内存加以保护，当存取控制字段仅有一位时，可用来规定该存储块中的内存时允许读&#x2F;写，还是只读；若存取控制字段为二位，则可规定为读&#x2F;写、只读、只执行等存取方式。</p>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>　地址变换机构的功能将用户的逻辑地址转变为内存中的物理地址。逻辑地址由页号和页内位移量组成。页的大小和内存物理块的大小是相同的，所以页内位移量即为物理块内位移量。<strong>地址变换任务是借助页表来完成的</strong>。</p>
<p>　页表的功能可以由一组专门的寄存器来实现，一个页表项用一个寄存器，由于寄存器具有较高的访问速度，因而有利于提高地址变换的速度，但成本较高，且页表项一般会很多，都使用寄存器实现不太现实，因此，<strong>页表大多驻留在内存</strong>。在系统中只设置一个<strong>页表寄存器PTR(Page-Table Register)，用于存放页表在内存的始址和页表的长度</strong>，平时，页表的始址和页表长度存放在本进程的PCB中，当调度程序调度到某进程时，将这两个数据装入页表寄存器，因此，在单处理机环境下，虽然系统中可以运行多个进程，但只需要一个页表寄存器。</p>
<p>　当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址（相对地址）分为页号和页内偏移量两部分，从PTR中得到页表首址，再以页号为索引去检索页表，查找操作由硬件执行，在执行检索前，先将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址超越了进程的地址空间，这一错误将被系统发现并产生一个地址越界中断。若未出现错误，则将页表始址加上<em><strong>页号与页面大小乘积</strong></em>，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将之装入物理地址寄存器，与此同时，再将页内地址送入物理地址寄存器的块内地址字段中，这样，便完成了逻辑地址到物理地址的转换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160625211026453-286611371.png"></p>
<p>　上述操作中，每次存取一个数据时，都会<strong>访问内存两次</strong>，第一次是访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，以形成物理地址，第二次访问时，才是从第一次所得的地址中获得所需数据，因此，这种方式会使计算机的处理速度降低一半，为了提高地址变换速度，可以在地址变换机构中增设一个具有并行查询能力的<strong>高速缓冲寄存器</strong>，又称为<strong>联想寄存器或快表</strong>（TLB），专门保存当前进程最近访问过的一组页表项。</p>
<p>　此时的变换过程如下，在CPU给出有效地址后（逻辑地址），由地址变换机构自动的将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与之相匹配的页号（<strong>命中</strong>），便表示所要访问的页表项在快表中，于是，可以直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中，如在快表中没有找到（<strong>命中失败</strong>），则还需要再访问内存中的页表，找到后，把从页表项读出的物理块好送入地址寄存器，同时，再将此页表项存入快表的寄一个寄存器单元，即修改快表，如果快表已满，则OS需要找到一个老的且已被认为不再需要的页表项，将它换出。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160625212714688-1055550023.png">　</p>
<p><em>例1：某采用分页存储管理的系统中，物理地址占20位，逻辑地址中页号占6位，页面大小为1KB，问：</em><br>⑴该系统的内存空间大小为多少？每个存储块的大小为多少？逻辑地址共几位？每个作业的最大长度为多少？<br>⑵若第0、1、2页分别放在第3、7、9存储块中，则逻辑地址0420H对应的物理地址是多少？<br>在分页存储管理系统中，根据题意：<br>⑴物理地址占20位，所以该系统的内存空间大小<br>为：1MB<br>存储块的大小与页面大小相同，而页面大小为1KB，因此存储块的大小为：1KB<br>由于页面大小为1KB，占10位，而页号占6位，因此逻辑地址共16位，<br>从 而 该 系 统 中 每 个 作 业 的 最 大 长 度 为 ：64KB<br>⑵法1（全部转换成10进制）：<br>逻辑地址：0420H&#x3D;1056<br>因为1K&lt;&#x3D;1056&lt;2K-1，所以在1号页面内，其页内位移量为：1056-1K&#x3D;32； 而1号页面对应7号物理块，所以物理地址为：7×1K+32&#x3D;7200。<br>法2（将页面转换成16进制表示）：<br>页面大小：1K&#x3D;0400H 。因为0400H&lt;&#x3D;0420H&lt;07FFH，所以在1号页面内，其页内位移量为：0420H-0400H&#x3D;20H；而1号 页 面 对 应 7 号 物 理 块 ， 所 以 物 理 地 址 为 ：<br>7×0400H +20H&#x3D;1C20H。</p>
<p><em><strong>访问内存的有效时间 EAT</strong></em><br>定义：从进程发出指定逻辑地址的访问请求，经过地址变换，再到内存中找到对应的物理单元并取出数据，所花费的总时间。<br>➢如检索快表时间为20 ns，访问内存为100 ns。</p>
<ul>
<li>若能在快表中检索到CPU给出的页号，则CPU存取一<br>个数据共需120 ns。</li>
<li>否则，需要220 ns的时间。</li>
</ul>
<p><strong>有效访问时间</strong> &#x3D; HitR×(TLB+MA) + (1-HitR)×(TLB+2MA)，HitR为命中率。</p>
<p>例：设访问主存时间为200ns,访问联想存储器为40ns，命中率为90％，则平均存取时间为多少？<br>查页表两次访存：200＋200＝400ns<br>查快表，平均为：40+200&#x3D;240ns<br>(200+40)×90％＋(200+200+40)×10％&#x3D;260ns</p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>　现代计算机系统中，可以支持非常大的逻辑地址空间（2^32~2^64），这样，页表就变得非常大，要占用非常大的内存空间，如，具有32位逻辑地址空间的分页系统，规定页面大小为4KB，则在每个进程页表中的页表项可达1M(2^20)个，又因为每个页表项占用一个字节，故每个进程仅仅页表就要占用1MB的内存空间，而且要求连续，这显然是不现实的，可以通过如下两个方法解决该问题。</p>
<p>　　① 采用离散分配方式来解决难以找到一块连续的大内存空间的问题。</p>
<p>　　② 只将当前需要的部分页表项调入内存，其余页表项仍驻留在磁盘上，需要时再调入。</p>
<p>　　对于要求连续的内存空间来存放页表的问题，可利用将页表进行分页，并离散地将各个页面分别存放在不同的物理块中的办法来解决，同样的，也要为离散分配在页表再建立一张页表，称为外层页表。在每个页表项中记录了页表页面的物理块号，以32位逻辑地址空间为例进行说明。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_12-58-51.png"></p>
<p>　　层页号P1为10位，可以表示1024个物理块号，外层页表中的外层也内地址P2为10位，可以表示1024个物理块号，页内地址为12位，表示页面大小为4K。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160625203109875-1471651688.png"></p>
<p>　　在页表的每一个表项中存放的是进程的某页在内存中的<strong>物理块号</strong>，如第0页的0页存放1#物理块，第1页存放4#物理块，而在外层页表的每个页表项中，所存放的是某页表分页的<strong>首址</strong>，如第0页页表存放在1011#物理块中，第1页页表存放在1078#物理块中。</p>
<p>　　为了实现地址变换，在地址变换机构中需要增设一个外层页表寄存器，用于存放外层页表的始址，并利用逻辑地址中的外层页号，作为外层页表的索引，从中找到指定页表分页的始址，在利用P2作为指定页表分页的索引，找到指定的页表项，其中即含有该页在内存的物理块号，用该块号和页内地址d即可构成访问的内存物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_12-59-13.png"></p>
<p>　利用离散分配方法实现的两级页表只是解决了大页表无需大片连续存储空间问题，但并未减少用较少内存去存放大页表问题，有关此类问题的成功解决方案放在虚拟存储器<br>管理中。</p>
<p>　对于64位的机器而言，采用两级页表已经不太合适，如果页面大小仍采用4KB，那么剩下52位，若还是按照物理块的大小（2^12位）来划分页表，每个页表项4B，故一页中可存放2^10个页表项，则将余下的42位用于外层页号，此时，外层页表中可能有4096G个页表项，要占用16384GB的连续内存空间，显然是不行的。使用1MB的页面，剩44位。若按1MB来划分页表，还剩26位用于二级页表，二级页表有64M个页表项，占<br>256MB空间必须采用多级页表，即将外层页表再进行分页。若计算机的虚拟地址空间大小为2^64，页面大小为4KB，页表项为4B，则最少页表的级数为6级，首先总的页面个数为2^52（64 - 12），其次，每个物理块能装入的页表项为4KB&#x2F;4B &#x3D; 2^10个，10 * 6 &gt; 52，即最少需要6级。</p>
<p><em><strong>反置页表Inverted Page Table（IPT）</strong></em></p>
<p>逻辑空间越来越大，页表占内存也越来越大，为了解决大页表问题占内存多现象，减少内存开销，避免一个进程一个页表。<strong>IPT思想：</strong>（1）IPT是为主存中的每一个物理块建立一个页表项并按照块号排序；（2）该表每个表项包含正在访问该物理块的进程标识、页号及特征位,用来完成主存物理块到访问进程的页号的转换。</p>
<blockquote>
<p>常采用部分装入，所以必须为每个进程建立一个外部页表。当该页不在主存时，需要访问外部页表。<br>反置页表只索引正在运行的进程页面<br>因为IPT都大，所以利用进程标识符和页号去检索是相当费时的。采用Hash表来检索。</p>
</blockquote>
<p>反置页表地址转换过程如下:<br>给出进程标识和页号,用它们去比较IPT,若整个反置页表中未能找到匹配的页表项,说明该页不在主存,产生请求调页中断,请求操作系统调入;否则，该表项的序号便是物理块号,块号加上位移,便形成物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_13-38-32.png"></p>
<p><em><strong>对换</strong></em></p>
<p>　对换指把内存中暂不能运行的进程或暂时不用和程序和数据，换到外存上，以腾出足够的内存空间，把已具备运行条件的进程，或进程所需要的程序和数据，换入内存。对换是系统行为，是提高内存的利用率的有效措施。常用于多道程序系统或小型分时系统中，与分区存储管理配合使用。实现：可在系统中设一对换进程，以执行换进内存、换出至外存操作。</p>
<p>分类：</p>
<ul>
<li>“整体对换”（进程对换）：<br>对换以整个进程为单位，用于分时系统，以解决内存紧张的问题；</li>
<li>“页面对换&#x2F;分段对换”：<br>对换以“页”或“段”为单位进行“部分对换”，该方法是实现请求分页及请求分段存储器的基础，支持虚存系统。</li>
</ul>
<p>为实现对换，系统需要三方面的功能：　</p>
<ol>
<li><p><strong>对换空间的管理</strong>，在具有对换功能的OS中，通常把<strong>外存分为文件区和对换区</strong>，前者用于存放文件，后者用于存放从内存换出的进程。由于文件通常是较长久的驻留在外存上，文件区的管理主要目标是<em>提高存储空间的利用率</em>，采取离散分配方式(用指针相连)，进程通常在对换区中驻留的时间较短暂，对换操作较频繁，故对对换空间管理的主要目标是<em>提高进程换入和换出的速度</em>，采取的是连续分配的方式，较少考虑外存中的碎片问题。为了能对对换区中的空闲盘块进行管理，在系统中应配置相应的数据结构，以记录外存的使用情况。空闲分区表或空闲分区链。在空闲分区表中的每个表目应包含两项，即对换分区首址和对换区长度，它们的基本单位都是<strong>盘块</strong>。</p>
</li>
<li><p><strong>进程的换出</strong>，选择：首先选择<strong>阻塞</strong>或<strong>睡眠状态</strong>的进程，若有多个，按优先级<strong>由低到高</strong>进行选择。若没有此状态进程，则选择<strong>就绪</strong>状态的，仍然按优先级由低到高进行选择。为避免某进程被频繁的换入换出，还应考虑进程在内存中的驻留时间，优先选择<strong>驻留时间长</strong>的进程。</p>
</li>
<li><p><strong>进程的换入</strong>，①从 PCB集合中查找“就绪且换出”的进程，有多个，则选择换出时间最长的。②根据进程大小申请内存，成功则读入，否则要先执行换出，再换入。③若还有可换入进程，则转向①。直至无“就绪且换出”进程或无法获得足够内存空间为止。</p>
</li>
</ol>
<h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><p>从固定分区到动态分区分配，再到分页存储管理方式，其主要动力为提高内存利用率，引入分段存储管理的目的在于满足用户在编程和使用上多方面的要求。如</p>
<p>　① 方便编程，用户可以把自己的作业按照逻辑关系划分为若干段，每个段都是从0开始编址，并有自己的名字和长度。</p>
<p>　② 分段共享，在实现对程序和数据的共享时，是以信息的逻辑单位为基础的，比如共享某个函数。</p>
<p>　③ 分段保护，对内存中信息的保护同样是对信息的逻辑单位进行保护。</p>
<p>　④ 动态增长，在实际应用中，数据段在使用过程中往往会不断增长，而实现无法确切知道数据段会增长到多大，分段可以较好的解决这个问题。</p>
<p>　⑤ 动态链接，再运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中有需要调用某段时，才将该段调入内存并进行链接。</p>
<h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3><p>　在分段管理中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，如有主程序段MAIN，子程序段X，数据段D及栈段S，每个段都有自己的名字，每个段从0开始编址，并采用一段连续的地址空间，段的长度由相应的逻辑信息组的长度决定，因而各段长度不等，整个作业的地址空间由于是分成多个段，因而是二维的，即其<strong>逻辑地址由段号和段内地址构成</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_13-53-24.png"></p>
<p>​	该系统可允许一个作业允许最长有64K个段，每个段的最大长度为64KB。</p>
<p>　在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区，为了使程序正常运行，能够物理内存中找出每个逻辑段所对应的位置，应该为每个进程建立一张段映射表，称为<strong>段表</strong>，每个段在表中有一个表项，其中记录了该段在内存中的起始地址和段的长度。段表可以存放在一组寄存器中，这样有利于提高地址转换速度，但通常将段表放在内存中。<strong>段表用于实现从逻辑段到物理内存区的映射</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160626090308469-1366473959.png"></p>
<p>　为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，<strong>用于存放段表始址和段表长度TL</strong>，在进行地址变换时，系统将逻辑地址中的段号与段表长度TL进行比较，若S&gt;TL，表示段号太大，访问越界，产生越界中断信号，若未越界，则根据段表的始址和该段的段号，计算该段对应段表项的位置，从中读出该段在内存中的起始地址，然后，再检查段内地址d是否超过该段的段长SL，若超过，同样发出越界中断信号，若未超过，则将该段的基址与段内地址d相加，即得到要访问的内存物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160626092459344-1686459587.png"></p>
<p>　每次访问一个数据时（需给出段号和段内地址），也需要访问两次内存，第一次根据段号获得基址，第二次根据基址与段内地址之和访问真实数据的物理地址。这降低了计算机的速率，也可以增设一个联想存储器，用来保存最近常用的段表项，用来加速存取数据的时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_14-06-30.png"></p>
<h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><p>一个多用户系统可接纳40个用户，它们都执行一个文本编辑程序(ED)，ED代码共160K，每个用户还有40K的数据区(DA)。<br>不采用信息共享时需占用的内存空间？<br>( 160K + 40K ) * 40 &#x3D; 8000K<br>采用信息共享（若ED可共享）后占用的内存空间？<br>160K + 40K * 40 &#x3D; 1760K　</p>
<p>分页与分段存在很大的相似性，如都采用离散分配方式，都需要通过地址映射机构实现地址变换，但两者的主要<strong>区别</strong>如下。</p>
<p><em>分页共享</em></p>
<ul>
<li>对于数据页面，实现起来比较简单。因为这个数据页面可以安排在诸作业地址空间中的任何一页面上。</li>
<li>对于代码页面，它必须把共享的代码安排到所有共享它的作业地址空间中相同页号的页面中。即共享代码所在的地址空间必须重叠。之所以有这种要求，是因为一个作业在运行前必须链接好，而链接后，一个例程的所占页号就确定了。如果其它作业要共享该例程，则必须使它具有相同的页号，才能正确运行。</li>
</ul>
<p><em>分段共享</em>　</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_14-23-02.png"></p>
<p>分段的共享是通过两个作业段表的相应表目都指向COS过程的同一物理副本来实现的。<br>说明：<br>⑴由于段号是在动态链接过程中分配的，而且，系统不可能事先知道某个过程将为哪些作业所调用；因此，一个公共过程不一定也无需赋相同的段号。<br>例如，[COS]在作业1的地址空间中，其段号为6，但在作业2的地址空间中其段号为3。<br>⑵当某个共享段移出主存后，必须在共享该段的每个作业之段表的相应表目中，置状态为“不在主存”标志。</p>
<p><strong>分页和分段的主要区别</strong></p>
<p>① 页是信息的物理单位，分页是为实现离散分配方式，以<strong>消减内存的外零头，提高内存的利用率</strong>，或者说，分页仅仅是由于系统管理的需要而不是用户的需要，段则是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。</p>
<p>② 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，一个系统中，只存在一种大小的页面，段的长度则不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p>
<p>③ 分页的作业的地址空间是一维的，即单一的线性的地址空间，程序员只利用一个记忆符即可表示一个地址，而分段的作业地址空间是二维的，程序员在标识一个地址是，需要给出段名和段内地址。</p>
<h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><p>　分页系统能够有效的提高内存利用率（但是会存在页内碎片），分段系统则能够很好地满足用户需要。若能将两种方式结合起来，既具有分段系统的便于实现、分段可共享、易于保护、可动态链接等优点，又能像分页系统那样很好地解决内存的外部碎片问题，基于此，提出了段页式系统。</p>
<p>　段页式系统先将用户程序分成若干个段，再把段分为若干个页，并为每一个段赋予一个段名。段页式系统中，地址结构由段号、段内页号、页内地址三部分构成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_14-24-02.png"></p>
<p>　在段页式系统中，为了便于实现地址转换，须配置一个段表寄存器，其中存放段表始址和段表长TL，进行地址变换时，首先利用段号S，将它与段表长TL进行比较，若S&lt;TL，表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用b和页内地址构成物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160626100219578-1875843366.png"></p>
<p>　在段页式系统中，为了获得一条指令或数据，需要<strong>访问内存三次</strong>，第一次访问时访问内存中的段表，从中取得页表始址，第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址，第三次访问才是真正的从第二次访问所得的地址中，取出指令或数据。同样，也可以增设高速缓冲寄存器用于加快访问速度，表项应包括段号、页号、物理块号。</p>
<p>分页管理提供( A)维的地址结构，分段管理提供(B )维的地址结构，段页式管理提供(C )维的地址结构。</p>
<p>A. 1 B. 2 C. 3 D. 4</p>
<p>段页式管理每取一次数据，要访问(C )次内存;若改为分页式管理或者分段式管理，要访问( B)次内存。</p>
<p>A. 1 B. 2 C. 3 D. 4</p>
<p>页管理的主要任务之一是实现（逻辑页号 ）到（ 物理块号） 的内存地址映像。</p>
<p>在分段管理中，系统为每个运行的作业建立一个(段表)，其内容主要包括(段号)、(段长)、(内存起始地址)和状态标志。段表是一种数据结构，用于存储程序的逻辑段与物理内存之间的映射关系。当程序访问内存时，操作系统会使用段表来查找逻辑地址对应的物理地址，然后将数据从物理内存中读取或写入  。</p>
<p>在分段管理的地址变换过程中，若执行某条指令，首先要找到该作业段表的(始址)，然后根据逻辑地址中的段号去查找(段表项)，得到该段的内存中的(物理始址)，其值与段内位移量(相加)，得到(操作的实际地址)。</p>
<h2 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h2><h3 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h3><p>前面所介绍的存储器管理方式都有共同的特点：<br>“一次性”: 要求将一个作业全部装入内存才能运行，</p>
<ul>
<li><p>大作业无法运行。</p>
</li>
<li><p>限制作业并发执行的程度。</p>
</li>
</ul>
<p>“驻留性”: 作业装入后一直驻留内存直到作业完成。</p>
<ul>
<li>内存中存在一些已无用的、或暂时不用的程序或数据，浪费内存空间。</li>
</ul>
<p>出现了下面两种情况：</p>
<p>　① 有的作业很大，其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行。</p>
<p>　② 有大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让他们先运行，而将其他大量作业留在外存上等待。</p>
<p>　为了解决上述问题，可以增加物理内存，但是其不太现实，另外是从逻辑上扩充内存容量。</p>
<p>　基于程序的局部性原理（时间局限性和空闲局限性），程序在运行之前，没有必要全部装入内存，仅需将那些当前要运行的少数页面或段先装入内存便可运行。其余部分暂留在磁盘上，程序运行时，如果它所要访问的页（段）已经调入内存，便可继续执行下去，但如果程序所要访问的页（段）尚未调入内存（缺页或缺段），此时程序应利用OS的请求调页（段）功能，将它们调入内存，以使进程继续执行下去。如果此时内存已满，无法再装入新的页（段），则还需利用页（段）的置换功能，将内存中暂时不用的页（段）调至磁盘上，再将要访问的页（段）调入内存，使程序继续执行。这样，可以使很大的用户程序在较小的内存空间中运行。从用户的调入看，该系统具有很大的内存容量，但是，用户看到的大容量只是一种感觉，这种存储器被称为<strong>虚拟存储器</strong>。所谓虚拟存储器，是指具有<strong>请求调入功能和置换功能</strong>，能从逻辑上对内存容量加以扩充的一种存储器系统，其逻辑容量由<strong>内存容量和外存容量之和</strong>决定，<strong>其运行速度接近内存，成本接近外存</strong>。</p>
<p>虚拟存储器虽然给用户提供了特大地址空间，但其容量不<br>是无限大，主要受两个方面的限制：</p>
<ul>
<li>指令中表示地址的字长<br>如：若CPU的有效地址长度为32位，则可以表示的地址最大空间为2^32，逻辑空间大小为4G，即虚存容量为 4GB。<em>与物理空间的大小无直接关系</em>。</li>
<li>外存的容量（对换区）</li>
</ul>
<h3 id="虚拟存储器的实现方法"><a href="#虚拟存储器的实现方法" class="headerlink" title="虚拟存储器的实现方法"></a>虚拟存储器的实现方法</h3><p>一、请求分页系统<br>它是在纯分页系统的基础上增加了请求调页、页面置换两大功能所形成的页式虚拟存储系统。为了实现请求调页、页面置换两大功能，系统必须提供如下的硬件支持：</p>
<ol>
<li>请求分页的页表机制。</li>
<li>缺页中断机构。</li>
<li>地址变换机构。<br> 此外，实现请求调页、页面置换两大功能还需得到<br> OS的支持。</li>
</ol>
<p>二、请求分段系统<br>它是在纯分段系统的基础上增加了请求调段、分段置换两大功能所形成的段式虚拟存储系统。为了实现请求调段、分段置换两大功能，系统必须提供如下的硬件支持：</p>
<ol>
<li>请求分段的段表机制。</li>
<li>缺段中断机构。</li>
<li>地址变换机构。<br> 此外，实现请求调段、分段置换两大功能还需<br> 得到OS的支持。</li>
</ol>
<p>三、段页式虚拟系统<br>目前，许多虚拟存储管理系统是建立在段页式系统的基础上的，通过增加了请求调页、<br>页面置换两大功能所形成的段页式虚拟存储系统。<br>如：Intel 80386处理机便支持段页式虚拟存储系统。</p>
<h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><p>1．多次性<br>多次性是指一个作业被分成多次调入内存运行。<br>2．对换性<br>对换性是指作业的运行过程中进行换进、换出。换进和换出能有效地提高内存利用率。<br>3．虚拟性<br>虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</p>
<p>虚拟性是以多次性和对换性为基础的；而多次性和对换性又必须建立在离散分配的基础上。</p>
<p>虚存实现的理论依据是什么？程序执行的局部性原理</p>
<p>如何将程序划分成部分？分页或分段</p>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><p>请求分页是建立在分页基础上的，增加了请求调页功能和页面置换功能。</p>
<h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3><p>　① <strong>页表机制</strong>，在虚拟存储系统中的所有的页表，其页描述子有了新的扩充，这是进行地址变换机构所必须的，增加四个信息标识位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_14-50-00.png"></p>
<blockquote>
<p>(1)状态位(存在位)D：用于说明该页是否已调入内存，供程序访问时参考；D&#x3D;0，该页不在内存。D&#x3D;1，该页在内存。<br>(2)访问位A：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考。A&#x3D;0，该页未被访问 。A&#x3D;1，该页被访问<br>(3)修改位M：用于表示该页在调入内存后是否被修改过，也是提供给置换算法在换出页面时是否将该页面写回外存作参考。M&#x3D;0，该页在内存中未被修改。M&#x3D;1，该页在内存中已经被修改<br>(4)外存地址：用于指出该页在外存上的地址，供调入该页时使用。</p>
</blockquote>
<p>　② <strong>缺页中断机构</strong>，当要访问的页面不在内存时，产生一个缺页中断，请求OS将缺的页面调入内存，缺页作为中断，也需要经过保护CPU现场、分析中断原因、转入中断处理程序进行处理、恢复CPU环境等。但是，其与一般中断相比有一些不同，主要在于：在指令执行期间产生和处理中断信号（通常CPU都是在一条指令执行完后，才检查是否有中断请求到达，若有，则响应，否则，继续执行下一条指令，然而，缺页中断是在指令执行期间，发现所要访问的指令或数据不再内存时所产生和处理的），一条指令在执行期间，可能产生多次缺页中断。</p>
<p>　③ <strong>地址变换机构</strong>，在分页系统地址变换基础上，再为实现虚拟存储器而增加的某些功能而形成。如产生和处理缺页中断，以及从内存中换出一页功能等。</p>
<p><strong>缺页中断处理过程</strong></p>
<p>（1）操作系统接收到进程产生的缺页中断信号，启动中断处理例程，保留处理机现场；<br>（2）操作系统通知处理机从外存读取指定的页面；<br>（3）处理机激活I&#x2F;O设备；<br>（4） 检查内存有无足够的空闲空间装入该页面？若有，转（6），否则，执行（5）；<br>（5） 利用页面置换算法，选择内存中的某个页面，换出内存；<br>（6） 将指定页面从外存装入内存；<br>（7） 更新该进程的页表；<br>（8） 更新快表；<br>（9）计算物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_14-53-05.png"></p>
<h3 id="内存分配策略和分配算法"><a href="#内存分配策略和分配算法" class="headerlink" title="内存分配策略和分配算法"></a>内存分配策略和分配算法</h3><p><strong>最小物理块数</strong>：是指能保证进程正常运行所需的最少物理块数。若系统为某进程所分配的物理块数少于此值时，进程将无法运行。</p>
<p>对于某些简单的机器，若是单地址指令且采用直接寻址方式，则所需的最少物理块数为2。(在直接寻址方式中，指令中给出的是操作数的地址。因此，需要至少两个物理块，一个用于存储指令，另一个用于存储操作数。)<br>如果该机器允许间接寻址时，则至少要求有物理块数为3。(这是因为在间接寻址方式中，指令中给出的是操作数地址的地址。因此，需要至少三个物理块，一个用于存储指令，一个用于存储操作数地址的地址，另一个用于存储操作数)</p>
<h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><p>在请求分页系统中，可采取两种内存分配策略，固定和可变分配策略，在进行置换时，也可采用全局置换和局部置换，可组合出如下三种适用的策略。</p>
<p><strong>固定分配局部置换</strong>（为每个进程分配一定数目的物理块，整个运行期不再改变，如果进程在运行中发现缺页，则只能从该进程在内存的n个页面中选出一页换出，然后再调入一页，以保证分配给该进程的内存空间不变，若开始为进程分配的物理块数太少，则会频繁缺页，降低系统吞吐量，若太多，则使内存中驻留的进程数目减少，进而造成CPU空闲或其他资源空闲的情况）</p>
<p><strong>可变分配全局置换</strong>（先为系统中的每个进程分配一定数目的物理块，而OS自身也保持一个<strong>空闲物理块队列</strong>，当某进程发现缺页时，由系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的缺页装入其中，仅当空闲物理队列的物理块用完时，OS才能从内存中选择一页调出，该页可能是系统中任一进程的页，这样，会使那个进程的物理块减少，进而使缺页率增加）</p>
<p><strong>可变分配局部置换</strong>（为每个进程分配一定数目的物理块，当进程缺页时，只允许从该进程在内存中的页面中选出一页换出，这样不会影响其他进程的运行，<em>如果该进程频繁发生缺页，则系统需要再为该进程分配若干附加的物理块，直至该进程的缺页率减少到适当程度为止</em>，反之，若一个进程正在运行过程中的缺页率特别低，则此时可适当减少分配给该进程的物理块数，但不应该引起缺页率明显增加）。</p>
<h4 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h4><p>可采用<strong>平均分配算法</strong>（将系统中所有可供分配的物理块平均分配给各个进程）、<strong>按比例分配</strong>（根据进程的大小按比例分配物理块）、<strong>考虑优先权的分配算法</strong>（将重要的，紧迫的作业分配较多的内存空间，可将系统的物理块分成两部分，一部分按比例分配给各进程，另一部分则根据进程的优先权适当地增加相应份额后，分配给进程。在有的系统中，如重要的实时控制系统，则可能是完全按优先权来为各进程分配物理块。）</p>
<h3 id="调页策略"><a href="#调页策略" class="headerlink" title="调页策略"></a>调页策略</h3><p><em>系统应当在何时把一个页面装入内存？</em></p>
<ul>
<li><p>预调页 (Prepaging)</p>
<p>可采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面，预先调入内存。<br>处理过程：<br>当进程创建时，预先为进程装入多个页面。缺页中断时，系统为进程装入指定的页面以及与之相临的多个页面。<br>若局部性很差，预先装入的很多页面不会很快被引用，并会占用大量的内存空间，反而降低系统的效率。预调页的成功率仅约50％。</p>
</li>
<li><p>请求调页 (Demand Paging)</p>
<p>仅当进程执行过程中，通过检查页表发现相应<br>页面不在内存时，才装入该页面。当进程刚开始执行时，由于预先未装入进程的<br>页面，故需要频繁地申请装入页面。执行一段时<br>间以后，进程的缺页率将下降。采用请求调页方式，一次装入请求的一个页面，<br>磁盘I&#x2F;O的启动频率较高，系统的开销较大。</p>
</li>
</ul>
<p><em>何处调入页面？</em></p>
<p>（1）对换区：系统拥有足够的对换区空间，这时可以全部从对换区调入所需页面，以提高调页的速度。<br>（2）文件区、对换区：系统缺少足够的对换区空间，这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出，以后再调入时，仍从<strong>文件区</strong>直接调入。 但对于那些可能被修改的部分，在将它们换出时，便须调到<strong>对换区</strong>，以后需要时，再从对换区调入。<br>（3）UNIX方式。由于与进程有关的文件都放在文件区，应从文件区调入。故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。</p>
<p><em>页面调入过程？</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-22-39.png"></p>
<p><em>缺页率</em></p>
<p>假设：逻辑空间为n页，内存物理块数为m(m&lt;&#x3D;n)，在运行期间访问页面成功S次，失败F次，总访问次数为A&#x3D;S+F次，则缺页率为：f&#x3D;F&#x2F;A</p>
<p>缺页率的影响因素：</p>
<blockquote>
<p>页面大小<br>进程所分配物理块的数目<br>页面置换算法<br>程序的固有特性</p>
</blockquote>
<p>请求分页管理过程中，作业地址空间同样受到内存容量大小的限制。错误</p>
<p>系统是通过 ()、()和()来实现动态分页管理的，分别用以解决何时把作业需要的信息按()从外存调入内存；内存中无空闲页框，如何将已占据的页框释放；完成虚拟地址变换为对应的物理地址。(调入策略，替换策略，地址变换，一定规则；)</p>
<p>内存扩充的概念有两种，一种是在物理上进行扩充，为系统增配更多的存储芯片，以扩大 ()；另一种是利用目前机器中实际内存空间，借助软件技术，实现内存扩充，称为()，主要技术有()和()两种。(物理空间，虚拟内存，请求分页管理，请求分段管理；)</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法-Optimal"><a href="#最佳置换算法-Optimal" class="headerlink" title="最佳置换算法(Optimal)"></a>最佳置换算法(Optimal)</h4><p>最理想的页面置换策略是：<em><strong>从主存中移出永远不再需要的页面；如无这样的页面存在，则应选择最长时间不需要访问的页面</strong></em>。 最佳置换算法是一种理想化的算法，它具有最好<br>的性能，但实际上却难于实现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-27-38.png"></p>
<h4 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a>先进先出置换算法(FIFO)</h4><p>该算法的实质是：总是选择作业中驻留时间最长(即最老)的一页淘汰。即：先进入主存的页面先退出主存。算法实现比较容易，如分配给一个作业的存储块数为m，只需建立一个m个元素的队列表Q(0)、Q(1)、…、Q(m-1)和一个替换指针。该队列是按页面调入主存的先后顺序排列的，而<strong>指针始终指向最早调入主存的一页</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-29-09.png"></p>
<p>1、该算法的出发点是最早调入内存的页面不再被访问的可能性会大一些。<br>2、该算法实现比较简单，对具有线性顺序访问的程序比较合适，而对其他情况效率不高。因为经常被访问的页面，往往在内存中停留最久，结果这些常用的页面却因变老而被淘汰。</p>
<p>先进先出算法存在一种异常现象，即在某些情况下会出现分配给的进程物理块数增多，缺页次数有时增加，有时减少的奇怪现象，这种现象称为<strong>Belady</strong>现象。例如：</p>
<table>
<thead>
<tr>
<th>物理块数</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>缺页次数</td>
<td>9</td>
<td>10</td>
<td>5</td>
</tr>
</tbody></table>
<h4 id="最近最久未使用-LRU-置换算法"><a href="#最近最久未使用-LRU-置换算法" class="headerlink" title="最近最久未使用(LRU)置换算法"></a>最近最久未使用(LRU)置换算法</h4><p>这种算法的基本思想是，利用局部性原理，根据一个作业在执行过程中过去的页面访问踪迹来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将<br>来可能也不会再被访问。<br>算法的实质是：当需要置换一页面时，选择在最近一段时间内最久不用的页面予以淘汰。<br>实现这种技术，是通过周期性地对“页面访问”位进行检查，并利用它来记录一个页面自上次访问以来所经历的时间 t ，并选择 t 为最大的页予以淘汰。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-38-21.png"></p>
<p>一般来说，对于任何一个页的访问顺序(或序列)和任何一种换页算法，如果分给的物理块数增加，则缺页(所访问页不在主存)的频率应该减少。但这个结论并不普遍成立，对于某些页面访问序列，FIFO有随着分给的页架数增加，缺页频率也增加的异常现象。</p>
<p><strong>LRU算法</strong>需要以下两类硬件的支持：<br>1.寄存器。用于记录某进程在内存中各页使用情况。<br>2.栈。用于保存当前进程使用的各个页面的页面号。</p>
<p>（1）移位寄存器：<br>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器可表示为：<br>R&#x3D;Rn-1Rn-2Rn-3···R2R1RO</p>
<ul>
<li>当进程访问某物理块时，要将相应寄存器的最高位Rn-1位置<br>成1。系统每隔一定时间（例如100 ms）将寄存器右移一位。</li>
<li>如果我们把n位寄存器的数看作是一个整数，那么，具有最<br>小数值的寄存器所对应的页面，就是最近最久未使用的页面。</li>
</ul>
<p>例：某进程在内存中具有8个页面<br>R&#x3D; R7 R6 R5 R4 R3 R2 R1 R0，每100ms将寄存器右移一位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-41-09.png"></p>
<p>(2) 栈。每当进程访问时某页面时，便将该页面号从<strong>栈中移出，压入栈顶</strong>。这样栈底则是最近最久未使用页面的页面号。 例如:假定一进程访问某页面的时页面号如下(5个存储块）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-41-21.png"></p>
<h4 id="最少使用置换算法LFU"><a href="#最少使用置换算法LFU" class="headerlink" title="最少使用置换算法LFU"></a>最少使用置换算法LFU</h4><p>最少使用置换算法LFU（Least Frequently Used)选择到当前时间为止被访问次数最少的页面被置换。<br>1、基本方法：<br>记录每个页面的访问次数，最少访问的页面首先考虑淘汰<br>2、实际采取方法<br>为页面设置移位寄存器。<br>与LRU的区别：R1&#x3D;10000000，R2&#x3D;01110100<br>LRU———-淘汰R2<br>LFU———-淘汰R1</p>
<h4 id="简单的Clock置换算法（NRU）"><a href="#简单的Clock置换算法（NRU）" class="headerlink" title="简单的Clock置换算法（NRU）"></a>简单的Clock置换算法（NRU）</h4><p>当采用简单clock算法时，为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。<br>➢当某页被访问时，其访问位被置1。<br>➢置换程序从<strong>上次停止位置</strong>开始检查页面的访问位。<br>➢如果是0，就选择该页换出；<br>➢若为1，则重新将它置0，暂不换出，而给该页第二次驻留内存的机会。<br>➢由于该算法是循环地检查各页面的使用情况，故称为clock算法。置换时是将未使用过的页面换出去，故又把该算法称为最近未用算法NRU。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_15-42-14.png"></p>
<h4 id="改进型Clock置换算法"><a href="#改进型Clock置换算法" class="headerlink" title="改进型Clock置换算法"></a>改进型Clock置换算法</h4><p>系统把一个页面移出内存时，如果该页面驻留内存期间没有被修改过，那么不必把它写回辅存，否则系统必须把它写回辅存。这表明，换出未修改过的页面比换出被修改过的页面开销小。<br>❖ 显然，我们可以依据上述结论改进CLOCK算法。改进后的CLOCK算法将在置换范围内首选：<br>❖ <em><strong>在最近没有被使用过</strong></em>；<br>❖ <em><strong>在驻留内存期间没有被修改过的页面作为被置换页面</strong></em>。<br>➢由访问位A和修改位M可以组合成下面四种类型<br>的页面：<br>➢1类（A&#x3D;0，M&#x3D;0）：表示该页最近既未彼访问，又未被修改，是最佳淘汰页。<br>➢2类（A&#x3D;0，M&#x3D;1）：表示该页最近未被访问，但已被修改，并不是很好的淘汰页。<br>➢3类（A&#x3D;1，M&#x3D;0）：最近已被访问，但未被修改：该页有可能再被访问。<br>➢4类（A&#x3D;1，M&#x3D;1）：最近已被访问且被修改，该页可能再被访问。<br>执行过程可分成以下三步：</p>
<blockquote>
<p>（1）从指针所指示的当前位置开始，扫描循环队列，寻找A&#x3D;0且M&#x3D;0的第一类页面，将所遇到的第一个页面作为所选中的淘汰页。在第一次扫描期间不改变访问位A。<br>（2）如果第一步失败，即查找一周后未遇到<strong>第一类页面</strong>，则开始第二轮扫描，寻找A&#x3D;0且M＝1的<strong>第二类页面</strong>，将所遇到的第一个这类页面作为淘汰页。<em><strong>在第二轮扫描期间，将所有扫描过的页面的访问位A都置0</strong></em>。<br>（3）如果第二步也失败，亦即未找到第二类页面，则将指针返回到开始的位置，并将所有的访问位复0。然后重复第一步，如果仍失败，必要时再重复第二步，此时一定能找到被淘汰的页 。</p>
</blockquote>
<h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><p>有效访问时间是指访问存储器所需时间的平均值。假设使用了快表，则CPU访问内存时有以下三种情况：<br>设内存读写周期为t，查找快表时间为λ，缺页中断处理时间为ɛ</p>
<ul>
<li>页面在内存且页表项在快表中：只需一次访问内存<br>EAT&#x3D; λ + t</li>
<li>页面在内存但页表项不在快表中：需两次访问内存，一次读取页<br>表，一次读取数据，另外还需更新快表。<br>EAT&#x3D; λ + t + t + λ&#x3D;2(λ + t)</li>
<li>页面不在内存：考虑查找快表时间、查找页表时间、缺页中断处<br>理时间、更新快表时间、访问实际物理地址时间<br>EAT&#x3D; λ + t +ɛ + λ + t &#x3D; ɛ + 2(λ + t)<br>引入快表命中率为α，缺页中断率为f，则有效访问内存<br>时间为：<br>EAT&#x3D; λ + α t + (1- α)[t + f(t +ɛ +λ) + (1-f)(t+λ)]</li>
</ul>
<p>当进程要求装入新的页面或程序段时，如果当前没有足够的空闲空间，需要交换一些页面或段到外存。如果被交换出去的页面或段很快将被进程使用，则<br>又需要将其换入内存。<br>如果系统花费大量的时间把程序和数据频繁地换入和换出内存而不是执行用户指令，那么，称系统出现了<strong>抖动</strong>。出现抖动现象时，系统显得非常繁忙，但是吞吐量很低，甚至产出为零。<br>根本原因：选择的页面或段不恰当。显然，防止的根本手段给进程分配足够多的帧。</p>
<p><strong>抖动</strong>：如果运行进程的大部分时间都用于页面的换入&#x2F;换出，而几乎不能完成任何有效的工作，则称此进程处于抖动状态。抖动又称为颠簸。<br>抖动分为：</p>
<ul>
<li><p>局部抖动</p>
</li>
<li><p>全局抖动</p>
</li>
</ul>
<p>抖动产生的原因有：</p>
<blockquote>
<p>进程分配的物理块太少<br>置换算法选择不当<br>全局置换使抖动传播</p>
</blockquote>
<p>只要分配的帧空间能覆盖整个局部就不会出现太多的缺页!工作集模型就用来计算一个局部的宽度(帧数)。</p>
<p>工作集定义：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-08-44.png"></p>
<h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><p>一、<strong>段表机制</strong><br>在虚拟存储系统中的所有段表，其段描述子增加五个信息标识位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-09-13.png"></p>
<p>(1)状态位(存在位)P：用于说明该段是否已调入内存，供程序访问时参考；<br>P&#x3D;0，该段不在内存。P&#x3D;1，该段在内存<br>(2)访问位A：用于记录本段在一段时间内被访问的次数，提供给置换算法选择换出段时参考。A&#x3D;0，该段未被访问。 A&#x3D;1，该段被访问<br>(3)修改位M：用于表示该段在调入内存后是否被修改过，也是提供给置换算法在换出段时是否将该段写回外存作参考。M&#x3D;0，该段在内存中未被修改。M&#x3D;1，该段在内存中已经被修改<br>(4)外存地址：用于指出该段在外存上的地址，供调入该段时使用。<br>(5)增补位：说明该分段是否允许扩展，此外如该段已被增补，则在写回辅存时，需另选择辅存空间；</p>
<p> 二、<strong>缺页中断机构</strong>，进程运行时发现所需的段尚未调入内存，便由缺段中断机构产生一个缺段中断信号，进入OS后由缺段中断处理程序将所需要的段调入内存。需要在一条指令的执行期间，产生和处理中断，以及一条指令执行期间，可能会产生多次缺段中断。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-10-24.png"></p>
<p>三、<strong>地址变换机构</strong>，其在分段系统地址变换机构基础上形成，增加了缺段中断的请求和处理功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-10-35.png"></p>
<p>为了实现分段共享，可在系统中配置一张共享段表，所有共享段都在共享段表<br>中占有一个表项。</p>
<p>共享进程计数：记录有多少进程共享该段。<br>存取控制字段：对同一共享段，不同进程有不同的操作权限。<br>段号：共享段在不同进程中有不同的段号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-10-50.png"></p>
<p>共享段的分配与回收</p>
<ul>
<li><p>共享段的分配<br>在为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中增加一表项，填写有关数据，把count置为1；之后，当又有其它进程需要调用该共享段时，由于该共享段已被调入内存，故此时无须再为该段分配内存，而只需在调用进程的段表中，增加一表项，填写该共享段的物理地址；在共<br>享段表中，填上调用进程的进程名、存取控制等，再执行count：＝count＋1操作，以表明有两个进程共享该段。</p>
</li>
<li><p>共享段的回收<br>当共享此段的某进程不再需要该段时，应将该段释放，包括撤消该进程段表中共享段所对应的表项，以及执行count:&#x3D;count-1操作。若count结果为0，则须由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项，表明此时已没有进程使用该段；否则(减1结果不为0)， 则只是取消调用者进程在共享段表中的有关记录。</p>
</li>
</ul>
<p><em><strong>环保护</strong></em></p>
<p>低编号的环具有高优先权。OS核心处于0环内；某些重要的实用程序和操作系统服务，占居中间环；而一般的应用程序在外环上。</p>
<p>环保护的基本原则是：</p>
<ul>
<li>一个程序可以访问驻留在相同环或较低特权环中的<br>数据；</li>
<li>一个程序可以调用驻留在相同环或较高特权环中的<br>服务。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-11-18.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-14_16-11-39.png"></p>
<p>在虚拟段式存储管理中，若逻辑地址的段内地址大于段表中该段的段长，则发生(越界中断)   。</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之进程管理</title>
    <url>/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5/</url>
    <content><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>操作系统的进程管理是整个操作系统管理中的核心，它包含了进程的调度、协调以及进程通信。</p>
<h2 id="进程和线程的概念-、比较"><a href="#进程和线程的概念-、比较" class="headerlink" title="进程和线程的概念 、比较"></a>进程和线程的概念 、比较</h2><p>​	典型的进程定义有：<br>（1）进程是程序的一次执行。<br>（2）进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>（3）进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p>
<p>​	<strong>线程</strong>是进程的一个实体，是<strong>独立运行和独立调度</strong>的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的<strong>线程共享</strong>进程所拥有的全部资源。</p>
<p>对比：</p>
<p>线程只拥有少量在运行中必不可少的资源。<br>进程占用资源多，线程占用资源少，使用灵活。<br>线程不能脱离进程而存在，线程的层次关系，执行顺序并不明显，会增加程序的复杂度。<br>没有通过代码显示创建线程的进程，可以看成是只有一个线程的进程。</p>
<blockquote>
<p>进程是资源分配的基本单位，线程是程序执行的基本单位</p>
<p>进程拥有自己的资源空间，而线程与CPU资源分配无关，多个线程共享同一进程内的资源，使用相同的地址空间。</p>
<p>一个进程可以包含若干个线程。</p>
</blockquote>
<h2 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h2><p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_22-37-22.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_22-37-36.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_22-37-52.png"></p>
<h2 id="进程的基本状态及转换"><a href="#进程的基本状态及转换" class="headerlink" title="进程的基本状态及转换"></a>进程的基本状态及转换</h2><p><em><strong>进程的三种基本状态</strong></em></p>
<p>就绪状态(Ready)：当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，就可以立即运行，进程这时的状态称为就绪状态。在一个系统中可能多个进程处于就绪状态，通常将它们排成一个队列，称为就绪队列。</p>
<p>执行状态(Running)：进程已获得CPU，其程序正在执行。</p>
<p>阻塞状态(Blocked)：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，把这种暂停状态称为阻塞状态，有时也称为等待状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_09-14-09.png"></p>
<p><em><strong>进程五种状态及转换模型</strong></em></p>
<p>◼就绪：准备执行<br>◼执行：占用处理机（单处理机环境中，某一时刻仅一个进程占用处理机）<br>◼阻塞：等待某事件发生才能执行，如等待I&#x2F;O完成等<br>◼新建：进程已经创建，但未被OS接纳为可执行进程，并且程序还在辅存，PCB在内存<br>◼终止：因停止或取消，被OS从执行状态释放</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_09-21-57.png"></p>
<p><em><strong>状态转换</strong></em><br>① 空 → 新状态	新创建的进程首先处于新状态。<br>② 新状态 → 就绪状态	当系统允许增加就绪进程时，操作系统接纳新建状态进程，将它变为就绪状态，插入就绪队列中。<br>③ 就绪状态 → 执行状态	当处理机空闲时，将从就绪队列中选择一个进程执行，该选择过程称为<strong>进程调度</strong>，或将处理机分派给一个进程，该进程状态从就绪转变为执行。<br>④ 执行状态 → 终止状态	执行状态的进程执行完毕，或出现诸如访问地址越界、非法指令等错误，而被异常结束，则进程从执行状态转换为终止状态。</p>
<p>⑤ 执行状态 → 就绪状态	分时系统中，<strong>时间片用完，或优先级高的进程到来</strong>，将中断较低优先级进程的执行。进程从执行状态转变为就绪状态，等待下一次调度。<br>⑥ 执行状态 → 阻塞状态	执行进程需要等待某事件发生。通常，会因为进程需要的系统调用不能立即完成，如读文件、共享虚拟内存、等待I&#x2F;O操作、等待另一进程与之通信等事件而阻塞。<br>⑦ 阻塞状态 → 就绪状态	当阻塞进程等待的事件发生，就转换为就绪状态。进入就绪队列排队，等待被调度执行。</p>
<p><em><strong>多个进程竞争内存资源</strong></em></p>
<p>◼内存资源紧张<br>◼无就绪进程，处理机空闲：I&#x2F;O的速度比处理机的速度慢得多，可能出现全部进程阻塞,等待I&#x2F;O</p>
<p><em>解决办法</em></p>
<p>◼采用交换技术：换出一部分进程到外存，以腾出内存空间（对换）<br>◼采用虚拟存储技术：每个进程只能装入一部分程序和数据（存储管理部分）</p>
<p>使执行的进程暂停执行、静止下来。我们把这种静止状态称为<strong>挂起状态</strong>（由活动到静止，由内存到外存）。</p>
<p><em><strong>挂起与阻塞</strong></em></p>
<p>区分两个概念：<br>进程是否等待事件，阻塞与否? 进程是否被换出内存，挂起与否？</p>
<p>４种状态组合<br>就绪：进程在内存，准备执行<br>阻塞：进程在内存，等待事件<br>就绪&#x2F;挂起（静止就绪）：进程在外存，只要调入内存即可执行<br>阻塞&#x2F;挂起（静止阻塞）：进程在外存，等待事件</p>
<p>若进程处于阻塞状态，当引起阻塞的条件被解除时，进程状态应变为运行状态。(×)</p>
<p>① 进程由程序和数据两部分组成。（× ）<br>② 程序的封闭性是指该程序不允许某些进程调用。（ ×）<br>③ 操作系统中，进程是<strong>资源分配</strong> 、<strong>调度</strong>和管理的最小独立单位 ， 操作系统的各种活动都与<strong>进程</strong>有关。</p>
<h2 id="PCB的作用"><a href="#PCB的作用" class="headerlink" title="PCB的作用"></a>PCB的作用</h2><p>为使程序（含数据）能独立运行，应为之配置一进程控制块，即<strong>PCB</strong>(Process Control Block)； 而由程序段、相关的数据段和PCB三部分便构成了进程实体。所谓创建进程，实质上是创建进程实体中的PCB；而撤消进程，实质上是撤消进程的PCB。</p>
<p><em><strong>进程控制块的作用</strong></em><br>1） 作为独立运行基本单位的标志；<br>2） 能实现间断性运行方式；<br>3） 提供进程管理所需要的信息；<br>4） 提供进程调度所需要的信息；<br>5） 实现与其他进程的同步与通信。</p>
<p>PCB(process control block)常驻内存，是进程存在的唯一标志；</p>
<p><em><strong>进程控制块中的信息</strong></em><br>1）进程标识符<br>2）处理机状态<br>3）进程调度信息<br>4）进程控制信息</p>
<p><em><strong>PCB的组织方式</strong></em></p>
<p>1）线性方式<br>将系统中的所有PCB组织在一张线性表中，将该表的首地址存放在一个专用区域中。<br>2）链接方式<br>把具有同一状态的PCB，用其中的链接字链接成一个队列，排成就绪队列，若干个阻塞队列以及空白队列。<br>3）索引方式<br>系统根据所有进程的状态建立几张索引表。</p>
<h2 id="进程控制的原语操作"><a href="#进程控制的原语操作" class="headerlink" title="进程控制的原语操作"></a>进程控制的原语操作</h2><p><strong>原语</strong></p>
<p>是由若干条指令组成的，是用于完成一定功能的一个过程。<br>➢ 原语是原子操作：一个操作中的所有动作要么全做，要么全不做。（操作不可中断）<br>➢ <em>原子操作在系统态下执行，常驻内存</em>。<br>➢ 原语的作用是为了实现进程的通信和控制，系统对进程的控制如不使用原语会造成其状态的不确定性，达不到进程控制的目的。</p>
<p><em><strong>进程创建</strong></em><br>调用进程<strong>创建原语Creat</strong>（ ）按下述步骤创建一个新进程：<br>（1）申请空白PCB。<br>（2）为新进程分配资源。<br>（3）初始化进程控制块。包括：①初始化标识信息。②初始化处理机状态信息。③初始化处理机控制信息。<br>（4）将新进程插入就绪队列。</p>
<p><em><strong>进程阻塞过程</strong></em><br>1)正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用<strong>阻塞原语block</strong>( )把自己阻塞。<br>2)把进程控制块中的现行状态由“执行”改为“阻塞”，并将PCB插入阻塞队列。<br>3)转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换。</p>
<p><em><strong>进程的唤醒</strong></em><br>当被阻塞进程所期待的事件出现时，则由有关进程（比如，用完并释放了该I&#x2F;O设备的进程）调用<strong>唤醒原语wakeup</strong>（ ），将等待该事件的进程唤醒。<br>1）首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪。<br>2）然后再将该PCB插入到就绪队列中。</p>
<p>Block原语和Wakeup是一对作用相反的原语；有前者就必定由后者，否则：被阻塞的进程将会因不能被唤醒而长期处于阻塞状态，从而无法继续运行。</p>
<p><em><strong>进程的挂起</strong></em><br>当出现了引起进程挂起的事件时，系统将利用<strong>挂起原语suspend</strong>（ ）将指定进程进程挂起。<br>挂起原语的执行过程是：<br>•首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪；<br>•对于活动阻塞状态的进程，则将之改为静止阻塞状态。</p>
<p><em><strong>进程的激活过程</strong></em><br>1）当发生激活进程的事件时，则可将在外存上处于静止就绪状态的进程换入内存。<br>2）系统利用<strong>激活原语active</strong>（ ）将指定进程激活:<br>▪激活原语先将进程从外存调入内存，检查该进程的现行状态;<br>▪若是静止就绪，便将之改为活动就绪；若为静止阻塞，便将之改为活动阻塞。</p>
<ol>
<li>原语是指操作系统中的初始化程序。（× ）</li>
<li>一个进程可以由系统创建，或者由(父进程 )用创建原语创建。被创建的进程开始处于等待状态。在条件成熟时，采用(调度 ) 原语为它们分配除（处理机）以外的所需资源，并被排列到(就绪 )队列中。</li>
<li>进程运行过程中，因为(缺乏资源 )、等待I&#x2F;O操作等事件发生时，通过( 阻塞)原语将它撤下，排入( 等待)队列，并引起新的( 进程调度)。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/616953-20160619213048991-866706486.png"></p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>一次仅允许一个进程访问的资源为**临界资源 **。</p>
<p>每个进程中访问临界资源的那段代码称为<strong>临界区</strong></p>
<p><strong>进程互斥</strong>：一个进程正在访问临界资源，另一个要访问该资源的进程必须等待。</p>
<p><em><strong>同步机制应遵循的规则</strong></em><br>1)空闲让进<br>2)忙则等待<br>3)有限等待<br>4)让权等待</p>
<p>并发进程可以同时进入临界区，交替访问临界资源。（×）</p>
<p><em><strong>解决临界区（互斥）问题的几类方法</strong></em><br>（1）硬件同步机制<br>（2）信号量机制<br>（3）管程机制</p>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>1）整型信号量<br>2）记录型信号量<br>3）AND型信号量<br>4）信号量集</p>
<p><em><strong>整型信号量</strong></em></p>
<p>定义为一个整型量 ,仅能通过两个标准的原子操作wait（S）和signal（S）来访问。又称为P、V操作。<br><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_10-30-23.png"></p>
<p>1）P、V操作(即wait(s)和signal(s))为原语操作——不可中断<br>2）整型信号量的使用：<br>① 必须置一次且只能置一次初值，并且初值不能为负数。<br>② 只能执行P、V操作。<br>③必须成对使用P、V操作：P操作遗漏则不能保证互斥访问，V操作遗漏则不能在使用临界资源之后将其释放；P，V次序不能错误、重复或遗漏。<br>3）整型信号量的缺点：未遵循同步机制的“让权等待”一直判断是否处理完，占用处理机。（使程序处于忙等状态，这意味着当一个进程在等待信号量时，它会不断地检查信号量的值，而不是释放CPU资源，这会浪费大量的CPU时间。）</p>
<p><em><strong>记录型信号量</strong></em></p>
<p>记录型信号量机制，则是一种不存在“忙等”现象的进程同步机制。</p>
<p>记录型信号量的wait（S）操作（ 即P(S) ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure wait(S)</span><br><span class="line">	var S: semaphore;</span><br><span class="line">		begin</span><br><span class="line">			S.value:＝S.value-1;</span><br><span class="line">			if S.value＜0 then block(S.L);</span><br><span class="line">		end</span><br></pre></td></tr></table></figure>

<p>S.value＜0，该类资源已经分配完毕，进程必须放弃处理机，自我阻塞。</p>
<p>记录型信号量采用了“让权等待”策略，当一个进程在等待信号量时，它会被<strong>阻塞并释放CPU资源</strong>，直到被唤醒这样就避免了忙等现象。</p>
<p>记录型信号量的signal（S）操作（ 即V(S) ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure signal（S）</span><br><span class="line">	var S:semaphore;</span><br><span class="line">	begin</span><br><span class="line">		S.value:＝S.value+1;</span><br><span class="line">		if S.value≤0 then wakeup(S.L);</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<p>S.value&gt;0表示有S.value个资源可用;S.value&#x3D;0表示无资源可用。</p>
<p>S.value≤0 ，在信号量链表中，仍有等待该资源的进程被阻塞。</p>
<p>记录型信号量: 若S.value&lt;0，则| S.value|表示S等待队列中的进程个数。</p>
<p><em><strong>AND型信号量</strong></em></p>
<p>AND同步机制的基本思想：将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。 在wait操作中，增加了一个“AND”条件，故称为AND同步，或称为<strong>同时wait</strong>操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swait（S1，S2，···，Sn ） &#123;</span><br><span class="line">	while（true）&#123;</span><br><span class="line">		if（ S1≥1 and S2≥1 and…and Sn≥1 ）&#123;</span><br><span class="line">			for (i = 1 ; i&lt;= n; i++)&#123;</span><br><span class="line">				Si = Si – 1;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">			调用进程进入第一个小于1的信号量的等待队列Sj.queue;阻塞调用进程;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ssignal（S1，S2，···，Sn）&#123;</span><br><span class="line">	for( i = 1; i&lt;= n; i++ )&#123;</span><br><span class="line">		Si = Si+1;</span><br><span class="line">		for (each process P waiting in Si.queue)</span><br><span class="line">			从等待队列Si.queue中取出进程P放入就绪队列;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>信号量集</strong></em></p>
<p>一般信号量集是指同时需要<strong>多种资源</strong>、每种<strong>占用的数目不同</strong>、且可分配的资源还存在一个临界值时的信号量处理。一般信号量集的基本思路就是在AND型信号量集的基础上进行扩充，在一次原语操作中完成所有的资源申请</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swait（S1，t1，d1，…，Sn，tn，dn）（满足ti≥ di）</span><br><span class="line">	if( S1 ≥t1 &amp;…&amp; Sn≥tn)&#123;</span><br><span class="line">		for( i =1; i&lt;=n; i++)&#123;</span><br><span class="line">			Si ＝Si － di;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">			调用进程进入第一个小于1的信号量的等待队列Sj.queue;阻塞调用进程;</span><br><span class="line">	&#125;//end if</span><br><span class="line">&#125;//end Swait</span><br></pre></td></tr></table></figure>

<p>tn为资源下限值，dn为需求量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ssignal（S1，d1，···，Sn，dn）&#123;</span><br><span class="line">	for( i =1; i&lt;= n; i++)&#123;</span><br><span class="line">		Si = Si + di；</span><br><span class="line">		for (each process P waiting in Si.queue)</span><br><span class="line">			从等待队列Si.queue中取出进程P放入就绪队列;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号量应用"><a href="#信号量应用" class="headerlink" title="信号量应用"></a>信号量应用</h2><p><em><strong>利用信号量实现进程互斥</strong></em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_11-35-54.png"></p>
<p><em><strong>利用信号量实现前趋关系</strong></em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_10-31-12.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p1( )&#123; S1； signal（a）；signal（b）；&#125;</span><br><span class="line">p2( )&#123; wait(a); S2；signal（c）；signal（d）; &#125;</span><br><span class="line">p3( )&#123; wait（b）；S3；signal（e）；&#125;</span><br><span class="line">p4( )&#123; wait（c）；S4；signal（f）；&#125;</span><br><span class="line">p5( )&#123; wait（d）；S5；signal（g）；&#125;</span><br><span class="line">p6( )&#123; wait（e）；wait（f）；wait（g）；S6；&#125;</span><br><span class="line"></span><br><span class="line">void main( )&#123;</span><br><span class="line">	semaphore a,b,c,d,e,f,g;</span><br><span class="line">	a.value=b.value=c.value=0;</span><br><span class="line">	d.value=e.value=f.value=g.value=0;</span><br><span class="line">cobegin</span><br><span class="line">	p1( ); p2( ); p3( ); p4( ); p5( ); p6( );</span><br><span class="line">coend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量的物理意义是当信号量大于零时表示（资源的数目 ）；当信号量小于零时，其绝对值为（ 等待该资源的进程数目） 。</p>
<p>有m个进程共享同一临界资源，若使用信号量机制实现对临界资源的互斥访问，则信号<br>量值的变化范围是（ [1-m，1]）。</p>
<h2 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h2><p>◼生产者——消费者问题<br>◼哲学家进餐问题<br>◼读者——写者问题</p>
<h3 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h3><p>生产者和消费者进程共享一个大小固定的缓冲区，其中，一个或多个生产者生产数据，并将生产的数据存入缓冲区，并有一个消费者从缓冲区中取数据。</p>
<p>◆假设缓冲区的大小为n（存储单元的个数），它可以被生产者和消费者循环使用。<br>◆分别设置两个指针in和out，指向生产者将存放数据的存储单元和消费者将取数据的存储单元</p>
<p>生产者－消费者之间满足的条件：<br>◆ 消费者想接收数据时，有界缓冲区中至少有一个单元是满的（同步问题）<br>◆ 生产者想发送数据时，有界缓冲区中至少有一个单元是空的（同步问题）<br>◆ 有界缓冲区是临界资源（互斥问题）</p>
<p>full&#x3D;0; 表示当前队列中已有的数据个数<br>empty&#x3D;n; 表示当前队列中还可以放的数据个数</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_12-54-32.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-16_12-55-12.png"></p>
<p><em><strong>利用记录型信号量解决生产者一消费者问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int in=0, out=0;</span><br><span class="line">item buffer [n];</span><br><span class="line">semaphore mutex=1, empty=n, full=0; </span><br><span class="line">void producer();</span><br><span class="line">void consumer();</span><br><span class="line">void main()&#123;</span><br><span class="line">	cobegin</span><br><span class="line">		producer(); consumer();</span><br><span class="line">	coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void producer( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		…</span><br><span class="line">		Produce an item in nextp;</span><br><span class="line">		…</span><br><span class="line">		wait(empty);</span><br><span class="line">		wait(mutex);</span><br><span class="line">		buffer(in):=nextp;</span><br><span class="line">		in:=(in+1) mod n;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		signal(full);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">        wait(full);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextc:=buffer(out);</span><br><span class="line">        out:=(out+1) mod n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);</span><br><span class="line">		Consumer the item in nextc;</span><br><span class="line">		……</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wait(empty)</code>是一个同步P操作，因为它用于同步生产者和消费者之间的操作。当缓冲区已满时，生产者需要等待消费者从缓冲区中取出一个产品，才能继续向缓冲区中添加新的产品。<code>wait(mutex)</code>是一个互斥P操作，因为它用于保护对共享资源（即缓冲区）的互斥访问。当生产者或消费者需要访问缓冲区时，它们必须先获得对缓冲区的互斥访问权。</p>
<p>① P.V操作必须成对出现，有一个P操作就一定有一个V操作；<br>② 当为互斥操作时，PV处于同一进程；<br>③ 当为同步操作时，则PV不在同一进程中出现；<br>④ 如果P(S1)和P(S2)两个操作在一个进程中，那么P操作的顺序至关重要，<strong>一个同步P操作与一个互斥P操作在一起时,同步P操作在互斥P操作之前</strong>；<br>⑤ 两个V操作的顺序无关紧要。</p>
<p><em><strong>利用AND信号量解决生产者—消费者问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int in=0, out=0;</span><br><span class="line">item buffer[ n ];</span><br><span class="line">semaphore mutex=1, empty=n, full=0;</span><br><span class="line">void producer( )&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		…</span><br><span class="line">		produce an item in nextp;</span><br><span class="line">		…</span><br><span class="line">		Swait(empty, mutex);</span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        in = (in+1) % n;</span><br><span class="line">		Ssignal(mutex, full);</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125; //end producer</span><br><span class="line"></span><br><span class="line">void consumer&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">        Swait(full, mutex);</span><br><span class="line">        nextc = buffer[out];</span><br><span class="line">        out = (out+1) % n;</span><br><span class="line">        Ssignal(mutex, empty);</span><br><span class="line">        consumer the item in nextc;</span><br><span class="line">	&#125;while(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>5个哲学家围绕一张圆桌而坐，每个哲学家前面有一碟空心面，由于面很滑，所以要两把筷子才能夹住。相邻两个碟子之间有一把筷子。哲学家只有两种活动，在感觉到饿时，分两次取左边和右边的筷子（不分次序），如果成功的得到两把筷子，就吃饭，吃完后继续思考。</p>
<p><em><strong>利用记录型信号量解决哲学家进餐问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    wait(chopstick[i]);</span><br><span class="line">    wait(chopstick[(i + 1) % 5]);</span><br><span class="line"></span><br><span class="line">    // Eat</span><br><span class="line"></span><br><span class="line">    signal(chopstick[i]);</span><br><span class="line">    signal(chopstick[(i + 1) % 5]);</span><br><span class="line"></span><br><span class="line">    // Think</span><br><span class="line"></span><br><span class="line">&#125; while (TRUE);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然上述解法可以保证不会有两个相邻的哲学家同时进餐。但却有可能引起死锁。假如五位哲学家同时饥饿而各自拿起左边的筷子的时候，就会使五个信号量chopstick均为零。当他们在试图去拿右边的筷子，都将因为无筷子可拿而无限期的等待。</p>
<p>解决办法：</p>
<ol>
<li><strong>至多只允许有四位哲学家同时去拿左边的筷子</strong>，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。</li>
<li>仅当哲学家的<strong>左、右两只筷子均可用</strong>时，才允许他拿起筷子进餐。</li>
<li>规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐。</li>
</ol>
<p><em><strong>利用AND信号量解决哲学家进餐问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    think;</span><br><span class="line"></span><br><span class="line">    Sswait(chopstick[(i + 1) % 5], chopstick[i]);</span><br><span class="line"></span><br><span class="line">    // Eat</span><br><span class="line"></span><br><span class="line">    Ssignal(chopstick[(i + 1) % 5], chopstick[i]);</span><br><span class="line"></span><br><span class="line">&#125; while (TRUE);</span><br></pre></td></tr></table></figure>

<h3 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h3><p>问题描述：对于系统中的共享对象，把只要求读该文件的进程称为“reader进程”，其它进程称为“writer进程”。所谓读者——写者问题，是指保证一个write进程必须与其它进程互斥地访问共享对象的同步问题。</p>
<p><em><strong>利用记录型信号量解决读者—写者问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore rmutex=1, wmutex = 1;</span><br><span class="line">int readcount = 0;</span><br><span class="line"></span><br><span class="line">void reader() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(rmutex);</span><br><span class="line">        if (readcount == 0) then wait(wmutex);</span><br><span class="line">        readcount = readcount + 1;</span><br><span class="line">        signal(rmutex);</span><br><span class="line"></span><br><span class="line">        // Perform read operation</span><br><span class="line"></span><br><span class="line">        wait(rmutex);</span><br><span class="line">        readcount = readcount - 1;</span><br><span class="line">        if (readcount == 0) then signal(wmutex);</span><br><span class="line">        signal(rmutex);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(wmutex);</span><br><span class="line">        </span><br><span class="line">        // Perform write operation</span><br><span class="line">        </span><br><span class="line">        signal(wmutex);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        reader();</span><br><span class="line">        writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>信号量集解决读者—写者问题</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int RN;</span><br><span class="line">Semaphore L = RN, mx = 1;</span><br><span class="line"></span><br><span class="line">// RN标示同时允许多少读进程存在</span><br><span class="line">void reader() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        swait(L, 1, 1);</span><br><span class="line">        swait(mx, 1, 0);</span><br><span class="line"></span><br><span class="line">        // Perform read operation</span><br><span class="line"></span><br><span class="line">        ssignal(L, 1);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        swait(mx, 1, 1;L, RN, 0);</span><br><span class="line">        </span><br><span class="line">        // Perform write operation</span><br><span class="line"></span><br><span class="line">        ssignal(mx, 1);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        reader();</span><br><span class="line">        writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><p>有一个理发师，一把理发椅和n把供等候理发的顾客坐的椅子。如果没有顾客，理发师便在理发椅上睡觉；当一个顾客到来时，必须唤醒理发师进行理发；如果理发师正在理发时又有顾客到来，则如果有空椅子可坐，他就坐下来等，如果没有空椅子，他就离开。为理发师和顾客各编一段程序描述他们的行为。</p>
<p>使用三个信号量：<br>◼ customers用来记录等候理发的顾客数（不包括正在理发的顾客），其初值为0；<br>◼ barbers记录正在等候顾客的理发师数，其值为0或1；<br>◼ mutex用于实现共享变量的互斥访问，其初值为1。<br>◼ 共享变量count，它也用于记录等候的顾客数，它实际上是customers的一个备份，之所以使用count是因为无法读取信号量的当前值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore customers = 0; // 等候的顾客数</span><br><span class="line">semaphore barbers = 0;   // 等候顾客的理发师数</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">int count = 0;           // 等候的顾客数（还没理发）</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        barbers();</span><br><span class="line">        customers();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">barber() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        p(customers); // 是否有等候的顾客</span><br><span class="line">        p(mutex);</span><br><span class="line">        count = count - 1; // 顾客数减1</span><br><span class="line">        v(barbers);       // 理发师开始理发</span><br><span class="line">        v(mutex);</span><br><span class="line">        理发;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customer() &#123;</span><br><span class="line">    p(mutex);</span><br><span class="line">    if (count &lt; n) &#123;</span><br><span class="line">        count = count + 1; // 若有空椅子则等候的顾客数加1</span><br><span class="line">        v(customers);</span><br><span class="line">        v(mutex);</span><br><span class="line">        p(barbers);//无理发师,顾客坐着</span><br><span class="line">        理发;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        v(mutex); // 无空椅子则离开</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信——是指进程之间的信息交换。由于每个进程都有自己独立的地址空间，因此一个进程无法直接访问另一个进程的变量或数据结构。</p>
<p><em><strong>进程通信的类型</strong></em></p>
<p>1.共享存储器系统<br>（1）基于共享数据结构的通信方式。<br>（2）基于共享存储区的通信方式。<br>2.消息传递系统<br>• 是目前的主要通信方式，信息单位：消息（报文）<br>• 实现：一组通信命令（原语），具有透明性→同步的实现。<br>实现方式的不同，而分成：<br>（1）直接通信方式</p>
<p>这是指发送进程利用OS所提供的发送命令，直接把消息发送给目标进程。<br>系统提供下述两条通信命令（原语）：<br>Send （Receiver， message）；Receive（Sender， message）；</p>
<p>例：解决生产—消费问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	… </span><br><span class="line">	produce an item in nextp; </span><br><span class="line">	…</span><br><span class="line">	send(consumer, nextp);</span><br><span class="line">&#125;while(TRUE);</span><br><span class="line">do&#123;</span><br><span class="line">	receive( producer, nextc);</span><br><span class="line">	…</span><br><span class="line">	consumer the item in nextc;</span><br><span class="line">&#125;while(TRUE);</span><br></pre></td></tr></table></figure>

<p>（2）间接通信方式</p>
<p>指进程之间利用<strong>信箱</strong>的通信方式。发送进程发送给目标进程的消息存放信箱；接收进程则从该信箱中，取出对方发送给自己的消息；消息在信箱中可以安全地保存，只允许核准的目标用户随时读取。系统为信箱通信提供了若干条原语，分别用于信箱的<br>创建、撤消和消息的发送、接收等。</p>
<p>Send (mailbox, message);Receive (mailbox, message)</p>
<p>3.管道（Pipe）通信</p>
<p>管道：连接一个读进程和一个写进程之间通信的共享文件。<br>功能：大量的数据发收。</p>
<p>4.信号</p>
<hr>
<p>在生产者—消费者问题中，如果缺少了signal(full)或signal(empty)，对执行结果将会有何影响？</p>
<p><strong>如果缺少了<code>signal(full)</code>，则消费者进程将无法从缓冲区中取出产品</strong>。这是因为消费者进程在每次取出产品之前，都会调用<code>wait(full)</code>来检查缓冲区中是否有产品。如果缺少了<code>signal(full)</code>，则缓冲区中的产品数量将永远为0，消费者进程将一直被阻塞。<strong>如果缺少了<code>signal(empty)</code>，则生产者进程将无法向缓冲区中添加新的产品</strong>。这是因为生产者进程在每次生产新产品之前，都会调用<code>wait(empty)</code>来检查缓冲区是否有空闲位置。如果缺少了<code>signal(empty)</code>，则缓冲区中的空闲位置数量将永远为0，生产者进程将一直被阻塞。</p>
<p>尝试利用记录型信号量写出一个不会出现死锁的哲学家进餐问题的算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">semaphore num = 4;</span><br><span class="line"></span><br><span class="line">void philosopher(int i) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        wait(num);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[(i + 1) % 5]);</span><br><span class="line"></span><br><span class="line">        // 进行进餐操作</span><br><span class="line"></span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[(i + 1) % 5]);</span><br><span class="line">        signal(num);</span><br><span class="line"></span><br><span class="line">        // 进行思考操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试修改下面生产者—消费者问题解法中的错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void producer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 生成一个项目 nextp</span><br><span class="line"></span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(full);</span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        signal(mutex);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(empty);</span><br><span class="line">        nextc = buffer[out];</span><br><span class="line">        out = (out + 1) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line"></span><br><span class="line">        // 消费 nextc 项目</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void producer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 生成一个项目 nextp</span><br><span class="line"></span><br><span class="line">        wait(empty);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        in = (in + 1) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(full);</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(full);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextc = buffer[out];</span><br><span class="line">        out = (out + 1) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);</span><br><span class="line"></span><br><span class="line">        // 消费 nextc 项目</span><br><span class="line">    &#125; while (TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习之文件系统</title>
    <url>/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3/</url>
    <content><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>​	文件系统是操作系统用于明确<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87/3340812?fromModule=lemma_inlink">存储设备</a>（常见的是磁盘）或分区上的文件的方法和<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fromModule=lemma_inlink">数据结构</a>；即在存储设备上组织文件的方法。操作系统中负责管理和<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6/23734835?fromModule=lemma_inlink">存储文件</a>信息的软件机构称为<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/8164847?fromModule=lemma_inlink">文件管理系统</a>，简称文件系统。</p>
<h2 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h2><p>文件系统的功能：</p>
<blockquote>
<p>有效地管理文件的存储空间；<br>管理文件目录；<br>完成文件的读&#x2F;写操作；<br>实现文件共享与保护；<br>为用户提供交互式命令接口和程序调用接口。</p>
</blockquote>
<p>​	文件系统定义：<strong>操作系统中的各类文件、管理文件的软件，以及管理文件所涉及到的数据结构等信息的集合</strong>。</p>
<p>​	现代OS几乎都是通过文件系统来组织和管理在计算机中所存储的大量程序和数据的。文件系统的管理功能是通过把它所管理的程序和数据组织成一系列文件的方法来实现的。而文件则是指具有文件名的若干相关元素的集合<strong>。</strong>元素通常是记录，而记录是一组有意义的数据项的集合。可以把数据组成分为<strong>数据项、记录、文件</strong>。</p>
<p>　① <strong>数据项</strong>，数据项是最低级数据组织形式。分为基本数据项（用于描述一个对象某种属性的字符集，是数据组织中可以命名的最小逻辑数据单位，即原子数据，又称为数据元素或字段）和组合数据项（由若干个基本数据项组成，简称组项）</p>
<p>　② <strong>记录</strong>，是一组相关数据项的集合，用于描述一个对象在某方面的属性，为了能够唯一标识一个记录，需要在一个记录的各个数据项中确定一个或几个数据项，把他们的集合称为<em><strong>关键字</strong></em>，关键字是能够唯一标识一个记录的数据项。</p>
<p>　③ <strong>文件</strong>，文件是具有文件名的一组相关元素的集合，分为有结构文件和无结构文件。有结构文件由若干个相关记录组成，无结构文件则被看成一个字符流。文件是文件系统的最大数据单位，它描述了一个对象集。</p>
<p><em><strong>一个文件可对应若干个记录，一个记录可对应若干个数据项。</strong></em></p>
<p>文件应该具有自己的属性，包括文件类型，文件长度，文件的物理位置，文件的建立时间。文件长度（文件的当前长度，也可能是最大允许长度），文件的物理位置（指示文件在哪一个设备上及在该设备的哪个位置的指针），文件的建立时间（文件最后一次修改时间）。</p>
<p><strong>文件类型</strong></p>
<ul>
<li><p><em>按用途分类</em><br>(1)系统文件<br> 这是指由系统软件构成的文件。大多数的系统文件只允许用户调用，但不允许用户去读，更不允许修改；有的系统文件不直接对用户开放。<br>(2) 用户文件<br> 由用户的源代码、目标文件、可执行文件或数据等所构成的文件。<br>(3) 库文件<br> 这是由标准子例程及常用的例程等所构成的文件。这类文件允许用户调用，但不允许修改。　</p>
</li>
<li><p><em>按文件中数据的形式分类</em><br>(1)源文件<br>指由源程序和数据构成的文件。<br>(2) 目标文件<br>指把源程序经过相应语言的编译程序编译过，但尚未经过链接程序链接的目标代码所构成的文件。它属于二进制文件。<br>(3) 可执行文件<br>指把编译后所产生的目标代码再经过链接程序链接后所形成的文件。</p>
</li>
<li><p><em>按存取控制属性分类</em><br>根据系统管理员或用户所规定的存取控制属性，可将文件分为三类：<br>(1)只执行文件<br>该类文件只允许被核准的用户调用执行，既不允许读，更不允许写。<br>(2) 只读文件<br>该类文件只允许文件主及被核准的用户去读，但不允许写。<br>(3) 读写文件<br>这是指允许文件主和被核准的用户去读或写的文件。</p>
</li>
<li><p><em>按组织形式和处理方式分类</em></p>
<p>分为普通文件，目录文件，特殊文件。</p>
</li>
</ul>
<p><em><strong>文件系统模型</strong></em></p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_10-13-38.png"></p>
<p>​	文件系统管理的对象有：<strong>文件</strong>（作为文件管理的直接对象），<strong>目录</strong>（为了方便用户对文件的存取和检索，在文件系统中配置目录，每个目录项中，必须含有文件名及该文件所在的物理地址，对目录的组织和管理是方便用户和提高对文件存取速度的关键），<strong>磁盘（磁带）存储空间</strong>（文件和目录必定占用存储空间，对这部分空间的有效管理，不仅能提高外存的利用率，而且能提高对文件的存取速度）。</p>
<p>​	为方便用户使用文件系统，文件系统通常向用户提供两种类型的接口：<br>(1) <strong>命令接口</strong>。这是指作为用户与文件系统交互的接口。 用户可通过键盘终端键入命令，取得文件系统的服务。<br>(2) <strong>程序接口</strong>。这是指作为用户程序与文件系统的接口。 用户程序可通过系统调用来取得文件系统的服务。</p>
<p><em><strong>文件操作</strong></em></p>
<p>​	用户通过文件系统提供的<strong>系统调用</strong>实施对文件的操作。最基本的文件操作有：创建文件、删除文件。读文件、写文件、截断文件和设置文件的读／写位置。</p>
<p>　当前OS所提供的大多数对文件的操作，其过程大致都是这样两步：首先，检索文件目录来找到指定文件的属性及其在外存上的位置；然后，对文件实施相应的操作，如读&#x2F;写文件等，当用户要求对一个文件实施多次读&#x2F;写或其他操作时，每次都要从检索目录开始，为了避免多次重复地检索目录，在大多数OS中都引入了打开这一文件系统调用，当用户第一次请求对某文件系统进行操作时，先利用open系统调用将该文件打开。</p>
<p>　<strong>打开是指系统将指名文件的属性（包括该文件在外存上的物理位置）从外存拷贝到内存打开文件表的一个表目中，并将该表目的编号（索引）返回给用户</strong>，以后，当用户再要求对该文件进行操作时，便可利用系统所返回的索引号向系统提出操作请求，系统便可直接利用该索引到打开文件表中去查找，从而避免了对该文件的再次检索，如果用户不再需要对该文件实施操作，可利用关闭系统调用来关闭此文件，OS将会把该文件从打开文件表中的表目上删除掉。</p>
<p>文件操作实例（Linux）</p>
<blockquote>
<p>open：打开一个文件，并指定访问该文件的方式，调用成功后返回一个文件描述符。<br>creat：打开一个文件，如果该文件不存在，则创建它，调用成功后返回一个文件描述符。<br>close：关闭文件，进程对文件所加的锁全都被释放。<br>read：从文件描述符对应的文件中读取数据，调用成功后返回读出的字节数。<br>write：向文件描述符对应的文件中写入数据，调用成功后返回写入的字节数。</p>
</blockquote>
<h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><p>　对任何的文件，都存在以下两种形式的结构</p>
<p>　① <strong>文件的逻辑结构</strong>，这是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称为文件组织。文件逻辑结构的类型：顺序文件、索引文件、索引顺序文件。</p>
<p>　② <strong>文件的物理结构</strong>，又称为文件的存储结构，是指文件在外存上的存储组织形式，不仅与存储介质的存储性能有关，还与外存分配方式有关。（分为顺序、链接及索引结构）</p>
<p>​	文件的物理结构即文件的外存分配方式，是从系统的角度来看文件，从文件在物理介质上的存放方式来研究文件。要考虑的主要问题： 如何有效地利用外存空间、如何提高对文件的访问速度。<br>目前常用的外存分配方法：<br>（1）连续分配（顺序分配）－&gt; 顺序文件结构<br>（2）链接分配－&gt; 链接文件结构<br>（3）索引分配－&gt; 索引文件结构　</p>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>　连续分配要求为每个文件分配一组相邻接的盘块，一组盘块地址定义了磁盘上的一段线性地址。采用连续分配方式时，<strong>把逻辑文件中的数据顺序地存储到邻接的各物理盘块中，这样所形成的物理文件可以进行顺序存取</strong>。文件目录中为每个文件建立一个表项，其中记载文件的第一个数据块地址及文件长度。对于顺序文件，连续读&#x2F;写多个数据块内容时，性能较好。这种分配方式保证了逻辑文件中的记录顺序与存储器中文件占用盘块的顺序的一致性。下图为连续分配方式（假设记录与盘块一样大）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_10-36-44.png">　　</p>
<p>连续分配的优点如下：</p>
<p>　① 顺序访问容易，可以随机存取, 能很快检索文件中的一个数据块。例如，如果一个文件的第一个数据块的序号为x，需要检索文件的第y块，则该数据块在外存中的位置为x+y-1。</p>
<p>　② 顺序访问速度快，磁头移动距离短，效率最高。</p>
<p>连续分配的缺点如下：</p>
<p>　① 要求又连续的存储空间，要为每个文件分配一段连续的存储空间，这样，可能产生许多磁盘碎片，严重地降低了外存空间利用率。解决方法：系统定期或不定期采用紧凑技术，将小分区合并为大的、连续分区，将文件占用空间合并在一起。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_10-37-04.png"></p>
<p>　② 必须事先知道文件的长度，事先知道文件的长度，然后根据其大小，在存储空间中找出一块其大小足够的存储区，将文件装入，对于动态增长的文件非常低效。<strong>空间利用率不高；不利于文件尺寸的动态增长。</strong></p>
<h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><p>　如果将一个逻辑文件存储到外存上，并不要求为整个文件分配一块连续的空间，而是可以将文件装到多个离散的盘块中，采用链接分配方式，可通过在每个盘块上的链接指针，<strong>将同属于一个文件的多个离散盘块链接成一个链表</strong>，把这样形成的物理文件称为链接文件。链接分配采取离散分配方式，消除了外部碎片，故而显著地提高了外存空间的利用率，并且对文件的增、删、改、查十分方便。链接方式可分为<em><strong>隐式链接和显示链接</strong></em>两种形式。</p>
<p>　① <strong>隐式链接</strong>， 在文件目录的每个目录项中，都须含有<strong>指向链接文件第一个盘块和最后一个盘块的指针</strong>。<strong>每个盘块中都含有一个指向下一个盘块的指针</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_10-37-35.png"></p>
<p>　第9个盘块指向第16个盘块，第16个盘块指向第1个盘块，第1个盘块指向第10个盘块，第10个盘块指向第25个盘块（结束块）。　　</p>
<p>　隐式链接分配的主要问题在于：其只适合于顺序访问，对随机访问的效率极其低效。如果要访问文件所在的第 i 个盘块，则必须先读出文件的第一个盘块……，就这样顺序地查找直至第 i 块。此外，其可靠性较差，任何一个指针出现问题，都会导致整个链的断开。可以将几个盘块组成一个簇，然后以簇为单位进行分配，会减少查找指定块的时间，但是会增加内部碎片。</p>
<p>　② <strong>显示链接</strong>，把用于链接文件各物理块的指针，显式的放在内存的一张链接表中，在整个磁盘仅设置一张<strong>文件分配表</strong>（FAT）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-01-31.png"></p>
<p>　表的序号从0开始，直至N-1，N为盘块总数，在每个表项中存放链接指针，即下一个盘块号，在该表中，凡是属于某一文件的第一个盘块号，或者说是每一条链的链首指针所对应的盘块号，均作为文件地址被填入相应的文件的FCB(File Control Block)的<strong>物理地址</strong>字段中，由于查找记录的过程是在内存中进行的，因而提<strong>高了检索速度，减少了访问磁盘的次数</strong>，由于分配给文件的所有盘块号都在该表中，故把该表称为文件分配表FAT（File Allocation Table）。</p>
<ul>
<li>链接分配优点<br>1、无外部碎片，没有磁盘空间浪费<br>2、无需事先知道文件大小。文件动态增长时，可动态分配空闲盘块。对文件的增、删、改十分方便。</li>
<li>缺点<br>  1、<em><strong>不能支持高效随机&#x2F;直接访问，仅适合于顺序存取</strong></em><br>  2、需为指针分配空间。（隐式链接）<br>  3、可靠性较低（指针丢失&#x2F;损坏）<br>  4、<em><strong>文件分配表FAT（显式链接），FAT需占用较大的内存空间</strong></em>。</li>
</ul>
<h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><p>​	事实上，在打开某个文件时，只需要把该文件占用的盘块号的编号调入内存即可，完全没有必要把整个FAT调入内存，为此，应该<strong>将每个文件所对应的盘块号集中地放在一起</strong>，索引分配方式就是基于这种想法所形成的一种分配方式。<em>其为每个文件分配一个索引块（表），再把分配给该文件的所有盘块号都记录在该索引块中，因而该索引块就是一个含有许多磁盘块号的数组</em>。在建立一个文件时，只需要在为之建立的目录项中填上指向该索引块的指针（单级索引）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-02-23.png"></p>
<p>　索引方式支持直接访问，可在索引块中直接找到第i个盘块，索引方式也不会产生外部碎片，当文件较大时，索引分配方式要优于链接分配方式。其主要问题在于：大文件索引项较多，可能使一个数据块容纳不了一个文件的所有分区的索引。可能需要花费较多的外存空间，每当建立一个文件时，便须为之分配一个索引块，将分配给该文件的所有盘块号记录其中。对于小文件而言，索引块的利用率非常低。</p>
<p>　当文件太大，其一级索引块太多时，这种方法是低效的。此时，应为这些索引块再建立一级索引，形成<strong>两级索引分配</strong>方式。即系统再分配一个索引块，作为第一级索引的索引块，将第一块、第二块……等索引块的盘块号填入到此索引表中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-02-32.png"></p>
<p>　在二级索引分配方式下，若每个盘块的大小为1KB，每个盘块号占4个字节，则在一个索引块可以存放256个盘块号，这样，在两级索引时，最多可以包括存放文件的盘块号总数为64K(256 * 256)个盘块号，所允许文件最大长度为64MB，若盘块大小为4KB，则一级索引的最大文件大小为4MB，二级索引的最大文件大小为4GB。</p>
<p>　④ <strong>混合索引分配方式</strong>，将多种索引分配方式相结合而形成的一种分配方式，如<strong>直接地址</strong>（在索引结点中设置10个直接地址项，每项中所存放的是该文件数据所在盘块的盘块号，假如每个盘块大小为4KB，当文件不大于40KB时，可以直接从索引结点中读出该文件的全部盘号），<strong>一次间接地址</strong>（利用索引结点中的地址项来提供一次间接地址，其实质就是一级索引分配方式，可存放1K个盘块号，允许最大文件为4MB），<strong>多次间接地址</strong>（当文件大于4MB + 40KB时，系统采用二次间址分配方式，其实质是两级索引分配方式，采用二次间址的最大文件大小为4GB，同理，可采用三次间接地址，允许文件最大大小为4TB）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-31-01.png"></p>
<h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><p>文件管理要解决的重要问题之一是如何为<strong>新创建的文件</strong>分配存储空间。<br>存储空间的<em><strong>基本分配单位是磁盘块</strong></em>。<br>其分配方法与内存的分配有许多相似之处，即同样可采取<em>连续分配方式或离散分配方式</em>。<br>系统应为分配存储空间而设置相应的数据结构；其次，系统应提供对存储空间进行分配和回收的手段。</p>
<p>文件存储空间的管理方法：</p>
<ul>
<li>空闲分区表</li>
<li>空闲链表法</li>
<li>位示图</li>
<li>成组链接法</li>
</ul>
<h3 id="空闲分区表"><a href="#空闲分区表" class="headerlink" title="空闲分区表"></a>空闲分区表</h3><p>　空闲表法属于<strong>连续分配方式</strong>，它与内存的动态分配方式雷同，它为每个文件分配一块连续的存储空间，即<strong>系统也为外存上所有空闲区建立一张空闲表，每个空闲区对应于一个空闲表项</strong>，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块号等信息，再将所有空闲区按其起始盘块号递增排列。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-39-03.png"></p>
<p>　适合于<em><strong>可变大小分区的连续分配</strong></em>方式。为文件分配存储空间时，首先顺序查找空闲分<br>区表中的各个表项，直至找到第一个大小适合的空闲分区。可以采用首次适应分配算法、最佳适应分配算法等。然后，将该分区分配给文件，同时修改空闲分区表，删除相应表项。当删除文件释放出空间时，系统回收其存储空间，合并相邻空闲分区.系统在对用户所释放的存储空间进行回收时，也采取类似于内存回收的方法，即考虑回收区是否与空闲表中插入点的前区和后区相邻接，对相邻接者应该予以合并。<em><strong>对交换分区一般都采用连续分配方式。当文件较小时，采用连续分配方式，当文件较大时，可采用离散分配方式。</strong></em></p>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>　空闲链表法是将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，把链表分成两种形式，空闲盘块链和空闲盘区链。</p>
<p>　① 空闲盘块链，这是将磁盘上的所有空闲空间，<em><strong>以盘块为单位拉成一条链</strong></em>，当用户因创建文件而请求分配存储空间时，系统从链首开始，依次摘下适当数目的空闲盘块分配给用户，当删除文件而释放空间时，系统将回收的盘块依次插入空闲盘块链的末尾，其优点是用于分配和回收一个盘块的过程简单，但在为文件分配盘块时，可能要重复操作多次。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-40-19.png"></p>
<p>　② 空闲盘区链，这是将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链，在每个盘区上除了含有只是下一个空闲盘区的指针外，还应有能指明本盘区大小（盘块数）的信息。盘区分配与内存的动态分配类似，可采用首次适应算法，在回收盘区时，同样也要将回收区和相邻接的空闲盘区相合并，在采用首次适应算法时，可以采用显式链接法提高检索速度，在内存中为空闲盘区建立一张链表。每个分区结点内容：起始盘块号、盘块数、指向下一个空闲盘区的指针。</p>
<p>​	可能的问题：</p>
<p>​	一段时间以后，可能会使空闲分区链表中包含太多小分区，使文件分配到的存储空间过分离散。删除一个由许多离散小分区组成的文件时，将回收的小分区链接到空闲分区链表中需要很长时间。若一个文件申请连续存储空间，则需要花费较长的时间查找相邻的空闲分区。因此，这种空闲空间组织方法<em><strong>适合于非连续存储</strong></em>文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-53-58.png"></p>
<h3 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h3><p>　利用二进制的一位表示磁盘中的一个盘块的使用情况，当其值为0时，表示对应的盘块空闲，为1时，表示已经分配，磁盘上的所有盘块都有一个二进制位与之对应，这样，由所有盘块所对应的位构成一个集合，称为<strong>位示图</strong>，通常可用m×n个位数来构成位示图，并使m * n等于磁盘的总块数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_11-39-38.png"></p>
<p>　对于盘块的分配分为如下三步</p>
<p>　① <strong>顺序扫描位示图</strong>，从中找出一个或一组值为0的二进制位。</p>
<p>　② 将所找到的一个或一组二进制位转换成与之相应的盘块号。</p>
<p>​	假定找到的其值为“0”的二进制位位于位示图的第i 行、第j列，则其相应的盘块号按式计算：b &#x3D; n( i - 1) + j</p>
<p>　③ 修改位示图，令map[i,j]&#x3D;1。</p>
<p>　对于盘块的回收分为如下两步</p>
<p>　① 将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为：</p>
<p>​	i &#x3D; (b - 1)DIV n + 1<br>​	j &#x3D; (b - 1)MOD n + 1</p>
<p>　② 修改位示图，令map[i,j] &#x3D;0。</p>
<p>　此方法的优点在于从位示图中很容易找到一个或一组连续的空闲分区，例如，我们需要找到8个相邻接的空闲盘块，这只需在位示图中找出8个其值连续为“0”的位即可。<br>一个位示图需要占用的存储空间大小为：磁盘容量（字节数）&#x2F; （8 * 数据块大小）<br>由于位示图很小，占用空间少，因而可将其保存在内存中，进而使在每次进行盘区分配时，无需首先把盘区分配表读入内存，节省磁盘启动时间。</p>
<p>​	但是，对于一个16GB的磁盘，若数据块大小为512字节，则位示图大小为4MB，大约需要占用8000个磁盘块的存储空间。很难一次性将该位示图全部装入内存。即使内存<br>足够大，可以存放全部或绝大部分位示图数据，搜索一个很大的位示图将会降低文件系统的性能。尤其当磁盘空间快用完，剩下的空闲磁盘块很少时，文件系统的性能将严重降低。</p>
<h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><p>　空闲表法和空闲链表法都不适用于大型系统，因为这会使空闲表或空闲链表很长，在UNIX采用的成组链接法，结合上述两种方法。</p>
<p>　① 空线盘块的组织，空闲盘块栈用来存放当前可用的一组空闲盘块的盘块号（最多含100个号），以及栈中尚有的空闲盘块号数N，顺便指出，N兼做栈顶指针使用，栈是临界资源，系统设置一把锁供进程互斥访问。其中，S.free(0)是栈底，栈满时栈顶为S.free(99)。</p>
<p>　② 文件区中的所有空闲盘块被分成若干个组，如每100个盘块作为一组。</p>
<p>　③ 将每一组含有的盘块总数N和该组所有的盘块号记入其前一组的第一个盘块S.free(0)~S.free(99)中，这样，由各组的第一个盘块可链接成一条链。</p>
<p>　④ 将第一组的盘块总数和所有的盘块号记入空闲盘块号栈中，作为当前可供分配的空闲盘块号。</p>
<p>　⑤ 最末一组只有99个盘块，其盘块号分别记入其前一组的S.free(1)~S.free(99)中，而在S.free(0)中则存放0，作为空闲盘块链的结束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_13-12-13.png"></p>
<p>　当系统要为用户分配文件所需的盘块时，须调用盘块分配过程来完成。该过程首先检查空闲盘块号栈是否上锁，如未上锁，便从栈顶取出一空闲盘块号，将与之对应的盘块分配给用户，然后将栈顶指针下移一格。若该盘块号已是栈底，即S.free(0)，这是当前栈中最后一个可分配的盘块号。由于在该盘块号所对应的盘块中记有下一组可用的盘块号，因此，须调用磁盘读过程，将栈底盘块号所对应盘块的内容读入栈中，作为新的盘块号栈的内容，并把<strong>原栈底对应的盘块分配出去</strong>(其中的有用数据已读入栈中)。然后，再分配一相应的缓冲区(作为该盘块的缓冲区)。最后，把栈中的空闲盘块数减1并返回。</p>
<p>　在系统回收空闲盘块时，须调用盘块回收过程进行回收。它是将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加1操作。当栈中空闲盘块号数目已达100时，表示栈已满，<strong>便将现有栈中的100个盘块号，记入新回收的盘块中，再将其盘块号作为新栈底</strong>。</p>
<p>例：在  UNIX  系统中有空闲盘块栈如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/6100690_1492936796345_072774B6B658B3603E1AA7198722775C.png"></p>
<p>​    (1)    现有一个进程要释放4 个物理块，其块号为150＃、156＃、172 ＃、177＃，画出空闲盘块栈每次的变化情况。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/6100690_1492936877377_072774B6B658B3603E1AA7198722775C.png"></p>
<p>​    (2)   在（ 1 ）的基础上假定一个进程要求分配5 个空闲块，画出分配完成后的空闲盘块栈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/6100690_1492936928232_072774B6B658B3603E1AA7198722775C.png"></p>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>　为了能够对文件实施有效的管理，必须对它们加以妥善组织，这主要是通过文件目录实现的，文件目录也是一种数据结构，用于标识系统中的文件及其物理地址，供检索时使用，对目录的管理要求如下：</p>
<p>　① **实现”按名存取”**，即用户只须向系统提供所需访问的文件的名字，便能够快速准确地找到指定文件在外存上的存储位置，这是目录管理中最基本的功能。</p>
<p>　② <strong>提高对目录检索速度</strong>，通过合理地组织目录结构的方法，可加快对目录的检索速度，从而提高对文件的存取速度。</p>
<p>　③ <strong>文件共享</strong>，在多用户系统中，应该允许用户共享一个文件。</p>
<p>　④ <strong>允许文件重名</strong>，系统应允许不同用户对不同文件采用相同的名字，以便用户按照自己的习惯给文件命名和使用文件。</p>
<p><strong>文件控制块</strong></p>
<p>　为了能对文件进行正确的存取，必须为文件设置<strong>用于描述和控制文件的数据结构</strong>，称之为文件控制块(FCB)，FCB是文件存在的标志。文件管理程序可借助于文件控制块中的信息，对文件施加各种操作，文件与文件控制块一一对应，而人们把<strong>文件控制块的有序集合称为文件目录</strong>，一个文件控制块就是一个文件目录项。为了实现对文件目录的管理，通常将<strong>文件目录以文件的形式保存在外存</strong>，这个文件就叫目录文件。</p>
<p>FCB的内容：</p>
<blockquote>
<p>基本信息：文件名、文件类型等；<br>地址信息：卷（存储文件的设备）、起始地址（起始物理地址）、文件长度（以字节、字或块为单位）等。<br>访问控制信息：文件所有者、访问信息（用户名和口令等）、合法操作等；<br>使用信息：创建时间、创建者身份、当前状态、最近修改时间、最近访问时间等。</p>
</blockquote>
<p>　<strong>文件目录通常是存放在磁盘上的</strong>，当文件很多时，文件目录可能要占用大量的盘块，在查找的过程中，先将存放目录文件的第一个盘块中的目录调入内存，然后把用户所给定的文件名和目录项中的文件名逐一对比。若未找到指定文件，则再将下一个盘块中的目录项调入内存。在检索目录文件时，只用到了文件名，仅当找到一个目录项（即其中的文件名与指定要查找的文件名相匹配）时，才需要从该目录项中读出该文件的物理地址，而其他一些对该文件进行描述的信息，在检索目录时一概不用，显然，这些信息在检索目录时不需要调入内存。为此，在有的系统中，如UNIX系统，便采用了把文件名和文件描述信息分开的方法，亦即，使文件描述信息单独形成一个称为<strong>索引结点</strong>的数据结构，简称为i结点，在文件目录中的每个目录项由文件名和指向该文件所对应的i结点的指针所构成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_14-28-08.png"></p>
<p>　<strong>每个文件都有唯一的磁盘索引结点（磁盘索引结点信息与文件名等信息一起构成了FCB）</strong>	</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>　目录结构的组织，关系到文件系统的存取速度，也关系到文件的共享性和安全性，目前常用的目录结构形式有单级目录、两级目录、多级目录。</p>
<p>　① <strong>单级目录结构</strong>，所有用户的全部文件目录保存在一张目录表中，每个文件的目录项占用一个表项。</p>
<p>单级目录的优点是简单且能实现目录管理的基本功能——<strong>按名存取</strong><br>存在下述一些缺点：</p>
<blockquote>
<p>(1) 查找速度慢<br>(2) 不允许重名<br>(3) 不便于实现文件共享</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_14-37-20.png"></p>
<p>② <strong>两级目录结构</strong>，为每个用户建立一个单独的<strong>用户文件目录UFD</strong>（User File Directory），这些文件目录具有相似的结构，由用户所有文件的文件控制块组成。此外，系统中还有一个<strong>主文件目录MFD</strong>（Master File Directory)，在主文件目录中，每个用户目录文件都占有一个目录项，其目录项包括<strong>用户名和指向用户目录文件的指针</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_14-38-57.png"></p>
<p>　具有如下优点：<strong>提高了检索目录的速度</strong>（如果在主目录中有n个子目录，每个用户目录最多为m个目录项，则为查找一指定的目录项，最多只需要检索n+m个目录项）。<strong>在不同的用户目录中，可以使用相同的文件名</strong>（只要在用户自己的UFD中，每个文件名都是唯一的，不同用户可以有文件名相同的文件）。<strong>不同用户还可使用不同的文件名来访问系统中同一个共享文件</strong>。但在多个用户需要合作完成一个大任务时，不便于用户之间共享文件。</p>
<p>　③ 多级目录结构，对于大型文件系统，通常采用三级或三级以上的目录结构，以提高对目录的检索速度和文件系统的性能。多级目录结构又称为树形目录结构，<strong>主目录被称为根目录</strong>，把<strong>数据文件称为树叶</strong>，<strong>其他的目录均作为树的结点</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_14-39-30.png"></p>
<p>　方框代表目录文件，圆圈代表数据文件，主目录中有是哪个用户总目录A、B、C，在B用户的总目录B中，又包括三个分目录F、E、D，其中每个分目录中又包含多个文件，为提高系统的灵活性，<strong>应该允许在一个目录文件中的目录项既是作为目录文件的FCB，又是数据文件的FCB</strong>，这一信息可用目录项中的一位来指示。如用户A总目录中，目录项A是目录文件FCB，而目录项B和D则是数据文件的FCB。</p>
<p>　在树形目录结构中，从根目录到任何数据文件，都只有一条唯一的通路，在该路径上从树的根开始，把全部目录文件名和数据文件名依次用”&#x2F;“连接起来，即构成该数据文件的路径名。<strong>系统中的每个文件都有唯一的路径名</strong>。例如，用户B访问文件J，则使用路径名&#x2F;B&#x2F;F&#x2F;J来访问。路径名：从树的根（即主目录）开始，把全部目录文件名与数据文件名，依次地用“&#x2F;”连接起来，即构成该数据文件的路径名（path name）。<strong>系统中的每一个文件都有惟一的路径名</strong>。当前目录：为每个进程设置一个“当前目录”，又称为“工作目录”，进程对各文件的访问都相对于“当前目录”而进行。<strong>把从当前目录开始的数据文件为止所构成的路径名称为相对路径名</strong>，而<strong>把从树根开始的路径名称为绝对路径名</strong>。</p>
<p><em><strong>增加和删除目录</strong></em></p>
<p>​	在树形目录结构中，用户可为自己建立UFD，并可再创建子目录，在用户要创建一个新文件时，只需要查看自己的UFD及其子目录中有无与新建文件相同的文件名，若无，便可在UFD或其某个子目录中增加一个新目录项。在树形目录中，如何删除一个目录，应该视情况而定，若要删除的目录为空，则简单地将其删除，使它在其上一级目录中所对应的目录项为空。若不为空，可采用如下方法：<strong>不删除非空目录</strong>（当目录不为空时，为了删除一个非空目录，必须先删除目录中所有的文件，使之称为空目录，然后再删除，如果目录中包含有子目录，则应该递归调用方式删除），<strong>可删除非空目录</strong>（将目录中的所有文件和子目录同时删除）。</p>
<h3 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h3><p>　当用户要访问一个已存在的文件时，系统首先利用用户提供的文件名对目录进行查询，找出该文件的文件控制块或对应索引结点，然后，根据FCB或索引结点中所记录的文件物理地址（盘块号），换算出文件在磁盘上的物理位置，最后，再通过磁盘驱动程序，将所需文件读入内存。目前常用的方式有<strong>线性检索法</strong>和<strong>Hash方法。</strong></p>
<p>　① <strong>线性检索法</strong>，其又称为顺序检索法，<em>在单级目录中</em>，利用用户提供的文件名，用顺序查找法直接从文件目录中找到指名文件的目录项。<em>在树形目录中</em>，用户提供的文件名是由多个文件分量名组成的路径名，此时须对多级目录进行查找，假定用户给定的文件路径名为&#x2F;usr&#x2F;ast&#x2F;mbox，则查找过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_14-59-42.png"></p>
<p>　首先，系统应先读入第一个文件分量名usr，用它与根目录文件（或当前目录文件）中各目录项中的文件名顺序地进行比较，从中找到匹配者，并得到匹配项的索引结点号是6，再从6号索引结点中得到usr目录文件放在132号盘块中，将该盘块内容读入内存。接着，系统再将路径名中的第二个分量名ast读入，用它与放在132号盘块中的第二级目录文件中各目录项的文件名顺序进行比较，又找到匹配项，从中得到ast的目录文件放在26号索引结点中，再从26号索引结点中得知&#x2F;usr&#x2F;ast是存放在496号盘块中，再读入496号盘块。然后，将文件的第三个分量名mbox读入，用它与第三级目录文件&#x2F;usr&#x2F;ast中各目录项的文件名进行比较，最后得到&#x2F;usr&#x2F;ast&#x2F;mbox的索引结点号为60，即在60号索引结点中存放了指定文件的物理地址，目录查询操作到此结束，如果在顺序查找过程中发现有一个文件分量名没有找到，则停止查找，并返回文件未找到信息。</p>
<p>　② <strong>Hash方法</strong>，系统利用用户提供的文件名并将它转换为文件目录的索引值，再利用该索引值到目录中去查找，这将提高检索速度。</p>
<p>①在利用Hash值查找目录时，如果目录表中相应的目录项是空的，则表示系统中并无指定文件。<br>②如果目录项中的文件名与指定文件名相匹配，则表示该目录项正是所要寻找的文件所对应的目录项，故而可从中找到该文件所在的物理地址。<br>③如果在目录表的相应目录项中的文件名与指定文件名并不匹配，则表示发生了“Hash冲突”<br>解决Hash冲突的方法 ：将其Hash值再加上一个<strong>常数</strong>（该常数应与目录的长度值互质），形成新的索引值，再返回到第一步重o新开始查找。</p>
<h2 id="文件共享和访问控制"><a href="#文件共享和访问控制" class="headerlink" title="文件共享和访问控制"></a>文件共享和访问控制</h2><p>文件共享的有效控制涉及两个方面：</p>
<ul>
<li>同时存取（Simultaneous Access）</li>
<li>存取权限（Access Rights）</li>
</ul>
<p>​	允许多个用户同时读文件内容，但<strong>不允许同时修改</strong>，或<strong>同时读且修改文件内容</strong>。共享用户之一修改文件内容时，可以将整个文件作为<em>临界资源</em>，锁定整个文件，不允许其他共享用户同时读或写文件。也可以仅仅锁定指定的一条记录，允许其他共享用户读&#x2F;写该文件的其它记录。后者的并发性能更好。</p>
<p>控制授权用户以合法的方式访问文件，包括：</p>
<blockquote>
<p>执行（Execution） — 用户可以装载并执行程序，但不允许拷贝程序内容。</p>
<p>读（Reading）— 允许用户读文件内容，包括拷贝和执行文件。某些系统严格地将浏览文件内容和拷贝权限分开，可以控制文件只能被浏览（显示），不能被拷贝。</p>
<p>追加（Appending）— 允许用户向文件添加数据，通常只能将数据添加到文件尾。但是，不能修改或删除文件内容。例如，超市收银员只能将新结帐的数据添加到文件中，不允许其修改或删除已有的数据。</p>
<p>更新（Updating）— 允许用户修改、删除、增加文件内容。包括创建文件、重写文件的全部或部分内容、移动文件的全部或部分数据等操作。</p>
<p>更改权限 (Changing protection) —一般只有文件主才能更改共享该文件的其他用户对该文件的存取权限。有的系统允许文件主将更改文件存取权限赋予其他某个用户，但必须限制授权用户更改的权限范围。</p>
<p>删除 (Deletion) 允许用户删除文件</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_15-00-00.png"></p>
<p>​	在树型结构的目录中，当有两个(或多个)用户要共享一个子目录或文件时，必须<em><strong>将共享文件或子目录链接到两个(或多个)用户的目录中</strong></em>，才能方便地找到该文件。此时该文件系统的目录结构已不再是树型结构，而是个<em><strong>有向非循环图</strong></em>。</p>
<p>​	实现文件共享的<strong>实质</strong>就是可以<strong>从不同地方打开同一个文件</strong>。打开文件的首要步骤就是找到文件的目录项，读取文件在外存的起始地址。<br>实现文件共享的方式：</p>
<ul>
<li>利用链接目录项实现法</li>
<li>利用索引节点实现法</li>
<li>利用符号链实现法</li>
</ul>
<p><strong>利用链接目录项实现法</strong></p>
<p>文件目录项中设置一个链接指针，用于指向共享文件的目录项。访问文件时，根据链接指针内容找到共享文件的目录项，读取该目录项中文件起始位置等信息，操作该文件。每当有用户（进程）共享文件时，共享文件目录项中的“共享计数”加1；当用户不再共享该文件，撤消链接指针时，“共享计数”减1。只有当共享文件用户数为1时，才能删除共享文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_15-00-27.png"></p>
<p><strong>利用索引节点实现法</strong>（硬链接）</p>
<p>​	文件的物理地址及其它的文件属性等信息，不再是放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。由任何用户对文件进行Append 操作或修改，所引起的相应结点内容的改变(例如，增加了新的盘块号和文件长度等)，都是其他用户可见的，从而也就能提供给其他用户来共享。</p>
<p>​	可以通过<em><strong>共享文件索引节点来共享文件</strong></em>，即当用户需要共享文件时，在自己的文件目录中新建一个目录项，为共享文件命名(也可用原名)，并将<em><strong>索引节点指针指向共享文件的索引节点</strong></em>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_15-00-37.png"></p>
<p>​	在索引结点中还应有一个链接计数count，用于表示链接到本索引结点(亦即文件)上的用户目录项的数目。当用户C创建一个新文件时，他便是该文件的所有者，此时将count 置1。当有用户B要共享此文件时，在用户B 的目录<br>中增加一目录项，并设置一指针指向该文件的索引结点，此时，文件主仍然是C，count&#x3D;2。<br>​	如果用户C 不再需要此文件，是否能将此文件删除呢？因为若删除了该文件，也必然删除了该文件的索引结点，这样便会便用户B的指针悬空，而用户B则可能正在此文件上执行写操作，此时用户B会无法访问到文件。因此用户C不能删除此文件，只是将该文件的count减1，然后删除自己目录中的相应目录项。用户B仍可以使用该文件。当count &#x3D;0时，表示没有用户使用该文件，系统将负责删除该文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uestc-wxy/blog_img/img/Snipaste_2023-06-15_15-00-52.png"></p>
<p><strong>利用符号链实现法</strong>（软链接）</p>
<p>​	为使B能共享C的一个文件F，可以由系统<em><strong>创建一个LINK类型的新文件</strong></em>，也取名为F并将F写入B的目录中，以实现B的目录与文件F的链接；在新文件<em><strong>只<br>包含被创文件F的路径名</strong></em>。这样的链接方法被称为<strong>符号链接</strong>。新文件中的路径名，则只被看作是符号链。当B要访问被链接的文件F且正要读LINK类新文件时，<em><strong>将被OS截获， OS根据新文件中的路径名去读该文件</strong></em>，于是就实现了用户B对文件F的共享。<br>​	在利用符号链方式实现文件共享时，只是文件主才拥有指向其索引结点的指针,而共享该文件的其它用户，则只有该文件的路径名，并不拥有指向其索引结点的指针。</p>
<p>符号链方式优点：能连接任何机器上的文件。每增加一个连接，就增加一个文件名，各用户使用自己的名字去共享文件。<br>缺点：备份可能会产生多个拷贝。这是因为每个用户都有自己的符号链接，而备份程序可能无法识别这些符号链接实际上指向同一个文件。因此，它可能会为每个符号链接创建一个单独的备份，从而导致多个拷贝。</p>
<p><strong>利用URL实现文件共享</strong><br>    统一资源定位器URL (Uniform Resource Locator)是Internet上用来链接超文本文件的一种方法。它可以链接同一台计算机中的本地文件，也可链接Internet中任何主机上的远程文件。一个完整的URL包括访问文件的方法（协议）、文件所在的主机域名、目录路径名和文件名几部份。例如，<br><a href="http://www.uestc.edu.cn/templates/index2k3/index.html">http://www.uestc.edu.cn/templates/index2k3/index.html</a></p>
<p><strong>文件保护</strong></p>
<p>​	不同对象允许实施的操作各不相同。例如，文件可施加读、写、执行等操作，信号量只能施加wait()和signal()操作。因此，<em><strong>系统为所有对象设置一个允许进程实施操作的操作集</strong></em>，任何对对象的操作必须符合操作集中的规定，防止未授权进程访问对象。</p>
<p>例一：存放在某个磁盘上的文件系统，对于采用混合索引分配方式，其FCB中共有13项地址项，第0～9个地址项为直接地址，第10个地址项为一次间接地址，第11个地址项为二次 间接地址，第12个地址项为三次间接地址。如果每个盘块的大小为512字节，盘块号需要3个字节来描述，则每个盘块最多存放170个盘块地址。<br> (1) 该文件系统允许的最大长度是多少？<br> (2) 将文件的字节偏移量5000、15000、150000转换为物理块号和块内偏移量。<br> (3) 假设某文件的索引结点已在内存中，但其他信息均在外存，为了访问该文件中某个位置的内容，最多需要几次访 问磁盘？</p>
<p>(1) 该文件系统中一个文件的最大长度可达:</p>
<p>10+170+170×170+170×170×170&#x3D;4942080块,共4942080×512字节&#x3D;2471040KB</p>
<p>(2)5000&#x2F;512得到商为9,余数为392,即字节偏移量5000对应的逻辑块号为9,块内偏移量为392。由于9&lt;10,故可直接从该文件的FCB的第9个地址项处得到物理盘块号,块内偏移量为392。</p>
<p>15000&#x2F;512得到商为29,余数为152,即字节偏移量15000对应的逻辑块号为29,块内偏移量为152。由于10&lt; 29&lt; 10+170,而29-10&#x3D;19,故可从FCB的第10个地址项,即一次间址项中得到一次间址块的地址;并从一次间址块的第19项(即该块的第57~59这3个字节)中获得对应的物理盘块号,块内偏移量为152。</p>
<p>150000&#x2F;512得到商为292,余数为496,即字节偏移量150000对应的逻辑块号为292,块内偏移量为496。由于10+170&lt; 292&lt; 10+170+170×170,而292-(10+170)&#x3D;112,112&#x2F;170得到商为0,余数为112,故可从FCB的第11个地址项,即二次间址项中得到二次间址块的地址,并从二次间址块的第0项中获得一个一次间址块的地址,再从这一次间址块的第112项中获得对应的物理盘块号,块内偏移量为496。</p>
<p>(3) 由于文件的FCB己在内存，为了访问文件中某个位置的内容，最少需要1次访问磁盘(即可通过直接地址直接读文件盘块)，最多需要4次访问磁盘(第一次是读三次间址块,第二次是读二次间址块,第三次是读一次间址块,第四次是读文件盘块)。</p>
<p>例二：有一个磁盘组共用10个盘面，每个盘面上有100个磁道，每个磁道有16个扇区，假定以扇区为单位，若使 用位示图管理磁盘空间，问位示图需要占多少空间？ 若空闲表的每个空闲表项占用5个字节，问什么时候空闲表大于位示图？</p>
<p>​	磁盘组的总扇区数为10 * 100 * 16 &#x3D; 16000。因此，位示图需要占用16000位 &#x3D; 2000字节的空间。</p>
<p>​	若空闲表的每个空闲表项占用5个字节，则当空闲表项数大于2000&#x2F;5&#x3D;400时，空闲表的大小将大于位示图。也就是说，当磁盘组中有超过400个连续的空闲扇区时，使用空闲表管理磁盘空间所需的存储空间将大于使用位示图所需的存储空间。</p>
]]></content>
      <categories>
        <category>大二下期末复习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
