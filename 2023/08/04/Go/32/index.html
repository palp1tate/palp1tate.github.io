<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RPC与gRPC详解 | Palp1tate</title><meta name="author" content="Palp1tate,1939311091@qq.com"><meta name="copyright" content="Palp1tate"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RPC原理与Go RPC什么是RPCRPC（Remote Procedure Call），即远程过程调用。它允许像调用本地服务一样调用远程服务。 RPC是一种服务器-客户端（Client&#x2F;Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。 首先与RPC（远程过程调用）相对应的是本地调用。 本地调用12345678910111213141516package ma">
<meta property="og:type" content="article">
<meta property="og:title" content="RPC与gRPC详解">
<meta property="og:url" content="https://uestcwxy.love/2023/08/04/Go/32/index.html">
<meta property="og:site_name" content="Palp1tate">
<meta property="og:description" content="RPC原理与Go RPC什么是RPCRPC（Remote Procedure Call），即远程过程调用。它允许像调用本地服务一样调用远程服务。 RPC是一种服务器-客户端（Client&#x2F;Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。 首先与RPC（远程过程调用）相对应的是本地调用。 本地调用12345678910111213141516package ma">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/IMG_20230801_114856.jpg">
<meta property="article:published_time" content="2023-08-04T03:43:59.000Z">
<meta property="article:modified_time" content="2023-09-15T11:29:54.243Z">
<meta property="article:author" content="Palp1tate">
<meta property="article:tag" content="大二自学">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/IMG_20230801_114856.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://uestcwxy.love/2023/08/04/Go/32/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Palp1tate","link":"链接: ","source":"来源: Palp1tate","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RPC与gRPC详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-15 19:29:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Palp1tate" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-clipboard-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/IMG_20230801_114856.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Palp1tate"><span class="site-name">Palp1tate</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-clipboard-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RPC与gRPC详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-04T03:43:59.000Z" title="发表于 2023-08-04 11:43:59">2023-08-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-15T11:29:54.243Z" title="更新于 2023-09-15 19:29:54">2023-09-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%92%E8%AE%AD%E8%90%A5/">青训营</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>66分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RPC与gRPC详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="RPC原理与Go-RPC"><a href="#RPC原理与Go-RPC" class="headerlink" title="RPC原理与Go RPC"></a>RPC原理与Go RPC</h1><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>RPC（Remote Procedure Call），即远程过程调用。它允许像调用本地服务一样调用远程服务。</p>
<p>RPC是一种服务器-客户端（Client&#x2F;Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。</p>
<p>首先与RPC（远程过程调用）相对应的是本地调用。</p>
<h3 id="本地调用"><a href="#本地调用" class="headerlink" title="本地调用"></a>本地调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	z := x + y</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用本地函数add</span></span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	b := <span class="number">20</span></span><br><span class="line">	ret := add(a, b)</span><br><span class="line">	fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述程序编译成二进制文件——<code>app1</code>后运行，会输出结果30。</p>
<p>在<code>app1</code>程序中本地调用<code>add</code>函数的执行流程，可以理解为以下四个步骤。</p>
<ol>
<li>将a和b的值压栈</li>
<li>通过函数指针找到add函数，进入函数取出栈中的值10和20，将其赋予x和y</li>
<li>计算x*y，并将结果存在z</li>
<li>将z的值压栈，然后从 add函数返回</li>
<li>从栈中取出z返回值，并赋值给ret</li>
</ol>
<h3 id="RPC调用"><a href="#RPC调用" class="headerlink" title="RPC调用"></a>RPC调用</h3><p>本地过程调用发生在同一进程中——定义<code>add</code>函数的代码和调用<code>add</code>函数的代码共享同一个内存空间，所以调用能够正常执行。</p>
<p>但是我们无法直接在另一个程序——<code>app2中调用</code>add&#96;函数，因为它们是两个程序——内存空间是相互隔离的。（app1和app2可能部署在同一台服务器上也可能部署在互联网的不同服务器上。）</p>
<p>RPC就是为了解决类似远程、跨内存空间、的函数&#x2F;方法调用的。要实现RPC就需要解决以下三个问题。</p>
<ol>
<li>如何确定要执行的函数？ 在本地调用中，函数主体通过函数指针函数指定，然后调用 add 函数，编译器通过函数指针函数自动确定 add 函数在内存中的位置。但是在 RPC 中，调用不能通过函数指针完成，因为它们的内存地址可能完全不同。因此，调用方和被调用方都需要维护一个{ function &lt;-&gt; ID }映射表，以确保调用正确的函数。</li>
<li>如何表达参数？ 本地过程调用中传递的参数是通过堆栈内存结构实现的，但 RPC 不能直接使用内存传递参数，因此参数或返回值需要在传输期间序列化并转换成字节流，反之亦然。</li>
<li>如何进行网络传输？ 函数的调用方和被调用方通常是通过网络连接的，也就是说，function ID 和序列化字节流需要通过网络传输，因此，只要能够完成传输，调用方和被调用方就不受某个网络协议的限制。例如，一些 RPC 框架使用 TCP 协议，一些使用 HTTP。</li>
</ol>
<p>以往实现跨服务调用的时候，我们会采用RESTful API的方式，被调用方会对外提供一个HTTP接口，调用方按要求发起HTTP请求并接收API接口返回的响应数据。下面的示例是将<code>add</code>函数包装成一个RESTful API。</p>
<h3 id="HTTP调用RESTful-API"><a href="#HTTP调用RESTful-API" class="headerlink" title="HTTP调用RESTful API"></a>HTTP调用RESTful API</h3><p>首先，我们编写一个基于HTTP的server服务，它将接收其他程序发来的HTTP请求，执行特定的程序并将结果返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> addParam <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="type">int</span> <span class="string">`json:&quot;x&quot;`</span></span><br><span class="line">	Y <span class="type">int</span> <span class="string">`json:&quot;y&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> addResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code <span class="type">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">	Data <span class="type">int</span> <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check for the HTTP method to be POST</span></span><br><span class="line">	<span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;Method not allowed&quot;</span>, http.StatusMethodNotAllowed)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parse the request body</span></span><br><span class="line">	<span class="keyword">var</span> param addParam</span><br><span class="line">	err := json.NewDecoder(r.Body).Decode(&amp;param)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;Invalid request body&quot;</span>, http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Perform the business logic</span></span><br><span class="line">	ret := add(param.X, param.Y)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return the response</span></span><br><span class="line">	resp := addResult&#123;Code: <span class="number">0</span>, Data: ret&#125;</span><br><span class="line">	w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">	err = json.NewEncoder(w).Encode(resp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;Error encoding response:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/add&quot;</span>, addHandler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们编写一个客户端来请求上述HTTP服务，传递x和y两个整数，等待返回结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Param <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="type">int</span> <span class="string">`json:&quot;x&quot;`</span></span><br><span class="line">	Y <span class="type">int</span> <span class="string">`json:&quot;y&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code <span class="type">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">	Data <span class="type">int</span> <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通过HTTP请求调用其他服务器上的add服务</span></span><br><span class="line">	url := <span class="string">&quot;http://127.0.0.1:9090/add&quot;</span></span><br><span class="line">	param := Param&#123;</span><br><span class="line">		X: <span class="number">10</span>,</span><br><span class="line">		Y: <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	paramBytes, err := json.Marshal(param)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error marshalling request body:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err := http.Post(url, <span class="string">&quot;application/json&quot;</span>, bytes.NewReader(paramBytes))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error making HTTP POST request:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	respBytes, err := io.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error reading response body:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> respData Result</span><br><span class="line">	err = json.Unmarshal(respBytes, &amp;respData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error unmarshalling response body:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(respData.Data) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式是我们目前比较常见的跨服务或跨语言之间基于RESTful API的服务调用模式。 既然使用API调用也能实现类似远程调用的目的，为什么还要用RPC呢？</p>
<p>使用 RPC 的目的是让我们调用远程方法像调用本地方法一样无差别。并且基于RESTful API通常是基于HTTP协议，传输数据采用JSON等文本协议，相较于RPC 直接使用TCP协议，传输数据多采用二进制协议来说，RPC通常相比RESTful API性能会更好。</p>
<p>RESTful API多用于前后端之间的数据传输，而目前微服务架构下各个微服务之间多采用RPC调用。</p>
<h2 id="net-rpc"><a href="#net-rpc" class="headerlink" title="net&#x2F;rpc"></a>net&#x2F;rpc</h2><h3 id="基础RPC示例"><a href="#基础RPC示例" class="headerlink" title="基础RPC示例"></a>基础RPC示例</h3><p>Go语言的 rpc 包提供对通过网络或其他 i&#x2F;o 连接导出的对象方法的访问，服务器注册一个对象，并把它作为服务对外可见（服务名称就是类型名称）。注册后，对象的导出方法将支持远程访问。服务器可以注册不同类型的多个对象(服务) ，但是不支持注册同一类型的多个对象。</p>
<p>在下面的代码中我们定义一个<code>ServiceA</code>类型，并为其定义了一个可导出的<code>Add</code>方法。并将<code>ServiceA</code>类型注册为一个服务，其Add方法就支持RPC调用了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc demo/service.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceA 自定义一个结构体类型</span></span><br><span class="line"><span class="keyword">type</span> ServiceA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 为ServiceA类型增加一个可导出的Add方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceA)</span></span> Add(args *Args, reply *<span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">	*reply = args.X + args.Y</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	service := <span class="built_in">new</span>(ServiceA)</span><br><span class="line">	rpc.Register(service) <span class="comment">// 注册RPC服务</span></span><br><span class="line">	rpc.HandleHTTP()      <span class="comment">// 基于HTTP协议</span></span><br><span class="line">	l, e := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line">	http.Serve(l, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，client 端便能看到一个拥有“Add”方法的“ServiceA”服务，想要调用这个服务需要使用下面的代码先连接到server端再执行远程调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc demo/client.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClientArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立HTTP连接</span></span><br><span class="line">	client, err := rpc.DialHTTP(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同步调用</span></span><br><span class="line">	args := &amp;ClientArgs&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ServiceA.Add error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ServiceA.Add: %d+%d=%d\n&quot;</span>, args.X, args.Y, reply)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步调用</span></span><br><span class="line">	<span class="keyword">var</span> reply2 <span class="type">int</span></span><br><span class="line">	divCall := client.Go(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply2, <span class="literal">nil</span>)</span><br><span class="line">	replyCall := &lt;-divCall.Done <span class="comment">// 接收调用结果</span></span><br><span class="line">	fmt.Println(replyCall.Error)</span><br><span class="line">	fmt.Println(reply2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a. 同步调用：</p>
<ul>
<li><code>client.Call(&quot;ServiceA.Add&quot;, args, &amp;reply)</code>: 该行代码表示使用<code>client</code>连接对象对名为”ServiceA.Add”的远程方法进行同步调用，传递了<code>args</code>作为参数，并将结果存储在<code>reply</code>中。</li>
<li>如果调用出现错误，则通过<code>log.Fatal</code>输出错误信息。</li>
</ul>
<p>b. 异步调用：</p>
<ul>
<li><code>client.Go(&quot;ServiceA.Add&quot;, args, &amp;reply2, nil)</code>: 该行代码表示使用<code>client</code>连接对象对名为”ServiceA.Add”的远程方法进行异步调用，传递了<code>args</code>作为参数，并将结果存储在<code>reply2</code>中。此处使用了Go方法，该方法会立即返回一个<code>rpc.Call</code>对象，它代表了异步调用的状态。</li>
<li><code>&lt;-divCall.Done</code>: 通过使用<code>&lt;-</code>操作符，我们等待异步调用完成，这里<code>divCall.Done</code>是一个通道，它会在异步调用结束时收到一个通知。</li>
<li><code>replyCall.Error</code>: 获取异步调用结果的错误信息（如果有的话）。</li>
<li><code>reply2</code>: 获取异步调用的返回值。</li>
</ul>
<p>执行上述两个程序，查看 RPC 调用的结果。</p>
<p>会看到如下输出结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServiceA.Add: 10+20=30</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<h3 id="基于TCP协议的RPC"><a href="#基于TCP协议的RPC" class="headerlink" title="基于TCP协议的RPC"></a>基于TCP协议的RPC</h3><p>当然 rpc 包也支持直接使用 TCP 协议而不使用HTTP协议。</p>
<p>server 端代码修改如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc demo/service.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceA 自定义一个结构体类型</span></span><br><span class="line"><span class="keyword">type</span> ServiceA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 为ServiceA类型增加一个可导出的Add方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceA)</span></span> Add(args *Args, reply *<span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">	*reply = args.X + args.Y</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	service := <span class="built_in">new</span>(ServiceA)</span><br><span class="line">	rpc.Register(service) <span class="comment">// 注册RPC服务</span></span><br><span class="line">	l, e := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, _ := l.Accept()</span><br><span class="line">		rpc.ServeConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client 端代码修改如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc demo/client.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClientArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立TCP连接</span></span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同步调用</span></span><br><span class="line">	args := &amp;ClientArgs&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ServiceA.Add error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ServiceA.Add: %d+%d=%d\n&quot;</span>, args.X, args.Y, reply)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步调用</span></span><br><span class="line">	<span class="keyword">var</span> reply2 <span class="type">int</span></span><br><span class="line">	divCall := client.Go(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply2, <span class="literal">nil</span>)</span><br><span class="line">	replyCall := &lt;-divCall.Done <span class="comment">// 接收调用结果</span></span><br><span class="line">	fmt.Println(replyCall.Error)</span><br><span class="line">	fmt.Println(reply2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用JSON协议的RPC"><a href="#使用JSON协议的RPC" class="headerlink" title="使用JSON协议的RPC"></a>使用JSON协议的RPC</h3><p>rpc 包默认使用的是 gob 协议对传输数据进行序列化&#x2F;反序列化，比较有局限性。下面的代码将尝试使用 JSON 协议对传输数据进行序列化与反序列化。</p>
<p>server 端代码修改如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc demo/service.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceA 自定义一个结构体类型</span></span><br><span class="line"><span class="keyword">type</span> ServiceA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 为ServiceA类型增加一个可导出的Add方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceA)</span></span> Add(args *Args, reply *<span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">	*reply = args.X + args.Y</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	service := <span class="built_in">new</span>(ServiceA)</span><br><span class="line">	rpc.Register(service) <span class="comment">// 注册RPC服务</span></span><br><span class="line">	l, e := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, _ := l.Accept()</span><br><span class="line">		<span class="comment">// 使用JSON协议</span></span><br><span class="line">		rpc.ServeCodec(jsonrpc.NewServerCodec(conn))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client 端代码修改如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc demo/client.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClientArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立TCP连接</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:9091&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用JSON协议</span></span><br><span class="line">	client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))</span><br><span class="line">	<span class="comment">// 同步调用</span></span><br><span class="line">	args := &amp;ClientArgs&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ServiceA.Add error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ServiceA.Add: %d+%d=%d\n&quot;</span>, args.X, args.Y, reply)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步调用</span></span><br><span class="line">	<span class="keyword">var</span> reply2 <span class="type">int</span></span><br><span class="line">	divCall := client.Go(<span class="string">&quot;ServiceA.Add&quot;</span>, args, &amp;reply2, <span class="literal">nil</span>)</span><br><span class="line">	replyCall := &lt;-divCall.Done <span class="comment">// 接收调用结果</span></span><br><span class="line">	fmt.Println(replyCall.Error)</span><br><span class="line">	fmt.Println(reply2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python调用RPC"><a href="#Python调用RPC" class="headerlink" title="Python调用RPC"></a>Python调用RPC</h3><p>下面的代码演示了如何使用 python client 远程调用上面 Go server中 serviceA的Add方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">request = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;params&quot;</span>: [&#123;<span class="string">&quot;x&quot;</span>:<span class="number">10</span>, <span class="string">&quot;y&quot;</span>:<span class="number">20</span>&#125;],  <span class="comment"># 参数要对应上Args结构体</span></span><br><span class="line">    <span class="string">&quot;method&quot;</span>: <span class="string">&quot;ServiceA.Add&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client = socket.create_connection((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9091</span>),<span class="number">5</span>)</span><br><span class="line">client.sendall(json.dumps(request).encode())</span><br><span class="line"></span><br><span class="line">rsp = client.recv(<span class="number">1024</span>)</span><br><span class="line">rsp = json.loads(rsp.decode())</span><br><span class="line"><span class="built_in">print</span>(rsp)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;id&#x27;: 0, &#x27;result&#x27;: 30, &#x27;error&#x27;: None&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h2><p>RPC 让远程调用就像本地调用一样，其调用过程可拆解为以下步骤。</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/image-20230804131507445.png" alt="image-20230804131507445"></p>
<p>① 服务调用方（client）以本地调用方式调用服务；</p>
<p>② client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</p>
<p>③ client stub找到服务地址，并将消息发送到服务端；</p>
<p>④ server 端接收到消息；</p>
<p>⑤ server stub收到消息后进行解码；</p>
<p>⑥ server stub根据解码结果调用本地的服务；</p>
<p>⑦ 本地服务执行并将结果返回给server stub；</p>
<p>⑧ server stub将返回结果打包成能够进行网络传输的消息体；</p>
<p>⑨ 按地址将消息发送至调用方；</p>
<p>⑩ client 端接收到消息；</p>
<p>⑪ client stub收到消息并进行解码；</p>
<p>⑫ 调用方得到最终结果。</p>
<p>使用RPC框架的目标是只需要关心第1步和最后1步，中间的其他步骤统统封装起来，让使用者无需关心。例如社区中各式RPC框架（grpc、thrift等）就是为了让RPC调用更方便。</p>
<h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><h2 id="gRPC是什么"><a href="#gRPC是什么" class="headerlink" title="gRPC是什么"></a>gRPC是什么</h2><p><code>gRPC</code>是一种现代化开源的高性能RPC框架，能够运行于任意环境之中。最初由谷歌进行开发。它使用HTTP&#x2F;2作为传输协议。</p>
<p>在gRPC里，客户端可以像调用本地方法一样直接调用其他机器上的服务端应用程序的方法，帮助你更容易创建分布式应用程序和服务。与许多RPC系统一样，gRPC是基于定义一个服务，指定一个可以远程调用的带有参数和返回类型的的方法。在服务端程序中实现这个接口并且运行gRPC服务处理客户端调用。在客户端，有一个stub提供和服务端相同的方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/grpc.svg" alt="grpc"></p>
<h2 id="为什么要用gRPC"><a href="#为什么要用gRPC" class="headerlink" title="为什么要用gRPC"></a>为什么要用gRPC</h2><p>使用gRPC， 我们可以一次性的在一个<code>.proto</code>文件中定义服务并使用任何支持它的语言去实现客户端和服务端，反过来，它们可以应用在各种场景中，从Google的服务器到你自己的平板电脑—— gRPC帮你解决了不同语言及环境间通信的复杂性。使用<code>protocol buffers</code>还能获得其他好处，包括高效的序列化，简单的IDL以及容易进行接口更新。总之一句话，使用gRPC能让我们更容易编写跨语言的分布式代码。</p>
<blockquote>
<p>IDL（Interface description language）是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用C++写成，另一个组件用Go写成。</p>
</blockquote>
<h2 id="安装gRPC"><a href="#安装gRPC" class="headerlink" title="安装gRPC"></a>安装gRPC</h2><h3 id="安装gRPC-1"><a href="#安装gRPC-1" class="headerlink" title="安装gRPC"></a>安装gRPC</h3><p>在你的项目目录下执行以下命令，获取 gRPC 作为项目依赖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get google.golang.org/grpc@latest</span><br></pre></td></tr></table></figure>

<h3 id="安装Protocol-Buffers-v3"><a href="#安装Protocol-Buffers-v3" class="headerlink" title="安装Protocol Buffers v3"></a>安装Protocol Buffers v3</h3><p>安装用于生成gRPC服务代码的协议编译器，最简单的方法是从下面的链接：<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases/">https://github.com/protocolbuffers/protobuf/releases/</a>下载适合你平台的预编译好的二进制文件（<code>protoc-&lt;version&gt;-&lt;platform&gt;.zip</code>）。</p>
<blockquote>
<p>适用Windows 64位<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases/download/v23.4/protoc-23.4-win64.zip">protoc-23.4-win64.zip</a></p>
</blockquote>
<p>其中：</p>
<ul>
<li>bin 目录下的 protoc 是可执行文件。</li>
<li>include 目录下的是 google 定义的<code>.proto</code>文件，我们<code>import &quot;google/protobuf/timestamp.proto&quot;</code>就是从此处导入。</li>
</ul>
<p>由于需要将下载得到的可执行文件<code>protoc</code>所在的 bin 目录加到我们电脑的环境变量中，于是我把它放到了<code>GOPATH/bin</code>里。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>因为本文我们是使用Go语言做开发，接下来执行下面的命令安装<code>protoc</code>的Go插件：</p>
<p>安装go语言插件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28</span><br></pre></td></tr></table></figure>

<p>该插件会根据<code>.proto</code>文件生成一个后缀为<code>.pb.go</code>的文件，包含所有<code>.proto</code>文件中定义的类型及其序列化方法。</p>
<p>安装grpc插件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2</span><br></pre></td></tr></table></figure>

<p>该插件会生成一个后缀为<code>_grpc.pb.go</code>的文件，其中包含：</p>
<ul>
<li>一种接口类型(或存根) ，供客户端调用的服务方法。</li>
<li>服务器要实现的接口类型。</li>
</ul>
<p>上述命令会默认将插件安装到<code>GOPATH/bin</code>，为了<code>protoc</code>编译器能找到这些插件，请确保你的<code>GOPATH/bin</code>在环境变量中。</p>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>依次执行以下命令检查一下是否开发环境都准备完毕。</p>
<ol>
<li><p>确认 protoc 安装完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --version</span><br><span class="line">libprotoc 23.4</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认 protoc-gen-go 安装完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ protoc-gen-go --version</span><br><span class="line">protoc-gen-go.exe v1.28.1</span><br></pre></td></tr></table></figure>

<p>如果这里提示<code>protoc-gen-go</code>不是可执行的程序，请确保你的 GOPATH 下的 bin 目录在你电脑的环境变量中。</p>
</li>
<li><p>确认 protoc-gen-go-grpc 安装完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ protoc-gen-go-grpc --version</span><br><span class="line">protoc-gen-go-grpc 1.2.0</span><br></pre></td></tr></table></figure>

<p>如果这里提示<code>protoc-gen-go-grpc</code>不是可执行的程序，请确保你的 GOPATH 下的 bin 目录在你电脑的环境变量中。</p>
</li>
</ol>
<h2 id="gRPC的开发方式"><a href="#gRPC的开发方式" class="headerlink" title="gRPC的开发方式"></a>gRPC的开发方式</h2><p>把大象放进冰箱分几步？</p>
<ol>
<li>把冰箱门打开。</li>
<li>把大象放进去。</li>
<li>把冰箱门带上。</li>
</ol>
<p>gRPC开发同样分三步：</p>
<h3 id="编写-proto文件定义服务"><a href="#编写-proto文件定义服务" class="headerlink" title="编写.proto文件定义服务"></a>编写<code>.proto</code>文件定义服务</h3><p>像许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以通过参数和返回类型远程调用的方法。默认情况下，gRPC 使用 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers">protocol buffers</a>作为接口定义语言(IDL)来描述服务接口和有效负载消息的结构。可以根据需要使用其他的IDL代替。</p>
<p>例如，下面使用 protocol buffers 定义了一个<code>HelloService</code>服务。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">HelloService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> greeting = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResponse</span> &#123;</span><br><span class="line">  <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在gRPC中你可以定义四种类型的服务方法。</p>
<ul>
<li>普通 rpc，客户端向服务器发送一个请求，然后得到一个响应，就像普通的函数调用一样。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> SayHello(HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务器流式 rpc，其中客户端向服务器发送请求，并获得一个流来读取一系列消息。客户端从返回的流中读取，直到没有更多的消息。gRPC 保证在单个 RPC 调用中的消息是有序的。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> LotsOfReplies(HelloRequest) <span class="keyword">returns</span> (stream HelloResponse)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端流式 rpc，其中客户端写入一系列消息并将其发送到服务器，同样使用提供的流。一旦客户端完成了消息的写入，它就等待服务器读取消息并返回响应。同样，gRPC 保证在单个 RPC 调用中对消息进行排序。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> LotsOfGreetings(stream HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>双向流式 rpc，其中双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照自己喜欢的顺序读写: 例如，服务器可以等待接收所有客户端消息后再写响应，或者可以交替读取消息然后写入消息，或者其他读写组合。每个流中的消息是有序的。</li>
</ul>
<h3 id="生成指定语言的代码"><a href="#生成指定语言的代码" class="headerlink" title="生成指定语言的代码"></a>生成指定语言的代码</h3><p>在 <code>.proto</code> 文件中的定义好服务之后，gRPC 提供了生成客户端和服务器端代码的 protocol buffers 编译器插件。</p>
<p>我们使用这些插件可以根据需要生成<code>Java</code>、<code>Go</code>、<code>C++</code>、<code>Python</code>等语言的代码。我们通常会在客户端调用这些 API，并在服务器端实现相应的 API。</p>
<ul>
<li>在服务器端，服务器实现服务声明的方法，并运行一个 gRPC 服务器来处理客户端发来的调用请求。gRPC 底层会对传入的请求进行解码，执行被调用的服务方法，并对服务响应进行编码。</li>
<li>在客户端，客户端有一个称为存根（stub）的本地对象，它实现了与服务相同的方法。然后，客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的 protocol buffers 消息类型中—— gRPC 在向服务器发送请求并返回服务器的 protocol buffers 响应之后进行处理。</li>
</ul>
<h3 id="编写业务逻辑代码"><a href="#编写业务逻辑代码" class="headerlink" title="编写业务逻辑代码"></a>编写业务逻辑代码</h3><p>gRPC 帮我们解决了 RPC 中的服务调用、数据传输以及消息编解码，我们剩下的工作就是要编写业务逻辑代码。</p>
<p>在服务端编写业务代码实现具体的服务方法，在客户端按需调用这些方法。</p>
<h2 id="gRPC入门示例"><a href="#gRPC入门示例" class="headerlink" title="gRPC入门示例"></a>gRPC入门示例</h2><h3 id="编写proto代码"><a href="#编写proto代码" class="headerlink" title="编写proto代码"></a>编写proto代码</h3><p><code>Protocol Buffers</code>是一种与语言无关，平台无关的可扩展机制，用于序列化结构化数据。使用<code>Protocol Buffers</code>可以一次定义结构化的数据，然后可以使用特殊生成的源代码轻松地在各种数据流中使用各种语言编写和读取结构化数据。</p>
<p>关于<code>Protocol Buffers</code>的教程可以查看<a target="_blank" rel="noopener" href="https://www.liwenzhou.com/posts/Go/Protobuf3-language-guide-zh/">Protocol Buffers V3中文指南</a>，本文后续内容默认读者熟悉<code>Protocol Buffers</code>。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 版本声明，使用Protocol Buffers v3版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;xx&quot;</span>;  <span class="comment">// 指定生成的Go代码在你项目中的导入路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pb; <span class="comment">// 包名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="comment">// SayHello 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResponse</span> &#123;</span><br><span class="line">    <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写Server端Go代码"><a href="#编写Server端Go代码" class="headerlink" title="编写Server端Go代码"></a>编写Server端Go代码</h3><p>我们新建一个<code>hello_server</code>项目，在项目根目录下执行<code>go mod init hello_server</code>。</p>
<p>再新建一个<code>pb</code>文件夹，将上面的 proto 文件保存为<code>hello.proto</code>，将<code>go_package</code>按如下方式修改。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;hello_server/pb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>此时，项目的目录结构为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello_server</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── pb</span><br><span class="line">    └── hello.proto</span><br></pre></td></tr></table></figure>

<p>在项目根目录下执行以下命令，根据<code>hello.proto</code>生成 go 源码文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative pb/hello.proto</span><br></pre></td></tr></table></figure>

<p>生成后的go源码文件会保存在pb文件夹下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello_server</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── pb</span><br><span class="line">    ├── hello.pb.go</span><br><span class="line">    ├── hello.proto</span><br><span class="line">    └── hello_grpc.pb.go</span><br></pre></td></tr></table></figure>

<p>将下面的内容添加到<code>hello_server/main.go</code>中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_server/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(_ context.Context, in *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloResponse&#123;Reply: <span class="string">&quot;Hello &quot;</span> + in.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听本地的8972端口</span></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8972&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()                  <span class="comment">// 创建gRPC服务器</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;) <span class="comment">// 在gRPC服务端注册服务</span></span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	err = s.Serve(lis)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并执行 <code>http_server</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build</span><br><span class="line">./server</span><br></pre></td></tr></table></figure>

<h3 id="编写Client端Go代码"><a href="#编写Client端Go代码" class="headerlink" title="编写Client端Go代码"></a>编写Client端Go代码</h3><p>我们新建一个<code>hello_client</code>项目，在项目根目录下执行<code>go mod init hello_client</code>。</p>
<p>再新建一个<code>pb</code>文件夹，将上面的 proto 文件保存为<code>hello.proto</code>，将<code>go_package</code>按如下方式修改。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;hello_client/pb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在项目根目录下执行以下命令，根据<code>hello.proto</code>在<code>http_client</code>项目下生成 go 源码文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative pb/hello.proto</span><br></pre></td></tr></table></figure>

<p>此时，项目的目录结构为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http_client</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── pb</span><br><span class="line">    ├── hello.pb.go</span><br><span class="line">    ├── hello.proto</span><br><span class="line">    └── hello_grpc.pb.go</span><br></pre></td></tr></table></figure>

<p>在<code>http_client/main.go</code>文件中按下面的代码调用<code>http_server</code>提供的 <code>SayHello</code> RPC服务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;hello_client/pb&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello_client</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultName = <span class="string">&quot;world&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	addr = flag.String(<span class="string">&quot;addr&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>, <span class="string">&quot;the address to connect to&quot;</span>)</span><br><span class="line">	name = flag.String(<span class="string">&quot;name&quot;</span>, defaultName, <span class="string">&quot;Name to greet&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 连接到server端，此处禁用安全传输</span></span><br><span class="line">	conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行RPC调用并打印收到的响应数据</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.GetReply())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后将<code>hello_client</code>编译并执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build</span><br><span class="line">./hello_client -name=wxy</span><br></pre></td></tr></table></figure>

<p>得到以下输出结果，说明RPC调用成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023/08/04 14:11:19 Greeting: Hello wxy</span><br></pre></td></tr></table></figure>

<h3 id="gRPC跨语言调用"><a href="#gRPC跨语言调用" class="headerlink" title="gRPC跨语言调用"></a>gRPC跨语言调用</h3><p>接下来，我们演示一下如何使用gRPC实现跨语言的RPC调用。</p>
<p>我们使用<code>Python</code>语言编写<code>Client</code>，然后向上面使用<code>go</code>语言编写的<code>server</code>发送RPC请求。</p>
<p>python下安装 grpc：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install grpcio</span><br></pre></td></tr></table></figure>

<p>安装gRPC tools：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install grpcio-tools</span><br></pre></td></tr></table></figure>

<h3 id="生成Python代码"><a href="#生成Python代码" class="headerlink" title="生成Python代码"></a>生成Python代码</h3><p>新建一个<code>py_client</code>项目工程，将<code>hello.proto</code>文件保存到<code>py_client/pb/</code>目录下。 </p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 版本声明，使用Protocol Buffers v3版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;py_client/pb&quot;</span>;  <span class="comment">// 指定生成的Go代码在你项目中的导入路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pb; <span class="comment">// 包名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="comment">// SayHello 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResponse</span> &#123;</span><br><span class="line">    <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>py_client</code>目录下执行以下命令，生成python源码文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -Ipb --python_out=. --grpc_python_out=. pb/hello.proto</span><br></pre></td></tr></table></figure>

<h3 id="编写Python版RPC客户端"><a href="#编写Python版RPC客户端" class="headerlink" title="编写Python版RPC客户端"></a>编写Python版RPC客户端</h3><p>将下面的代码保存到<code>py_client/client.py</code>文件中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> hello_pb2</span><br><span class="line"><span class="keyword">import</span> hello_pb2_grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="comment"># NOTE(gRPC Python Team): .close() is possible on a channel and should be</span></span><br><span class="line">    <span class="comment"># used in circumstances in which the with statement does not fit the needs</span></span><br><span class="line">    <span class="comment"># of the code.</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">&#x27;127.0.0.1:8972&#x27;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = hello_pb2_grpc.GreeterStub(channel)</span><br><span class="line">        resp = stub.SayHello(hello_pb2.HelloRequest(name=<span class="string">&#x27;q1mi&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span> + resp.reply)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<p>此时项目的目录结构图如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">py_client</span><br><span class="line">├── client.py</span><br><span class="line">├── hello_pb2.py</span><br><span class="line">├── hello_pb2_grpc.py</span><br><span class="line">└── pb</span><br><span class="line">    └── hello.proto</span><br></pre></td></tr></table></figure>

<h3 id="Python-RPC-调用"><a href="#Python-RPC-调用" class="headerlink" title="Python RPC 调用"></a>Python RPC 调用</h3><p>执行<code>client.py</code>调用go语言的<code>SayHello</code>RPC服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python client.py</span><br><span class="line">Greeter client received: Hello wxy</span><br></pre></td></tr></table></figure>

<p>这里我们就实现了，使用 Python 代码编写的client去调用Go语言版本的server了。</p>
<h2 id="gRPC流式示例"><a href="#gRPC流式示例" class="headerlink" title="gRPC流式示例"></a>gRPC流式示例</h2><p>在上面的示例中，客户端发起了一个RPC请求到服务端，服务端进行业务处理并返回响应给客户端，这是gRPC最基本的一种工作方式（Unary RPC）。除此之外，依托于HTTP2，gRPC还支持流式RPC（Streaming RPC）。</p>
<h3 id="服务端流式RPC"><a href="#服务端流式RPC" class="headerlink" title="服务端流式RPC"></a>服务端流式RPC</h3><p>客户端发出一个RPC请求，服务端与客户端之间建立一个单向的流，服务端可以向流中写入多个响应消息，最后主动关闭流；而客户端需要监听这个流，不断获取响应直到流关闭。应用场景举例：客户端向服务端发送一个股票代码，服务端就把该股票的实时数据源源不断的返回给客户端。</p>
<p>我们在此编写一个使用多种语言打招呼的方法，客户端发来一个用户名，服务端分多次返回打招呼的信息。</p>
<p>1.定义服务</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 版本声明，使用Protocol Buffers v3版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;hello_server/pb&quot;</span>;  <span class="comment">// 指定生成的Go代码在你项目中的导入路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pb; <span class="comment">// 包名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// 服务端返回流式数据</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> LotsOfReplies(HelloRequest) <span class="keyword">returns</span> (stream HelloResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResponse</span> &#123;</span><br><span class="line">  <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>.proto</code>文件后，需要重新使用 protocol buffers编译器生成<font  color="red">客户端和服务端</font>代码。</p>
<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative pb/hello.proto</span><br></pre></td></tr></table></figure>

<p>2.服务端需要实现 <code>LotsOfReplies</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_server/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LotsOfReplies 返回使用多种语言打招呼</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> LotsOfReplies(in *pb.HelloRequest, stream pb.Greeter_LotsOfRepliesServer) <span class="type">error</span> &#123;</span><br><span class="line">	words := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;你好&quot;</span>,</span><br><span class="line">		<span class="string">&quot;hello&quot;</span>,</span><br><span class="line">		<span class="string">&quot;こんにちは&quot;</span>,</span><br><span class="line">		<span class="string">&quot;안녕하세요&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">		data := &amp;pb.HelloResponse&#123;</span><br><span class="line">			Reply: word + in.GetName(),</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 使用Send方法返回多个数据</span></span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听本地的8972端口</span></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8972&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()                  <span class="comment">// 创建gRPC服务器</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;) <span class="comment">// 在gRPC服务端注册服务</span></span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	err = s.Serve(lis)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.客户端调用<code>LotsOfReplies</code> 并将收到的数据依次打印出来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;hello_client/pb&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello_client</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultName = <span class="string">&quot;world&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	addr = flag.String(<span class="string">&quot;addr&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>, <span class="string">&quot;the address to connect to&quot;</span>)</span><br><span class="line">	name = flag.String(<span class="string">&quot;name&quot;</span>, defaultName, <span class="string">&quot;Name to greet&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 连接到server端，此处禁用安全传输</span></span><br><span class="line">	conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// server端流式RPC</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	stream, err := c.LotsOfReplies(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;c.LotsOfReplies failed, err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 接收服务端返回的流式数据，当收到io.EOF或错误时退出</span></span><br><span class="line">		res, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;c.LotsOfReplies failed, err: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">&quot;got reply: %q\n&quot;</span>, res.GetReply())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后将<code>hello_client</code>编译并执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build</span><br><span class="line">./hello_client -name=wxy</span><br></pre></td></tr></table></figure>

<p>执行程序后会得到如下输出结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2023/08/04 15:08:38 got reply: <span class="string">&quot;你好wxy&quot;</span></span><br><span class="line">2023/08/04 15:08:38 got reply: <span class="string">&quot;hellowxy&quot;</span></span><br><span class="line">2023/08/04 15:08:38 got reply: <span class="string">&quot;こんにちはwxy&quot;</span></span><br><span class="line">2023/08/04 15:08:38 got reply: <span class="string">&quot;안녕하세요wxy&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="客户端流式RPC"><a href="#客户端流式RPC" class="headerlink" title="客户端流式RPC"></a>客户端流式RPC</h3><p>客户端传入多个请求对象，服务端返回一个响应结果。典型的应用场景举例：物联网终端向服务器上报数据、大数据流式计算等。</p>
<p>在这个示例中，我们编写一个多次发送人名，服务端统一返回一个打招呼消息的程序。</p>
<p>1.定义服务</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 版本声明，使用Protocol Buffers v3版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;hello_server/pb&quot;</span>;  <span class="comment">// 指定生成的Go代码在你项目中的导入路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pb; <span class="comment">// 包名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// 客户端发送流式数据</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> LotsOfGreetings(stream HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应消息</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloResponse</span> &#123;</span><br><span class="line">  <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>.proto</code>文件后，需要重新使用 protocol buffers编译器生成客户端和服务端代码。</p>
<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative pb/hello.proto</span><br></pre></td></tr></table></figure>

<p>2.服务端实现<code>LotsOfGreetings</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_server/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LotsOfGreetings 接收流式数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> LotsOfGreetings(stream pb.Greeter_LotsOfGreetingsServer) <span class="type">error</span> &#123;</span><br><span class="line">	reply := <span class="string">&quot;你好：&quot;</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 接收客户端发来的流式数据</span></span><br><span class="line">		res, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="comment">// 最终统一回复</span></span><br><span class="line">			<span class="keyword">return</span> stream.SendAndClose(&amp;pb.HelloResponse&#123;</span><br><span class="line">				Reply: reply,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		reply += res.GetName()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听本地的8972端口</span></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8972&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()                  <span class="comment">// 创建gRPC服务器</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;) <span class="comment">// 在gRPC服务端注册服务</span></span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	err = s.Serve(lis)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>3.客户端调用<code>LotsOfGreetings</code>方法，向服务端发送流式请求数据，接收返回值并打印。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;hello_client/pb&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello_client</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultName = <span class="string">&quot;world&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	addr = flag.String(<span class="string">&quot;addr&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>, <span class="string">&quot;the address to connect to&quot;</span>)</span><br><span class="line">	name = flag.String(<span class="string">&quot;name&quot;</span>, defaultName, <span class="string">&quot;Name to greet&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 连接到server端，此处禁用安全传输</span></span><br><span class="line">	conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="comment">// 客户端流式RPC</span></span><br><span class="line">	stream, err := c.LotsOfGreetings(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;c.LotsOfGreetings failed, err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	names := []<span class="type">string</span>&#123;<span class="string">&quot;wxy&quot;</span>, <span class="string">&quot;Palp1tate&quot;</span>, <span class="string">&quot;沙河娜扎&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">		<span class="comment">// 发送流式数据</span></span><br><span class="line">		err := stream.Send(&amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;c.LotsOfGreetings stream.Send(%v) failed, err: %v&quot;</span>, name, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res, err := stream.CloseAndRecv()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;c.LotsOfGreetings failed: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;got reply: %v&quot;</span>, res.GetReply())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述函数将得到如下数据结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023/08/04 15:11:59 got reply: 你好：wxyPalp1tate沙河娜扎</span><br></pre></td></tr></table></figure>

<h3 id="双向流式RPC"><a href="#双向流式RPC" class="headerlink" title="双向流式RPC"></a>双向流式RPC</h3><p>双向流式RPC即客户端和服务端均为流式的RPC，能发送多个请求对象也能接收到多个响应对象。典型应用示例：聊天应用等。</p>
<p>我们这里还是编写一个客户端和服务端进行人机对话的双向流式RPC示例。</p>
<p>1.定义服务</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向流式数据</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> BidiHello(stream HelloRequest) <span class="keyword">returns</span> (stream HelloResponse)</span>;</span><br></pre></td></tr></table></figure>

<p>修改<code>.proto</code>文件后，需要重新使用 protocol buffers编译器生成客户端和服务端代码。</p>
<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative pb/hello.proto</span><br></pre></td></tr></table></figure>

<p>2.服务端实现<code>BidiHello</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_server/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BidiHello 双向流式打招呼</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> BidiHello(stream pb.Greeter_BidiHelloServer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 接收流式请求</span></span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		reply := magic(in.GetName()) <span class="comment">// 对收到的数据做些处理</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回流式响应</span></span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(&amp;pb.HelloResponse&#123;Reply: reply&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// magic 一段价值连城的“人工智能”代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">magic</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	s = strings.ReplaceAll(s, <span class="string">&quot;吗&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	s = strings.ReplaceAll(s, <span class="string">&quot;吧&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	s = strings.ReplaceAll(s, <span class="string">&quot;你&quot;</span>, <span class="string">&quot;我&quot;</span>)</span><br><span class="line">	s = strings.ReplaceAll(s, <span class="string">&quot;？&quot;</span>, <span class="string">&quot;!&quot;</span>)</span><br><span class="line">	s = strings.ReplaceAll(s, <span class="string">&quot;?&quot;</span>, <span class="string">&quot;!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听本地的8972端口</span></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8972&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()                  <span class="comment">// 创建gRPC服务器</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;) <span class="comment">// 在gRPC服务端注册服务</span></span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	err = s.Serve(lis)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.客户端调用<code>BidiHello</code>方法，一边从终端获取输入的请求数据发送至服务端，一边从服务端接收流式响应。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;hello_client/pb&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello_client</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultName = <span class="string">&quot;world&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	addr = flag.String(<span class="string">&quot;addr&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>, <span class="string">&quot;the address to connect to&quot;</span>)</span><br><span class="line">	name = flag.String(<span class="string">&quot;name&quot;</span>, defaultName, <span class="string">&quot;Name to greet&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 连接到server端，此处禁用安全传输</span></span><br><span class="line">	conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Minute)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="comment">// 双向流模式</span></span><br><span class="line">	stream, err := c.BidiHello(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;c.BidiHello failed, err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	waitc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 接收服务端返回的响应</span></span><br><span class="line">			in, err := stream.Recv()</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="comment">// read done.</span></span><br><span class="line">				<span class="built_in">close</span>(waitc)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatalf(<span class="string">&quot;c.BidiHello stream.Recv() failed, err: %v&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;AI：%s\n&quot;</span>, in.GetReply())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 从标准输入获取用户输入</span></span><br><span class="line">	reader := bufio.NewReader(os.Stdin) <span class="comment">// 从标准输入生成读对象</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		cmd, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读到换行</span></span><br><span class="line">		cmd = strings.TrimSpace(cmd)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(cmd) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> strings.ToUpper(cmd) == <span class="string">&quot;QUIT&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将获取到的数据发送至服务端</span></span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(&amp;pb.HelloRequest&#123;Name: cmd&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;c.BidiHello stream.Send(%v) failed: %v&quot;</span>, cmd, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stream.CloseSend()</span><br><span class="line">	&lt;-waitc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将服务端和客户端的代码都运行起来，就可以实现简单的对话程序了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/image-20230804152125944.png" alt="image-20230804152125944"></p>
<h2 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h2><p>元数据（<a target="_blank" rel="noopener" href="https://pkg.go.dev/google.golang.org/grpc/metadata">metadata</a>）是指在处理RPC请求和响应过程中需要但又不属于具体业务（例如身份验证详细信息）的信息，采用键值对列表的形式，其中键是<code>string</code>类型，值通常是<code>[]string</code>类型，但也可以是二进制数据。gRPC中的 metadata 类似于我们在 HTTP headers中的键值对，元数据可以包含认证token、请求标识和监控标签等。</p>
<p>metadata中的键是大小写不敏感的，由字母、数字和特殊字符<code>-</code>、<code>_</code>、<code>.</code>组成并且不能以<code>grpc-</code>开头（gRPC保留自用），二进制值的键名必须以<code>-bin</code>结尾。</p>
<p>元数据对 gRPC 本身是不可见的，我们通常是在应用程序代码或中间件中处理元数据，我们不需要在<code>.proto</code>文件中指定元数据。</p>
<p>如何访问元数据取决于具体使用的编程语言。 在Go语言中我们是用<a target="_blank" rel="noopener" href="https://pkg.go.dev/google.golang.org/grpc/metadata">google.golang.org&#x2F;grpc&#x2F;metadata</a>这个库来操作metadata。</p>
<p>metadata 类型定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MD <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>元数据可以像普通map一样读取。注意，这个 map 的值类型是<code>[]string</code>，因此用户可以使用一个键附加多个值。</p>
<h3 id="创建新的metadata"><a href="#创建新的metadata" class="headerlink" title="创建新的metadata"></a>创建新的metadata</h3><p>常用的创建MD的方法有以下两种。</p>
<p>第一种方法是使用函数 <code>New</code> 基于<code>map[string]string</code> 创建元数据:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md := metadata.New(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;key1&quot;</span>: <span class="string">&quot;val1&quot;</span>, <span class="string">&quot;key2&quot;</span>: <span class="string">&quot;val2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>另一种方法是使用<code>Pairs</code>。具有相同键的值将合并到一个列表中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md := metadata.Pairs(</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1-2&quot;</span>, <span class="comment">// &quot;key1&quot;的值将会是 []string&#123;&quot;val1&quot;, &quot;val1-2&quot;&#125;</span></span><br><span class="line">    <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>注意: 所有的键将自动转换为小写，因此“ kEy1”和“ Key1”将是相同的键，它们的值将合并到相同的列表中。这种情况适用于 <code>New</code> 和 <code>Pair</code>。</p>
<h3 id="元数据中存储二进制数据"><a href="#元数据中存储二进制数据" class="headerlink" title="元数据中存储二进制数据"></a>元数据中存储二进制数据</h3><p>在元数据中，键始终是字符串。但是值可以是字符串或二进制数据。要在元数据中存储二进制数据值，只需在密钥中添加“-bin”后缀。在创建元数据时，将对带有“-bin”后缀键的值进行编码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md := metadata.Pairs(</span><br><span class="line">    <span class="string">&quot;key&quot;</span>, <span class="string">&quot;string value&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key-bin&quot;</span>, <span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="number">96</span>, <span class="number">102</span>&#125;), <span class="comment">// 二进制数据在发送前会进行(base64) 编码</span></span><br><span class="line">                                        <span class="comment">// 收到后会进行解码</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="从请求上下文中获取元数据"><a href="#从请求上下文中获取元数据" class="headerlink" title="从请求上下文中获取元数据"></a>从请求上下文中获取元数据</h3><p>可以使用 <code>FromIncomingContext</code> 可以从RPC请求的上下文中获取元数据:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeRPC(ctx context.Context, in *pb.SomeRequest) (*pb.SomeResponse, err) &#123;</span><br><span class="line">    md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">    <span class="comment">// do something with metadata</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送和接收元数据-客户端"><a href="#发送和接收元数据-客户端" class="headerlink" title="发送和接收元数据-客户端"></a>发送和接收元数据-客户端</h3><h4 id="发送metadata"><a href="#发送metadata" class="headerlink" title="发送metadata"></a>发送metadata</h4><p>有两种方法可以将元数据发送到服务端。推荐的方法是使用 <code>AppendToOutgoingContext</code> 将 kv 对附加到context。无论context中是否已经有元数据都可以使用这个方法。如果先前没有元数据，则添加元数据; 如果context中已经存在元数据，则将 kv 对合并进去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建带有metadata的context</span></span><br><span class="line">ctx := metadata.AppendToOutgoingContext(ctx, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一些 metadata 到 context (e.g. in an interceptor)</span></span><br><span class="line">ctx := metadata.AppendToOutgoingContext(ctx, <span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起普通RPC请求</span></span><br><span class="line">response, err := client.SomeRPC(ctx, someRequest)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者发起流式RPC请求</span></span><br><span class="line">stream, err := client.SomeStreamingRPC(ctx)</span><br></pre></td></tr></table></figure>

<p>或者，可以使用 <code>NewOutgoingContext</code> 将元数据附加到context。但是，这将替换context中的任何已有的元数据，因此必须注意保留现有元数据(如果需要的话)。这个方法比使用 <code>AppendToOutgoingContext</code> 要慢。这方面的一个例子如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建带有metadata的context</span></span><br><span class="line">md := metadata.Pairs(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line">ctx := metadata.NewOutgoingContext(context.Background(), md)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一些metadata到context (e.g. in an interceptor)</span></span><br><span class="line">send, _ := metadata.FromOutgoingContext(ctx)</span><br><span class="line">newMD := metadata.Pairs(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line">ctx = metadata.NewOutgoingContext(ctx, metadata.Join(send, newMD))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起普通RPC请求</span></span><br><span class="line">response, err := client.SomeRPC(ctx, someRequest)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者发起流式RPC请求</span></span><br><span class="line">stream, err := client.SomeStreamingRPC(ctx)</span><br></pre></td></tr></table></figure>

<h4 id="接收metadata"><a href="#接收metadata" class="headerlink" title="接收metadata"></a>接收metadata</h4><p>客户端可以接收的元数据包括header和trailer。</p>
<blockquote>
<p>trailer可以用于服务器希望在处理请求后给客户端发送任何内容，例如在流式RPC中只有等所有结果都流到客户端后才能计算出负载信息，这时候就不能使用headers（header在数据之前，trailer在数据之后）。</p>
</blockquote>
<p>引申：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Trailer">HTTP trailer</a></p>
<h5 id="普通调用"><a href="#普通调用" class="headerlink" title="普通调用"></a>普通调用</h5><p>可以使用 <a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc#CallOption">CallOption</a> 中的 <a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc#Header">Header</a> 和 <a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc#Trailer">Trailer</a> 函数来获取普通RPC调用发送的header和trailer:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> header, trailer metadata.MD <span class="comment">// 声明存储header和trailer的变量</span></span><br><span class="line">r, err := client.SomeRPC(</span><br><span class="line">    ctx,</span><br><span class="line">    someRequest,</span><br><span class="line">    grpc.Header(&amp;header),    <span class="comment">// 将会接收header</span></span><br><span class="line">    grpc.Trailer(&amp;trailer),  <span class="comment">// 将会接收trailer</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// do something with header and trailer</span></span><br></pre></td></tr></table></figure>

<h5 id="流式调用"><a href="#流式调用" class="headerlink" title="流式调用"></a>流式调用</h5><p>流式调用包括：</p>
<ul>
<li>客户端流式</li>
<li>服务端流式</li>
<li>双向流式</li>
</ul>
<p>使用接口 <a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc#ClientStream">ClientStream</a> 中的 <code>Header</code> 和 <code>Trailer</code> 函数，可以从返回的流中接收 Header 和 Trailer:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream, err := client.SomeStreamingRPC(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收 header</span></span><br><span class="line">header, err := stream.Header()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收 trailer</span></span><br><span class="line">trailer := stream.Trailer()</span><br></pre></td></tr></table></figure>

<h3 id="发送和接收元数据-服务器端"><a href="#发送和接收元数据-服务器端" class="headerlink" title="发送和接收元数据-服务器端"></a>发送和接收元数据-服务器端</h3><h4 id="接收metadata-1"><a href="#接收metadata-1" class="headerlink" title="接收metadata"></a>接收metadata</h4><p>要读取客户端发送的元数据，服务器需要从 RPC 上下文检索它。如果是普通RPC调用，则可以使用 RPC 处理程序的上下文。对于流调用，服务器需要从流中获取上下文。</p>
<h5 id="普通调用-1"><a href="#普通调用-1" class="headerlink" title="普通调用"></a>普通调用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">    <span class="comment">// do something with metadata</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="流式调用-1"><a href="#流式调用-1" class="headerlink" title="流式调用"></a>流式调用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) <span class="type">error</span> &#123;</span><br><span class="line">    md, ok := metadata.FromIncomingContext(stream.Context()) <span class="comment">// get context from stream</span></span><br><span class="line">    <span class="comment">// do something with metadata</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发送metadata-1"><a href="#发送metadata-1" class="headerlink" title="发送metadata"></a>发送metadata</h4><h5 id="普通调用-2"><a href="#普通调用-2" class="headerlink" title="普通调用"></a>普通调用</h5><p>在普通调用中，服务器可以调用 <a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc">grpc</a> 模块中的 <a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc#SendHeader">SendHeader</a> 和 <a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc#SetTrailer">SetTrailer</a> 函数向客户端发送header和trailer。这两个函数将context作为第一个参数。它应该是 RPC 处理程序的上下文或从中派生的上下文：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建和发送 header</span></span><br><span class="line">    header := metadata.Pairs(<span class="string">&quot;header-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    grpc.SendHeader(ctx, header)</span><br><span class="line">    <span class="comment">// 创建和发送 trailer</span></span><br><span class="line">    trailer := metadata.Pairs(<span class="string">&quot;trailer-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    grpc.SetTrailer(ctx, trailer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="流式调用-2"><a href="#流式调用-2" class="headerlink" title="流式调用"></a>流式调用</h5><p>对于流式调用，可以使用接口 <a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc#ServerStream">ServerStream</a> 中的 <code>SendHeader</code> 和 <code>SetTrailer</code> 函数发送header和trailer:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 创建和发送 header</span></span><br><span class="line">    header := metadata.Pairs(<span class="string">&quot;header-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    stream.SendHeader(header)</span><br><span class="line">    <span class="comment">// 创建和发送 trailer</span></span><br><span class="line">    trailer := metadata.Pairs(<span class="string">&quot;trailer-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    stream.SetTrailer(trailer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通RPC调用metadata示例"><a href="#普通RPC调用metadata示例" class="headerlink" title="普通RPC调用metadata示例"></a>普通RPC调用metadata示例</h3><h4 id="client端的metadata操作"><a href="#client端的metadata操作" class="headerlink" title="client端的metadata操作"></a>client端的metadata操作</h4><p>下面的代码片段演示了client端如何设置和获取metadata。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unaryCallWithMetadata 普通RPC调用客户端metadata操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unaryCallWithMetadata</span><span class="params">(c pb.GreeterClient, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;--- UnarySayHello client---&quot;</span>)</span><br><span class="line">	<span class="comment">// 创建metadata</span></span><br><span class="line">	md := metadata.Pairs(</span><br><span class="line">		<span class="string">&quot;token&quot;</span>, <span class="string">&quot;app-test-q1mi&quot;</span>,</span><br><span class="line">		<span class="string">&quot;request_id&quot;</span>, <span class="string">&quot;1234567&quot;</span>,</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// 基于metadata创建context.</span></span><br><span class="line">	ctx := metadata.NewOutgoingContext(context.Background(), md)</span><br><span class="line">	<span class="comment">// RPC调用</span></span><br><span class="line">	<span class="keyword">var</span> header, trailer metadata.MD</span><br><span class="line">	r, err := c.SayHello(</span><br><span class="line">		ctx,</span><br><span class="line">		&amp;pb.HelloRequest&#123;Name: name&#125;,</span><br><span class="line">		grpc.Header(&amp;header),   <span class="comment">// 接收服务端发来的header</span></span><br><span class="line">		grpc.Trailer(&amp;trailer), <span class="comment">// 接收服务端发来的trailer</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;failed to call SayHello: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从header中取location</span></span><br><span class="line">	<span class="keyword">if</span> t, ok := header[<span class="string">&quot;location&quot;</span>]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;location from header:\n&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> i, e := <span class="keyword">range</span> t &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot; %d. %s\n&quot;</span>, i, e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;location expected but doesn&#x27;t exist in header&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">// 获取响应结果</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;got response: %s\n&quot;</span>, r.Reply)</span><br><span class="line">	<span class="comment">// 从trailer中取timestamp</span></span><br><span class="line">	<span class="keyword">if</span> t, ok := trailer[<span class="string">&quot;timestamp&quot;</span>]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;timestamp from trailer:\n&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> i, e := <span class="keyword">range</span> t &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot; %d. %s\n&quot;</span>, i, e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;timestamp expected but doesn&#x27;t exist in trailer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="server端metadata操作"><a href="#server端metadata操作" class="headerlink" title="server端metadata操作"></a>server端metadata操作</h4><p>下面的代码片段演示了server端如何设置和获取metadata。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnarySayHello 普通RPC调用服务端metadata操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> UnarySayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 通过defer中设置trailer.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		trailer := metadata.Pairs(<span class="string">&quot;timestamp&quot;</span>, strconv.Itoa(<span class="type">int</span>(time.Now().Unix())))</span><br><span class="line">		grpc.SetTrailer(ctx, trailer)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从客户端请求上下文中读取metadata.</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.DataLoss, <span class="string">&quot;UnarySayHello: failed to get metadata&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t, ok := md[<span class="string">&quot;token&quot;</span>]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;token from metadata:\n&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(t) &lt; <span class="number">1</span> || t[<span class="number">0</span>] != <span class="string">&quot;app-test-q1mi&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Unauthenticated, <span class="string">&quot;认证失败&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建和发送header.</span></span><br><span class="line">	header := metadata.New(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;location&quot;</span>: <span class="string">&quot;BeiJing&quot;</span>&#125;)</span><br><span class="line">	grpc.SendHeader(ctx, header)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;request received: %v, say hello...\n&quot;</span>, in)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloResponse&#123;Reply: in.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流式RPC调用metadata示例"><a href="#流式RPC调用metadata示例" class="headerlink" title="流式RPC调用metadata示例"></a>流式RPC调用metadata示例</h3><p>这里以双向流式RPC为例演示客户端和服务端如何进行metadata操作。</p>
<h4 id="client端的metadata操作-1"><a href="#client端的metadata操作-1" class="headerlink" title="client端的metadata操作"></a>client端的metadata操作</h4><p>下面的代码片段演示了client端在服务端流式RPC模式下如何设置和获取metadata。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bidirectionalWithMetadata 流式RPC调用客户端metadata操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bidirectionalWithMetadata</span><span class="params">(c pb.GreeterClient, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建metadata和context.</span></span><br><span class="line">	md := metadata.Pairs(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;app-test-q1mi&quot;</span>)</span><br><span class="line">	ctx := metadata.NewOutgoingContext(context.Background(), md)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用带有metadata的context执行RPC调用.</span></span><br><span class="line">	stream, err := c.BidiHello(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to call BidiHello: %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 当header到达时读取header.</span></span><br><span class="line">		header, err := stream.Header()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;failed to get header from stream: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从返回响应的header中读取数据.</span></span><br><span class="line">		<span class="keyword">if</span> l, ok := header[<span class="string">&quot;location&quot;</span>]; ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;location from header:\n&quot;</span>)</span><br><span class="line">			<span class="keyword">for</span> i, e := <span class="keyword">range</span> l &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot; %d. %s\n&quot;</span>, i, e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;location expected but doesn&#x27;t exist in header&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送所有的请求数据到server.</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> err := stream.Send(&amp;pb.HelloRequest&#123;Name: name&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatalf(<span class="string">&quot;failed to send streaming: %v\n&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		stream.CloseSend()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取所有的响应.</span></span><br><span class="line">	<span class="keyword">var</span> rpcStatus <span class="type">error</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;got response:\n&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		r, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			rpcStatus = err</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot; - %s\n&quot;</span>, r.Reply)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rpcStatus != io.EOF &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;failed to finish server streaming: %v&quot;</span>, rpcStatus)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当RPC结束时读取trailer</span></span><br><span class="line">	trailer := stream.Trailer()</span><br><span class="line">	<span class="comment">// 从返回响应的trailer中读取metadata.</span></span><br><span class="line">	<span class="keyword">if</span> t, ok := trailer[<span class="string">&quot;timestamp&quot;</span>]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;timestamp from trailer:\n&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> i, e := <span class="keyword">range</span> t &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot; %d. %s\n&quot;</span>, i, e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;timestamp expected but doesn&#x27;t exist in trailer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="server端的metadata操作"><a href="#server端的metadata操作" class="headerlink" title="server端的metadata操作"></a>server端的metadata操作</h4><p>下面的代码片段演示了server端在服务端流式RPC模式下设置和操作metadata。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BidirectionalStreamingSayHello 流式RPC调用客户端metadata操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> BidirectionalStreamingSayHello(stream pb.Greeter_BidiHelloServer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 在defer中创建trailer记录函数的返回时间.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		trailer := metadata.Pairs(<span class="string">&quot;timestamp&quot;</span>, strconv.Itoa(<span class="type">int</span>(time.Now().Unix())))</span><br><span class="line">		stream.SetTrailer(trailer)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从client读取metadata.</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(stream.Context())</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> status.Errorf(codes.DataLoss, <span class="string">&quot;BidirectionalStreamingSayHello: failed to get metadata&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> t, ok := md[<span class="string">&quot;token&quot;</span>]; ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;token from metadata:\n&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> i, e := <span class="keyword">range</span> t &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot; %d. %s\n&quot;</span>, i, e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建和发送header.</span></span><br><span class="line">	header := metadata.New(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;location&quot;</span>: <span class="string">&quot;X2Q&quot;</span>&#125;)</span><br><span class="line">	stream.SendHeader(header)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取请求数据发送响应数据.</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;request received %v, sending reply\n&quot;</span>, in)</span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(&amp;pb.HelloResponse&#123;Reply: in.Name&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="gRPC-code"><a href="#gRPC-code" class="headerlink" title="gRPC code"></a>gRPC code</h3><p>类似于HTTP定义了一套响应状态码，gRPC也定义有一些状态码。Go语言中此状态码由<a target="_blank" rel="noopener" href="https://pkg.go.dev/google.golang.org/grpc/codes">codes</a>定义，本质上是一个uint32。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Code <span class="type">uint32</span></span><br></pre></td></tr></table></figure>

<p>使用时需导入<code>google.golang.org/grpc/codes</code>包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google.golang.org/grpc/codes&quot;</span></span><br></pre></td></tr></table></figure>

<p>目前已经定义的状态码有如下几种。</p>
<table>
<thead>
<tr>
<th align="center">Code</th>
<th align="center">值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OK</td>
<td align="center">0</td>
<td align="center">请求成功</td>
</tr>
<tr>
<td align="center">Canceled</td>
<td align="center">1</td>
<td align="center">操作已取消</td>
</tr>
<tr>
<td align="center">Unknown</td>
<td align="center">2</td>
<td align="center">未知错误。如果从另一个地址空间接收到的状态值属 于在该地址空间中未知的错误空间，则可以返回此错误的示例。 没有返回足够的错误信息的API引发的错误也可能会转换为此错误</td>
</tr>
<tr>
<td align="center">InvalidArgument</td>
<td align="center">3</td>
<td align="center">表示客户端指定的参数无效。 请注意，这与 FailedPrecondition 不同。 它表示无论系统状态如何都有问题的参数（例如，格式错误的文件名）。</td>
</tr>
<tr>
<td align="center">DeadlineExceeded</td>
<td align="center">4</td>
<td align="center">表示操作在完成之前已过期。对于改变系统状态的操作，即使操作成功完成，也可能会返回此错误。 例如，来自服务器的成功响应可能已延迟足够长的时间以使截止日期到期。</td>
</tr>
<tr>
<td align="center">NotFound</td>
<td align="center">5</td>
<td align="center">表示未找到某些请求的实体（例如，文件或目录）。</td>
</tr>
<tr>
<td align="center">AlreadyExists</td>
<td align="center">6</td>
<td align="center">创建实体的尝试失败，因为实体已经存在。</td>
</tr>
<tr>
<td align="center">PermissionDenied</td>
<td align="center">7</td>
<td align="center">表示调用者没有权限执行指定的操作。 它不能用于拒绝由耗尽某些资源引起的（使用 ResourceExhausted ）。 如果无法识别调用者，也不能使用它（使用 Unauthenticated ）。</td>
</tr>
<tr>
<td align="center">ResourceExhausted</td>
<td align="center">8</td>
<td align="center">表示某些资源已耗尽，可能是每个用户的配额，或者整个文件系统空间不足</td>
</tr>
<tr>
<td align="center">FailedPrecondition</td>
<td align="center">9</td>
<td align="center">指示操作被拒绝，因为系统未处于操作执行所需的状态。 例如，要删除的目录可能是非空的，rmdir 操作应用于非目录等。</td>
</tr>
<tr>
<td align="center">Aborted</td>
<td align="center">10</td>
<td align="center">表示操作被中止，通常是由于并发问题，如排序器检查失败、事务中止等。</td>
</tr>
<tr>
<td align="center">OutOfRange</td>
<td align="center">11</td>
<td align="center">表示尝试超出有效范围的操作。</td>
</tr>
<tr>
<td align="center">Unimplemented</td>
<td align="center">12</td>
<td align="center">表示此服务中未实施或不支持&#x2F;启用操作。</td>
</tr>
<tr>
<td align="center">Internal</td>
<td align="center">13</td>
<td align="center">意味着底层系统预期的一些不变量已被破坏。 如果你看到这个错误，则说明问题很严重。</td>
</tr>
<tr>
<td align="center">Unavailable</td>
<td align="center">14</td>
<td align="center">表示服务当前不可用。这很可能是暂时的情况，可以通过回退重试来纠正。 请注意，重试非幂等操作并不总是安全的。</td>
</tr>
<tr>
<td align="center">DataLoss</td>
<td align="center">15</td>
<td align="center">表示不可恢复的数据丢失或损坏</td>
</tr>
<tr>
<td align="center">Unauthenticated</td>
<td align="center">16</td>
<td align="center">表示请求没有用于操作的有效身份验证凭据</td>
</tr>
<tr>
<td align="center">_maxCode</td>
<td align="center">17</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="gRPC-Status"><a href="#gRPC-Status" class="headerlink" title="gRPC Status"></a>gRPC Status</h3><p>Go语言使用的gRPC Status 定义在<a target="_blank" rel="noopener" href="https://pkg.go.dev/google.golang.org/grpc/status">google.golang.org&#x2F;grpc&#x2F;status</a>，使用时需导入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google.golang.org/grpc/status&quot;</span></span><br></pre></td></tr></table></figure>

<p>RPC服务的方法应该返回 <code>nil</code> 或来自<code>status.Status</code>类型的错误。客户端可以直接访问错误。</p>
<h4 id="创建错误"><a href="#创建错误" class="headerlink" title="创建错误"></a>创建错误</h4><p>当遇到错误时，gRPC服务的方法函数应该创建一个 <code>status.Status</code>。通常我们会使用 <code>status.New</code>函数并传入适当的<code>status.Code</code>和错误描述来生成一个<code>status.Status</code>。调用<code>status.Err</code>方法便能将一个<code>status.Status</code>转为<code>error</code>类型。也存在一个简单的<code>status.Error</code>方法直接生成<code>error</code>。下面是两种方式的比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建status.Status</span></span><br><span class="line">st := status.New(codes.NotFound, <span class="string">&quot;some description&quot;</span>)</span><br><span class="line">err := st.Err()  <span class="comment">// 转为error类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vs.</span></span><br><span class="line"></span><br><span class="line">err := status.Error(codes.NotFound, <span class="string">&quot;some description&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="为错误添加其他详细信息"><a href="#为错误添加其他详细信息" class="headerlink" title="为错误添加其他详细信息"></a>为错误添加其他详细信息</h4><p>在某些情况下，可能需要为服务器端的特定错误添加详细信息。<code>status.WithDetails</code>就是为此而存在的，它可以添加任意多个<code>proto.Message</code>，我们可以使用<code>google.golang.org/genproto/googleapis/rpc/errdetails</code>中的定义或自定义的错误详情。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st := status.New(codes.ResourceExhausted, <span class="string">&quot;Request limit exceeded.&quot;</span>)</span><br><span class="line">ds, _ := st.WithDetails(</span><br><span class="line">	<span class="comment">// proto.Message</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ds.Err()</span><br></pre></td></tr></table></figure>

<p>然后，客户端可以通过首先将普通<code>error</code>类型转换回<code>status.Status</code>，然后使用<code>status.Details</code>来读取这些详细信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := status.Convert(err)</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> s.Details() &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>我们现在要为<code>hello</code>服务设置访问限制，每个<code>name</code>只能调用一次<code>SayHello</code>方法，超过此限制就返回一个请求超过限制的错误。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>使用map存储每个name的请求次数，超过1次则返回错误，并且记录错误详情。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_server/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/genproto/googleapis/rpc/errdetails&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/codes&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/status&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// grpc server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">	mu    sync.Mutex     <span class="comment">// count的并发锁</span></span><br><span class="line">	count <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="comment">// 记录每个name的请求次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello 是我们需要实现的方法</span></span><br><span class="line"><span class="comment">// 这个方法是我们对外提供的服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">	s.count[in.Name]++ <span class="comment">// 记录用户的请求次数</span></span><br><span class="line">	<span class="comment">// 超过1次就返回错误</span></span><br><span class="line">	<span class="keyword">if</span> s.count[in.Name] &gt; <span class="number">1</span> &#123;</span><br><span class="line">		st := status.New(codes.ResourceExhausted, <span class="string">&quot;Request limit exceeded.&quot;</span>)</span><br><span class="line">		ds, err := st.WithDetails(</span><br><span class="line">			&amp;errdetails.QuotaFailure&#123;</span><br><span class="line">				Violations: []*errdetails.QuotaFailure_Violation&#123;&#123;</span><br><span class="line">					Subject:     fmt.Sprintf(<span class="string">&quot;name:%s&quot;</span>, in.Name),</span><br><span class="line">					Description: <span class="string">&quot;限制每个name调用一次&quot;</span>,</span><br><span class="line">				&#125;&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, st.Err()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ds.Err()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 正常返回响应</span></span><br><span class="line">	reply := <span class="string">&quot;hello &quot;</span> + in.GetName()</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloResponse&#123;Reply: reply&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	l, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8972&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to listen, err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer() <span class="comment">// 创建grpc服务</span></span><br><span class="line">	<span class="comment">// 注册服务，注意初始化count</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;count: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;)</span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	err = s.Serve(l)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;failed to serve,err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>当服务端返回错误时，尝试从错误中获取detail信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/status&quot;</span></span><br><span class="line">	<span class="string">&quot;hello_client/pb&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/genproto/googleapis/rpc/errdetails&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// grpc 客户端</span></span><br><span class="line"><span class="comment">// 调用server端的 SayHello 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = flag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;七米&quot;</span>, <span class="string">&quot;通过-name告诉server你是谁&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse() <span class="comment">// 解析命令行参数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接server</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;127.0.0.1:8972&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;grpc.Dial failed,err:%v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="comment">// 创建客户端</span></span><br><span class="line">	c := pb.NewGreeterClient(conn) <span class="comment">// 使用生成的Go代码</span></span><br><span class="line">	<span class="comment">// 调用RPC方法</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	resp, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		s := status.Convert(err)        <span class="comment">// 将err转为status</span></span><br><span class="line">		<span class="keyword">for</span> _, d := <span class="keyword">range</span> s.Details() &#123; <span class="comment">// 获取details</span></span><br><span class="line">			<span class="keyword">switch</span> info := d.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *errdetails.QuotaFailure:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;Quota failure: %s\n&quot;</span>, info)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;Unexpected type: %s\n&quot;</span>, info)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;c.SayHello failed, err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拿到了RPC响应</span></span><br><span class="line">	log.Printf(<span class="string">&quot;resp:%v\n&quot;</span>, resp.GetReply())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="加密或认证"><a href="#加密或认证" class="headerlink" title="加密或认证"></a>加密或认证</h2><h3 id="无加密认证"><a href="#无加密认证" class="headerlink" title="无加密认证"></a>无加密认证</h3><p>在上面的示例中，我们都没有为我们的 gRPC 配置加密或认证，属于不安全的连接（insecure connection）。</p>
<p>Client端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn, _ := grpc.Dial(<span class="string">&quot;127.0.0.1:8972&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">client := pb.NewGreeterClient(conn)</span><br></pre></td></tr></table></figure>

<p>Server端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer()</span><br><span class="line">lis, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>)</span><br><span class="line"><span class="comment">// error handling omitted</span></span><br><span class="line">s.Serve(lis)</span><br></pre></td></tr></table></figure>

<h3 id="使用服务器身份验证-SSL-TLS"><a href="#使用服务器身份验证-SSL-TLS" class="headerlink" title="使用服务器身份验证 SSL&#x2F;TLS"></a>使用服务器身份验证 SSL&#x2F;TLS</h3><p>gRPC 内置支持 SSL&#x2F;TLS，可以通过 SSL&#x2F;TLS 证书建立安全连接，对传输的数据进行加密处理。</p>
<p>这里我们演示如何使用自签名证书进行server端加密。</p>
<h4 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h4><h5 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h5><p>执行下面的命令生成私钥文件——<code>server.key</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ecparam -genkey -name secp384r1 -out server.key</span><br></pre></td></tr></table></figure>

<p>这里生成的是ECC私钥，当然你也可以使用RSA。</p>
<h5 id="生成自签名的证书"><a href="#生成自签名的证书" class="headerlink" title="生成自签名的证书"></a>生成自签名的证书</h5><blockquote>
<p>Go1.15之后x509弃用Common Name改用SANs。</p>
</blockquote>
<p>当出现如下错误时，需要提供SANs信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transport: authentication handshake failed: x509: certificate relies on legacy Common Name field, use SANs or temporarily <span class="built_in">enable</span> Common Name matching with GODEBUG=x509ignoreCN=0</span><br></pre></td></tr></table></figure>

<p>为了在证书中添加SANs信息，我们将下面自定义配置保存到<code>server.cnf</code>文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[ req ]</span><br><span class="line">default_bits       = 4096</span><br><span class="line">default_md		= sha256</span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line">req_extensions     = req_ext</span><br><span class="line"></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line">countryName                 = Country Name (2 letter code)</span><br><span class="line">countryName_default         = CN</span><br><span class="line">stateOrProvinceName         = State or Province Name (full name)</span><br><span class="line">stateOrProvinceName_default = BEIJING</span><br><span class="line">localityName                = Locality Name (eg, city)</span><br><span class="line">localityName_default        = BEIJING</span><br><span class="line">organizationName            = Organization Name (eg, company)</span><br><span class="line">organizationName_default    = DEV</span><br><span class="line">commonName                  = Common Name (e.g. server FQDN or YOUR name)</span><br><span class="line">commonName_max              = 64</span><br><span class="line">commonName_default          = liwenzhou.com</span><br><span class="line"></span><br><span class="line">[ req_ext ]</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1   = localhost</span><br><span class="line">DNS.2   = liwenzhou.com</span><br><span class="line">IP      = 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>执行下面的命令生成自签名证书——<code>server.crt</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -nodes -new -x509 -sha256 -days 3650 -config server.cnf -extensions <span class="string">&#x27;req_ext&#x27;</span> -key server.key -out server.crt</span><br></pre></td></tr></table></figure>

<h4 id="建立安全连接"><a href="#建立安全连接" class="headerlink" title="建立安全连接"></a>建立安全连接</h4><p>Server端使用<code>credentials.NewServerTLSFromFile</code>函数分别加载证书<code>server.cert</code>和秘钥<code>server.key</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">creds, _ := credentials.NewServerTLSFromFile(certFile, keyFile)</span><br><span class="line">s := grpc.NewServer(grpc.Creds(creds))</span><br><span class="line">lis, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>)</span><br><span class="line"><span class="comment">// error handling omitted</span></span><br><span class="line">s.Serve(lis)</span><br></pre></td></tr></table></figure>

<p>而client端使用上一步生成的证书文件——<code>server.cert</code>建立安全连接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">creds, _ := credentials.NewClientTLSFromFile(certFile, <span class="string">&quot;&quot;</span>)</span><br><span class="line">conn, _ := grpc.Dial(<span class="string">&quot;127.0.0.1:8972&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class="line"><span class="comment">// error handling omitted</span></span><br><span class="line">client := pb.NewGreeterClient(conn)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>除了这种自签名证书的方式外，生产环境对外通信时通常需要使用受信任的CA证书。</p>
<h2 id="拦截器（中间件）"><a href="#拦截器（中间件）" class="headerlink" title="拦截器（中间件）"></a>拦截器（中间件）</h2><p>gRPC 为在每个 ClientConn&#x2F;Server 基础上实现和安装拦截器提供了一些简单的 API。 拦截器拦截每个 RPC 调用的执行。用户可以使用拦截器进行日志记录、身份验证&#x2F;授权、指标收集以及许多其他可以跨 RPC 共享的功能。</p>
<p>在 gRPC 中，拦截器根据拦截的 RPC 调用类型可以分为两类。第一个是普通拦截器（一元拦截器），它拦截普通RPC 调用。另一个是流拦截器，它处理流式 RPC 调用。而客户端和服务端都有自己的普通拦截器和流拦截器类型。因此，在 gRPC 中总共有四种不同类型的拦截器。</p>
<h3 id="客户端端拦截器"><a href="#客户端端拦截器" class="headerlink" title="客户端端拦截器"></a>客户端端拦截器</h3><h4 id="普通拦截器-一元拦截器"><a href="#普通拦截器-一元拦截器" class="headerlink" title="普通拦截器&#x2F;一元拦截器"></a>普通拦截器&#x2F;一元拦截器</h4><p><a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc#UnaryClientInterceptor">UnaryClientInterceptor</a> 是客户端一元拦截器的类型，它的函数前面如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, method <span class="type">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>一元拦截器的实现通常可以分为三个部分: 调用 RPC 方法之前（预处理）、调用 RPC 方法（RPC调用）和调用 RPC 方法之后（调用后）。</p>
<ul>
<li>预处理：用户可以通过检查传入的参数(如 RPC 上下文、方法字符串、要发送的请求和 CallOptions 配置)来获得有关当前 RPC 调用的信息。</li>
<li>RPC调用：预处理完成后，可以通过执行<code>invoker</code>执行 RPC 调用。</li>
<li>调用后：一旦调用者返回应答和错误，用户就可以对 RPC 调用进行后处理。通常，它是关于处理返回的响应和错误的。 若要在 <code>ClientConn</code> 上安装一元拦截器，请使用<code>DialOptionWithUnaryInterceptor</code>的<code>DialOption</code>配置 Dial 。</li>
</ul>
<h4 id="流拦截器"><a href="#流拦截器" class="headerlink" title="流拦截器"></a>流拦截器</h4><p><a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc#StreamClientInterceptor">StreamClientInterceptor</a>是客户端流拦截器的类型。它的函数签名是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, desc *StreamDesc, cc *ClientConn, method <span class="type">string</span>, streamer Streamer, opts ...CallOption)</span></span> (ClientStream, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>流拦截器的实现通常包括预处理和流操作拦截。</p>
<ul>
<li>预处理：类似于上面的一元拦截器。</li>
<li>流操作拦截：流拦截器并没有事后进行 RPC 方法调用和后处理，而是拦截了用户在流上的操作。首先，拦截器调用传入的<code>streamer</code>以获取 <code>ClientStream</code>，然后包装 <code>ClientStream</code> 并用拦截逻辑重载其方法。最后，拦截器将包装好的 <code>ClientStream</code> 返回给用户进行操作。</li>
</ul>
<p>若要为 <code>ClientConn</code> 安装流拦截器，请使用<code>WithStreamInterceptor</code>的 DialOption 配置 Dial。</p>
<h3 id="server端拦截器"><a href="#server端拦截器" class="headerlink" title="server端拦截器"></a>server端拦截器</h3><p>服务器端拦截器与客户端类似，但提供的信息略有不同。</p>
<h4 id="普通拦截器-一元拦截器-1"><a href="#普通拦截器-一元拦截器-1" class="headerlink" title="普通拦截器&#x2F;一元拦截器"></a>普通拦截器&#x2F;一元拦截器</h4><p><a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc#UnaryServerInterceptor">UnaryServerInterceptor</a>是服务端的一元拦截器类型，它的函数签名是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span></span> (resp <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>服务端一元拦截器具体实现细节和客户端版本的类似。</p>
<p>若要为服务端安装一元拦截器，请使用 <code>UnaryInterceptor</code> 的<code>ServerOption</code>配置 <code>NewServer</code>。</p>
<h4 id="流拦截器-1"><a href="#流拦截器-1" class="headerlink" title="流拦截器"></a>流拦截器</h4><p><a target="_blank" rel="noopener" href="https://godoc.org/google.golang.org/grpc#StreamServerInterceptor">StreamServerInterceptor</a>是服务端流式拦截器的类型，它的签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ss ServerStream, info *StreamServerInfo, handler StreamHandler)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>实现细节类似于客户端流拦截器部分。</p>
<p>若要为服务端安装流拦截器，请使用 <code>StreamInterceptor</code> 的<code>ServerOption</code>来配置 <code>NewServer</code>。</p>
<h3 id="拦截器示例"><a href="#拦截器示例" class="headerlink" title="拦截器示例"></a>拦截器示例</h3><p>下面将演示一个完整的拦截器示例，我们为一元RPC和流式RPC服务都添加上拦截器。</p>
<p>我们首先定义一个名为<code>valid</code>的校验函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// valid 校验认证信息.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">valid</span><span class="params">(authorization []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(authorization) &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	token := strings.TrimPrefix(authorization[<span class="number">0</span>], <span class="string">&quot;Bearer &quot;</span>)</span><br><span class="line">	<span class="comment">// 执行token认证的逻辑</span></span><br><span class="line">	<span class="comment">// 这里是为了演示方便简单判断token是否与&quot;some-secret-token&quot;相等</span></span><br><span class="line">	<span class="keyword">return</span> token == <span class="string">&quot;some-secret-token&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端拦截器定义"><a href="#客户端拦截器定义" class="headerlink" title="客户端拦截器定义"></a>客户端拦截器定义</h4><h5 id="一元拦截器"><a href="#一元拦截器" class="headerlink" title="一元拦截器"></a>一元拦截器</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unaryInterceptor 客户端一元拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unaryInterceptor</span><span class="params">(ctx context.Context, method <span class="type">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> credsConfigured <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">		_, ok := o.(grpc.PerRPCCredsCallOption)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			credsConfigured = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !credsConfigured &#123;</span><br><span class="line">		opts = <span class="built_in">append</span>(opts, grpc.PerRPCCredentials(oauth.NewOauthAccess(&amp;oauth2.Token&#123;</span><br><span class="line">			AccessToken: <span class="string">&quot;some-secret-token&quot;</span>,</span><br><span class="line">		&#125;)))</span><br><span class="line">	&#125;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	err := invoker(ctx, method, req, reply, cc, opts...)</span><br><span class="line">	end := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;RPC: %s, start time: %s, end time: %s, err: %v\n&quot;</span>, method, start.Format(<span class="string">&quot;Basic&quot;</span>), end.Format(time.RFC3339), err)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>grpc.PerRPCCredentials()</code>函数指明每个 RPC 请求使用的凭据，它接收一个<code>credentials.PerRPCCredentials</code>接口类型的参数。<code>credentials.PerRPCCredentials</code>接口的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PerRPCCredentials <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// GetRequestMetadata 获取当前请求的元数据,如果需要则会设置token。</span></span><br><span class="line">	<span class="comment">// 传输层在每个请求上调用，并且数据会被填充到headers或其他context。</span></span><br><span class="line">	GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// RequireTransportSecurity 指示该 Credentials 的传输是否需要需要 TLS 加密</span></span><br><span class="line">	RequireTransportSecurity() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而示例代码中使用的<code>oauth.NewOauthAccess()</code>是内置oauth包提供的一个函数，用来返回包含给定token的<code>PerRPCCredentials</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewOauthAccess constructs the PerRPCCredentials using a given token.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOauthAccess</span><span class="params">(token *oauth2.Token)</span></span> credentials.PerRPCCredentials &#123;</span><br><span class="line">	<span class="keyword">return</span> oauthAccess&#123;token: *token&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(oa oauthAccess)</span></span> GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	ri, _ := credentials.RequestInfoFromContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> err := credentials.CheckSecurityLevel(ri.AuthInfo, credentials.PrivacyAndIntegrity); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to transfer oauthAccess PerRPCCredentials: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;authorization&quot;</span>: oa.token.Type() + <span class="string">&quot; &quot;</span> + oa.token.AccessToken,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(oa oauthAccess)</span></span> RequireTransportSecurity() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="流式拦截器"><a href="#流式拦截器" class="headerlink" title="流式拦截器"></a>流式拦截器</h5><p>自定义一个<code>ClientStream</code>类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> wrappedStream <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wrappedStream</code>重写<code>grpc.ClientStream</code>接口的<code>RecvMsg</code>和<code>SendMsg</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wrappedStream)</span></span> RecvMsg(m <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	logger(<span class="string">&quot;Receive a message (Type: %T) at %v&quot;</span>, m, time.Now().Format(time.RFC3339))</span><br><span class="line">	<span class="keyword">return</span> w.ClientStream.RecvMsg(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wrappedStream)</span></span> SendMsg(m <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	logger(<span class="string">&quot;Send a message (Type: %T) at %v&quot;</span>, m, time.Now().Format(time.RFC3339))</span><br><span class="line">	<span class="keyword">return</span> w.ClientStream.SendMsg(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWrappedStream</span><span class="params">(s grpc.ClientStream)</span></span> grpc.ClientStream &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;wrappedStream&#123;s&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的<code>wrappedStream</code>嵌入了<code>grpc.ClientStream</code>接口类型，然后又重新实现了一遍<code>grpc.ClientStream</code>接口的方法。</p>
</blockquote>
<p>下面就定义一个流式拦截器，最后返回上面定义的<code>wrappedStream</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streamInterceptor 客户端流式拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">streamInterceptor</span><span class="params">(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method <span class="type">string</span>, streamer grpc.Streamer, opts ...grpc.CallOption)</span></span> (grpc.ClientStream, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> credsConfigured <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">		_, ok := o.(*grpc.PerRPCCredsCallOption)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			credsConfigured = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !credsConfigured &#123;</span><br><span class="line">		opts = <span class="built_in">append</span>(opts, grpc.PerRPCCredentials(oauth.NewOauthAccess(&amp;oauth2.Token&#123;</span><br><span class="line">			AccessToken: <span class="string">&quot;some-secret-token&quot;</span>,</span><br><span class="line">		&#125;)))</span><br><span class="line">	&#125;</span><br><span class="line">	s, err := streamer(ctx, desc, cc, method, opts...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newWrappedStream(s), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务端拦截器定义"><a href="#服务端拦截器定义" class="headerlink" title="服务端拦截器定义"></a>服务端拦截器定义</h4><h5 id="一元拦截器-1"><a href="#一元拦截器-1" class="headerlink" title="一元拦截器"></a>一元拦截器</h5><p>服务端定义一个一元拦截器，对从请求元数据中获取的<code>authorization</code>进行校验。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unaryInterceptor 服务端一元拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// authentication (token verification)</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.InvalidArgument, <span class="string">&quot;missing metadata&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !valid(md[<span class="string">&quot;authorization&quot;</span>]) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.Unauthenticated, <span class="string">&quot;invalid token&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	m, err := handler(ctx, req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;RPC failed with error %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流拦截器-2"><a href="#流拦截器-2" class="headerlink" title="流拦截器"></a>流拦截器</h4><p>同样为流RPC也定义一个从元数据中获取认证信息的流式拦截器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streamInterceptor 服务端流拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">streamInterceptor</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// authentication (token verification)</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(ss.Context())</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> status.Errorf(codes.InvalidArgument, <span class="string">&quot;missing metadata&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !valid(md[<span class="string">&quot;authorization&quot;</span>]) &#123;</span><br><span class="line">		<span class="keyword">return</span> status.Errorf(codes.Unauthenticated, <span class="string">&quot;invalid token&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err := handler(srv, newWrappedStream(ss))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;RPC failed with error %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h4><p>客户端注册拦截器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conn, err := grpc.Dial(<span class="string">&quot;127.0.0.1:8972&quot;</span>,</span><br><span class="line">	grpc.WithTransportCredentials(creds),</span><br><span class="line">	grpc.WithUnaryInterceptor(unaryInterceptor),</span><br><span class="line">	grpc.WithStreamInterceptor(streamInterceptor),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>服务端注册拦截器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := grpc.NewServer(</span><br><span class="line">	grpc.Creds(creds),</span><br><span class="line">	grpc.UnaryInterceptor(unaryInterceptor),</span><br><span class="line">	grpc.StreamInterceptor(streamInterceptor),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="go-grpc-middleware"><a href="#go-grpc-middleware" class="headerlink" title="go-grpc-middleware"></a>go-grpc-middleware</h3><p>社区中有很多开源的常用的grpc中间件——<a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/go-grpc-middleware">go-grpc-middleware</a>，根据需要选择使用。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://uestcwxy.love">Palp1tate</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://uestcwxy.love/2023/08/04/Go/32/">https://uestcwxy.love/2023/08/04/Go/32/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://uestcwxy.love" target="_blank">Palp1tate</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E4%BA%8C%E8%87%AA%E5%AD%A6/">大二自学</a><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/IMG_20230801_114856.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/01/gitlab/" title="Ubuntu安装部署Gitlab详细教程"><img class="cover" src="https://s2.loli.net/2023/05/31/z6eMNGUOmTkQ8aC.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Ubuntu安装部署Gitlab详细教程</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/04/giterr/" title="完美解决git报错fatal unable to access ‘https://github.com/.../.git‘:Recv failure Connection was reset"><img class="cover" src="https://s2.loli.net/2023/05/31/TREyA8hgqS7JnfV.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">完美解决git报错fatal unable to access ‘https://github.com/.../.git‘:Recv failure Connection was reset</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/27/qingxun/" title="从入门到渐入佳境——记我的第六届字节青训营经历"><img class="cover" src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/IMG_20230801_114856.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-27</div><div class="title">从入门到渐入佳境——记我的第六届字节青训营经历</div></div></a></div><div><a href="/2023/06/06/Go/10/" title="方法与接口"><img class="cover" src="https://s2.loli.net/2023/06/01/a4okGxJeW3smrcQ.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">方法与接口</div></div></a></div><div><a href="/2023/06/09/Go/12/" title="type关键字与错误处理"><img class="cover" src="https://s2.loli.net/2023/06/01/a4okGxJeW3smrcQ.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-09</div><div class="title">type关键字与错误处理</div></div></a></div><div><a href="/2023/06/08/Go/11/" title="补充函数与字符串"><img class="cover" src="https://s2.loli.net/2023/06/01/a4okGxJeW3smrcQ.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-08</div><div class="title">补充函数与字符串</div></div></a></div><div><a href="/2023/06/10/Go/13/" title="包的使用和time包"><img class="cover" src="https://s2.loli.net/2023/06/01/a4okGxJeW3smrcQ.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-10</div><div class="title">包的使用和time包</div></div></a></div><div><a href="/2023/06/12/Go/15/" title="断点续传与bufio包"><img class="cover" src="https://s2.loli.net/2023/06/01/a4okGxJeW3smrcQ.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-12</div><div class="title">断点续传与bufio包</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Palp1tate</div><div class="author-info__description">等我苦尽甘来时，我给你讲讲来时走的路。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/palp1tate/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://www.facebook.com/profile.php?id=100092533320651" target="_blank" title="facebook"><i class="fab fa-facebook" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:1939311091@qq.com" target="_blank" title="email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/1907948898" target="_blank" title="b站"><i class="fab fa-bilibili" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/img/tiktok.jpg" target="_blank" title="抖音"><i class="fab fa-tiktok" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/img/weixin.jpg" target="_blank" title="微信"><i class="fab fa-weixin" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">刚建站不久，博客美化有待研究，部分页面也没时间弄，路过的你将就看啦~😊，图片没加载出来就是网络不佳噢~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC%E5%8E%9F%E7%90%86%E4%B8%8EGo-RPC"><span class="toc-number">1.</span> <span class="toc-text">RPC原理与Go RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRPC"><span class="toc-number">1.1.</span> <span class="toc-text">什么是RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">本地调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">RPC调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%B0%83%E7%94%A8RESTful-API"><span class="toc-number">1.1.3.</span> <span class="toc-text">HTTP调用RESTful API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#net-rpc"><span class="toc-number">1.2.</span> <span class="toc-text">net&#x2F;rpc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80RPC%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础RPC示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84RPC"><span class="toc-number">1.2.2.</span> <span class="toc-text">基于TCP协议的RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JSON%E5%8D%8F%E8%AE%AE%E7%9A%84RPC"><span class="toc-number">1.2.3.</span> <span class="toc-text">使用JSON协议的RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E8%B0%83%E7%94%A8RPC"><span class="toc-number">1.2.4.</span> <span class="toc-text">Python调用RPC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">RPC原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gRPC"><span class="toc-number">2.</span> <span class="toc-text">gRPC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gRPC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">gRPC是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8gRPC"><span class="toc-number">2.2.</span> <span class="toc-text">为什么要用gRPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85gRPC"><span class="toc-number">2.3.</span> <span class="toc-text">安装gRPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85gRPC-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">安装gRPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Protocol-Buffers-v3"><span class="toc-number">2.3.2.</span> <span class="toc-text">安装Protocol Buffers v3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">安装插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5"><span class="toc-number">2.3.4.</span> <span class="toc-text">检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gRPC%E7%9A%84%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">gRPC的开发方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99-proto%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.4.1.</span> <span class="toc-text">编写.proto文件定义服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.4.2.</span> <span class="toc-text">生成指定语言的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81"><span class="toc-number">2.4.3.</span> <span class="toc-text">编写业务逻辑代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gRPC%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.5.</span> <span class="toc-text">gRPC入门示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99proto%E4%BB%A3%E7%A0%81"><span class="toc-number">2.5.1.</span> <span class="toc-text">编写proto代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99Server%E7%AB%AFGo%E4%BB%A3%E7%A0%81"><span class="toc-number">2.5.2.</span> <span class="toc-text">编写Server端Go代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99Client%E7%AB%AFGo%E4%BB%A3%E7%A0%81"><span class="toc-number">2.5.3.</span> <span class="toc-text">编写Client端Go代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gRPC%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8"><span class="toc-number">2.5.4.</span> <span class="toc-text">gRPC跨语言调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90Python%E4%BB%A3%E7%A0%81"><span class="toc-number">2.5.5.</span> <span class="toc-text">生成Python代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99Python%E7%89%88RPC%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.5.6.</span> <span class="toc-text">编写Python版RPC客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-RPC-%E8%B0%83%E7%94%A8"><span class="toc-number">2.5.7.</span> <span class="toc-text">Python RPC 调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gRPC%E6%B5%81%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.6.</span> <span class="toc-text">gRPC流式示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%81%E5%BC%8FRPC"><span class="toc-number">2.6.1.</span> <span class="toc-text">服务端流式RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E5%BC%8FRPC"><span class="toc-number">2.6.2.</span> <span class="toc-text">客户端流式RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%B5%81%E5%BC%8FRPC"><span class="toc-number">2.6.3.</span> <span class="toc-text">双向流式RPC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#metadata"><span class="toc-number">2.7.</span> <span class="toc-text">metadata</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84metadata"><span class="toc-number">2.7.1.</span> <span class="toc-text">创建新的metadata</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%AD%98%E5%82%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">2.7.2.</span> <span class="toc-text">元数据中存储二进制数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">2.7.3.</span> <span class="toc-text">从请求上下文中获取元数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E5%85%83%E6%95%B0%E6%8D%AE-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.7.4.</span> <span class="toc-text">发送和接收元数据-客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81metadata"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">发送metadata</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6metadata"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">接收metadata</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%B0%83%E7%94%A8"><span class="toc-number">2.7.4.2.1.</span> <span class="toc-text">普通调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">2.7.4.2.2.</span> <span class="toc-text">流式调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E5%85%83%E6%95%B0%E6%8D%AE-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-number">2.7.5.</span> <span class="toc-text">发送和接收元数据-服务器端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6metadata-1"><span class="toc-number">2.7.5.1.</span> <span class="toc-text">接收metadata</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%B0%83%E7%94%A8-1"><span class="toc-number">2.7.5.1.1.</span> <span class="toc-text">普通调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E8%B0%83%E7%94%A8-1"><span class="toc-number">2.7.5.1.2.</span> <span class="toc-text">流式调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81metadata-1"><span class="toc-number">2.7.5.2.</span> <span class="toc-text">发送metadata</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%B0%83%E7%94%A8-2"><span class="toc-number">2.7.5.2.1.</span> <span class="toc-text">普通调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E8%B0%83%E7%94%A8-2"><span class="toc-number">2.7.5.2.2.</span> <span class="toc-text">流式调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9ARPC%E8%B0%83%E7%94%A8metadata%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.7.6.</span> <span class="toc-text">普通RPC调用metadata示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#client%E7%AB%AF%E7%9A%84metadata%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.6.1.</span> <span class="toc-text">client端的metadata操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#server%E7%AB%AFmetadata%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.6.2.</span> <span class="toc-text">server端metadata操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%BC%8FRPC%E8%B0%83%E7%94%A8metadata%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.7.7.</span> <span class="toc-text">流式RPC调用metadata示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#client%E7%AB%AF%E7%9A%84metadata%E6%93%8D%E4%BD%9C-1"><span class="toc-number">2.7.7.1.</span> <span class="toc-text">client端的metadata操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#server%E7%AB%AF%E7%9A%84metadata%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.7.2.</span> <span class="toc-text">server端的metadata操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.8.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gRPC-code"><span class="toc-number">2.8.1.</span> <span class="toc-text">gRPC code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gRPC-Status"><span class="toc-number">2.8.2.</span> <span class="toc-text">gRPC Status</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%94%99%E8%AF%AF"><span class="toc-number">2.8.2.1.</span> <span class="toc-text">创建错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E9%94%99%E8%AF%AF%E6%B7%BB%E5%8A%A0%E5%85%B6%E4%BB%96%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-number">2.8.2.2.</span> <span class="toc-text">为错误添加其他详细信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.8.3.</span> <span class="toc-text">代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">2.8.3.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.8.3.2.</span> <span class="toc-text">客户端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E6%88%96%E8%AE%A4%E8%AF%81"><span class="toc-number">2.9.</span> <span class="toc-text">加密或认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%8A%A0%E5%AF%86%E8%AE%A4%E8%AF%81"><span class="toc-number">2.9.1.</span> <span class="toc-text">无加密认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81-SSL-TLS"><span class="toc-number">2.9.2.</span> <span class="toc-text">使用服务器身份验证 SSL&#x2F;TLS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6"><span class="toc-number">2.9.2.1.</span> <span class="toc-text">生成证书</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E7%A7%81%E9%92%A5"><span class="toc-number">2.9.2.1.1.</span> <span class="toc-text">生成私钥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8D%E7%9A%84%E8%AF%81%E4%B9%A6"><span class="toc-number">2.9.2.1.2.</span> <span class="toc-text">生成自签名的证书</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.9.2.2.</span> <span class="toc-text">建立安全连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%89"><span class="toc-number">2.10.</span> <span class="toc-text">拦截器（中间件）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AB%AF%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.10.1.</span> <span class="toc-text">客户端端拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%8B%A6%E6%88%AA%E5%99%A8-%E4%B8%80%E5%85%83%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.10.1.1.</span> <span class="toc-text">普通拦截器&#x2F;一元拦截器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.10.1.2.</span> <span class="toc-text">流拦截器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#server%E7%AB%AF%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.10.2.</span> <span class="toc-text">server端拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%8B%A6%E6%88%AA%E5%99%A8-%E4%B8%80%E5%85%83%E6%8B%A6%E6%88%AA%E5%99%A8-1"><span class="toc-number">2.10.2.1.</span> <span class="toc-text">普通拦截器&#x2F;一元拦截器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%8B%A6%E6%88%AA%E5%99%A8-1"><span class="toc-number">2.10.2.2.</span> <span class="toc-text">流拦截器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.10.3.</span> <span class="toc-text">拦截器示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">2.10.3.1.</span> <span class="toc-text">客户端拦截器定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.10.3.1.1.</span> <span class="toc-text">一元拦截器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.10.3.1.2.</span> <span class="toc-text">流式拦截器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">2.10.3.2.</span> <span class="toc-text">服务端拦截器定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E6%8B%A6%E6%88%AA%E5%99%A8-1"><span class="toc-number">2.10.3.2.1.</span> <span class="toc-text">一元拦截器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%8B%A6%E6%88%AA%E5%99%A8-2"><span class="toc-number">2.10.3.3.</span> <span class="toc-text">流拦截器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.10.3.4.</span> <span class="toc-text">注册拦截器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-grpc-middleware"><span class="toc-number">2.10.4.</span> <span class="toc-text">go-grpc-middleware</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/21/Go/41/" title="分别用Python和Go实现对文件夹及其子文件夹里的文件进行批量重命名"><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/4d287328613d2f4952a70edb9192044037dd5e22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分别用Python和Go实现对文件夹及其子文件夹里的文件进行批量重命名"/></a><div class="content"><a class="title" href="/2023/09/21/Go/41/" title="分别用Python和Go实现对文件夹及其子文件夹里的文件进行批量重命名">分别用Python和Go实现对文件夹及其子文件夹里的文件进行批量重命名</a><time datetime="2023-09-21T11:45:18.000Z" title="发表于 2023-09-21 19:45:18">2023-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/19/Go/40/" title="Go语言的单元测试与基准测试"><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/4d287328613d2f4952a70edb9192044037dd5e22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言的单元测试与基准测试"/></a><div class="content"><a class="title" href="/2023/09/19/Go/40/" title="Go语言的单元测试与基准测试">Go语言的单元测试与基准测试</a><time datetime="2023-09-19T02:26:26.000Z" title="发表于 2023-09-19 10:26:26">2023-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/18/%E7%AE%97%E6%B3%95/q4/" title="q4"><img src="https://cdn.jsdelivr.net/gh/palp1tate/ImgPicGo/img/1284.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="q4"/></a><div class="content"><a class="title" href="/2023/09/18/%E7%AE%97%E6%B3%95/q4/" title="q4">q4</a><time datetime="2023-09-18T10:46:55.000Z" title="发表于 2023-09-18 18:46:55">2023-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/14/%E7%AE%97%E6%B3%95/9/" title="排序"><img src="https://cdn.jsdelivr.net/gh/palp1tate/ImgPicGo/img/1284.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序"/></a><div class="content"><a class="title" href="/2023/09/14/%E7%AE%97%E6%B3%95/9/" title="排序">排序</a><time datetime="2023-09-14T07:30:08.000Z" title="发表于 2023-09-14 15:30:08">2023-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/13/%E7%AE%97%E6%B3%95/q3/" title="数组必刷题"><img src="https://cdn.jsdelivr.net/gh/palp1tate/ImgPicGo/img/1284.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数组必刷题"/></a><div class="content"><a class="title" href="/2023/09/13/%E7%AE%97%E6%B3%95/q3/" title="数组必刷题">数组必刷题</a><time datetime="2023-09-13T05:12:21.000Z" title="发表于 2023-09-13 13:12:21">2023-09-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/IMG_20230801_114856.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By Palp1tate</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><i class="fa-solid fa-cloud"></i><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>萌ICP备20230529号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="6614140207" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-mini="true"> </div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>