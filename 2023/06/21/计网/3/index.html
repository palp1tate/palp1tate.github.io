<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计网期末复习之传输层 | Palp1tate</title><meta name="author" content="Palp1tate,1939311091@qq.com"><meta name="copyright" content="Palp1tate"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、传输层：两个进程之间的逻辑通信，网络层: 两个主机之间的逻辑通信  传输层协议运行在端系统  发送方: 将应用程序报文分成报文段传递给网络层,  接受方: 将报文段重新组装成报文传递到应用层   传输层可以为应用提供多种协议(因特网: TCP 和 UDP) 可靠按序递交 (TCP)：拥塞控制&#x2F;流量控制&#x2F;连接建立 不可靠的无序传递: UDP“尽力传递” IP的直接扩展 两种服">
<meta property="og:type" content="article">
<meta property="og:title" content="计网期末复习之传输层">
<meta property="og:url" content="https://uestcwxy.love/2023/06/21/%E8%AE%A1%E7%BD%91/3/index.html">
<meta property="og:site_name" content="Palp1tate">
<meta property="og:description" content="1、传输层：两个进程之间的逻辑通信，网络层: 两个主机之间的逻辑通信  传输层协议运行在端系统  发送方: 将应用程序报文分成报文段传递给网络层,  接受方: 将报文段重新组装成报文传递到应用层   传输层可以为应用提供多种协议(因特网: TCP 和 UDP) 可靠按序递交 (TCP)：拥塞控制&#x2F;流量控制&#x2F;连接建立 不可靠的无序传递: UDP“尽力传递” IP的直接扩展 两种服">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png">
<meta property="article:published_time" content="2023-06-21T11:54:05.000Z">
<meta property="article:modified_time" content="2023-09-15T11:33:51.666Z">
<meta property="article:author" content="Palp1tate">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://uestcwxy.love/2023/06/21/%E8%AE%A1%E7%BD%91/3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Palp1tate","link":"链接: ","source":"来源: Palp1tate","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计网期末复习之传输层',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-09-15 19:33:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Palp1tate" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-clipboard-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Palp1tate"><span class="site-name">Palp1tate</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-clipboard-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计网期末复习之传输层</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-21T11:54:05.000Z" title="发表于 2023-06-21 19:54:05">2023-06-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-15T11:33:51.666Z" title="更新于 2023-09-15 19:33:51">2023-09-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">大二下期末复习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计网期末复习之传输层"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>1、传输层：两个进程之间的<strong>逻辑通信</strong>，网络层: 两个<strong>主机</strong>之间的逻辑通信</p>
<ul>
<li>传输层协议运行在端系统 <ul>
<li><strong>发送方</strong>: 将应用程序报文分成报文段传递给网络层, </li>
<li><strong>接受方</strong>: 将报文段重新组装成报文传递到应用层</li>
</ul>
</li>
<li>传输层可以为应用提供多种协议(因特网: TCP 和 UDP)<ul>
<li>可靠按序递交 (TCP)：拥塞控制&#x2F;流量控制&#x2F;连接建立</li>
<li>不可靠的无序传递: UDP“尽力传递” IP的直接扩展</li>
<li>两种服务均不保证: 延迟&#x2F;带宽</li>
</ul>
</li>
</ul>
<p>2、多路复用&#x2F;多路分解工作原理</p>
<p>在发送主机多路复用:从多个套接字收集数据, 用首部封装数据，然后将报文段传递到网络层(多路复用）</p>
<p>在接收主机多路分解:将接收到的数据段传递到正确的套接字（多路分解）</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_08-40-33.png"></p>
<p>多路复用&#x2F;分解如何工作?（报文段头部字段实现）</p>
<ul>
<li><p>主机收到IP数据报</p>
<ul>
<li>每个数据报有<strong>源IP地址</strong>，<strong>目的IP地址</strong></li>
<li>每个数据报搬运一个报文段</li>
<li>每个报文段有源和目的端口号 （回忆: 对于特定应用程序具有周知端口号)</li>
</ul>
</li>
<li><p>主机用<strong>IP地址和端口号</strong>指明报文段属于哪个合适的套接字</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_08-40-51.png"></p>
<p>3、无连接多路分解（ UDP 套接字：目的IP地址, 目的端口号）</p>
<ul>
<li>当主机收到UDP报文段：检查报文段中的目的端口号、用<strong>端口号</strong>指示UDP报文段属于哪个套接字</li>
<li>来自不同的源IP地址且&#x2F;或源端口号的IP报文报，导向同一个的套接字</li>
<li><strong>SP 提供“返回地址”</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_08-53-15.png"></p>
<p>4、面向连接的多路分解（TCP套接字：源IP地址、源端口号、目的IP地址、目的端口号）</p>
<ul>
<li>服务器主机支持很多同时的TCP 套接字:每个套接字用4部分来表示 </li>
<li>Web服务器对每个连接的客户都有不同的套接字：非持久 HTTP 将对每个请求有一个不同的套接字</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_08-53-37.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_08-53-53.png"></p>
<p>5、 UDP用户数据报协议</p>
<p>UDP 是<strong>面向报文</strong>的</p>
<p><strong>基于Internet IP协议</strong></p>
<ul>
<li>复用&#x2F;分用</li>
<li>简单的错误校验</li>
</ul>
<p><strong>“尽最大努力”服务，报文段可能</strong>: </p>
<ul>
<li>丢失</li>
<li>会传递失序的报文到应用程序无连接</li>
<li>在UDP接收者发送者之间<strong>没有握手</strong></li>
<li>每个UDP 报文段的处理独立于其他报文段</li>
</ul>
<p>为什么有 UDP?</p>
<ul>
<li>不需要建立连接 (减少延迟)</li>
<li>简单: 在发送者接受者之间不需要连接状态</li>
<li>很小的报文段首部</li>
<li>没有拥塞控制: UDP 能够用尽可能快的速度传递</li>
</ul>
<p>**常用于流式多媒体应用：丢包容忍&#x2F;速率敏感 **<br>其他UDP应用：DNS&#x2F;SNMP&#x2F;RTP</p>
<p><strong>经UDP的可靠传输</strong> : 在应用层增加可靠性&#x2F;应用程序特定的差错恢复！</p>
<p>6、UDP报文格式（8字节）每个字段含义</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_09-11-16.png"></p>
<p>7、UDP是面向报文的传输方式</p>
<p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。即<strong>应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文</strong>。</p>
<p>思考大的视频文件如何利用UDP传输：</p>
<ul>
<li><p>将大数据分成多个小包，每个小包的大小不能超过UDP协议数据包的最大长度（一般为64KB）。</p>
</li>
<li><p>在每个小包中增加一个序列号，用于确保数据包的顺序和完整性。</p>
</li>
<li><p>在每个小包中增加一个校验和，用于检测数据包在传输过程中的错误。</p>
</li>
<li><p>接收方将收到的小包按照序列号和校验和的方式进行重组和验证，确保数据的完整性和正确性。</p>
</li>
<li><p>对于丢失的数据包，发送方需要在一定时间内进行重传，以保证数据的可靠性。</p>
</li>
</ul>
<p>9、UDP首部的<strong>校验和</strong>计算</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_09-08-11.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_09-08-35.png"></p>
<p>（1）将UDP伪头部、UDP头部和数据部分全部用16进制数表示。</p>
<p>（2）将第一个16进制数与第二个16进制数相加。求和时产生的进位必须回卷加到结果上。</p>
<p>（3）将上一步得到的16位数与第三个16进制的数相加，重复第二步，直到累加完所有的16进制数，并且得到的结果为16进制数。</p>
<p>（4）将累加最后得到的16进制数取反，得到校验和。</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_09-10-17.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_09-26-04.png"></p>
<p>发送方对校验和进行了反码操作，并放入了校验和字段 发送给了接受方 等接收方对其他字段进行了二进制的加法，其中就有校验和字段，就会变成原码和反码的加法，就都变成1了，如果不是都是1的话 那就说明其中的字段和发送方的字段不一样，肯定就是错误的，就把包丢了。</p>
<p>10、可靠数据传输原理rdt1.0-rdt3.0的工作场景（no loss、lost packet、lost ack、timeout）</p>
<p>Rdt1.0: 完全可靠信道上的可靠数据传输</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_10-18-04.png"></p>
<p>Rdt2.0: 具有bit错误的信道</p>
<ul>
<li>下层信道可能让传输分组中的bit受损：利用校验和检测bit位错误</li>
<li>问题: 如何从错误中恢复<ul>
<li>确认(ACKs): 接收方明确告诉发送方分组接收正确</li>
<li>否认 (NAKs):接收方明确告诉发送方分组接收出错</li>
<li>发送方收到NAK后重发这个分组</li>
</ul>
</li>
<li>在 rdt2.0中的新机制 (在 rdt1.0中没有的)：<ul>
<li>差错检测</li>
<li>接收方反馈: 控制信息 (ACK,NAK)   rcvr-&gt;sender</li>
<li>重传</li>
</ul>
</li>
</ul>
<p>停等协议:发送方发送一个报文，然后等待接受方的响应</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_10-18-42.png"></p>
<p><strong>rdt2.0: 缺陷</strong></p>
<p>如果ACK&#x2F;NAK发生错误&#x2F;被破坏(corrupted)会怎么样？</p>
<ul>
<li>为ACK&#x2F;NAK增加校验和，检错并纠错</li>
<li>发送方收到被破坏ACK&#x2F;NAK时不知道接收方发生了什么，添加额外的控制消息</li>
<li>如果ACK&#x2F;NAK坏掉，发送方重传</li>
<li>不能简单的重传：产生重复分组</li>
</ul>
<p>如何解决重复分组问题？</p>
<ul>
<li>序列号(Sequence number): 发送方给每个分组增加序列号</li>
<li>接收方丢弃重复分组</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/rdt2.1.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_10-27-30.png"></p>
<p><strong>rdt2.2: 无NAK的消息协议</strong></p>
<p>我们真的需要两种确认消息(ACK + NAK)吗？</p>
<ul>
<li>同 rdt2.1一样的功能, 但只用 ACKs </li>
<li>如何实现？<ul>
<li>接收方通过ACK告知最后一个被正确接收的分组</li>
<li>在ACK消息中显式地加入被确认分组的序列号</li>
</ul>
</li>
<li>发送方收到重复ACK之后，采取与收到NAK消息相同的动作<ul>
<li>重传当前分组</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_10-27-48.png"></p>
<p><strong>rdt3.0: 具有出错和丢失的信道</strong></p>
<p>新假设: 下层信道还要丢失报文 (数据或者 ACKs)</p>
<p>校验和, 序号, 确认, 重发将会有帮助，但是不够</p>
<p>方法: 发送者等待“合理的”确认时间</p>
<ul>
<li>如果在这个时间内没有收到确认就<strong>重发</strong></li>
<li>如果报文（或者确认）只是延迟 (没有丢失):<ul>
<li>重发将导致重复，但是使用序号已经处理了这个问题</li>
<li>接受方必须指定被确认的报文序号</li>
</ul>
</li>
<li>要求<strong>倒计时定时器</strong>：只有在定时器超时时才触发重发</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_10-28-16.png"></p>
<p><strong>rdt3.0的性能分析</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-15-06.png"></p>
<p>流水线: 发送方允许发送多个 “在路上的”, 还没有确认的报文</p>
<ul>
<li>序号数目的范围必须增加</li>
<li>在发送方&#x2F;接收方必须有缓冲区</li>
</ul>
<p>流水线技术的两个通用形式: <em><strong>go-Back-N</strong></em>,*** 选择重传***</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_10-28-44.png"></p>
<p>11、GBN协议</p>
<p><strong>Go-Back-N(GBN)协议: 发送方</strong></p>
<ul>
<li>分组头部包含k-bit序列号</li>
<li>窗口尺寸为N，最多允许N个分组未确认</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-16-47.png"></p>
<ul>
<li>ACK(n): 确认到序列号n(包含n)的分组均已被正确接收<ul>
<li>可能收到重复ACK</li>
</ul>
</li>
<li>对第一个发送未被确认的报文定时(timer)</li>
<li>timeout(n):若超时，重传窗口中的分组n及所有更高序号的分组</li>
</ul>
<p><strong>Go-Back-N(GBN)协议: 接收方</strong></p>
<p>只有ACK: 对接收的分组总是发送具有最高按序序号的ACK</p>
<ul>
<li>可能产生冗余的ACKs</li>
<li>仅仅需要记住期望的序号值（expectedseqnum）</li>
</ul>
<p>对失序的分组: </p>
<ul>
<li>丢弃 (不缓存) -&gt; <strong>没有接收缓冲区</strong>!</li>
<li>重新确认具有按序的分组</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_12-35-57.png"></p>
<p>12、SR协议</p>
<ul>
<li>接收方分别确认已经收到的分组:必要时，缓冲报文, 最后按序提交给上层</li>
<li>发送者只重发没有收到确认的分组:对每个没有确认的报文发送者都要启动一个定时器(每个未被确认的报文都有一个定时器)</li>
<li>发送窗口:N 个连续序号&#x2F;限制被发送的未确认的分组数量</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-17-24.png"></p>
<p><strong>发送方</strong></p>
<ul>
<li>从上层收到数据 ：如果下一个可用的序号在发送方窗口内，则将数据打包并发送,启动定时器</li>
<li>超时(n)：重发分组n, 重启定时器</li>
<li>收到ACK(n)在[sendbase,sendbase+N-1]内:<ul>
<li>标记分组n被接收</li>
<li>如果n是最小的未确认分组，则增加窗口基序号到下一个未被确认的序号</li>
</ul>
</li>
</ul>
<p><strong>接收方</strong></p>
<ul>
<li><p>分组n的序号在[rcvbase, rcvbase+N-1]内</p>
<ul>
<li><p>发送ACK(n)</p>
</li>
<li><p>失序分组: 缓冲</p>
</li>
<li><p>有序分组: 交付上层 (包括已经缓冲的有序分组), 提高窗口到下一个没有接收的分组</p>
</li>
</ul>
</li>
<li><p>分组n在[rcvbase-N,rcvbase-1]内</p>
<ul>
<li>发送ACK(n)</li>
</ul>
</li>
<li><p>其他：忽略</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-18-28.png"></p>
<p>选择性重传: 两难选择</p>
<p>例子: </p>
<p>序号: 0, 1, 2, 3</p>
<p>window size&#x3D;3</p>
<p>在两种情况下接收方没有感觉到差别!</p>
<p>Q: 窗口大小和序号大小有什么关系?</p>
<p>A: 窗口小于或等于序号空间大小的一半</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-18-55.png"></p>
<p><strong>可靠数据传输机制及用途总结</strong></p>
<table>
<thead>
<tr>
<th>机制</th>
<th align="left">用途和说明</th>
</tr>
</thead>
<tbody><tr>
<td>检验和</td>
<td align="left">用于检测在一个传输分组中的比特错误。</td>
</tr>
<tr>
<td>定时器</td>
<td align="left">用于检测超时&#x2F;重传一个分组，可能因为该分组（或其ACK）在信道中丢失了。由于当一个分组被时延但未丢失（过早超时），或当一个分组已被接收方收到但从接收方到发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余拷贝。</td>
</tr>
<tr>
<td>序号</td>
<td align="left">用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使该接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余拷贝。</td>
</tr>
<tr>
<td>确认</td>
<td align="left">接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议。</td>
</tr>
<tr>
<td>否定确认</td>
<td align="left">接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常携带着未被正确接收的分组的序号。</td>
</tr>
<tr>
<td>窗口、流水线</td>
<td align="left">发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力或网络中的拥塞程度，或两者情况来进行设置。</td>
</tr>
</tbody></table>
<p>13、TCP是面向面向连接传输</p>
<ul>
<li><p>点到点:</p>
<ul>
<li>一个发送者,一个接收者</li>
</ul>
</li>
<li><p>可靠按序的字节流:</p>
<ul>
<li>没有“信息边界”</li>
</ul>
</li>
<li><p>流水线:</p>
<ul>
<li>TCP 拥塞和流量控制设置窗口大小</li>
</ul>
</li>
<li><p>收发缓冲区<br><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-19-16.png"></p>
</li>
<li><p>全双工数据:</p>
<ul>
<li>同一个连接上的双向数据流</li>
<li>MSS: 最大报文段长</li>
</ul>
</li>
<li><p>面向连接: </p>
<ul>
<li>在数据交换前握手(交换控制信息)</li>
<li>连接状态只在连接的两端中维护，在沿途节点中并不维护状态。</li>
<li>TCP连接包括：两台主机上的缓存、连接状态变量、socket等</li>
</ul>
</li>
<li><p>流量控制:</p>
<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
</ul>
<p><strong>TCP是面向字节流</strong>，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p>
<p><strong>有可能将多条数据当成一条数据进行处理</strong>，因此需要在应用层进行数据的边界管理</p>
<p>编程影响：上层可能会将多条数据当做一条数据处理。</p>
<p>特殊字符间隔： 使用此方法则必须对数据中的特殊字符进行转义，否则会造成二义</p>
<p>数据定长：规定固定长度的数据，实际数据少的则需要进行补位</p>
<p>在应用层头部定义数据长度（例如http协议，先取头部，再根据头部中的数据长度取出数据）</p>
<p>14、TCP报文格式（字段含义&#x2F;用途）</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-19-52.png"></p>
<p>15、 TCP 往返时延的估计和超时</p>
<p>设置超时</p>
<ul>
<li><p>EstimtedRTT 加上 “安全余量” </p>
</li>
<li><p>EstimatedRTT变化大 -&gt; 更大的安全余量</p>
</li>
</ul>
<p>SampleRTT 偏离 EstimatedRTT多少的估计</p>
<ul>
<li>DevRTT &#x3D; (1-β)*DevRTT +β*| SampleRTT-EstimatedRTT |    (典型地, β &#x3D; 0.25)</li>
</ul>
<p>然后设置超时时间间隔:   </p>
<p> TimeoutInterval &#x3D; EstimatedRTT + 4*DevRTT</p>
<p>设置超时</p>
<p>初始时TimeoutInterval设置为1秒</p>
<p>第一个样本RTT获得后， EstimatedRTT&#x3D;SampleRTT，DevRTT&#x3D;SampleRTT&#x2F;2，     TimeoutInterval &#x3D;EstimatedRTT + max (G, K*DevRTT) （K&#x3D;4，G是用户设置的时间粒度）</p>
<p>16、TCP可靠数据传输</p>
<p><strong>TCP 发送方事件</strong></p>
<ul>
<li><p>从应用程序接收数据:</p>
<ul>
<li>用序号创造一个报文</li>
<li>序号是报文中第一个数据字节在字节流中的位置编号</li>
<li>如果没有启动定时器，则启动定时器 （定时器是最早没有被确认的报文发送时启动的）</li>
<li>设置超时间隔: TimeOutInterval</li>
</ul>
</li>
<li><p>超时:</p>
<ul>
<li>重发导致超时的报文</li>
<li>重新开始定时器</li>
</ul>
</li>
<li><p>收到确认:</p>
<ul>
<li>如果ACK落在窗口之内，则确认对应的报文，并且滑动窗口 </li>
<li>若还有未确认的报文，重新开始定时器</li>
</ul>
</li>
</ul>
<p><strong>TCP 接收方事件</strong></p>
<table>
<thead>
<tr>
<th>接收方的事件</th>
<th>TCP 接收方行为</th>
</tr>
</thead>
<tbody><tr>
<td>期望序号的报文段按序到达. 所有在期望序号以前的报文段都被确认</td>
<td>延迟ACK. 等到 500ms看是否有下一个报文段，如果没有，发送ACK</td>
</tr>
<tr>
<td>期望序号的报文段按序到达.另一个按序报文段等待发送ACK</td>
<td>立即发送单个累积ACK, 确认两个有序的报文段</td>
</tr>
<tr>
<td>收到一个失序的报文段，高于期望的序号，检测到缝隙</td>
<td>立即发送重复 ACK, 指出期望的序号</td>
</tr>
<tr>
<td>到达的报文段部分地或者完全地填充接收数据间隔</td>
<td>立即发送 ACK, 证实缝隙低端的报文段已经收到</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-21-16.png"></p>
<p><strong>超时间隔加倍</strong></p>
<ul>
<li><p>TCP每次重传，都会把下一次的超时间隔设置为先前值的两倍。</p>
</li>
<li><p>但是当收到上层应用的数据和收到ACK两个事件中的任何一个发生时，定时器的TimeoutInterval值恢复为由近期的EstimatedRTT和DevRTT计算得到。</p>
</li>
<li><p>TimeoutInterval &#x3D;EstimatedRTT + max (G, K*DevRTT) （K&#x3D;4，G是用户设置的时间粒度）</p>
</li>
</ul>
<p><strong>快速重传</strong></p>
<ul>
<li>发送方可以在超时之前通过重复的ACK检测丢失报文段</li>
<li>发送方常常一个接一个地发送很多报文段</li>
<li>如果报文段丢失,则发送方将可能接收到很多重复的 ACKs</li>
<li>如果发送方收到4个对同样报文段的确认，则发送方认为该报文段之后的数据已经丢失。</li>
<li>启动<strong>快速重传</strong>: 在定时器超时之前重发丢失的报文段</li>
</ul>
<p>17、 TCP 流量控制机制</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-21-33.png"></p>
<p>(假设 TCP 接收方丢弃失序的报文段)</p>
<ul>
<li><p>缓冲区的剩余空间&#x3D; RcvWindow&#x3D; RcvBuffer-[LastByteRcvd - LastByteRead]</p>
</li>
<li><p>接收方在报文段接收窗口字段中通告其接收缓冲区的剩余空间</p>
</li>
<li><p>Sender限制自己已经发送的但还未收到ACK的数据不超过接收方的空闲RcvWindow尺寸</p>
</li>
<li><p>Receiver告知Sender，RcvWindow&#x3D;0,会出现什么情况？</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-22-48.png"></p>
<p>18、 TCP连接管理（序号、确认序号）</p>
<p><strong>建立连接</strong></p>
<p>回忆: TCP在交换数据报文段之前在发送方和接收方之间建立连接</p>
<p>初始化TCP 变量:</p>
<p>-序号</p>
<p>-缓冲区流控信息 (例，接收窗口)</p>
<p>客户: 连接发起者  Socket clientSocket &#x3D; new   Socket(“hostname”,”port number”); </p>
<p>服务器: 被客户联系  Socket connectionSocket &#x3D; welcomeSocket.accept();</p>
<p>三次握手：</p>
<p>Step 1: 客户发送TCP SYN报文段到服务器</p>
<p>-指定初始的序号</p>
<p>-没有数据</p>
<p>Step 2: 服务器接收SYN, 回复 SYN&#x2F;ACK 报文段</p>
<p>-服务器分配缓冲区</p>
<p>-指定服务器的初始序号</p>
<p>Step 3: 客户接收 SYN&#x2F;ACK, 回复 ACK 报文段, 可能包含数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-23-01.png"></p>
<p><strong>关闭连接</strong></p>
<p>客户关闭套接字: clientSocket.close	</p>
<p>Step 1: 客户发送 TCP FIN 控制报文段到服务器 </p>
<p>Step 2: 服务器接收 FIN, 回复 ACK. 进入半关闭连接状态； </p>
<p>Step 3: 服务器发送FIN到客户，客户接收 FIN, 回复 ACK，进入 “time wait”状态等待结束时释放连接资源</p>
<p>Step 4: 服务器接收 ACK.  连接关闭. </p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-23-12.png"></p>
<p>19、拥塞控制的方法</p>
<p>根据网路层是否为运输层拥塞控制提供了显示帮助，来区分拥塞控制方法。分为两类方法:</p>
<p>端到端拥塞控制:</p>
<ul>
<li>没有从网络中得到明确的反馈</li>
<li>从端系统观察到的丢失和延迟推断出拥塞</li>
<li>TCP采用的方法</li>
</ul>
<p>网络辅助的拥塞控制:</p>
<p>路由器给端系统提供反馈</p>
<p>单bit指示拥塞 (SNA, DECnet, TCP&#x2F;IP ECN, ATM)</p>
<p>指明发送者应该发送的速率</p>
<p>19、TCP拥塞控制（慢启动、拥塞避免、快速恢复；总结: TCP 拥塞控制）</p>
<ul>
<li><p>端到端控制 (没有网络辅助)</p>
</li>
<li><p>发送方限制发送:  LastByteSent-LastByteAcked  &lt;min( CongWin , RcvWindow )</p>
</li>
<li><p>大体上,</p>
<p>rate&#x3D;CongWin &#x2F;RTT(Bytes&#x2F;sec)，CongWin 是动态的, 感知的网络拥塞的函数</p>
</li>
<li><p>发送方如何感知拥塞 ?</p>
<ul>
<li>丢失事件 &#x3D; 超时或者 3 个重复的ACKs</li>
<li>TCP 发送方在丢失事件发生后降低发送速率 (CongWin)</li>
</ul>
</li>
<li><p>如何合理控制发送速率？</p>
<ul>
<li>AIMD（拥塞避免）</li>
<li>慢启动</li>
</ul>
</li>
</ul>
<p><strong>TCP AIMD(Additive-increase,multiplicative-decrease)</strong></p>
<p><strong>原理</strong>：发送方增加传输速率（窗口大小），谨慎地探测可用带宽，直到发生丢包事件</p>
<p><strong>方法：AIMD</strong></p>
<ul>
<li>加性递增: 每个RTT内如果没有丢失事件发生，拥塞窗口增加1个MSS（拥塞避免）</li>
<li>乘性递减: 发生丢包事件后将拥塞窗口减半</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-24-05.png"></p>
<p><strong>TCP 慢启动（slow  start）</strong></p>
<ul>
<li><p>连接开始的时候, CongWin &#x3D; 1 MSS</p>
<ul>
<li><p>Example: MSS &#x3D; 500 bytes &amp; RTT &#x3D; 200 msec</p>
</li>
<li><p>初始速率 &#x3D; 20 kbps</p>
</li>
</ul>
</li>
<li><p>有效带宽将 &gt;&gt; MSS&#x2F;RTT     </p>
<ul>
<li>希望尽快达到期待的速率，故将以2的指数方式增加速率。</li>
</ul>
</li>
<li><p>故以指数方式增加速率，直到产生丢失事件，或者达到某个阈值ssthresh</p>
</li>
</ul>
<p><strong>ssthresh（阈值）变量</strong></p>
<p>（发送<strong>丢失事件</strong>后，ssthresh设置为<strong>丢失事件</strong>事件前的 CongWin 的1&#x2F;2）</p>
<p>什么时候从指数增加变为线性增加（拥塞避免）?</p>
<ul>
<li>当CongWin达到ssthresh时。</li>
<li>每收到1个ACK, CongWin &#x3D;CongWin + (MSS&#x2F; CongWin)*MSS</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-24-39.png"></p>
<p><strong>对拥塞事件的反应</strong></p>
<ul>
<li>当超时事件发生时:<ul>
<li>CongWin 立即设置为 1个 MSS； </li>
<li>窗口开始指数增长（进入慢启动）</li>
<li>到达一个阈值后再线性增长</li>
</ul>
</li>
<li>收到三个重复的确认时：<ul>
<li>CongWin 减半+3 (Reno版) </li>
<li>然后，窗口线性增长（快速恢复）</li>
</ul>
</li>
</ul>
<p>注：上述为TCP Reno版本的内容，在TCP Tahoe版本里，无论超时还是三个重复，都直接将CongWin 置为 1个 MSS</p>
<p>怎么理解不同的丢包事件？</p>
<ul>
<li>3 个重复的 ACKs 表明网络具有传输一些数据段的能力</li>
<li>在三个重复的确认之前超时是“更加严重的警告”</li>
</ul>
<p><em>在快速恢复阶段：</em></p>
<ul>
<li>对于引起TCP进入快速恢复状态的<strong>缺失报文段</strong>，每收到一个冗余的ACK，CongWin的值增加一个MSS。</li>
<li>最终，当对丢失的报文段的一个ACK到达时，TCP在降低 CongWin（cwnd &#x3D; ssthresh）后，进入<strong>拥塞避免</strong>状态。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-24-39.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-22_11-25-51.png"></p>
<hr>
<p>UDP 报文实现差错检测时，不需要在网络上传输的部分是（A ） </p>
<p>A. 伪首部 	B. 首部 		C. 数据 		D. 校验和</p>
<p>运输层协议在端系统和路由器中都可以实现。(  ×  )</p>
<p>数据0x9876A543的十六比特因特网校验和为（ C      ）</p>
<p>A、0x3DB9	B、0x3DBA	C、0xC245	D、0xC246</p>
<p>十六比特因特网校验和是通过将数据分成16位的字，然后将这些字相加，如果有溢出则将溢出部分加到结果上，最后对结果取反得到的。对于数据0x9876A543，我们可以将其分成两个16位的字：0x9876和0xA543。将这两个字相加得到0x13DB9，由于有溢出，所以我们需要将溢出部分加到结果上，得到0x3DBA。最后对结果取反得到校验和为0xC245。</p>
<p>UDP服务器端将为每个客户的请求建立一个新的套接字。  （  ×    ）</p>
<p>TCP 中，套接字是一对一的关系。如要向 10 个客户端提供服务，那么除了负责监听的套接字外，还需要创建 10 套接字。但在 UDP 中，不管是服务器端还是客户端都只需要 1 个套接字。</p>
<p>一条线路带宽为1Mbps，往返时延为45ms，假设数据帧的大小为1000字节。若采用停等协议方式，实际的数据率大约是（  C    ）。</p>
<p>A、15Kbps  B、1.5Kbps  C、151Kbps  D、1510Kbps</p>
<p>由于带宽为1Mbps，所以发送一个1000字节的数据帧需要8ms。加上往返时延45ms，总共需要53ms才能发送一个数据帧。因此，实际的数据率为1000字节&#x2F;53ms &#x3D; 151.51Kbps。</p>
<p>在选择重传协议中，假设发送窗口和接收窗口的大小相等，如果用来表示分组序号的字段长度为8个比特，则发送方窗口长度最大为（ C ）。</p>
<p>A、32    B、64    C、128    D、256</p>
<p>在选择重传协议中，发送窗口和接收窗口的大小相等，用来表示分组序号的字段长度为8个比特，那么序号的范围为0-255。由于选择重传协议要求发送窗口的大小不能超过序号空间的一半，所以发送方窗口长度最大为256&#x2F;2&#x3D;128。</p>
<p>流水线可靠传输技术中序号的数量应该大于等于发送窗口和接收窗口之和。（√）</p>
<p>因为序号的数量决定了可以同时发送的数据帧的数量，而发送窗口和接收窗口之和决定了可以同时发送和接收的数据帧的数量。如果序号的数量小于发送窗口和接收窗口之和，那么就会出现序号重复的情况，导致数据传输出错。因此，为了保证流水线可靠传输技术的正确性，序号的数量应该大于等于发送窗口和接收窗口之和。</p>
<p>GBN回退N帧可靠传输中某一分组超时时，要重传该分组及其以后的所有分组。（√）</p>
<p>因为在GBN协议中，接收方只能按序接收数据帧，如果某一分组丢失，那么其后面的所有分组都无法被接收方正确接收。因此，当某一分组超时时，发送方需要重传该分组及其以后的所有分组，以保证数据的正确传输。</p>
<p>在选择重传（SR）协议中，发送方可能会收到落在其当前窗口之外的分组的ACK包。（√）</p>
<p>比如，如果序号为sendbase的分组发送后，接收方正确的收到了该分组，但是对其应答的ack超时，没有到，于是发送方又重发了序号为sendbase的分组。而接收方，也会再次发送ack。后到的ack就可能在窗口外。</p>
<p>能为计算机网络通信提供加密防护服务的协议是(  B  )。</p>
<p>A、ARP	B、SSL    C、SMTP     D、PPP </p>
<p>SSL协议在传输层和应用层之间，为网络通信提供安全保障。</p>
<p>ARP（Address Resolution Protocol）是一种用于将IP地址解析为物理地址的协议；SMTP（Simple Mail Transfer Protocol）是一种用于发送电子邮件的协议；PPP（Point-to-Point Protocol）是一种用于在点对点链路上进行数据传输的协议。</p>
<p>TCP是一个点对点的协议，协议双方连接的端点是应用进程端口号（ √     ）</p>
<p>TCP报头中的确认号是指（    B    ）</p>
<p>A、传输数据的第一个字节在缓冲区中的位置编号 </p>
<p>B、期待接收的下一个字节的位置编号</p>
<p>C、已连续接收的最后一个字节在缓冲区中的位置编号  </p>
<p>D、当前接收数据的序号 </p>
<p>确认号用于告诉发送方，接收方已经成功接收到了哪些数据，期待接收的下一个字节的序号是多少。这样，发送方就可以根据确认号来判断哪些数据已经被成功接收，哪些数据需要重传。</p>
<p>假设主机 A 通过一条 TCP 连接向主机 B 发送两个紧接着的 TCP 报文段。第一个 报文段的序号为 90，第二个报文段序号为 110。<br>a. 第一个报文段中有多少数据？20 bytes<br>b. 假设第一个报文段丢失而第二个报文段到达主机 B。那么在主机 B 发往主机 A 的确认报文中，确认号应该是多少？确认号 &#x3D; 90</p>
<p>假定主机A通过TCP连接向主机B发送一个序号为20的20字节报文段后，那么主机A收到的确认号不可能是（ B ）</p>
<p>A、10  B、39  C、40   D、无法确定</p>
<p>主机甲和主机乙间已建立一个TCP连接，主机甲向主机乙发送了两个连续的TCP段，分别包含300字节和500字节的有效载荷，第一个段的序列号为200，主机乙正确接收到两个段后，发送给主机甲的确认序列号是  （ D ）</p>
<p>A．500  B.700  C.800  D.1000</p>
<p>TCP协议中的确认号表示接收方期待接收的下一个字节的序号。由于主机甲发送了两个连续的TCP段，分别包含300字节和500字节的有效载荷，所以主机乙期待接收的下一个字节的序号应该是200+300+500&#x3D;1000。</p>
<p>主机甲与主机乙之间已建立一个TCP连接，主机甲向主机乙发送了3个连续的TCP段，分别包含300字节、400字节和500字节的有效载荷，第3个段的序号为900。若主机乙仅正确接收到第1和第3个段，则主机乙发送给主机甲的确认序号是（B     ）    </p>
<p>A．300      B．500      C．1200     D．1400 </p>
<p>TCP什么时候对报文段采用快速重传？ (C)</p>
<p>A、报文段的定时器过期                                      </p>
<p>B、估计往返时延过长</p>
<p>C、收到之前发出的一个报文段的三个重复ACK    </p>
<p>D、以上都不是</p>
<p>快速重传是TCP协议中的一种重传机制，它用于在收到三个或以上的冗余ACK（duplicate ACK）时快速重传丢失的数据包。当发送方收到三个重复的ACK时，它可以推断出接收方已经成功接收了之前的报文段，但是当前的报文段丢失了。因此，发送方会立即重传该报文段，而不是等待定时器过期。</p>
<p>网络上所抓到的TCP数据报文段中，有一个字段RcvWindow，其含义和作用为（ A ）</p>
<p>A、接收可用空间大小，用于流量控制       </p>
<p>B、发送可用空间大小，用于流量控制</p>
<p>C、发送可用空间大小，用于拥塞控制       </p>
<p>D、接收可用空间大小，用于拥塞控制</p>
<p>是接收方向发送方指示接收缓存可用空间的大小，主要用于发送方控制其发送窗口的大小。</p>
<p>主机甲和主机乙之间已建立一个TCP连接，TCP最大段长度为1000字节，若主机甲的当前拥塞窗口为4000字节，在主机甲向主机乙连接发送2个最大段后，成功收到主机乙发送的第一段的确认段，确认段中通告的接收窗口大小为2000字节，则此时主机甲还可以向主机乙发送的最大字节数是（A）</p>
<p>A：1000             B：2000        C：3000             D：4000</p>
<p>TCP采用序列号、确认、滑动窗口协议等机制来实现端到端节点之间可靠的数据传输。其中，滑动窗口协议规定未被确认的分组数最多为窗口的大小，且只需要重传未被确认的分组。通告的接收窗口大小为2000B，则说明此时主机乙具有一个2000B的空闲缓冲区，即此时主机乙最大还可以接收2000B的数据。由于主机乙还未对主机甲发出第2个报文段进行确认，因此这2000B的空闲缓冲区还需预留出1000B用于接收第2个报文段，即此时主机甲还可以向主机乙发送的最大字节数只有1000B。</p>
<p>主机甲向主机乙发送一个(SYN＝1，seq＝3210)的TCP段，期望与主机乙建立TCP连接，若主机乙接受该连接请求，则主机乙向主机甲发送的正确的TCP段可能是（C ）  </p>
<p>A．(SYN＝0，ACK＝0，seq＝3211，ack＝3211)    </p>
<p>B．(SYN＝1，ACK＝1，seq＝3210，ack＝3210)    </p>
<p>C．(SYN＝1，ACK＝1，seq＝3211，ack＝3211)    </p>
<p>D．(SYN＝0，ACK＝0，seq＝3210，ack＝3210)</p>
<p>TCP是面向连接的,所谓面向连接,就是当计算机双方 通信时必需先建立连接,然后数据传送,最后拆除三个过程,也就是 客户主动打开TCP传输,服务器被动打开。第一次握手:客户发送SYN &#x3D;1, seq &#x3D; x给服务器,即客户的TCP向服务器发出连接请求报文段, 其首部中的同步位SYN&#x3D;1,并选择序号seq &#x3D; x,表明传送数据时的第一个数据字节的序号是 x。第二次握手:服务器发送 SYN&#x3D; 1, ACK &#x3D;l , seq &#x3D; y, ack &#x3D; x+1给客户,即服务器的TCP收到连接请求报文段后,如同意则发回确认。服务器在确认报文段中应使 SYN&#x3D;1,使ACK&#x3D; 1,其确认号ack &#x3D; x+1,自己选择的序号seq &#x3D; y。第三次握手: 客户发送ACK&#x3D; 1, seq &#x3D; x+1, ack &#x3D; y+1给服务器,即客户收到此报 文段后向服务器给出确认, 其ACK&#x3D; 1,确认号ack &#x3D; y+1。客户的TCP 通知上层应用进程,连接已经建立。服务器的 TCP收到主机客户的确认后,也通知其上层应用进程: TCP连接已经建立。 如果ACK为0，那么数据报不包含确认信息，确认字段被省略。 SYN：用于建立连接。 目前连接还在建立阶段，乙向甲发送的TCP段是包含确认信息ack的， 则SYN&#x3D;1，ACK&#x3D;1； 至于seq，ack，乙向甲发送的seq可以随意，但是 乙向甲发送的 ack却要求是之前甲向乙发送的请求seq加1。</p>
<p>一个TCP连接总是以1KB的最大段长发送TCP段，发送方有足够多的数据要发送。当拥塞窗口为16KB时发生了超时，如果接下来的4个RTT（往返时间）时 间内的TCP段的传输都是成功的，那么当第4个RTT时间内发送的所有TCP段 都得到肯定应答时，拥塞窗口大小是多少？</p>
<p>根据慢开始算法的原则,在第4个RTT时间后,拥塞窗口为16,此时发生拥塞,拥塞窗口大小变为1KB,慢开始门限值变为8 KB。接下来3个RTT后,拥塞窗口大小变为8 KB,此时进入拥塞避免算法,当第4个RTT后,拥塞窗口加1,拥塞窗口大小变为9 KB。</p>
<p>16KB超时，阈值变为8KB，客户端从1KB开始穿（执行快开始算法）</p>
<p>1RTT 结束，1KB-&gt;2KB<br>2RTT 结束，2KB-&gt;4KB<br>3RTT 结束，4KB-&gt;8KB（到达阈值，执行拥塞避免算法）<br>4RTT 结束，8KB-&gt;9KB</p>
<p>（1）将“慢开始门限值”设置为出现超时时刻的“拥塞窗口值”的一半，也就是16KB ÷ 2 &#x3D; 8KB；</p>
<p>（2）将“拥塞窗口值”设置为1KB，重新开始“慢开始”算法。题目还给定超时后的4个RTT（往返时间）时间内的TCP段的传输都是成功，也就是说超时后又进行了以下四个轮次的传输：</p>
<p>超时后的第一个传输轮次：拥塞窗口值为1KB，进行超时后的第一个传输轮次，成功后拥塞窗口值增加到2KB；</p>
<p>超时后的第二个传输轮次：拥塞窗口值为2 KB，进行超时后的第二个传输轮次，成功后拥塞窗口值增加到4 KB；</p>
<p>超时后的第三个传输轮次：拥塞窗口值为4 KB，进行超时后的第三个传输轮次，成功后拥塞窗口值增加到8 KB；</p>
<p>超时后的第四个传输轮次：拥塞窗口值为8 KB，进行超时后的第四个传输轮次，成功后需要增加拥塞窗口的值，由于已经达到“慢开始门限值”，因此拥塞窗口的值线性加1 KB变为9 KB，之后改用“拥塞避免”算法。</p>
<p><strong>拥塞避免和慢启动</strong><br>当拥塞发生时（超时或收到重复确认），慢启动门限ssthresh被设置为当前拥塞窗口cwnd大小（题目为16）的一半，即8。同时cwnd重置为1（最大报文段长度）。新的数据被接收，则cwnd增加，规则为ssthresh之前， 慢启动，即cwnd指数增长；到达ssthresh之后， 拥塞避免，即cwnd加1。</p>
<p>TCP 可靠数据传输过程中的定时器设置，初始时定时器 T 设置为 1 秒，第 1 个样本 SampleRTT&#x3D;2 秒，获得该样本后估算 EstimatedRTT&#x3D;2 秒，偏差 DevRTT&#x3D;1 秒，第 2 个样本 SampleRTT&#x3D;1 秒，第 3 个样本 SampleRTT&#x3D;3 秒，计算收到第三个样本后 TCP 为第四个待发送分 组设定的定时器 T 的值？（要求：给出 EstimatedRTT 和 DevRTT 的均值公式和定时器 T 的计算 公式，EstimatedRTT 公式中系数是 0.125，DevRTT 公式中系数是 0.25，给出每次收到样本时均 值的变化，计算时小数保留 3 位）</p>
<p>ERTT&#x3D;（1-a）ERTT+a*SRTT<br>DRTT&#x3D;（1-b）DRTT+b*|SRTT-ERTT|<br>T&#x3D;ERTT+4*DRTT<br>收到第二个样本后：DRTT&#x3D;（1-0.25）*1+0.25*|1-2|&#x3D;1 秒 ，ERTT&#x3D;（1-0.125）*2+0.125*1&#x3D;1.875 秒<br>收到第三个样本后：DRTT&#x3D;（1-0.25）*1+0.25*|3-1.875|&#x3D;1.031 秒 ，ERTT&#x3D;（1-0.125）*1.875+0.125*3&#x3D;2.016 秒<br>定时器 T：（1 分） T&#x3D;2.016+4*1.031&#x3D;6.14 秒</p>
<p>（注：在计算DRTT时，ERTT用上一轮的）</p>
<p>在SR中，发送窗口大小不能超过序号空间的(1&#x2F;2)。</p>
<p>小于(1024)的TCP&#x2F;UDP端口号已保留与现有服务一一对应，此数字以上的端口号可自由分配。</p>
<p>设TCP拥塞窗口的当前阈值为8（单位为报文段），当拥塞窗口上升到12时收到3个重复ACK，那么下一轮传输时拥塞窗口大小为( )</p>
<p>A.8	B.9	C.6	D.4</p>
<p>在 TCP 拥塞控制中，当收到 3 个重复的 ACK 时，会触发快速重传和快速恢复算法。在快速重传和快速恢复算法中，当收到 3 个重复的 ACK 时，阈值会被设置为当前拥塞窗口大小的一半，拥塞窗口大小会被设置为阈值加上 3 个 MSS（最大报文段长度）的大小。根据题目中给出的信息，当前阈值为 8，当拥塞窗口上升到 12 时收到 3 个重复 ACK。此时，阈值会被设置为当前拥塞窗口大小的一半，即 12&#x2F;2&#x3D;6。拥塞窗口大小会被设置为阈值加上 3 个 MSS 的大小，即 6+3&#x3D;9。</p>
<p>TCP通信时，若某一方发送带有FIN标志的数据段，其含义为（C）</p>
<p>A.将断开通信双方的TCP连接</p>
<p>B.连接被重新建立</p>
<p>C.单方面释放连接，表示本方已经无数据发送，但可以接收对方数据</p>
<p>D.终止数据发送，双方都不能发送数据</p>
<p>假设使用8位校验和字段对数据0x5879B432计算Internet校验和，结果是（C）</p>
<p>A.0xB8</p>
<p>B.0x48</p>
<p>C.0x47</p>
<p>D.0xB7</p>
<p>以下哪个TCP熟知端口号是错误的（ D ）</p>
<p>A.HTTP:80</p>
<p>B.TELENT:23</p>
<p>C.SMTP:25</p>
<p>D.FTP:24</p>
<p>一般情况下,FTP使用的端口号为21和20。</p>
<p>主机甲和主机乙已建立TCP连接，甲始终以MSS&#x3D;1KB大小的段发送数据，并一直有数据发送；乙每收到一个数据段都会发出一个接收窗口为10KB的确认段。若甲在t时刻发生超时，其拥塞窗口为8KB。则从t时刻开始，不再发生超时情况下，经过10个RTT后，甲的发送窗口是多少？</p>
<p>当t时刻发生超时时，把sthresh设为8的一半，即为4，且拥塞窗口设为1KB。然后经历10个RTT后，拥塞窗口的大小依次为2、4、5、6、7、8、9、10、11、12，而发送窗口取当时的拥塞窗口和接收窗口的最小值，而接收窗口始终为10KB，所以此时的发送窗口为10KB。</p>
<blockquote>
<p>简述 TCP 拥塞控制中进入慢启动、快速恢复、拥塞避免三种状态对应的触发事件？</p>
</blockquote>
<p>慢启动状态的事件：开始传输；超时；低于阈值； </p>
<p>快速恢复的事件：三次及以上重复确认； </p>
<p>拥塞避免：高于阈值，正常收到分组确认</p>
<blockquote>
<p>假设主机A通过一条TCP连接向主机B发送一个大文件。主机A发送但未被确认的字节数不会 超过接收缓存的大小。   （  √ ）</p>
</blockquote>
<p>流量控制</p>
<blockquote>
<p>假设主机A通过TCP连接向主机B发送一个大文件。如果某个段(segment)的Seq号为 m,那下一个正常发送的段的Seq号必然为m+1（×）</p>
</blockquote>
<p>下一个正常发送的段的序列号并不一定是m+1，而是m加上前一个段中数据的字节数。例如，如果前一个段中包含512个字节的数据，那么下一个正常发送的段的序列号将是m+512。</p>
<blockquote>
<p>TCP报文段在它的首部中有一个rwnd字段。(√)</p>
</blockquote>
<p>rwnd即接收窗口（receive window），用来告知发送方，自己在该TCP连接的缓存中还有多少可用空间</p>
<blockquote>
<p>假定在一条TCP连接中最后的SampleRTT等于1秒，那么对于该连接的TimeoutInterval的当前值 必定大于等于1秒。 （ ×  ）</p>
</blockquote>
<p>Timeout Interval&#x3D;EstimatedRTT+4×DevRTT，所以TimeoutInterval数据和SampleRTT无关</p>
<blockquote>
<p>假设主机A通过一条TCP连接向主机B发送一个序号为38的4个字节的报文段。在这个相同的 报文段中，确认号必定是42。   （ ×  ）</p>
</blockquote>
<p>某些情况下（比如该报文段发送超时）接收方会发送一个重复的ACK，即确认号仍然是 38。</p>
<blockquote>
<p>考虑TCP的拥塞控制。当发送方定时器超时时，其ssthresh的值将被设置为原来值的 一半。（ x ）</p>
</blockquote>
<p>看准了，应该是ssthresh被设置为<code>当前拥塞窗口的一半</code>。</p>
<blockquote>
<p>考虑一个GBN协议，其发送方窗口为4,序号范围为1024。假设在时刻接收方期待的下一个有序分组的序号是k，且媒体不会对报文重新排序。回答以下问题：</p>
<p> a. 在t时刻，发送方窗口内的报文序号可能是多少？论证你的回答。</p>
<p>b. 在t时刻，在当前传播回发送方的所有可能报文中，ACK字段的所有可能值是多少？论证你的 回答。</p>
</blockquote>
<p>GBN协议特点：GBN协议几个特点：</p>
<ul>
<li>发送方拥有一个窗口，长度为N；</li>
<li>接收方无窗口，只接收希望接受序号的报文，对于<strong>失序到达</strong>的报文段采取的方式是直接丢弃；</li>
<li>在重传的时候，将会重传当前发送方窗口中所有未被确认的报文段。</li>
</ul>
<p>a）在t时刻，接收方起到收到的下一个分组序号为k，说明接收方已经正确接受了k之前的所有分组，对于发送方而言，我们考虑两种最极端的情况：</p>
<p>第一种情况：假设之前所有的报文都正确传输，没有任何丢失的问题，那么在这种情况下，发送方正确接收了接收方对于小于k的所有报文的ACK确认，因此窗口将会不断向后移动，序号如下图所示：</p>
<table>
<thead>
<tr>
<th>k</th>
<th>k+1</th>
<th>k+2</th>
<th>k+3</th>
</tr>
</thead>
</table>
<p>第二种情况：由已知条件我们可以得知序号为k-1的报文是发送方发送的最后一个报文，假设该报文虽然到达了接收方，但是接收方返回的ACK确认由于一些原因没有到达发送方，则窗口不会移动，在这种情况下我们再假设序号k-1位于窗口的最后一列，即如下图所示的所有序号报文都没有在发送方被确认，则得到了我们最坏的一种情况：</p>
<table>
<thead>
<tr>
<th>K-4</th>
<th>K-3</th>
<th>K-2</th>
<th>K-1</th>
</tr>
</thead>
</table>
<p>两种极端情况中间的任意一种情况都可能发生，因此发送方窗口序号可能为k-4、k-3、k-2、k-1、k、k+1、k+2、k+3。如果发送方窗口为N，则发送方窗口序号可能为[k，k+N-1]或[k-N，k-1]。</p>
<p>b）如果接收机正在等待分组k，则它已经接收（并确认）了分组k-1和在此之前的3个分组。如果发送方尚未接收到这4个ACK中的任何一个，则值为[k-4，k-1]的ACK消息可能仍在传播。ACK字段的所有可能值为k-1、k-2、k-3、k-4。如果发送方窗口为N，那么ACK字段的所有可能值为[k-N，k-1]。</p>
<blockquote>
<p>考虑从主机A向主机B传输L字节的大文件，假设MSS为536字节。</p>
<p>a. 为了使得TCP序号不至于用完，L的最大值是多少？前面讲过TCP的序号字段为4字节。</p>
<p> b. 对于你在(a)中得到的L，求出传输此文件要用多长时间？假定运输层、网络层和数据链路层首部总共为66字节，并加在每个报文段上，然后经155Mbps链路发送得到的分组。忽略流量控制和拥塞控制，使主机A能够一个接一个连续不断地发送这些报文段。</p>
</blockquote>
<p>a. 序号占用 4 字节，即 32 位。它的范围是 [0,2^32−1]，也就是说一共有 4 294 967 296 个序号。<br>L &#x3D; 2^32 &#x3D; 4294967296 byte</p>
<p>b. 报文段的数量为L&#x2F;MSS取上整。4294967296&#x2F;536 ≈ 8012999组<br>所有分组的总头部信息 &#x3D; 66 * 8012999 &#x3D; 528857934 byte<br>总数据量 4294967296 + 528857934 &#x3D; 4823825230 byte<br>所需时间 &#x3D; 4823825230 byte&#x2F;155Mbps ≈ 249秒 &#x3D; 4.15分钟</p>
<blockquote>
<p>UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节:01010011，01100110，01110100。这些8比特字节和的反码是多少?(注意到尽管UDP 和 TCP 使用 16 比特的字来计算检验和，但对于这个问题，你应该考虑8比特和。)写出所有工作过程。UDP 为什么要用该和的反码，即为什么不直接使用该和呢?使用该反码方案，接收方如何检测出差错?1比特的差错将可能检测不出来吗?2比特的差错呢?</p>
</blockquote>
<p>0101 0011 + 0110 0110 &#x3D; 1011 1001<br>1011 1001 + 0111 0100 &#x3D; 1 0010 1101（多了一位，第一位1回卷）<br>0010 1101 + 1 &#x3D; 0010 1110 取其反码，得到1101 0001。</p>
<p>运用反码相加，全1的检测对于计算机来说更加方便，速度会更快。</p>
<p>将反码1101 0001 放在检验和处，在接受方将全部的传输数据和检验和相加为1111 1111时，无差错，只要有任意一位为0，传输中就出现了差错。</p>
<p>1比特的差错一定能够检查出来，2比特的差错如果出现在同一位上，则会被忽略。</p>
<blockquote>
<p>主机A和B经一条TCP连接通信，并且主机B已经收到了来自A的最长为126字节的所有字节。 假定主机A随后向主机B发送两个紧接着的报文段。第一个和第二个报文段分别包含了 80字节和 40字节的数据。在第一个报文段中，序号是127,源端口号是302,目的地端口号是80。无论何时 主机B接收到来自主机A的报文段，它都会发送确认。</p>
<p>a)在从主机A发往B的第二个报文段中，序号、源端口号和目的端口号各是什么？ </p>
<p>b)如果第一个报文段在第二个报文段之前到达，在第一个到达报文段的确认中，确认号、源端口号和目的端口号各是什么？ </p>
<p>c)如果第二个报文段在第一个报文段之前到达，在第一个到达报文段的确认中，确认号是什么？ </p>
<p>d)假定由A发送的两个报文段按序到达B。第一个确认丢失了而第二个确认在第一个超时间隔之后到达。画出时序图，显示这些报文段和发送的所有其他报文段和确认。（假设没有其他分组丢 失。）对于图上每个报文段，标出序号和数据的字节数量；对于你增加的每个应答，标出确认号。</p>
</blockquote>
<p>a） 在从主机A到B的第二段中，序列号为207，源端口号码是302，目的地端口号是80。</p>
<p>b） 如果第一段在第二段之前到达，则在对第一段的确认中到达段，确认号为207，源端口号为80并且目的地端口号是302。</p>
<p>c） 如果第二段在第一段之前到达，则在对第一个到达的段，确认号码是127，表明它仍然是等待字节127及以后。</p>
<p>d）</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-25_11-30-33.png"></p>
<blockquote>
<p>假设TCP Reno是一个经历如上所示行为的协议，回答下列问题。在各种情况中，简要地论证你的回答。</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/yskztt1.png"></p>
<p>（1）指出TCP慢启动运行时的时间间隔。</p>
<p>（2）指出TCP拥塞避免运行时的时间间隔。</p>
<p>（3）在第16个传输轮回之后，报文段的丢失是根据3个冗余ACK还是根据超时检测岀来的？</p>
<p>（4）在第22个传输轮回之后，报文段的丢失是根据3个冗余ACK还是根据超时检测出来的？</p>
<p>（5）在第1个传输轮回里，ssthresh的初始值设置为多少？</p>
<p>（6）在第18个传输轮回里，ssthresh的值设置为多少？</p>
<p>（7）在第24个传输轮回里，ssthresh的值设置为多少？</p>
<p>（8）在哪个传输轮回内发送第70个报文段？</p>
<p>（9）假定在第26个传输轮回后，通过收到3个冗余ACK检测出有分组丢失，拥塞的窗口长度和 ssthresh的值应当是多少？</p>
<p>（10）假定使用TCP Tahoe （而不是TCP Reno）,并假定在第16个传输轮回收到3个冗余ACK。在第19 个传输轮回，ssthresh和拥塞窗口长度是什么？</p>
<p>（11）再次假设使用TCP Tahoe,在第22个传输轮回有一个超时事件。从第17个传输轮回到第22个传 输轮回（包括这两个传输轮回），一共发送了多少分组？</p>
</blockquote>
<p>(1)	[1,6] and [23,26] </p>
<p>(2)	[6,16] and [17,22]</p>
<p>(3)	3个冗余ACK</p>
<p>(4)	超时</p>
<p>(5)	32</p>
<p>(6)	21（在16轮回， CongWin &#x3D; 42, ssthresh设置为当前拥塞窗口的一半）</p>
<p>(7)	14（在22轮回， CongWin &#x3D; 29,向下取整）</p>
<p>(8)	7（64-96）</p>
<p>(9)	4，7</p>
<p>(10)	21，4（拥塞窗口长度变为1，慢启动，17为1，18为2，19为4）</p>
<p>(11)	52&#x3D;1+2+4+8+16+21(第17个发了1个，第18个发了2个，第19个发了4个，第20个发了8个，第21个发了16个，第22个翻倍超过ssthresh，因此只发了21个,慢启动不能超阈值)</p>
<blockquote>
<p>主机A通过一条TCP连接向主机B发送一个很大的文件。在这条连接上，不会出现任何分组丢失和定时器超时。主机A与因特网连接链路的传输速率表示为R  bps，主机A上的进程能够以S  bps 的速率向TCP套接字发送数据，其中S &#x3D; 10 x R。假设TCP的接收缓存足够大，能够容纳整个文件，并且发送缓存只能容纳这个文件的百分之一。如何防止主机A上的进程连续地向TCP套接字以速率S  bps传送数据呢？还是用TCP流量控制呢？还是用TCP拥塞控制？或者用其他措施？阐述其理由。</p>
</blockquote>
<p>首先，由于接收方的接收缓存能容纳整个大文件，因此不会出现流量控制；并且因为在这条连接上不会出现任何分组丢失和定时器超时，因此拥塞控制机制不会遏制发送方的速率。最后，由于发送方的发送缓存会很快被填充满，因此一旦发送缓存被填充满，进程将无法继续以 S 速率向套接字发送数据，而是以 R 向套接字发送数据。</p>
<blockquote>
<p><strong>比较GBN、SR和TCP（无延时的ACK）。假设对所有3个协议的超时值足够长，使得5个连续的数据报文段及其对应的ACK能够分别由接收主机（主机B）和发送主机（主机A）收到（如果在信道中无丢失）。假设主机A向主机B发送5个数据报文段，并且第二个报文段（从A出发）丢失。最后所有5个数据报文段已经被主机B正确接收。</strong></p>
<p><strong>请问主机A总共发送了多少个报文段和主机B总共发送了多少ACK？它们的序号是多少？对于三种协议回答这个问题。</strong></p>
</blockquote>
<p>假设发送的五个数据报文段的序号分别为1、2、3、4、5.</p>
<p>GBN：A总共发送了5+4&#x3D;9个报文段，分别为1、2、3、4、5、2、3、4、5，B总共发送了4+4&#x3D;8个ACK，序号分别为1、1、1、1、2、3、4、5；</p>
<p>SR：A总共发送了5+1&#x3D;6个报文段，分别为1、2、3、4、5、2，B总共发送了4+1&#x3D;5个ACK，序号分别为1、3、4、5、2；</p>
<p>TCP：A总共发送了5+1&#x3D;6个报文段，分别为1、2、3、4、5、2，B总共发送了4+1&#x3D;5个ACK，序号分别为2、2、2、2、6.</p>
<p><strong>对于TCP，GBN，SR之间关系的总结</strong>：</p>
<p><em><strong>GBN</strong></em>：</p>
<p>发送方拥有一个窗口，长度为N；</p>
<p>接收方无窗口，只接收希望接受序号的报文，对于失序到达的报文段采取的方式是直接丢弃；</p>
<p>在重传的时候，将会重传当前发送方窗口中<strong>所有未被确认</strong>的报文段；</p>
<p>采用<strong>累计应答</strong>的方式。例如接收端返回ACK&#x3D;3，则证明报文段3以及之前的报文段都被正确接收。</p>
<p>接收端不对失序到达的分组进行缓存。</p>
<p><em><strong>SR</strong></em>：</p>
<p>发送方拥有一个窗口，长度为N；</p>
<p>接收方拥有一个窗口，长度为N，对于失序到达的报文段将会<strong>缓存</strong>下来；</p>
<p>在重传的时候，将会<strong>重传窗口中超时的单个报文</strong>，而不会重传窗口中所有的报文；</p>
<p>接收端返回ACK是当前接收成功报文段的序号，SR不采用累计应答的方式，如接收到序号为0的报文段，则ACK确认ACK&#x3D;0。</p>
<p><em><strong>TCP</strong></em>：</p>
<p>TCP使用累计应答的方式。这一点与GBN类似。</p>
<p>TCP在接收端会设置缓存，来缓存正确接收但是失序的分组，这点与SR类似。（实际上TCP RFC并没有对接收端要怎样处理失序到达的分组提出要求，但是在接收端设置缓存是实践中大家都采用的方法）</p>
<p>TCP使用<strong>快速重传</strong>机制：如果收到对于一个特定报文段的3个冗余ACK，则在超时事件发生前就会对该报文段进行重传，这大大节约了时间。</p>
<p>在重传的时候，将会重传窗口中超时的单个报文，而不会重传窗口中所有的报文；</p>
<p>接收方回复的ACK确认序号是希望接收到的下一个报文段的序号，如接收到序号为0的报文段，则ACK确认ACK&#x3D;1。</p>
<p><em><strong>补充关于选择重传的过程</strong></em>：</p>
<p><strong>窗口下界：最左边第一个窗口对应的序号</strong></p>
<p>假设发送窗口和接收窗口都为4，发送方发送0帧，接收方收到0帧，并回复0帧确认，由于0帧是接收窗口下界，于是移动窗口使得窗口下界为第一个未被接收的帧（1号帧），同时把新加入帧（4号帧）的状态置为可接收状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-25_15-56-21.png"></p>
<p>发送方发送1帧，接收方收到1帧，并回复1帧确认，由于1帧是接收窗口下界，于是移动窗口使得窗口下界为第一个未被接收的帧（2号帧），同时把新加入帧（5号帧）的状态置为可接收状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-25_15-56-30.png"></p>
<p>发送方发送2帧，但是2帧丢失，接收方未收到2帧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-25_15-56-44.png"></p>
<p>发送方发送3帧，接收方收到3帧，缓存三帧，发送ACK3：</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-25_15-56-52.png"></p>
<p>发送方收到ACK0，由于窗口下限被确认，所以窗口右移一个，发送4帧，接收方收到4帧，缓存，发送ACK4：</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-25_15-57-20.png"></p>
<p>发送方收到ACK1，由于窗口下界被确认，所以窗口右移1个，发送5帧，接收方接收5帧，缓存，发送ACK5：</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-25_15-57-27.png"></p>
<p>发送方2帧超时未收到2帧确认，重新传2帧，这次接收方收到了，2-5帧交付（发送给上层网络层），发送ACK2：</p>
<p><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/Snipaste_2023-06-25_15-57-36.png"></p>
<p>发送方收到ACK3，但是无帧可发，等待，一直到ACK2到达，窗口下界被确认，窗口右移1个。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://uestcwxy.love">Palp1tate</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://uestcwxy.love/2023/06/21/%E8%AE%A1%E7%BD%91/3/">https://uestcwxy.love/2023/06/21/%E8%AE%A1%E7%BD%91/3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://uestcwxy.love" target="_blank">Palp1tate</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/21/%E8%AE%A1%E7%BD%91/2/" title="计网期末复习之应用层"><img class="cover" src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计网期末复习之应用层</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/23/%E8%AE%A1%E7%BD%91/4/" title="计网期末复习之网络层"><img class="cover" src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计网期末复习之网络层</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/20/%E8%AE%A1%E7%BD%91/1/" title="计网期末复习之计算机网络与因特网"><img class="cover" src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-20</div><div class="title">计网期末复习之计算机网络与因特网</div></div></a></div><div><a href="/2023/06/21/%E8%AE%A1%E7%BD%91/2/" title="计网期末复习之应用层"><img class="cover" src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-21</div><div class="title">计网期末复习之应用层</div></div></a></div><div><a href="/2023/06/23/%E8%AE%A1%E7%BD%91/5/" title="计网期末复习之链路层"><img class="cover" src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="title">计网期末复习之链路层</div></div></a></div><div><a href="/2023/06/23/%E8%AE%A1%E7%BD%91/4/" title="计网期末复习之网络层"><img class="cover" src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="title">计网期末复习之网络层</div></div></a></div><div><a href="/2023/06/24/%E8%AE%A1%E7%BD%91/6/" title="计网期末复习之套接字编程"><img class="cover" src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-24</div><div class="title">计网期末复习之套接字编程</div></div></a></div><div><a href="/2023/06/25/%E8%AE%A1%E7%BD%91/7/" title="电子科大计网期末复习之经典大题"><img class="cover" src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-25</div><div class="title">电子科大计网期末复习之经典大题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Palp1tate</div><div class="author-info__description">等我苦尽甘来时，我给你讲讲来时走的路。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/palp1tate/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://www.facebook.com/profile.php?id=100092533320651" target="_blank" title="facebook"><i class="fab fa-facebook" style="color: #4a7dbe;"></i></a><a class="social-icon" href="mailto:1939311091@qq.com" target="_blank" title="email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/1907948898" target="_blank" title="b站"><i class="fab fa-bilibili" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/img/tiktok.jpg" target="_blank" title="抖音"><i class="fab fa-tiktok" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/img/weixin.jpg" target="_blank" title="微信"><i class="fab fa-weixin" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">刚建站不久，博客美化有待研究，部分页面也没时间弄，路过的你将就看啦~😊，图片没加载出来就是网络不佳噢~</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/05/Go/44/" title="如何用go获取IPv4地址，WLAN的IPv4地址，本机公网IP地址，本机空闲端口"><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/4d287328613d2f4952a70edb9192044037dd5e22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何用go获取IPv4地址，WLAN的IPv4地址，本机公网IP地址，本机空闲端口"/></a><div class="content"><a class="title" href="/2023/10/05/Go/44/" title="如何用go获取IPv4地址，WLAN的IPv4地址，本机公网IP地址，本机空闲端口">如何用go获取IPv4地址，WLAN的IPv4地址，本机公网IP地址，本机空闲端口</a><time datetime="2023-10-05T01:41:38.000Z" title="发表于 2023-10-05 09:41:38">2023-10-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/27/Go/43/" title="加密算法仓库更新完成！支持18种算法！"><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/4d287328613d2f4952a70edb9192044037dd5e22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="加密算法仓库更新完成！支持18种算法！"/></a><div class="content"><a class="title" href="/2023/09/27/Go/43/" title="加密算法仓库更新完成！支持18种算法！">加密算法仓库更新完成！支持18种算法！</a><time datetime="2023-09-27T13:59:24.000Z" title="发表于 2023-09-27 21:59:24">2023-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/23/Go/42/" title="十小时开源了一个加密算法仓库，功能强大，后端开发人员狂喜！"><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/4d287328613d2f4952a70edb9192044037dd5e22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十小时开源了一个加密算法仓库，功能强大，后端开发人员狂喜！"/></a><div class="content"><a class="title" href="/2023/09/23/Go/42/" title="十小时开源了一个加密算法仓库，功能强大，后端开发人员狂喜！">十小时开源了一个加密算法仓库，功能强大，后端开发人员狂喜！</a><time datetime="2023-09-23T10:54:48.000Z" title="发表于 2023-09-23 18:54:48">2023-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/21/Go/41/" title="分别用Python和Go实现对文件夹及其子文件夹里的文件进行批量重命名"><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/4d287328613d2f4952a70edb9192044037dd5e22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分别用Python和Go实现对文件夹及其子文件夹里的文件进行批量重命名"/></a><div class="content"><a class="title" href="/2023/09/21/Go/41/" title="分别用Python和Go实现对文件夹及其子文件夹里的文件进行批量重命名">分别用Python和Go实现对文件夹及其子文件夹里的文件进行批量重命名</a><time datetime="2023-09-21T11:45:18.000Z" title="发表于 2023-09-21 19:45:18">2023-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/19/Go/40/" title="Go语言的单元测试与基准测试"><img src="https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/4d287328613d2f4952a70edb9192044037dd5e22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言的单元测试与基准测试"/></a><div class="content"><a class="title" href="/2023/09/19/Go/40/" title="Go语言的单元测试与基准测试">Go语言的单元测试与基准测试</a><time datetime="2023-09-19T02:26:26.000Z" title="发表于 2023-09-19 10:26:26">2023-09-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/palp1tate/blog_img/img/82b824685df6df454395916e44474501.png')"><div id="footer-wrap"><div class="copyright">&copy;2023 By Palp1tate</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><i class="fa-solid fa-cloud"></i><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>萌ICP备20230529号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="6614140207" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-mini="true"> </div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>